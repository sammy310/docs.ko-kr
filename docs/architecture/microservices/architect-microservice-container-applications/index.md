---
title: 컨테이너 및 마이크로 서비스 기반 애플리케이션 설계
description: 컨테이너 및 마이크로 서비스 기반 애플리케이션 설계는 간단한 작업이 아니므로 가볍게 여겨서는 안 됩니다. 이 장에서 핵심 개념을 알아보세요.
ms.date: 01/13/2021
ms.openlocfilehash: b31c560fefa0928cefef2fdb92d6cfdbac084c57
ms.sourcegitcommit: c7f0beaa2bd66ebca86362ca17d673f7e8256ca6
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/23/2021
ms.locfileid: "104873148"
---
# <a name="architecting-container-and-microservice-based-applications"></a><span data-ttu-id="a8633-104">컨테이너 및 마이크로 서비스 기반 애플리케이션 설계</span><span class="sxs-lookup"><span data-stu-id="a8633-104">Architecting container and microservice-based applications</span></span>

<span data-ttu-id="a8633-105">*마이크로 서비스는 기존 아키텍처에 비해 다양한 이점이 있지만, 해결해야 할 새로운 과제도 있습니다. 마이크로 서비스 아키텍처 패턴은 마이크로 서비스 기반 애플리케이션을 만들 때 중추적인 역할을 합니다.*</span><span class="sxs-lookup"><span data-stu-id="a8633-105">*Microservices offer great benefits but also raise huge new challenges. Microservice architecture patterns are fundamental pillars when creating a microservice-based application.*</span></span>

<span data-ttu-id="a8633-106">이 가이드의 초반부에서는 컨테이너와 Docker에 대한 기본 개념을 알아보았습니다.</span><span class="sxs-lookup"><span data-stu-id="a8633-106">Earlier in this guide, you learned basic concepts about containers and Docker.</span></span> <span data-ttu-id="a8633-107">해당 정보는 개념은 컨테이너를 시작하는 데 필요한 최소한의 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="a8633-107">That information was the minimum you needed to get started with containers.</span></span> <span data-ttu-id="a8633-108">컨테이너를 사용하면 마이크로 서비스를 제대로 구현할 수 있지만, 컨테이너는 마이크로 서비스 아키텍처의 필수 요소는 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="a8633-108">Even though containers are enablers of, and a great fit for microservices, they aren't mandatory for a microservice architecture.</span></span> <span data-ttu-id="a8633-109">이 아키텍처 섹션의 많은 아키텍처 개념은 컨테이너 없이 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a8633-109">Many architectural concepts in this architecture section could be applied without containers.</span></span> <span data-ttu-id="a8633-110">그러나 이미 컨테이너의 중요성을 소개했으므로 이 가이드에서는 컨테이너와 Docker의 공통점을 집중적으로 알아보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="a8633-110">However, this guide focuses on the intersection of both due to the already introduced importance of containers.</span></span>

<span data-ttu-id="a8633-111">엔터프라이즈 애플리케이션은 복잡할 수 있으며 단일 서비스 기반 애플리케이션 대신 여러 서비스로 구성된 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="a8633-111">Enterprise applications can be complex and are often composed of multiple services instead of a single service-based application.</span></span> <span data-ttu-id="a8633-112">이러한 경우 마이크로 서비스, 특정 DDD(도메인 기반 디자인) 패턴 및 컨테이너 오케스트레이션 개념과 같은 기타 아키텍처 접근 방법을 이해해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a8633-112">For those cases, you need to understand other architectural approaches, such as the microservices and certain Domain-Driven Design (DDD) patterns plus container orchestration concepts.</span></span> <span data-ttu-id="a8633-113">이 장에서는 컨테이너에서의 마이크로 서비스뿐만 아니라 컨테이너화된 애플리케이션에 대해서도 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="a8633-113">Note that this chapter describes not just microservices on containers, but any containerized application, as well.</span></span>

## <a name="container-design-principles"></a><span data-ttu-id="a8633-114">컨테이너 디자인 원칙</span><span class="sxs-lookup"><span data-stu-id="a8633-114">Container design principles</span></span>

<span data-ttu-id="a8633-115">컨테이너 모델에서 컨테이너 이미지 인스턴스는 단일 프로세스를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="a8633-115">In the container model, a container image instance represents a single process.</span></span> <span data-ttu-id="a8633-116">컨테이너 이미지를 프로세스 경계로 정의하여 프로세스를 스케일링하거나 일괄 처리하는 데 사용할 수 있는 기본 형식을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a8633-116">By defining a container image as a process boundary, you can create primitives that can be used to scale or batch the process.</span></span>

<span data-ttu-id="a8633-117">컨테이너 이미지를 디자인하는 경우 Dockerfile에 [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint) 정의가 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="a8633-117">When you design a container image, you'll see an [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint) definition in the Dockerfile.</span></span> <span data-ttu-id="a8633-118">해당 정의에서는 컨테이너의 수명을 제어하는 수명의 프로세스를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="a8633-118">This definition defines the process whose lifetime controls the lifetime of the container.</span></span> <span data-ttu-id="a8633-119">프로세스가 완료되면 컨테이너 수명 주기가 종료됩니다.</span><span class="sxs-lookup"><span data-stu-id="a8633-119">When the process completes, the container lifecycle ends.</span></span> <span data-ttu-id="a8633-120">컨테이너는 웹 서버와 같은 장기 실행 프로세스를 나타낼 수 있지만 이전에 Azure [WebJobs](https://github.com/Azure/azure-webjobs-sdk/wiki)로 구현되었을 수 있는 일괄 작업과 같은 단기 실행 프로세스를 나타낼 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a8633-120">Containers might represent long-running processes like web servers, but can also represent short-lived processes like batch jobs, which formerly might have been implemented as Azure [WebJobs](https://github.com/Azure/azure-webjobs-sdk/wiki).</span></span>

<span data-ttu-id="a8633-121">프로세스에 실패할 경우 컨테이너가 종료되며 조정자가 이어서 프로세스를 진행합니다.</span><span class="sxs-lookup"><span data-stu-id="a8633-121">If the process fails, the container ends, and the orchestrator takes over.</span></span> <span data-ttu-id="a8633-122">조정자가 5개의 인스턴스는 실행하고 1개는 실패하도록 구성된 경우 조정자는 실패한 프로세스를 바꾸기 위해 다른 컨테이너 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="a8633-122">If the orchestrator was configured to keep five instances running and one fails, the orchestrator will create another container instance to replace the failed process.</span></span> <span data-ttu-id="a8633-123">일괄 작업에서 프로세스는 매개 변수와 함께 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="a8633-123">In a batch job, the process is started with parameters.</span></span> <span data-ttu-id="a8633-124">프로세스가 완료되면 작업이 완료됩니다.</span><span class="sxs-lookup"><span data-stu-id="a8633-124">When the process completes, the work is complete.</span></span> <span data-ttu-id="a8633-125">이 설명서의 뒷부분에서는 오케스트레이터에 대해 자세히 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="a8633-125">This guidance drills-down on orchestrators, later on.</span></span>

<span data-ttu-id="a8633-126">여러 프로세스를 단일 컨테이너에서 실행하려는 시나리오가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a8633-126">You might find a scenario where you want multiple processes running in a single container.</span></span> <span data-ttu-id="a8633-127">이러한 시나리오의 경우 컨테이너 1개당 진입점 1개만 허용되므로 필요에 따라 가능한 한 많은 프로그램을 시작하는 컨테이너에서 스크립트를 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a8633-127">For that scenario, since there can be only one entry point per container, you could run a script within the container that launches as many programs as needed.</span></span> <span data-ttu-id="a8633-128">예를 들어 [감독자](http://supervisord.org/) 또는 비슷한 도구를 사용하여 단일 컨테이너 내에서 여러 프로세스를 시작하는 것을 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a8633-128">For example, you can use [Supervisor](http://supervisord.org/) or a similar tool to take care of launching multiple processes inside a single container.</span></span> <span data-ttu-id="a8633-129">그러나 컨테이너당 여러 프로세스를 실행하는 아키텍처를 확인할 수 있더라도 이러한 접근 방식은 일반적인 방법이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="a8633-129">However, even though you can find architectures that hold multiple processes per container, that approach isn't very common.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="a8633-130">[이전](../net-core-net-framework-containers/official-net-docker-images.md)
>[다음](containerize-monolithic-applications.md)</span><span class="sxs-lookup"><span data-stu-id="a8633-130">[Previous](../net-core-net-framework-containers/official-net-docker-images.md)
[Next](containerize-monolithic-applications.md)</span></span>
