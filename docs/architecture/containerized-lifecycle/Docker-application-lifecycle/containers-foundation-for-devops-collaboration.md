---
title: DevOps 협업의 기반으로 사용되는 컨테이너
description: DevOps를 간소화하기 위한 컨테이너의 주요 역할을 이해합니다.
ms.date: 08/06/2020
ms.openlocfilehash: af28c1add8b2e6befbd2f3e6ae9fe707ccc5b106
ms.sourcegitcommit: ef50c99928183a0bba75e07b9f22895cd4c480f8
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/07/2020
ms.locfileid: "87916022"
---
# <a name="containers-as-the-foundation-for-devops-collaboration"></a>DevOps 협업의 기반으로 사용되는 컨테이너

컨테이너 및 Docker 기술의 본래 특성상 개발자는 “내 머신에서 작동한다”는 일반적인 변명을 하지 않고 소프트웨어 및 종속성을 IT 운영 부서 및 프로덕션 환경과 쉽게 공유할 수 있습니다. 컨테이너는 서로 다른 환경 간의 애플리케이션 충돌을 해결합니다. 컨테이너 및 Docker는 개발자와 IT 운영 부서를 더 가깝게 만들어 효과적으로 협업하기 쉽게 해주는 간접적인 효과가 있습니다. 컨테이너 워크플로를 채택하면 많은 고객에게 이전부터 추구해 왔지만 더 복잡한 릴리스 및 빌드 파이프라인 구성을 통해 구현해야 했던 DevOps 지속성을 제공합니다. 컨테이너는 DevOps의 빌드/테스트/배포 파이프라인을 간소화합니다.

![Docker 앱의 수명 주기에 대한 소유권을 보여 주는 다이어그램](./media/containers-foundation-for-devops-collaboration/persona-workloads-docker-container-lifecycle.png)

**그림 2-1.** 컨테이너화된 Docker 애플리케이션의 수명 주기에서 "가상 사용자별" 주요 워크로드

Docker 컨테이너를 사용하여 개발자는 컨테이너에 포함된 내용(애플리케이션과 서비스, 그리고 프레임워크와 구성 요소에 대한 종속성) 및 컨테이너와 서비스가 서비스 컬렉션에 의해 구성된 애플리케이션으로 함께 작동하는 방법을 주도적으로 관리합니다. 여러 컨테이너의 상호 종속성은 `docker-compose.yml` 파일 또는 *배포 매니페스트*라고 부를 수 있는 개체에 정의됩니다. 한편 IT 운영 팀(IT 전문가 및 관리 담당자)은 프로덕션 환경, 인프라, 확장성, 모니터링의 관리에 집중할 수 있으며, 결과적으로 여러 컨테이너의 내용을 알 필요 없이 애플리케이션이 최종 사용자를 위해 올바르게 제공되도록 할 수 있습니다. 따라서 "컨테이너"라는 이름은 실제 배송 컨테이너와 유사한 개념을 떠올리게 합니다. 즉, 컨테이너 내용물의 소유자는 컨테이너가 배송되는 방법에 직접 관여할 필요가 없으며, 배송 회사는 내용물을 알거나 관리할 필요 없이 컨테이너를 발송 지점에서 목적지로 운송합니다. 이와 유사한 개념으로 개발자는 "전송" 메커니즘에 직접 관여할 필요 없이 Docker 컨테이너 내에서 콘텐츠를 만들고 소유할 수 있습니다.

그림 2-1의 왼쪽에 있는 핵심 요소에서 개발자는 Windows용 또는 Mac용 Docker를 사용하여 Docker 컨테이너에서 코드를 작성하고 로컬로 실행합니다. 실행할 기본 운영 체제를 지정하는 Dockerfile을 사용하여 코드에 대한 운영 환경을 정의할 뿐만 아니라 해당 코드를 Docker 이미지로 빌드하기 위한 빌드 단계도 지정합니다. 개발자는 앞에서 언급한 `docker-compose.yml` 파일 배포 매니페스트를 사용하여 하나 이상의 이미지가 상호 운용하는 방법을 정의합니다. 로컬 개발을 완료할 때마다 애플리케이션 코드와 Docker 구성 파일을 선택한 코드 리포지토리(즉, Git 리포지토리)에 푸시합니다.

DevOps 핵심 요소는 코드 리포지토리에 제공된 Dockerfile을 사용하여 빌드-CI(지속적인 통합) 파이프라인을 정의합니다. CI 시스템은 선택한 Docker 레지스트리에서 기본 컨테이너 이미지를 풀하고 애플리케이션에 대한 사용자 지정 Docker 이미지를 빌드합니다. 그런 다음, 이미지의 유효성을 검사하고 여러 환경에 배포하는 데 사용되는 Docker 레지스트리에 이미지를 푸시합니다.

오른쪽의 핵심 요소에서 운영 팀은 환경 및 애플리케이션을 모니터링하면서 프로덕션에 배포된 애플리케이션과 인프라를 관리하여 애플리케이션 개선 방법에 관하여 개발 팀에 피드백과 인사이트를 제공할 수 있습니다. 일반적으로 컨테이너 앱은 [Kubernetes](https://kubernetes.io/)와 같은 컨테이너 오케스트레이터를 사용하여 프로덕션 환경에서 실행됩니다. 여기서 일반적으로 [Helm 차트](https://helm.sh/)는 docker 작성 파일 대신 배포 단위를 구성하는 데 사용됩니다.

두 팀은 기초 플랫폼(Docker 컨테이너)을 통해 협업하여 계약한 대로 우려를 불식시키는 동시에 애플리케이션 수명 주기에서 두 팀의 협업을 크게 개선합니다. 개발자는 컨테이너 콘텐츠, 해당 운영 환경 및 컨테이너 상호 의존성을 주도적으로 관리하며, 한편 운영 팀은 빌드된 이미지를 매니페스트와 함께 가져와서 자신의 오케스트레이션 시스템에서 실행합니다.

## <a name="challenges-in-the-application-life-cycle-when-using-docker"></a>Docker를 사용하는 경우 애플리케이션 수명 주기의 과제

향후 몇 년 동안 컨테이너화된 애플리케이션 수가 증가할 많은 이유가 있으며, 해당 이유 중 하나는 마이크로서비스를 기반으로 하는 애플리케이션을 만드는 것입니다.

지난 15년 동안 웹 서비스 사용은 수많은 애플리케이션의 기반이었으며, 아마도 몇 년 후에는 Docker 컨테이너에서 실행하는 마이크로 서비스 기반 애플리케이션에서 같은 상황을 목격할 것입니다.

또한 모놀리식 애플리케이션에 Docker 컨테이너를 사용해도 Docker의 이점을 잘 활용할 수 있을 것입니다. 컨테이너는 마이크로서비스만 대상으로 하지 않습니다.

Docker 컨테이너화 및 마이크로서비스 사용으로 조직의 개발 프로세스에 새로운 과제가 제기될 것이며, 따라서 프로덕션 시스템에서 실행하는 많은 컨테이너 및 마이크로서비스를 유지 관리하기 위한 확실한 전략이 필요합니다. 결과적으로 엔터프라이즈 애플리케이션은 프로덕션에서 실행하는 수많은 컨테이너/인스턴스를 포함하게 될 것입니다.

이러한 과제 때문에 DevOps 도구를 사용할 때 새로운 요구가 제기되므로 DevOps 작업에 새로운 프로세스를 정의하고 다음과 같은 유형의 질문에 대한 답을 찾아야 합니다.

- 개발, CI/CD, 관리 및 운영을 위해 어떤 도구를 사용할 수 있나요?

- 내 회사가 프로덕션에서 실행할 때 컨테이너의 오류를 어떻게 관리할 수 있나요?

- 가동 중지 시간을 최소화하면서 프로덕션에서 소프트웨어의 일부분을 어떻게 변경할 수 있나요?

- 프로덕션 시스템을 어떻게 크기 조정하고 모니터링할 수 있나요?

- 릴리스 파이프라인에 컨테이너 테스트 및 배포를 어떻게 포함할 수 있나요?

- Microsoft Azure에서 컨테이너용 오픈 소스 도구/플랫폼을 어떻게 사용할 수 있나요?

위의 모든 질문에 답할 수 있으면 애플리케이션(기존 또는 새 앱)을 Docker 컨테이너로 이동할 준비가 더 잘 된 것입니다.

## <a name="introduction-to-a-generic-end-to-end-docker-application-life-cycle-workflow"></a>일반적인 엔드투엔드 Docker 애플리케이션 수명 주기 워크플로 소개

그림 2-2는 특정 DevOps 작업과 자산의 이 인스턴스에 초점을 맞추어 Docker 애플리케이션 수명 주기의 더 자세한 워크플로를 보여줍니다.

![Docker 앱의 일반적인 엔드투엔드 수명 주기를 보여 주는 다이어그램](./media/containers-foundation-for-devops-collaboration/generic-end-to-enddpcker-app-life-cycle.png)

**그림 2-2.** Docker 컨테이너화된 애플리케이션 수명 주기에 대한 고급 워크플로

모든 작업은 내부 루프 워크플로에서 코드 작성을 시작하는 개발자와 함께 시작합니다. 내부 루프 단계에서 개발자는 코드를 코드 리포지토리(예: Git와 같은 원본 제어 시스템)에 푸시하기 전에 일어나는 모든 사항을 정의합니다. 정의한 사항이 커밋된 후 리포지토리에서 CI(지속적인 통합) 및 워크플로의 나머지 부분을 트리거합니다.

내부 루프는 “코드”, “실행”, “테스트” 및 “디버그”와 같은 일반적인 단계 및 앱을 로컬로 실행하기 직전에 필요한 추가 단계로 구성됩니다. 이러한 프로세스에서 개발자는 앱을 Docker 컨테이너로 실행하고 테스트합니다. 내부 루프 워크플로는 다음 섹션에서 설명합니다.

한 단계 되돌아가 엔드투엔드 워크플로를 살펴보면 DevOps 워크플로는 기술 또는 도구 세트 이상이며, 문화적 진화가 필요한 사고방식입니다. 즉, 사용자의 노력과 프로세스 개선 및 적절한 도구를 통해 애플리케이션 수명 주기를 더 빠르고 예측 가능하게 만들어야 합니다. 컨테이너화된 워크플로를 채택하는 기업은 대개 컨테이너화된 워크플로와 일치하는 사용자와 프로세스를 나타내도록 조직 구조를 개편합니다.

DevOps를 실천하면 오류가 발생하기 쉬운 수동 프로세스를 자동화된 프로세스로 바꾸어 추적성을 개선하고 워크플로를 반복 가능하게 만들어 팀이 함께 경쟁 압력에 더 빨리 대응할 수 있습니다. 또한 조직은 온-프레미스와 클라우드 리소스의 결합 및 치밀하게 통합된 툴링을 사용하여 환경을 더 효율적으로 관리하고 비용 절감을 실현할 수 있습니다.

Docker 애플리케이션에 대한 DevOps 워크플로를 구현하면 내부 루프에서 작업하는 개발실(코드, 실행, 디버그)에서 빌드-테스트-CI 단계, 그리고 끝으로 스테이징 및 프로덕션 환경에 컨테이너 배포에 이르기까지 워크플로의 거의 모든 단계에 Docker 기술이 반영된 것을 확인하게 됩니다.

품질 관리 방법을 개선하면 개발 주기의 조기에 결함을 식별하여 수정 비용을 줄일 수 있습니다. 환경 및 종속성을 이미지에 포함하고 여러 환경 간에 동일한 이미지를 배포한다는 철학을 채택하면 환경 고유의 구성을 추출하여 배포의 신뢰성을 높인다는 원칙이 더 빨리 정착될 것입니다.

효과적인 계측(모니터링 및 진단)을 통해 얻은 풍부한 데이터를 통해 성능 문제와 사용자 행동을 파악할 수 있는 통찰력을 제공하여 향후 우선 순위와 투자에 길잡이가 됩니다.

DevOps는 목적지가 아니라 여정이라고 생각해야 합니다. 즉, 성공, 학습 및 진화를 입증할 수 있는 적절한 범위가 설정된 프로젝트를 통해 점진적으로 구현해 가야 합니다.

## <a name="benefits-of-devops-for-containerized-applications"></a>컨테이너화된 애플리케이션에 대한 DevOps의 이점

다음은 확실한 DevOps 워크플로가 제공하는 매우 중요한 몇 가지 이점입니다.

- 더 빠르고 규정 준수가 강화된 높은 품질의 소프트웨어를 제공합니다.

- 지속적인 개선과 조정을 조기에 더 경제적으로 추진합니다.

- 소프트웨어 제공 및 운영에 관여하는 이해관계자 간의 투명성 및 협업을 개선합니다.

- 비용을 통제하고 프로비저닝된 리소스를 더 효율적으로 이용함과 동시에 보안 위험을 최소화합니다.

- 오픈 소스에 투자를 포함하여 기존 DevOps 투자와 즉시 연결하여 활용합니다.

>[!div class="step-by-step"]
>[이전](index.md)
>[다음](../Microsoft-platform-tools-containerized-apps/index.md)
