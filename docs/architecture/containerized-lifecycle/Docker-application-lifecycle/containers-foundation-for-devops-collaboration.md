---
title: DevOps 협업의 기반으로 사용되는 컨테이너
description: DevOps를 간소화하기 위한 컨테이너의 주요 역할을 이해합니다.
ms.date: 02/15/2019
ms.openlocfilehash: 8258f4331212d92376d64fef318adcdff492f61f
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/14/2020
ms.locfileid: "73094495"
---
# <a name="containers-as-the-foundation-for-devops-collaboration"></a><span data-ttu-id="0ebc0-103">DevOps 협업의 기반으로 사용되는 컨테이너</span><span class="sxs-lookup"><span data-stu-id="0ebc0-103">Containers as the foundation for DevOps collaboration</span></span>

<span data-ttu-id="0ebc0-104">컨테이너 및 Docker 기술의 본래 특성상 개발자는 “내 머신에서 작동한다”는 일반적인 변명을 하지 않고 소프트웨어 및 종속성을 IT 운영 부서 및 프로덕션 환경과 쉽게 공유할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-104">By the very nature of the containers and Docker technology, developers can share their software and dependencies easily with IT operations and production environments while eliminating the typical "it works on my machine" excuse.</span></span> <span data-ttu-id="0ebc0-105">컨테이너는 서로 다른 환경 간의 애플리케이션 충돌을 해결합니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-105">Containers solve application conflicts between different environments.</span></span> <span data-ttu-id="0ebc0-106">컨테이너 및 Docker는 개발자와 IT 운영 부서를 더 가깝게 만들어 효과적으로 협업하기 쉽게 해주는 간접적인 효과가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-106">Indirectly, containers and Docker bring developers and IT operations closer together, making it easier for them to collaborate effectively.</span></span> <span data-ttu-id="0ebc0-107">컨테이너 워크플로를 채택하면 많은 고객에게 이전부터 추구해 왔지만 더 복잡한 릴리스 및 빌드 파이프라인 구성을 통해 구현해야 했던 DevOps 지속성을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-107">Adopting the container workflow provides many customers with the DevOps continuity they've sought but previously had to implement via more complex configuration for release and build pipelines.</span></span> <span data-ttu-id="0ebc0-108">컨테이너는 DevOps의 빌드/테스트/배포 파이프라인을 간소화합니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-108">Containers simplify the build/test/deploy pipelines in DevOps.</span></span>

![Docker 앱의 수명 주기에 대한 소유권을 보여 주는 다이어그램](./media/containers-foundation-for-devops-collaboration/persona-workloads-docker-container-lifecycle.png)

<span data-ttu-id="0ebc0-110">**그림 2-1.**</span><span class="sxs-lookup"><span data-stu-id="0ebc0-110">**Figure 2-1.**</span></span> <span data-ttu-id="0ebc0-111">컨테이너화된 Docker 애플리케이션의 수명 주기에서 "가상 사용자별" 주요 워크로드</span><span class="sxs-lookup"><span data-stu-id="0ebc0-111">Main workloads per "personas" in the life cycle for containerized Docker applications</span></span>

<span data-ttu-id="0ebc0-112">Docker 컨테이너를 사용하여 개발자는 컨테이너에 포함된 내용(애플리케이션과 서비스, 그리고 프레임워크와 구성 요소에 대한 종속성) 및 컨테이너와 서비스가 서비스 컬렉션에 의해 구성된 애플리케이션으로 함께 작동하는 방법을 주도적으로 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-112">With Docker containers, developers own what's within the container (application and service, and dependencies to frameworks and components) and how the containers and services behave together as an application composed by a collection of services.</span></span> <span data-ttu-id="0ebc0-113">여러 컨테이너의 상호 종속성은 `docker-compose.yml` 파일 또는 *배포 매니페스트*라고 부를 수 있는 개체에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-113">The interdependencies of the multiple containers are defined in a `docker-compose.yml` file, or what could be called a *deployment manifest*.</span></span> <span data-ttu-id="0ebc0-114">한편 IT 운영 팀(IT 전문가 및 관리 담당자)은 프로덕션 환경, 인프라, 확장성, 모니터링의 관리에 집중할 수 있으며, 결과적으로 여러 컨테이너의 내용을 알 필요 없이 애플리케이션이 최종 사용자를 위해 올바르게 제공되도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-114">Meanwhile, IT operations teams (IT professionals and management) can focus on the management of production environments; infrastructure; scalability; monitoring; and, ultimately, ensuring that the applications are delivering properly for the end users, without having to know the contents of the various containers.</span></span> <span data-ttu-id="0ebc0-115">따라서 "컨테이너"라는 이름은 실제 배송 컨테이너와 유사한 개념을 떠올리게 합니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-115">Hence, the name "container," recalling the analogy to real-world shipping containers.</span></span> <span data-ttu-id="0ebc0-116">즉, 컨테이너 내용물의 소유자는 컨테이너가 배송되는 방법에 직접 관여할 필요가 없으며, 배송 회사는 내용물을 알거나 관리할 필요 없이 컨테이너를 발송 지점에서 목적지로 운송합니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-116">Thus, the owners of a container's content need not concern themselves with how the container will be shipped, and the shipping company transports a container from its point of origin to its destination without knowing or caring about the contents.</span></span> <span data-ttu-id="0ebc0-117">이와 유사한 개념으로 개발자는 "전송" 메커니즘에 직접 관여할 필요 없이 Docker 컨테이너 내에서 콘텐츠를 만들고 소유할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-117">In a similar manner, developers can create and own the contents within a Docker container without the need to concern themselves with the "transport" mechanisms.</span></span>

<span data-ttu-id="0ebc0-118">그림 2-1의 왼쪽에 있는 핵심 요소에서 개발자는 Windows용 또는 Mac용 Docker를 사용하여 Docker 컨테이너에서 코드를 작성하고 로컬로 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-118">In the pillar on the left side of Figure 2-1, developers write and run code locally in Docker containers by using Docker for Windows or Mac.</span></span> <span data-ttu-id="0ebc0-119">실행할 기본 운영 체제를 지정하는 Dockerfile을 사용하여 코드에 대한 운영 환경을 정의할 뿐만 아니라 해당 코드를 Docker 이미지로 빌드하기 위한 빌드 단계도 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-119">They define the operating environment for the code by using a Dockerfile that specifies the base operating system to run as well as the build steps for building their code into a Docker image.</span></span> <span data-ttu-id="0ebc0-120">개발자는 앞에서 언급한 `docker-compose.yml` 파일 배포 매니페스트를 사용하여 하나 이상의 이미지가 상호 운용하는 방법을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-120">The developers define how one or more images will interoperate using the aforementioned `docker-compose.yml` file deployment manifest.</span></span> <span data-ttu-id="0ebc0-121">로컬 개발을 완료할 때마다 애플리케이션 코드와 Docker 구성 파일을 선택한 코드 리포지토리(즉, Git 리포지토리)에 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-121">As they complete their local development, they push their application code plus the Docker configuration files to the code repository of their choice (that is, Git repository).</span></span>

<span data-ttu-id="0ebc0-122">DevOps 핵심 요소는 코드 리포지토리에 제공된 Dockerfile을 사용하여 빌드-CI(지속적인 통합) 파이프라인을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-122">The DevOps pillar defines the build–Continuous Integration (CI) pipelines using the Dockerfile provided in the code repository.</span></span> <span data-ttu-id="0ebc0-123">CI 시스템은 선택한 Docker 레지스트리에서 기본 컨테이너 이미지를 풀하고 애플리케이션에 대한 사용자 지정 Docker 이미지를 빌드합니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-123">The CI system pulls the base container images from the selected Docker registry and builds the custom Docker images for the application.</span></span> <span data-ttu-id="0ebc0-124">그런 다음, 이미지의 유효성을 검사하고 여러 환경에 배포하는 데 사용되는 Docker 레지스트리에 이미지를 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-124">The images then are validated and pushed to the Docker registry used for the deployments to multiple environments.</span></span>

<span data-ttu-id="0ebc0-125">오른쪽의 핵심 요소에서 운영 팀은 환경 및 애플리케이션을 모니터링하면서 프로덕션에 배포된 애플리케이션과 인프라를 관리하여 애플리케이션 개선 방법에 관하여 개발 팀에 피드백과 인사이트를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-125">In the pillar on the right, operations teams manage deployed applications and infrastructure in production while monitoring the environment and applications so that they can provide feedback and insights to the development team about how the application might be improved.</span></span> <span data-ttu-id="0ebc0-126">컨테이너 앱은 일반적으로 컨테이너 오케스트레이터를 사용하여 프로덕션에서 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-126">Container apps are typically run in production using container orchestrators.</span></span>

<span data-ttu-id="0ebc0-127">두 팀은 기초 플랫폼(Docker 컨테이너)을 통해 협업하여 계약한 대로 우려를 불식시키는 동시에 애플리케이션 수명 주기에서 두 팀의 협업을 크게 개선합니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-127">The two teams are collaborating through a foundational platform (Docker containers) that provides a separation of concerns as a contract, while greatly improving the two teams' collaboration in the application life cycle.</span></span> <span data-ttu-id="0ebc0-128">개발자는 컨테이너 콘텐츠, 해당 운영 환경 및 컨테이너 상호 의존성을 주도적으로 관리하며, 한편 운영 팀은 빌드된 이미지를 매니페스트와 함께 가져와서 자신의 오케스트레이션 시스템에서 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-128">The developers own the container contents, its operating environment, and the container interdependencies, whereas the operations teams take the built images along with the manifest and runs them in their orchestration system.</span></span>

## <a name="challenges-in-application-life-cycle-when-using-docker"></a><span data-ttu-id="0ebc0-129">Docker를 사용하는 경우 애플리케이션 수명 주기의 과제</span><span class="sxs-lookup"><span data-stu-id="0ebc0-129">Challenges in application life cycle when using Docker.</span></span>

<span data-ttu-id="0ebc0-130">향후 몇 년 동안 컨테이너화된 애플리케이션 수가 증가할 많은 이유가 있으며, 해당 이유 중 하나는 마이크로서비스를 기반으로 하는 애플리케이션을 만드는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-130">There are many reasons that will increase the number of containerized applications in the upcoming years, and one of these reasons is the creation of applications based on microservices.</span></span>

<span data-ttu-id="0ebc0-131">지난 15년 동안 웹 서비스 사용은 수많은 애플리케이션의 기반이었으며, 아마도 몇 년 후에는 Docker 컨테이너에서 실행하는 마이크로서비스 기반 애플리케이션에서 같은 상황을 목격할 것입니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-131">During the last 15 years, the use of web services has been the base of thousands of applications, and probably, after a few years, we'll find the same situation with microservice-based applications running on Docker containers.</span></span>

<span data-ttu-id="0ebc0-132">또한 모놀리식 애플리케이션에 Docker 컨테이너를 사용해도 Docker의 이점을 잘 활용할 수 있을 것입니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-132">It is also worth to mention that you can also use Docker containers for monolithic applications and you still get most of the benefits of Docker.</span></span> <span data-ttu-id="0ebc0-133">컨테이너는 마이크로서비스만 대상으로 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-133">Containers are not targeting only microservices.</span></span>

<span data-ttu-id="0ebc0-134">Docker 컨테이너화 및 마이크로서비스 사용으로 조직의 개발 프로세스에 새로운 과제가 제기될 것이며, 따라서 프로덕션 시스템에서 실행하는 많은 컨테이너 및 마이크로서비스를 유지 관리하기 위한 확실한 전략이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-134">The use of Docker containerization and microservices causes new challenges in the development process of your organizations and therefore, you need a solid strategy to maintain many containers and microservices running on production systems.</span></span> <span data-ttu-id="0ebc0-135">결과적으로 엔터프라이즈 애플리케이션은 프로덕션에서 실행하는 수많은 컨테이너/인스턴스를 포함하게 될 것입니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-135">Eventually, enterprise applications will have hundreds or thousands of containers/instances running in production.</span></span>

<span data-ttu-id="0ebc0-136">이러한 과제 때문에 DevOps 도구를 사용할 때 새로운 요구가 제기되므로 DevOps 작업에 새로운 프로세스를 정의하고 다음과 같은 유형의 질문에 대한 답을 찾아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-136">These challenges create new demands when using DevOps tools, so you'll have to define new processes in your DevOps activities, and find answers for this type of questions:</span></span>

- <span data-ttu-id="0ebc0-137">CI/CD, 관리 및 운영을 위해 어느 개발 도구를 사용할 수 있나요?</span><span class="sxs-lookup"><span data-stu-id="0ebc0-137">Which tools can I use for development, for CI/CD, management and operations?</span></span>

- <span data-ttu-id="0ebc0-138">내 회사가 프로덕션에서 실행할 때 컨테이너의 오류를 어떻게 관리할 수 있나요?</span><span class="sxs-lookup"><span data-stu-id="0ebc0-138">How can my company manage errors in containers when running in production?</span></span>

- <span data-ttu-id="0ebc0-139">가동 중지 시간을 최소화하면서 프로덕션에서 소프트웨어의 일부분을 어떻게 변경할 수 있나요?</span><span class="sxs-lookup"><span data-stu-id="0ebc0-139">How can we change pieces of our software in production with minimum downtime?</span></span>

- <span data-ttu-id="0ebc0-140">프로덕션 시스템을 어떻게 크기 조정하고 모니터링할 수 있나요?</span><span class="sxs-lookup"><span data-stu-id="0ebc0-140">How can we scale and how can we monitor our production system?</span></span>

- <span data-ttu-id="0ebc0-141">릴리스 파이프라인에 컨테이너 테스트 및 배포를 어떻게 포함할 수 있나요?</span><span class="sxs-lookup"><span data-stu-id="0ebc0-141">How can we include testing and deployment of containers in our release pipeline?</span></span>

- <span data-ttu-id="0ebc0-142">Microsoft Azure에서 컨테이너용 오픈 소스 도구/플랫폼을 어떻게 사용할 수 있나요?</span><span class="sxs-lookup"><span data-stu-id="0ebc0-142">How can we use Open Source tools/platforms for containers in Microsoft Azure?</span></span>

<span data-ttu-id="0ebc0-143">위의 모든 질문에 답할 수 있으면 애플리케이션(기존 또는 새 앱)을 Docker 컨테이너로 이동할 준비가 더 잘 된 것입니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-143">If you can answer all those questions, you'll be better prepared to move your applications (existing or new apps) to Docker containers.</span></span>

## <a name="introduction-to-a-generic-end-to-end-docker-application-life-cycle-workflow"></a><span data-ttu-id="0ebc0-144">일반적인 엔드투엔드 Docker 애플리케이션 수명 주기 워크플로 소개</span><span class="sxs-lookup"><span data-stu-id="0ebc0-144">Introduction to a generic end-to-end Docker application life cycle workflow</span></span>

<span data-ttu-id="0ebc0-145">그림 2-2는 특정 DevOps 작업과 자산의 이 인스턴스에 초점을 맞추어 Docker 애플리케이션 수명 주기의 더 자세한 워크플로를 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-145">Figure 2-2 presents a more detailed workflow for a Docker application life cycle, focusing in this instance on specific DevOps activities and assets.</span></span>

![Docker 앱의 일반적인 엔드투엔드 수명 주기를 보여 주는 다이어그램](./media/containers-foundation-for-devops-collaboration/generic-end-to-enddpcker-app-life-cycle.png)

<span data-ttu-id="0ebc0-147">**그림 2-2.**</span><span class="sxs-lookup"><span data-stu-id="0ebc0-147">**Figure 2-2.**</span></span> <span data-ttu-id="0ebc0-148">Docker 컨테이너화된 애플리케이션 수명 주기에 대한 고급 워크플로</span><span class="sxs-lookup"><span data-stu-id="0ebc0-148">High-level workflow for the Docker containerized application life cycle</span></span>

<span data-ttu-id="0ebc0-149">모든 작업은 내부 루프 워크플로에서 코드 작성을 시작하는 개발자와 함께 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-149">Everything begins with the developer, who starts writing code in the inner-loop workflow.</span></span> <span data-ttu-id="0ebc0-150">내부 루프 단계에서 개발자는 코드를 코드 리포지토리(예: Git와 같은 원본 제어 시스템)에 푸시하기 전에 일어나는 모든 사항을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-150">The inner-loop stage is where developers define everything that happens before pushing code into the code repository (for example, a source control system such as Git).</span></span> <span data-ttu-id="0ebc0-151">정의한 사항이 커밋된 후 리포지토리에서 CI(지속적인 통합) 및 워크플로의 나머지 부분을 트리거합니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-151">After it's committed, the repository triggers Continuous Integration (CI) and the rest of the workflow.</span></span>

<span data-ttu-id="0ebc0-152">내부 루프는 기본적으로 "코드", "실행", "테스트" 및 "디버그"와 같은 일반적인 단계 및 앱을 로컬로 실행하기 직전에 필요한 추가 단계로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-152">The inner loop basically consists of typical steps like "code," "run," "test," and "debug," plus the additional steps needed right before running the app locally.</span></span> <span data-ttu-id="0ebc0-153">이러한 프로세스에서 개발자는 앱을 Docker 컨테이너로 실행하고 테스트합니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-153">This is the developer's process to run and test the app as a Docker container.</span></span> <span data-ttu-id="0ebc0-154">내부 루프 워크플로는 다음 섹션에서 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-154">The inner-loop workflow will be explained in the sections that follow.</span></span>

<span data-ttu-id="0ebc0-155">한 단계 되돌아가 엔드투엔드 워크플로를 살펴보면 DevOps 워크플로는 기술 또는 도구 세트 이상이며, 문화적 진화가 필요한 사고방식입니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-155">Taking a step back to look at the end-to end workflow, the DevOps workflow is more than a technology or a tool set: it's a mindset that requires cultural evolution.</span></span> <span data-ttu-id="0ebc0-156">즉, 사용자의 노력과 프로세스 개선 및 적절한 도구를 통해 애플리케이션 수명 주기를 더 빠르고 예측 가능하게 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-156">It's people, processes, and the appropriate tools to make your application life cycle faster and more predictable.</span></span> <span data-ttu-id="0ebc0-157">컨테이너화된 워크플로를 채택하는 기업은 대개 컨테이너화된 워크플로와 일치하는 사용자와 프로세스를 나타내도록 조직 구조를 개편합니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-157">Enterprises that adopt a containerized workflow typically restructure their organizations to represent people and processes that match the containerized workflow.</span></span>

<span data-ttu-id="0ebc0-158">DevOps를 실천하면 오류가 발생하기 쉬운 수동 프로세스를 자동화된 프로세스로 바꾸어 추적성을 개선하고 워크플로를 반복 가능하게 만들어 팀이 함께 경쟁 압력에 더 빨리 대응할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-158">Practicing DevOps can help teams respond faster together to competitive pressures by replacing error-prone manual processes with automation, which results in improved traceability and repeatable workflows.</span></span> <span data-ttu-id="0ebc0-159">또한 조직은 온-프레미스와 클라우드 리소스의 결합 및 치밀하게 통합된 툴링을 사용하여 환경을 더 효율적으로 관리하고 비용 절감을 실현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-159">Organizations also can manage environments more efficiently and realize cost savings with a combination of on-premises and cloud resources as well as tightly integrated tooling.</span></span>

<span data-ttu-id="0ebc0-160">Docker 애플리케이션에 대한 DevOps 워크플로를 구현하면 내부 루프에서 작업하는 개발실(코드, 실행, 디버그)에서 빌드-테스트-CI 단계, 그리고 끝으로 스테이징 및 프로덕션 환경에 컨테이너 배포에 이르기까지 워크플로의 거의 모든 단계에 Docker 기술이 반영된 것을 확인하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-160">When implementing your DevOps workflow for Docker applications, you'll see that Docker technologies are present in almost every stage of the workflow, from your development box while working in the inner loop (code, run, debug), the build-test-CI phase, and, finally, the deployment of those containers to the staging and production environments.</span></span>

<span data-ttu-id="0ebc0-161">품질 관리 방법을 개선하면 개발 주기의 조기에 결함을 식별하여 수정 비용을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-161">Improvement of quality practices helps to identify defects early in the development cycle, which reduces the cost of fixing them.</span></span> <span data-ttu-id="0ebc0-162">환경 및 종속성을 이미지에 포함하고 여러 환경 간에 동일한 이미지를 배포한다는 철학을 채택하면 환경 고유의 구성을 추출하여 배포의 신뢰성을 높인다는 원칙이 더 빨리 정착될 것입니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-162">By including the environment and dependencies in the image and adopting a philosophy of deploying the same image across multiple environments, you promote a discipline of extracting the environment-specific configurations making deployments more reliable.</span></span>

<span data-ttu-id="0ebc0-163">효과적인 계측(모니터링 및 진단)을 통해 얻은 풍부한 데이터를 통해 성능 문제와 사용자 행동을 파악할 수 있는 통찰력을 제공하여 향후 우선 순위와 투자에 길잡이가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-163">Rich data obtained through effective instrumentation (monitoring and diagnostics) provides insight into performance issues and user behavior to guide future priorities and investments.</span></span>

<span data-ttu-id="0ebc0-164">DevOps는 목적지가 아니라 여정이라고 생각해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-164">DevOps should be considered a journey, not a destination.</span></span> <span data-ttu-id="0ebc0-165">즉, 성공, 학습 및 진화를 입증할 수 있는 적절한 범위가 설정된 프로젝트를 통해 점진적으로 구현해 가야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-165">It should be implemented incrementally through appropriately scoped projects from which you can demonstrate success, learn, and evolve.</span></span>

## <a name="benefits-of-devops-for-containerized-applications"></a><span data-ttu-id="0ebc0-166">컨테이너화된 애플리케이션에 대한 DevOps의 이점</span><span class="sxs-lookup"><span data-stu-id="0ebc0-166">Benefits of DevOps for containerized applications</span></span>

<span data-ttu-id="0ebc0-167">다음은 확실한 DevOps 워크플로가 제공하는 매우 중요한 몇 가지 이점입니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-167">Here are some of the most important benefits provided by a solid DevOps workflow:</span></span>

- <span data-ttu-id="0ebc0-168">더 빠르고 규정 준수가 강화된 높은 품질의 소프트웨어를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-168">Deliver better-quality software, faster and with better compliance.</span></span>

- <span data-ttu-id="0ebc0-169">지속적인 개선과 조정을 조기에 더 경제적으로 추진합니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-169">Drive continuous improvement and adjustments earlier and more economically.</span></span>

- <span data-ttu-id="0ebc0-170">소프트웨어 제공 및 운영에 관여하는 이해관계자 간의 투명성 및 협업을 개선합니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-170">Increase transparency and collaboration among stakeholders involved in delivering and operating software.</span></span>

- <span data-ttu-id="0ebc0-171">비용을 통제하고 프로비저닝된 리소스를 더 효율적으로 이용함과 동시에 보안 위험을 최소화합니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-171">Control costs and utilize provisioned resources more effectively while minimizing security risks.</span></span>

- <span data-ttu-id="0ebc0-172">오픈 소스에 투자를 포함하여 기존 DevOps 투자와 즉시 연결하여 활용합니다.</span><span class="sxs-lookup"><span data-stu-id="0ebc0-172">Plug and play well with many of your existing DevOps investments, including investments in open-source.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="0ebc0-173">[이전](index.md)
>[다음](../Microsoft-platform-tools-containerized-apps/index.md)</span><span class="sxs-lookup"><span data-stu-id="0ebc0-173">[Previous](index.md)
[Next](../Microsoft-platform-tools-containerized-apps/index.md)</span></span>
