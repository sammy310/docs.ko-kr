---
title: Docker 애플리케이션에 대한 외부 루프 DevOps 워크플로의 단계
description: DevOps 워크플로의 "외부 루프"에 대한 단계 알아보기
ms.date: 02/15/2019
ms.openlocfilehash: 44bd73bf88a743e5350e422d3ea000ca075f7383
ms.sourcegitcommit: 465547886a1224a5435c3ac349c805e39ce77706
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/21/2020
ms.locfileid: "82021294"
---
# <a name="steps-in-the-outer-loop-devops-workflow-for-a-docker-application"></a><span data-ttu-id="e5073-103">Docker 애플리케이션에 대한 외부 루프 DevOps 워크플로의 단계</span><span class="sxs-lookup"><span data-stu-id="e5073-103">Steps in the outer-loop DevOps workflow for a Docker application</span></span>

<span data-ttu-id="e5073-104">그림 5-1은 DevOps 외부 루프 워크플로를 구성하는 단계를 아주 자세히 묘사하여 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-104">Figure 5-1 presents an end-to-end depiction of the steps comprising the DevOps outer-loop workflow.</span></span> <span data-ttu-id="e5073-105">이 그림은 DevOps의 "외부 루프"를 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-105">It shows the "outer loop" of DevOps.</span></span> <span data-ttu-id="e5073-106">코드가 리포지토리에 푸시되면 CI 파이프라인이 시작된 후 CD 파이프라인을 시작하고 해당 파이프라인에서 애플리케이션이 배포됩니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-106">When code is pushed to the repo, a CI pipeline is started, then begins the CD pipeline, where the application gets deployed.</span></span> <span data-ttu-id="e5073-107">배포된 애플리케이션에서 수집된 메트릭은 개발 워크로드에 피드백되며, 여기서 "내부 루프"가 발생하므로 개발 팀은 사용자 및 비즈니스 요구에 응답하는 실질적인 데이터를 갖게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-107">Metrics collected from deployed applications are fed back into the development workload, where the "inner loop" occurs, so development teams have actual data to respond to user and business needs.</span></span>

![DevOps 외부 루프 워크플로의 6개 단계를 보여 주는 다이어그램](./media/docker-application-outer-loop-devops-workflow/overview-dev-ops-outter-loop-workflow.png)

<span data-ttu-id="e5073-109">**그림 5-1**.</span><span class="sxs-lookup"><span data-stu-id="e5073-109">**Figure 5-1**.</span></span> <span data-ttu-id="e5073-110">Microsoft 도구를 사용하는 Docker 애플리케이션에 대한 DevOps 외부 루프 워크플로</span><span class="sxs-lookup"><span data-stu-id="e5073-110">DevOps outer-loop workflow for Docker applications with Microsoft tools</span></span>

<span data-ttu-id="e5073-111">이제 이러한 각 단계를 자세히 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-111">Now, let's examine each of these steps in greater detail.</span></span>

## <a name="step-1-inner-loop-development-workflow"></a><span data-ttu-id="e5073-112">1단계: 내부 루프 개발 워크플로</span><span class="sxs-lookup"><span data-stu-id="e5073-112">Step 1: Inner-loop development workflow</span></span>

<span data-ttu-id="e5073-113">이 단계는 4 장에서 자세히 설명하지만, 요약하면 여기서 외부 루프가 시작되며 이 시점에 개발자가 코드를 원본 제어 관리 시스템(예: Git)에 푸시하여 CI 파이프라인 작업을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-113">This step is explained in detail in Chapter 4, but, to recap, here is where the outer-loop begins, the moment at which a developer pushes code to the source control management system (like Git) initiating CI pipeline actions.</span></span>

## <a name="step-2-source-code-control-integration-and-management-with-azure-devops-services-and-git"></a><span data-ttu-id="e5073-114">2단계: Azure DevOps Services 및 Git를 사용하여 소스 코드 컨트롤 통합 및 관리</span><span class="sxs-lookup"><span data-stu-id="e5073-114">Step 2: Source-Code Control integration and management with Azure DevOps Services and Git</span></span>

<span data-ttu-id="e5073-115">이 단계에서 버전 관리 시스템이 팀의 여러 개발자로부터 들어오는 모든 코드의 통합된 버전을 수집하게 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-115">At this step, you need to have a version-control system to gather a consolidated version of all the code coming from the different developers in the team.</span></span>

<span data-ttu-id="e5073-116">SCC(소스 코드 제어) 및 소스 코드 관리는 대부분의 개발자에게 습관처럼 생각될 수 있지만 DevOps 수명 주기에서 Docker 애플리케이션을 만드는 경우 개발자의 머신에서 애플리케이션과 함께 Docker 이미지를 글로벌 Docker 레지스트리(예: Azure Container Registry 또는 Docker Hub)에 직접 제출해서는 안 된다는 점이 매우 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-116">Even though source-code control (SCC) and source-code management might seem second-nature to most developers, when creating Docker applications in a DevOps life cycle, it's critical to emphasize that you must not submit the Docker images with the application directly to the global Docker Registry (like Azure Container Registry or Docker Hub) from the developer's machine.</span></span> <span data-ttu-id="e5073-117">반대로 프로덕션 환경에 릴리스 및 배포할 Docker 이미지는 소스 코드 리포지토리(예: Git)를 기반으로 글로벌 빌드 또는 CI 파이프라인에 통합되는 소스 코드에서만 생성해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-117">On the contrary, the Docker images to be released and deployed to production environments must be created solely on the source code that's being integrated in your global build or CI pipeline based on your source-code repository (like Git).</span></span>

<span data-ttu-id="e5073-118">개발자가 생성하는 로컬 이미지는 개발자 자신의 머신 내에서 테스트용으로만 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-118">The local images, generated by developers, should just be used by them when testing within their own machines.</span></span> <span data-ttu-id="e5073-119">DevOps 파이프라인을 SCC 코드에서 활성화하는 것이 중요한 것도 바로 이 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-119">That's why it's critical to have the DevOps pipeline activated from the SCC code.</span></span>

<span data-ttu-id="e5073-120">Azure DevOps Services 및 Team Foundation Server는 Git 및 Team Foundation 버전 관리를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-120">Azure DevOps Services and Team Foundation Server support Git and Team Foundation Version Control.</span></span> <span data-ttu-id="e5073-121">이들 중에서 선택하여 엔드투엔드 Microsoft 환경에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-121">You can choose between them and use it for an end-to-end Microsoft experience.</span></span> <span data-ttu-id="e5073-122">그러나 외부 리포지토리(예: GitHub, 온-프레미스 Git 리포지토리 또는 Subversion)에서 코드를 관리하고 해당 리포지토리에 연결하여 DevOps CI 파이프라인의 시작점으로 코드를 가져올 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-122">However, you can also manage your code in external repositories (like GitHub, on-premises Git repositories, or Subversion) and still be able to connect to it and get the code as the starting point for your DevOps CI pipeline.</span></span>

## <a name="step-3-build-ci-integrate-and-test-with-azure-devops-services-and-docker"></a><span data-ttu-id="e5073-123">3단계: Azure DevOps Services 및 Docker를 사용하여 빌드, CI, 통합 및 테스트</span><span class="sxs-lookup"><span data-stu-id="e5073-123">Step 3: Build, CI, Integrate, and Test with Azure DevOps Services and Docker</span></span>

<span data-ttu-id="e5073-124">CI는 최신 소프트웨어 테스트 및 제공을 위한 표준으로 부상 했습니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-124">CI has emerged as a standard for modern software testing and delivery.</span></span> <span data-ttu-id="e5073-125">Docker 솔루션은 개발 팀과 운영 팀 간에 관심사를 명확하게 분리합니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-125">The Docker solution maintains a clear separation of concerns between the development and operations teams.</span></span> <span data-ttu-id="e5073-126">Docker 이미지의 불변성 덕분에 CI를 통해 개발하고 테스트하는 내용과 프로덕션에서 실행하는 내용 간의 반복 가능한 배포가 보장됩니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-126">The immutability of Docker images ensures a repeatable deployment between what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="e5073-127">개발자 랩톱 및 테스트 인프라 간에 배포되는 Docker 엔진을 통해 환경 간에 컨테이너를 이식할 수 있게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-127">Docker Engine deployed across the developer laptops and test infrastructure makes the containers portable across environments.</span></span>

<span data-ttu-id="e5073-128">이 시점에서 올바른 코드가 제출된 버전 관리 시스템을 보유한 후 코드를 선택하고 글로벌 빌드 및 테스트를 실행하기 위해 *빌드 서비스*가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-128">At this point, after you have a version-control system with the correct code submitted, you need a *build service* to pick up the code and run the global build and tests.</span></span>

<span data-ttu-id="e5073-129">이 단계(CI, 빌드, 테스트)에 대한 내부 워크플로는 코드 리포지토리(Git 등), 빌드 서버(Azure DevOps 서비스), Docker 엔진 및 Docker 레지스트리 코드 리포지토리로 구성된 CI 파이프라인을 구축하는 과정입니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-129">The internal workflow for this step (CI, build, test) is about the construction of a CI pipeline consisting of your code repository (Git, etc.), your build server (Azure DevOps Services), Docker Engine, and a Docker Registry.</span></span>

<span data-ttu-id="e5073-130">애플리케이션을 빌드하고 CI 파이프라인을 설정하고 빌드된 "아티팩트"를 다음 단계에서 설명하는 "아티팩트 리포지토리"에 게시하기 위한 기초로 Azure DevOps Services를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-130">You can use Azure DevOps Services as the foundation for building your applications and setting your CI pipeline, and for publishing the built "artifacts" to an "artifacts repository," which is explained in the next step.</span></span>

<span data-ttu-id="e5073-131">배포를 위해 Docker를 사용하는 경우 배포할 "최종 아티팩트"는 애플리케이션 또는 해당 애플리케이션에 포함된 서비스를 포함하는 Docker 이미지입니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-131">When using Docker for the deployment, the "final artifacts" to be deployed are Docker images with your application or services embedded within them.</span></span> <span data-ttu-id="e5073-132">해당 이미지는 *Docker 레지스트리*(Azure Container Registry와 같은 프라이빗 리포지토리 또는 공식 기본 이미지에 널리 사용되는 Docker Hub 레지스트리와 같은 공용 리포지토리)에 푸시되거나 게시됩니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-132">Those images are pushed or published to a *Docker Registry* (a private repository like the ones you can have in Azure Container Registry, or a public one like Docker Hub Registry, which is commonly used for official base images).</span></span>

<span data-ttu-id="e5073-133">다음은 기본 개념입니다. CI 파이프라인은 Git와 같은 SCC 리포지토리에 대한 커밋에 의해 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-133">Here is the basic concept: The CI pipeline will be kicked-off by a commit to an SCC repository like Git.</span></span> <span data-ttu-id="e5073-134">이 커밋은 그림 5-2와 같이 Azure DevOps Services가 Docker 컨테이너 내에서 빌드 작업을 실행하고 해당 작업이 성공적으로 완료되면 Docker 이미지를 Docker 레지스트리에 푸시하게 합니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-134">The commit will cause Azure DevOps Services to run a build job within a Docker container and, upon successful completion of that job, push a Docker image to the Docker Registry, as illustrated in Figure 5-2.</span></span> <span data-ttu-id="e5073-135">외부 루프의 첫 번째 부분은 코드에서 실행, 디버그 및 유효성 검사 후 빌드 및 테스트 CI 단계까지의 코드 리포지토리에 이르는 1~3단계를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-135">The first part of the outer loop involves steps 1 to 3, from code, run, debug and validate, then the code repo up to the build and test CI step.</span></span>

![CI 워크플로와 관련된 세 단계를 보여 주는 다이어그램](./media/docker-application-outer-loop-devops-workflow/continuous-integration-steps.png)

<span data-ttu-id="e5073-137">**그림 5-2**.</span><span class="sxs-lookup"><span data-stu-id="e5073-137">**Figure 5-2**.</span></span> <span data-ttu-id="e5073-138">CI에 포함되는 단계</span><span class="sxs-lookup"><span data-stu-id="e5073-138">The steps involved in CI</span></span>

<span data-ttu-id="e5073-139">다음은 Docker 및 Azure DevOps Services를 사용하는 기본적인 CI 워크플로입니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-139">Here are the basic CI workflow steps with Docker and Azure DevOps Services:</span></span>

1. <span data-ttu-id="e5073-140">개발자가 SCC 리포지토리(Git/Azure DevOps Services, GitHub 등)에 대한 커밋을 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-140">The developer pushes a commit to an SCC repository (Git/Azure DevOps Services, GitHub, etc.).</span></span>

2. <span data-ttu-id="e5073-141">Azure DevOps Services 또는 Git를 사용하는 경우 CI는 기본 제공됩니다. 즉, Azure DevOps Services에서 확인란만 선택하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-141">If you're using Azure DevOps Services or Git, CI is built in, which means that it's as simple as selecting a check box in Azure DevOps Services.</span></span> <span data-ttu-id="e5073-142">외부 SCC(예: GitHub)를 사용하는 경우 `webhook`에서 Git/GitHub에 대한 업데이트 또는 푸시를 Azure DevOps Services에 알립니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-142">If you're using an external SCC (like GitHub), a `webhook` will notify Azure DevOps Services of the update or push to Git/GitHub.</span></span>

3. <span data-ttu-id="e5073-143">Azure DevOps Services는 이미지를 설명하는 Dockerfile 및 애플리케이션과 테스트 코드를 포함하여 SCC 리포지토리를 풀합니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-143">Azure DevOps Services pulls the SCC repository, including the Dockerfile describing the image, as well as the application and test code.</span></span>

4. <span data-ttu-id="e5073-144">Azure DevOps Services는 Docker 이미지를 빌드하고 빌드 번호로 해당 이미지에 레이블을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-144">Azure DevOps Services builds a Docker image and labels it with a build number.</span></span>

5. <span data-ttu-id="e5073-145">Azure DevOps Services는 프로비저닝된 Docker Host 내에서 Docker 컨테이너를 인스턴스화하고 적절한 테스트를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-145">Azure DevOps Services instantiates the Docker container within the provisioned Docker Host, and runs the appropriate tests.</span></span>

6. <span data-ttu-id="e5073-146">테스트에 성공하면 먼저 "빌드 성공"을 알 수 있도록 이미지에 의미 있는 이름으로 레이블("/1.0.0" 또는 다른 레이블)을 표시한 다음, Docker 레지스트리(Docker Hub, Azure Container Registry, DTR 등)에 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-146">If the tests are successful, the image is first relabeled to a meaningful name so that you know it's a "blessed build" (like "/1.0.0" or any other label), and then pushed up to your Docker Registry (Docker Hub, Azure Container Registry, DTR, etc.)</span></span>

### <a name="implementing-the-ci-pipeline-with-azure-devops-services-and-the-docker-extension-for-azure-devops-services"></a><span data-ttu-id="e5073-147">Azure DevOps Services 및 Azure DevOps Services용 Docker 확장을 사용하여 CI 파이프라인 구현</span><span class="sxs-lookup"><span data-stu-id="e5073-147">Implementing the CI pipeline with Azure DevOps Services and the Docker extension for Azure DevOps Services</span></span>

<span data-ttu-id="e5073-148">Visual Studio Azure DevOps Services는 CI/CD 파이프라인에 사용하여 Docker 이미지 빌드, 인증된 Docker 레지스트리에 Docker 이미지 푸시, Docker 이미지 실행, Docker CLI가 제공하는 다른 작업 실행을 수행할 수 있는 빌드 및 릴리스 템플릿을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-148">Visual Studio Azure DevOps Services contains Build & Release Templates that you can use in your CI/CD pipeline with which you can build Docker images, push Docker images to an authenticated Docker registry, run Docker images, or run other operations offered by the Docker CLI.</span></span> <span data-ttu-id="e5073-149">또한 다중 컨테이너 Docker 애플리케이션을 빌드, 푸시 또는 실행하는 데 사용할 수 있는 Docker Compose 작업을 추가하거나 그림 5-3과 같이 Docker Compose CLI가 제공하는 다른 작업을 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-149">It also adds a Docker Compose task that you can use to build, push, and run multi-container Docker applications, or run other operations offered by the Docker Compose CLI, as shown in Figure 5-3.</span></span>

![Azure DevOps의 Docker CI 파이프라인의 스크린샷](./media/docker-application-outer-loop-devops-workflow/docker-ci-pipeline-azure-devops.png)

<span data-ttu-id="e5073-151">**그림 5-3**.</span><span class="sxs-lookup"><span data-stu-id="e5073-151">**Figure 5-3**.</span></span> <span data-ttu-id="e5073-152">빌드 및 릴리스 템플릿과 관련 작업을 포함하는 Azure DevOps Services의 Docker CI 파이프라인</span><span class="sxs-lookup"><span data-stu-id="e5073-152">The Docker CI pipeline in Azure DevOps Services including Build & Release Templates and associated tasks.</span></span>

<span data-ttu-id="e5073-153">이 템플릿과 작업을 사용하여 Azure Service Fabric, Azure Kubernetes Service 및 유사한 제품에서 빌드 / 테스트 및 배포에 대해 CI/CD 아티팩트를 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-153">You can use these templates and tasks to construct your CI/CD artifacts to Build / Test and Deploy in Azure Service Fabric, Azure Kubernetes Service, and similar offerings.</span></span>

<span data-ttu-id="e5073-154">이러한 Visual Studio Team Services 작업을 통해 Azure 및 선호하는 Docker 레지스트리(Azure Container Registry, Docker Hub, 프라이빗 Docker DTR 또는 다른 Docker 레지스트리)에서 프로비저닝되는 Linux-Docker Host/VM을 빌드하면 Docker CI 파이프라인을 아주 일관된 방법으로 조립할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-154">With these Visual Studio Team Services tasks, a build Linux-Docker Host/VM provisioned in Azure and your preferred Docker registry (Azure Container Registry, Docker Hub, private Docker DTR, or any other Docker registry) you can assemble your Docker CI pipeline in a very consistent way.</span></span>

<span data-ttu-id="e5073-155">***요구 사항:***</span><span class="sxs-lookup"><span data-stu-id="e5073-155">***Requirements:***</span></span>

- <span data-ttu-id="e5073-156">Azure DevOps Services 또는 온-프레미스 설치의 경우 Team Foundation Server 2015 업데이트 3 이상</span><span class="sxs-lookup"><span data-stu-id="e5073-156">Azure DevOps Services, or for on-premises installations, Team Foundation Server 2015 Update 3 or later.</span></span>

- <span data-ttu-id="e5073-157">Docker 이진 파일을 포함하는 Azure DevOps Services 에이전트</span><span class="sxs-lookup"><span data-stu-id="e5073-157">An Azure DevOps Services agent that has the Docker binaries.</span></span>

  <span data-ttu-id="e5073-158">이러한 에이전트 중 하나를 만드는 쉬운 방법은 Docker를 사용하여 Azure DevOps Services 에이전트 Docker 이미지를 기반으로 컨테이너를 실행하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-158">An easy way to create one of these agents is to use Docker to run a container based on the Azure DevOps Services agent Docker image.</span></span>

> [!정보]<span data-ttu-id="e5073-159"> Azure DevOps Services Docker CI 파이프라인 조립에 대해 더 자세히 알아보려면 다음 사이트를 방문하세요.</span><span class="sxs-lookup"><span data-stu-id="e5073-159"> To read more about assembling an Azure DevOps Services Docker CI pipeline and view the walkthroughs, visit these sites:</span></span>
>
> - <span data-ttu-id="e5073-160">Visual Studio Team Services(현재 Azure DevOps Services) 에이전트를 Docker 컨테이너로 실행: </span><span class="sxs-lookup"><span data-stu-id="e5073-160">Running a Visual Studio Team Services (Now Azure DevOps Services) agent as a Docker container: </span></span>\
>   <https://hub.docker.com/_/microsoft-azure-pipelines-vsts-agent>
>
> - <span data-ttu-id="e5073-161">Azure DevOps Services를 사용하여 .NET Core Linux Docker 이미지 빌드: </span><span class="sxs-lookup"><span data-stu-id="e5073-161">Building .NET Core Linux Docker images with Azure DevOps Services: </span></span>\
>   <https://docs.microsoft.com/archive/blogs/stevelasker/building-net-core-linux-docker-images-with-visual-studio-team-services>
>
> - <span data-ttu-id="e5073-162">Docker 지원을 사용하여 Linux 기반 Visual Studio Team Service 빌드 머신 구축: </span><span class="sxs-lookup"><span data-stu-id="e5073-162">Building a Linux-based Visual Studio Team Service build machine with Docker support: </span></span>\
>   <http://donovanbrown.com/post/2016/06/03/Building-a-Linux-Based-Visual-Studio-Team-Service-Build-Machine-with-Docker-Support>

### <a name="integrate-test-and-validate-multi-container-docker-applications"></a><span data-ttu-id="e5073-163">다중 컨테이너 Docker 애플리케이션 통합, 테스트 및 유효성 검사</span><span class="sxs-lookup"><span data-stu-id="e5073-163">Integrate, test, and validate multi-container Docker applications</span></span>

<span data-ttu-id="e5073-164">일반적으로 대부분의 Docker 애플리케이션은 단일 컨테이너가 아닌 다중 컨테이너로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-164">Typically, most Docker applications are composed of multiple containers rather than a single container.</span></span> <span data-ttu-id="e5073-165">마이크로서비스당 하나의 컨테이너가 있는 마이크로서비스 지향 애플리케이션이 좋은 예입니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-165">A good example is a microservices-oriented application for which you would have one container per microservice.</span></span> <span data-ttu-id="e5073-166">그러나 마이크로서비스 방식의 패턴을 엄격하게 따르지 않으면 Docker 애플리케이션이 여러 컨테이너 또는 서비스로 구성될 가능성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-166">But, even without strictly following the microservices approach patterns, it's probable that your Docker application would be composed of multiple containers or services.</span></span>

<span data-ttu-id="e5073-167">따라서 CI 파이프라인에서 애플리케이션 컨테이너를 빌드한 후 통합 Docker 호스트 또는 컨테이너가 배포되는 테스트 클러스터 내의 모든 컨테이너를 포함하는 애플리케이션의 전체적인 배포, 통합 및 테스트도 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-167">Therefore, after building the application containers in the CI pipeline, you also need to deploy, integrate, and test the application as a whole with all of its containers within an integration Docker host or even into a test cluster to which your containers are distributed.</span></span>

<span data-ttu-id="e5073-168">단일 호스트를 사용하는 경우 Docker-Compose와 같은 Docker 명령을 사용하여 테스트할 관련 컨테이너를 빌드 및 배포하고 단일 VM에서 Docker 환경의 유효성을 검사할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-168">If you're using a single host, you can use Docker commands such as docker-compose to build and deploy related containers to test and validate the Docker environment in a single VM.</span></span> <span data-ttu-id="e5073-169">그러나 DC/OS, Kubernetes 또는 Docker Swarm 등의 다른 오케스트레이터 클러스터로 작업하는 경우 선택한 클러스터/스케줄러에 따라 다른 메커니즘 또는 오케스트레이터를 통해 컨테이너를 배포해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-169">But, if you're working with an orchestrator cluster like DC/OS, Kubernetes, or Docker Swarm, you need to deploy your containers through a different mechanism or orchestrator, depending on your selected cluster/scheduler.</span></span>

<span data-ttu-id="e5073-170">다음은 Docker 컨테이너에 대해 실행할 수 있는 몇 가지 테스트 유형입니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-170">The following are several types of tests that you can run against Docker containers:</span></span>

- <span data-ttu-id="e5073-171">Docker 컨테이너에 대한 단위 테스트</span><span class="sxs-lookup"><span data-stu-id="e5073-171">Unit tests for Docker containers</span></span>

- <span data-ttu-id="e5073-172">상호 관련된 애플리케이션 또는 마이크로서비스의 그룹 테스트</span><span class="sxs-lookup"><span data-stu-id="e5073-172">Testing groups of interrelated applications or microservices</span></span>

- <span data-ttu-id="e5073-173">프로덕션 및 "카나리아" 릴리스에서 테스트</span><span class="sxs-lookup"><span data-stu-id="e5073-173">Test in production and "canary" releases</span></span>

<span data-ttu-id="e5073-174">중요한 점은 통합 및 기능 테스트를 실행할 때 해당 테스트를 컨테이너의 외부에서 실행해야 한다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-174">The important point is that when running integration and functional tests, you must run those tests from outside of the containers.</span></span> <span data-ttu-id="e5073-175">컨테이너는 정적 이미지를 기반으로 하고 해당 이미지는 프로덕션에 배포할 이미지와 정확히 같아야 하기 때문에 테스트는 배포 중인 컨테이너에 포함되거나 해당 컨테이너에서 실행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-175">Tests are not contained or run in the containers you're deploying, because the containers are based on static images that should be exactly like the ones you'll be deploying to production.</span></span>

<span data-ttu-id="e5073-176">여러 클러스터(테스트 클러스터, 준비 클러스터 및 프로덕션 클러스터)를 포함하는 경우와 같은 고급 시나리오를 테스트할 때 실용적인 옵션은 이미지를 여러 클러스터에서 테스트할 수 있도록 레지스트리에 게시하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-176">A practical option when testing more advanced scenarios, like including several clusters (test cluster, staging cluster, and production cluster) is to publish the images to a registry, so it can be tested in various clusters.</span></span>

### <a name="push-the-custom-application-docker-image-into-your-global-docker-registry"></a><span data-ttu-id="e5073-177">글로벌 Docker 레지스트리에 사용자 지정 애플리케이션 Docker 이미지 푸시</span><span class="sxs-lookup"><span data-stu-id="e5073-177">Push the custom application Docker image into your global Docker Registry</span></span>

<span data-ttu-id="e5073-178">Docker 이미지를 테스트하고 유효성을 검사한 후 태그를 지정하고 Docker 레지스트리에 게시하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-178">After the Docker images have been tested and validated, you'll want to tag and publish them to your Docker registry.</span></span> <span data-ttu-id="e5073-179">Docker 레지스트리는 QA 및 프로덕션 환경에 배포할 사용자 지정 테스트(일명 "성공적인 이미지")를 저장하는 중심 위치이므로 Docker 애플리케이션 수명 주기에서 중요한 부분입니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-179">The Docker registry is a critical piece in the Docker application life cycle because it's the central place where you store your custom test (also known as "blessed images") to be deployed into QA and production environments.</span></span>

<span data-ttu-id="e5073-180">SCC 레지스트리(예: Git)에 저장된 애플리케이션 코드가 "신뢰할 수 있는 원본"인 이유와 유사한 원리로, Docker 레지스트리는 QA 또는 프로덕션 환경에 배포할 이진 애플리케이션 또는 비트의 "신뢰할 수 있는 원본"입니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-180">Similar to how the application code stored in your SCC repository (Git, etc.) is your "source of truth," the Docker registry is your "source of truth" for your binary application or bits to be deployed to the QA or production environments.</span></span>

<span data-ttu-id="e5073-181">일반적으로 Azure Container Registry의 프라이빗 리포지토리 또는 Docker Trusted Registry와 같은 온-프레미스 레지스트리 또는 제한된 액세스 권한을 가진 공용 클라우드 레지스트리(예: Docker Hub)에 사용자 지정 이미지에 대한 프라이빗 리포지토리가 있는 것이 좋습니다. 단, 마지막 레지스트리의 경우 코드가 오픈 소스가 아니더라도 공급업체의 보안을 신뢰해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-181">Typically, you might want to have your private repositories for your custom images either in a private repository in Azure Container Registry or in an on-premises registry like Docker Trusted Registry, or in a public-cloud registry with restricted access (like Docker Hub), although in this last case if your code is not open source, you must trust the vendor's security.</span></span> <span data-ttu-id="e5073-182">어느 방법이든 사용하는 방법은 유사하며 그림 5-4와 같이 `docker push` 명령을 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-182">Either way, the method you use is similar and is based on the `docker push` command, as shown in Figure 5-4.</span></span>

![컨테이너 레지스트리에 대한 사용자 지정 이미지 푸시를 보여 주는 다이어그램](./media/docker-application-outer-loop-devops-workflow/docker-push-custom-images.png)

<span data-ttu-id="e5073-184">**그림 5-4**.</span><span class="sxs-lookup"><span data-stu-id="e5073-184">**Figure 5-4**.</span></span> <span data-ttu-id="e5073-185">Docker 레지스트리에 사용자 지정 이미지 게시</span><span class="sxs-lookup"><span data-stu-id="e5073-185">Publishing custom images to Docker Registry</span></span>

<span data-ttu-id="e5073-186">3단계에서 통합 및 테스트(CI)를 빌드하는 경우 결과로 얻은 Docker 이미지를 프라이빗 또는 공용 레지스트리에 게시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-186">In step 3, for building integration and testing (CI) you might publish the resulting docker images to a private or public registry.</span></span> <span data-ttu-id="e5073-187">Azure Container Registry, Amazon Web Services Container Registry, Google Container Registry, Quay Registry 등 클라우드 공급업체의 Docker 레지스트리 제품이 많이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-187">There are multiple offerings of Docker registries from cloud vendors like Azure Container Registry, Amazon Web Services Container Registry, Google Container Registry, Quay Registry, and so on.</span></span>

<span data-ttu-id="e5073-188">Docker 작업을 사용하면 그림 5-5와 같이 다중 태그를 통해 `docker-compose.yml` 파일에 의해 정의되고 다중 태그를 포함하는 서비스 이미지 세트를 인증된 Docker 레지스트리(예: Azure Container Registry)에 푸시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-188">Using the Docker tasks, you can push a set of service images defined by a `docker-compose.yml` file, with multiple tags, to an authenticated Docker registry (like Azure Container Registry), as shown in Figure 5-5.</span></span>

![레지스트리에 이미지를 게시하는 단계를 보여 주는 스크린샷](./media/docker-application-outer-loop-devops-workflow/publish-custom-image-to-docker-registry.png)

<span data-ttu-id="e5073-190">**그림 5-5**.</span><span class="sxs-lookup"><span data-stu-id="e5073-190">**Figure 5-5**.</span></span> <span data-ttu-id="e5073-191">Azure DevOps Services를 사용하여 Docker 레지스트리에 사용자 이미지 푸시</span><span class="sxs-lookup"><span data-stu-id="e5073-191">Using Azure DevOps Services to publishing custom images to a Docker Registry</span></span>

> [!정보]<span data-ttu-id="e5073-192"> Azure Container Registry에 대한 자세한 내용은 <https://aka.ms/azurecontainerregistry>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="e5073-192"> For more information about Azure Container Registry, see <https://aka.ms/azurecontainerregistry>.</span></span>

## <a name="step-4-cd-deploy"></a><span data-ttu-id="e5073-193">4단계: CD, 배포</span><span class="sxs-lookup"><span data-stu-id="e5073-193">Step 4: CD, Deploy</span></span>

<span data-ttu-id="e5073-194">Docker 이미지의 불변성 덕분에 CI를 통해 개발하고 테스트하는 내용과 프로덕션에서 실행하는 내용을 이용한 반복 가능한 배포가 보장됩니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-194">The immutability of Docker images ensures a repeatable deployment with what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="e5073-195">Docker 레지스트리(프라이빗 또는 공용)에 애플리케이션 Docker 이미지를 게시한 후 Azure DevOps Services 파이프라인 작업 또는 Azure DevOps Services Release Management를 사용하여 CD 파이프라인에서 해당 이미지를 여러 환경(프로덕션, QA, 준비 등)에 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-195">After you have the application Docker images published in your Docker registry (either private or public), you can deploy them to the several environments that you might have (production, QA, staging, etc.) from your CD pipeline by using Azure DevOps Services pipeline tasks or Azure DevOps Services Release Management.</span></span>

<span data-ttu-id="e5073-196">그러나 이 시점에는 배포하는 Docker 애플리케이션의 종류에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-196">However, at this point it depends on what kind of Docker application you're deploying.</span></span> <span data-ttu-id="e5073-197">몇 개의 컨테이너 또는 서비스로 구성되고 몇 대의 서버 또는 VM에 배포되는 모놀리식 애플리케이션과 같은 간단한 애플리케이션을 배포하는 작업은 하이퍼스케일 기능을 갖춘 마이크로서비스 지향 애플리케이션과 같은 더 복잡한 애플리케이션을 배포하는 작업과 다릅니다(구성 및 배포 관점에서).</span><span class="sxs-lookup"><span data-stu-id="e5073-197">Deploying a simple application (from a composition and deployment point of view) like a monolithic application comprising a few containers or services and deployed to a few servers or VMs is different from deploying a more complex application like a microservices-oriented application with hyperscale capabilities.</span></span> <span data-ttu-id="e5073-198">두 시나리오를 다음 섹션에서 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-198">These two scenarios are explained in the following sections.</span></span>

### <a name="deploying-composed-docker-applications-to-multiple-docker-environments"></a><span data-ttu-id="e5073-199">구성된 Docker 애플리케이션을 Docker 환경에 배포</span><span class="sxs-lookup"><span data-stu-id="e5073-199">Deploying composed Docker applications to multiple Docker environments</span></span>

<span data-ttu-id="e5073-200">먼저 단일 환경 또는 다중 환경(QA, 준비 및 프로덕션)에서 간단한 Docker 호스트(VM 또는 서버)를 배포하는 덜 복잡한 시나리오를 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-200">Let's look first at the less-complex scenario: deploying to simple Docker hosts (VMs or servers) in a single environment or multiple environments (QA, staging, and production).</span></span> <span data-ttu-id="e5073-201">이 시나리오에서는 그림 5-6과 같이 내부적으로 CD 파이프라인이 Docker-Compose를 사용하여(Azure DevOps Services 배포 작업에서) Docker 애플리케이션을 관련 컨테이너 세트와 함께 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-201">In this scenario, internally your CD pipeline can use docker-compose (from your Azure DevOps Services deployment tasks) to deploy the Docker applications with its related set of containers or services, as illustrated in Figure 5-6.</span></span>

![3개 환경에 배포하는 CD 배포 단계를 보여 주는 다이어그램](./media/docker-application-outer-loop-devops-workflow/deploy-app-containers-to-docker-host-environments.png)

<span data-ttu-id="e5073-203">**그림 5-6**.</span><span class="sxs-lookup"><span data-stu-id="e5073-203">**Figure 5-6**.</span></span> <span data-ttu-id="e5073-204">간단한 Docker 호스트 환경 레지스트리에 애플리케이션 컨테이너 배포</span><span class="sxs-lookup"><span data-stu-id="e5073-204">Deploying application containers to simple Docker host environments registry</span></span>

<span data-ttu-id="e5073-205">그림 5-7은 작업 추가 대화 상자에서 Docker Compose를 클릭하여 Azure DevOps Services를 통해 빌드 CI를 QA/테스트 환경에 연결할 수 있는 방법을 강조합니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-205">Figure 5-7 highlights how you can connect your build CI to QA/test environments via Azure DevOps Services by clicking Docker Compose in the Add Task dialog box.</span></span> <span data-ttu-id="e5073-206">그러나 준비 또는 프로덕션 환경에 배포하는 경우 일반적으로 다중 환경(QA, 준비 및 프로덕션 등)을 처리하는 Release Management 기능을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-206">However, when deploying to staging or production environments, you would usually use Release Management features handling multiple environments (like QA, staging, and production).</span></span> <span data-ttu-id="e5073-207">단일 Docker 호스트에 배포하는 경우 Azure DevOps Services "Docker Compose" 작업(후드 아래에서 `docker-compose up` 명령을 호출하는)을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-207">If you're deploying to single Docker hosts, it is using the Azure DevOps Services "Docker Compose" task (which is invoking the `docker-compose up` command under the hood).</span></span> <span data-ttu-id="e5073-208">AKS(Azure Kubernetes Service)에 배포하는 경우 다음 섹션에서 설명하듯이 Docker 배포 작업을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-208">If you're deploying to Azure Kubernetes Service (AKS), it uses the Docker Deployment task, as explained in the section that follows.</span></span>

![Docker Compose 작업의 작업 추가 대화 상자를 보여 주는 스크린샷](./media/docker-application-outer-loop-devops-workflow/add-tasks-docker-compose.png)

<span data-ttu-id="e5073-210">**그림 5-7**.</span><span class="sxs-lookup"><span data-stu-id="e5073-210">**Figure 5-7**.</span></span> <span data-ttu-id="e5073-211">Azure DevOps Services 파이프라인에서 Docker Compose 작업 추가</span><span class="sxs-lookup"><span data-stu-id="e5073-211">Adding a Docker Compose task in an Azure DevOps Services pipeline</span></span>

<span data-ttu-id="e5073-212">Azure DevOps Services에서 릴리스를 만드는 경우 입력 아티팩트 세트를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-212">When you create a release in Azure DevOps Services, it takes a set of input artifacts.</span></span> <span data-ttu-id="e5073-213">이러한 아티팩트의 목적은 모든 환경에 걸쳐 릴리스의 수명이 계속되는 동안 변하지 않도록 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-213">These artifacts are intended to be immutable for the lifetime of the release, across all environments.</span></span> <span data-ttu-id="e5073-214">컨테이너를 도입하는 경우 입력 아티팩트는 배포할 레지스트리의 이미지를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-214">When you introduce containers, the input artifacts identify images in a registry to deploy.</span></span> <span data-ttu-id="e5073-215">이러한 이미지는 식별되는 방법에 따라 `docker-compose` 파일에서 `myimage:latest`를 참조하는 가장 명백한 경우 릴리스의 지속기간 동안 동일하게 유지된다는 보장이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-215">Depending on how these images are identified, they are not guaranteed to remain the same throughout the duration of the release, the most obvious case being when you reference `myimage:latest` from a `docker-compose` file.</span></span>

<span data-ttu-id="e5073-216">Azure DevOps Services 템플릿을 사용하면 특정 레지스트리 이미지 다이제스트를 포함하는 빌드 아티팩트를 생성하여 동일한 이미지 이진 파일을 고유하게 식별하도록 보장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-216">The Azure DevOps Services templates give you the ability to generate build artifacts that contain specific registry image digests that are guaranteed to uniquely identify the same image binary.</span></span> <span data-ttu-id="e5073-217">이것이 바로 릴리스에 대한 입력으로 사용하고자 하는 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-217">These are what you really want to use as input to a release.</span></span>

### <a name="managing-releases-to-docker-environments-by-using-azure-devops-services-release-management"></a><span data-ttu-id="e5073-218">Azure DevOps Services Release Management를 사용하여 Docker 환경에 대한 릴리스 관리</span><span class="sxs-lookup"><span data-stu-id="e5073-218">Managing releases to Docker environments by using Azure DevOps Services Release Management</span></span>

<span data-ttu-id="e5073-219">Azure DevOps Services 템플릿을 통해 새 이미지를 빌드하고, Docker 레지스트리에 게시하고, Linux 또는 Windows 호스트에서 실행하고, `docker-compose`와 같은 명령을 사용하여 여러 컨테이너를 전체 애플리케이션으로 배포할 수 있습니다. 이러한 작업은 모두 그림 5-8과 같은 여러 환경에 사용하기 위한 Azure DevOps Services Release Management 기능을 통해 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-219">Through the Azure DevOps Services templates, you can build a new image, publish it to a Docker registry, run it on Linux or Windows hosts, and use commands such as `docker-compose` to deploy multiple containers as an entire application, all through the Azure DevOps Services Release Management capabilities intended for multiple environments, as shown in Figure 5-8.</span></span>

![Docker Compose 릴리스의 구성을 보여 주는 스크린샷](./media/docker-application-outer-loop-devops-workflow/configure-docker-compose-release.png)

<span data-ttu-id="e5073-221">**그림 5-8**.</span><span class="sxs-lookup"><span data-stu-id="e5073-221">**Figure 5-8**.</span></span> <span data-ttu-id="e5073-222">Azure DevOps Services Release Management에서 Azure DevOps Services Docker Compose 작업 구성</span><span class="sxs-lookup"><span data-stu-id="e5073-222">Configuring Azure DevOps Services Docker Compose tasks from Azure DevOps Services Release Management</span></span>

<span data-ttu-id="e5073-223">그러나 그림 5-6에 나와 있고 그림 5-8에서 구현되는 시나리오는 단일 Docker 호스트 및 VM에 배포되고 이미지당 단일 컨테이너 또는 인스턴스가 있는 간단한 시나리오이며, 개발 또는 테스트 시나리오용으로만 사용해야 한다는 점을 염두에 두어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-223">However, keep in mind that the scenario shown in Figure 5-6 and implemented in Figure 5-8 is a simple one (it's deploying to single Docker hosts and VMs, and there will be a single container or instance per image) and probably should be used only for development or test scenarios.</span></span> <span data-ttu-id="e5073-224">대부분의 엔터프라이즈 프로덕션 시나리오에서는 여러 노드, 서버 및 VM 간의 부하 분산을 통해 HA(고가용성) 및 관리하기 쉬운 확장성을 갖기를 원하고 "인텔리전트 장애 조치(failover)" 기능을 더하여 서버 또는 노드에 장애가 발생한 경우 해당 서비스 및 컨테이너가 다른 호스트 서버 또는 VM으로 이동됩니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-224">In most enterprise production scenarios, you would want to have High Availability (HA) and easy-to-manage scalability by load balancing across multiple nodes, servers, and VMs, plus "intelligent failovers" so if a server or node fails, its services and containers will be moved to another host server or VM.</span></span> <span data-ttu-id="e5073-225">이 경우 컨테이너 클러스터, 오케스트레이터 및 스케줄러 등과 같은 고급 기술이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-225">In that case, you need more advanced technologies such as container clusters, orchestrators, and schedulers.</span></span> <span data-ttu-id="e5073-226">따라서 해당 클러스터에 배포하는 방법은 다음 섹션에서 설명하는 고급 시나리오를 처리하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-226">Thus, the way to deploy to those clusters is by handling the advanced scenarios explained in the next section.</span></span>

### <a name="deploying-docker-applications-to-docker-clusters"></a><span data-ttu-id="e5073-227">Docker 클러스터에 Docker 애플리케이션 배포</span><span class="sxs-lookup"><span data-stu-id="e5073-227">Deploying Docker applications to Docker clusters</span></span>

<span data-ttu-id="e5073-228">분산 애플리케이션의 특성 때문에 역시 분산된 컴퓨팅 리소스가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-228">The nature of distributed applications requires compute resources that are also distributed.</span></span> <span data-ttu-id="e5073-229">프로덕션 규모 기능을 가지려면 풀링된 리소스를 기반으로 높은 확장성 및 고가용성을 제공하는 클러스터링 기능이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-229">To have production-scale capabilities, you need to have clustering capabilities that provide high scalability and high availability based on pooled resources.</span></span>

<span data-ttu-id="e5073-230">CLI 도구 또는 웹 UI에서 수동으로 컨테이너를 해당 클러스터에 배포할 수 있지만, 그러한 종류의 수동 작업을 보류하고 확장 또는 모니터링과 같은 배포 테스트 또는 관리 목적을 찾아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-230">You could deploy containers manually to those clusters from a CLI tool or a web UI, but you should reserve that kind of manual work to spot deployment testing or management purposes like scaling-out or monitoring.</span></span>

<span data-ttu-id="e5073-231">CD 관점 및 구체적으로 Azure DevOps Services 관점에서 보면 그림 5-9와 같이 컨테이너화된 애플리케이션을 컨테이너 서비스의 배포된 클러스터에 배포하는 Azure DevOps Services Release Management 환경에서 명시적으로 만들어진 배포 작업을 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-231">From a CD point of view, and Azure DevOps Services specifically, you can run specially made deployment tasks from your Azure DevOps Services Release Management environments that will deploy your containerized applications to distributed clusters in Container Service, as illustrated in Figure 5-9.</span></span>

![오케스트레이터에 배포하는 CD 배포 단계를 보여 주는 다이어그램](./media/docker-application-outer-loop-devops-workflow/cd-deploy-to-orchestrators.png)

<span data-ttu-id="e5073-233">**그림 5-9**.</span><span class="sxs-lookup"><span data-stu-id="e5073-233">**Figure 5-9**.</span></span> <span data-ttu-id="e5073-234">컨테이너 서비스에 분산 애플리케이션 배포</span><span class="sxs-lookup"><span data-stu-id="e5073-234">Deploying distributed applications to Container Service</span></span>

<span data-ttu-id="e5073-235">처음에 특정 클러스터 또는 오케스트레이터에 배포하는 경우 전통적으로 `docker-compose.yml` 정의 파일을 기반으로 더 간단하고 사용하기 쉬운 `docker-compose` 도구 대신에 각 오케스트레이터마다 고유한 배포 스크립트 및 메커니즘을 사용할 것입니다(즉, Kubernetes와 Service Fabric의 배포 메커니즘이 서로 다름).</span><span class="sxs-lookup"><span data-stu-id="e5073-235">Initially, when deploying to certain clusters or orchestrators, you would traditionally use specific deployment scripts and mechanisms per each orchestrator (that is, Kubernetes and Service Fabric have different deployment mechanisms) instead of the simpler and easy-to-use `docker-compose` tool based on the `docker-compose.yml` definition file.</span></span> <span data-ttu-id="e5073-236">그러나 그림 5-10과 같은 Azure DevOps Services Docker 배포 작업 덕분에 `docker-compose.yml` 파일에서 오케스트레이터에 필요한 형식으로의 “변환”을 도구에서 수행해주므로 이제 친숙한 `docker-compose.yml` 파일만 사용하여 지원되는 오케스트레이터에 배포할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-236">However, thanks to the Azure DevOps Services Docker Deploy task, shown in Figure 5-10, now you can also deploy to the supported orchestrators by just using your familiar `docker-compose.yml` file because the tool performs that "translation" for you (from your `docker-compose.yml` file to the format needed by the orchestrator).</span></span>

![Kubernetes에 배포 작업을 보여 주는 스크린샷](./media/docker-application-outer-loop-devops-workflow/add-deploy-to-kubernetes-task.png)

<span data-ttu-id="e5073-238">**그림 5-10**.</span><span class="sxs-lookup"><span data-stu-id="e5073-238">**Figure 5-10**.</span></span> <span data-ttu-id="e5073-239">환경에 Kubernetes에 배포 작업 추가</span><span class="sxs-lookup"><span data-stu-id="e5073-239">Adding the Deploy to Kubernetes task to your Environment</span></span>

<span data-ttu-id="e5073-240">그림 5-11은 구성에 사용할 수 있는 섹션을 사용하여 Kubernetes에 배포 작업을 편집할 수 있는 방법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-240">Figure 5-11 demonstrates how you can edit the Deploy to Kubernetes task with the sections available for configuration.</span></span> <span data-ttu-id="e5073-241">이는 클러스터에 컨테이너로 배포할 즉시 사용 가능한 사용자 지정 Docker 이미지를 검색하는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-241">This is the task that will retrieve your ready-to-use custom Docker images to be deployed as containers in the cluster.</span></span>

![Kubernetes에 배포 작업 구성을 보여 주는 스크린샷](./media/docker-application-outer-loop-devops-workflow/edit-deploy-to-kubernetes-task.png)

<span data-ttu-id="e5073-243">**그림 5-11**.</span><span class="sxs-lookup"><span data-stu-id="e5073-243">**Figure 5-11**.</span></span> <span data-ttu-id="e5073-244">ACS DC/OS에 배포하는 Docker 배포 작업 정의</span><span class="sxs-lookup"><span data-stu-id="e5073-244">Docker Deploy task definition deploying to ACS DC/OS</span></span>

> [!정보]<span data-ttu-id="e5073-245"> Azure DevOps Services 및 Docker를 포함하는 CD 파이프라인에 대해 자세히 알아보려면 <https://azure.microsoft.com/services/devops/pipelines>을 방문하세요.</span><span class="sxs-lookup"><span data-stu-id="e5073-245"> To read more about the CD pipeline with Azure DevOps Services and Docker, visit <https://azure.microsoft.com/services/devops/pipelines></span></span>

## <a name="step-5-run-and-manage"></a><span data-ttu-id="e5073-246">5단계: 실행 및 관리</span><span class="sxs-lookup"><span data-stu-id="e5073-246">Step 5: Run and manage</span></span>

<span data-ttu-id="e5073-247">엔터프라이즈 프로덕션 레벨에서 애플리케이션 실행 및 관리는 그 자체가 중요한 주제이고 해당 수준에서 작업하는 운영 유형과 개인(IT 운영 담당자)이 특별하고 이 영역의 범위가 크기 때문에 다음 장 전체에서 따로 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-247">Because running and managing applications at enterprise-production level is a major subject in and of itself, and due to the type of operations and people working at that level (IT operations) as well as the large scope of this area, the entire next chapter is devoted to explaining it.</span></span>

## <a name="step-6-monitor-and-diagnose"></a><span data-ttu-id="e5073-248">6단계: 모니터링 및 진단</span><span class="sxs-lookup"><span data-stu-id="e5073-248">Step 6: Monitor and diagnose</span></span>

<span data-ttu-id="e5073-249">또한 이 주제는 다음 장에서 IT가 프로덕션 시스템에서 수행하는 작업의 일부로 다룹니다. 그러나 이 단계에서 얻는 인사이트는 애플리케이션의 지속적인 개선을 위해 개발 팀에게 피드백되어야 한다는 점을 강조해 둡니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-249">This topic also is covered in the next chapter as part of the tasks that IT performs in production systems; however, is important to highlight that the insights obtained in this step must feed back to the development team so that the application is constantly improved.</span></span> <span data-ttu-id="e5073-250">해당 관점에서 볼 때 이는 DevOps의 일부이기도 하지만 작업과 운영은 일반적으로 IT에서 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-250">From that point of view, it's also part of DevOps, although the tasks and operations are commonly performed by IT.</span></span>

<span data-ttu-id="e5073-251">모니터링 및 진단의 100%가 DevOps 범위 내에 속하는 유일한 경우는 개발 팀이 테스트 또는 베타 환경에 대해 수행하는 모니터링 프로세스와 분석뿐입니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-251">Only when monitoring and diagnostics are 100% within the realm of DevOps are the monitoring processes and analytics performed by the development team against testing or beta environments.</span></span> <span data-ttu-id="e5073-252">이 작업은 부하 테스트를 수행하거나 베타 테스터가 새로운 버전을 체험해보는 베타 또는 QA 환경을 모니터링하는 방법으로 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="e5073-252">This is done either by performing load testing or by monitoring beta or QA environments, where beta testers are trying the new versions.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="e5073-253">[이전](index.md)
>[다음](create-ci-cd-pipelines-azure-devops-services-aspnetcore-kubernetes.md)</span><span class="sxs-lookup"><span data-stu-id="e5073-253">[Previous](index.md)
[Next](create-ci-cd-pipelines-azure-devops-services-aspnetcore-kubernetes.md)</span></span>
