---
title: 서버리스 아키텍처 고려 사항 - 서버리스 앱
description: 상태 관리 및 영구 저장소에서 크기 조정, 로깅, 추적 및 진단까지 서버리스 애플리케이션 설계와 관련된 문제를 이해합니다.
author: JEREMYLIKNESS
ms.author: jeliknes
ms.date: 04/06/2020
ms.openlocfilehash: 3c07e1149e6af41a6b9a9317238e5c71015d2c4e
ms.sourcegitcommit: 8b02d42f93adda304246a47f49f6449fc74a3af4
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/24/2020
ms.locfileid: "82135674"
---
# <a name="serverless-architecture-considerations"></a>서버리스 아키텍처 고려 사항

서버리스 아키텍처를 채택할 때 특정 문제가 제기됩니다. 이 섹션에서는 몇 가지 일반적인 고려 사항을 살펴봅니다. 이러한 모든 문제에는 해결 방법이 있습니다. 모든 아키텍처 선택과 마찬가지로 서버리스 채택은 장단점을 신중하게 고려한 후에 결정해야 합니다. 애플리케이션 요구 사항에 따라 서버리스 구현이 특정 구성 요소에 적합한 솔루션이 아니라고 판단할 수 있습니다.

## <a name="managing-state"></a>상태 관리

일반적으로 마이크로 서비스에서와 마찬가지로 서버리스 함수는 기본적으로 상태 비저장입니다. 상태를 배제하면 서버리스가 사용 후 삭제 가능하고, 수직으로 확장할 수 있고, 중앙 실패 지점 없이 복원력을 제공할 수 있습니다. 경우에 따라 비즈니스 프로세스에는 상태가 필요합니다. 프로세스에 상태가 필요한 경우 두 가지 옵션이 있습니다. 서버리스 이외의 모델을 채택하거나 상태를 제공하는 별도의 서비스와 상호 작용할 수 있습니다. 상태를 추가하면 솔루션이 복잡해질 수 있으며 확장하기가 더 어렵고 잠재적으로 단일 실패 지점이 생성될 수 있습니다. 함수가 반드시 상태를 요구하는지 신중하게 고려해야 합니다. 대답이 "예"인 경우 그래도 서버리스로 구현하는 것이 적절한지 판단합니다.

서버리스의 이점을 훼손하지 않고 상태를 채택하는 솔루션이 여러 가지 있습니다. 가장 인기 있는 솔루션 중 일부는 다음과 같습니다.

- Redis와 같은 임시 데이터 저장소 또는 분산 캐시를 사용
- SQL 또는 CosmosDB와 같은 데이터베이스에 상태를 저장
- [지속성 함수](https://docs.microsoft.com/azure/azure-functions/durable/durable-functions-overview)와 같은 워크플로 엔진을 통해 상태를 처리합니다.

중요한 것은 서버리스로 구현하려는 프로세스에서 상태 관리의 필요성이 있는지 알고 있어야 한다는 점입니다.

## <a name="long-running-processes"></a>장기 실행 프로세스

서버리스의 많은 이점이 사용 후 삭제 프로세스에서 비롯됩니다. 실행 시간이 짧으면 서버리스 공급자가 함수 종료 시 리소스를 해제하고 호스트 간에 함수를 공유하기 더 쉬워집니다. 대부분의 클라우드 공급자는 함수를 실행할 수 있는 총 시간을 10분 정도로 제한합니다. 프로세스가 더 오래 걸릴 수 있다면 대체 구현을 고려할 수 있습니다.

몇 가지 예외와 해결 방법이 있습니다. 한 가지 해결 방법은 프로세스를 개별적으로 실행하는 데 걸리는 시간이 더 짧은 작은 구성 요소로 분할하는 것입니다. 종속성으로 인해 프로세스가 장시간 실행되는 경우 Durable Functions와 같은 솔루션을 사용하는 비동기 워크플로를 고려할 수도 있습니다. Durable Functions는 외부 프로세스가 완료될 때까지 대기하는 동안 프로세스를 일시 중지하고 상태를 유지합니다. 비동기 처리를 통해 실제 프로세스가 실행되는 시간이 줄어듭니다.

## <a name="startup-time"></a>시작 시간

서버리스 구현의 한 가지 잠재적 문제는 시작 시간입니다. 리소스를 절약하기 위해 대부분의 서버리스 공급자는 "주문형" 인프라를 만듭니다. 서버리스 함수가 일정 시간 후에 트리거되면 함수를 호스트하는 리소스를 만들거나 다시 시작해야 할 수 있습니다. 콜드 부팅으로 인해 몇 초 정도 지연될 수 있는 경우도 있습니다. 시작 시간은 공급자와 서비스 수준에 따라 달라집니다. 앱의 성공을 위해 시작 시간을 최소화하는 것이 중요한 경우 시작 시간을 해결하는 몇 가지 방법이 있습니다.

- 일부 공급자는 사용자가 인프라를 "항상 사용"하도록 보장하는 서비스 수준을 제공합니다.
- 연결 유지 메커니즘을 구현합니다(엔드포인트를 ping하여 "활성" 상태로 유지).
- 컨테이너화된 함수 접근 방식을 통해 Kubernetes와 같은 오케스트레이션을 사용합니다(호스트가 이미 실행 중이므로 새 인스턴스는 빠르게 실행됨).

## <a name="database-updates-and-migrations"></a>데이터베이스 업데이트 및 마이그레이션

서버리스 코드의 이점은 전체 애플리케이션을 다시 배포하지 않고도 새 함수를 릴리스할 수 있다는 것입니다. 이러한 장점이 관계형 데이터베이스가 포함된 경우에는 단점이 될 수 있습니다. 데이터베이스 스키마에 대한 변경 내용은 서버리스 업데이트와 동기화하기 어렵습니다. 문제가 발생하여 변경 내용을 롤백해야 하는 경우 추가적인 문제가 발생합니다. 데이터 무결성은 자체 데이터를 소유하는 것이 마이크로 서비스 및 서버리스 함수의 한 모범 사례인 이유 중 하나입니다. 변경 내용을 컴퓨팅 및 데이터의 단일 단위로 배포할 수 있습니다. 실제에서는 많은 레거시 시스템이 서버리스 아키텍처와 조정해야 하는 대규모 백 엔드 데이터베이스를 사용하고 있습니다.

스키마 버전 관리를 해결하는 일반적인 방법은 절대로 기존 속성 및 열을 수정하지 않고 새 정보를 추가하는 것입니다. 예를 들어 작업 목록에 대한 부울 "완료" 플래그에서 "완료 날짜"로 이동하는 변경하는 것을 생각해 봅시다. 기존 필드를 제거하는 대신 다음과 같이 데이터베이스를 변경합니다.

1. 새 "완료 날짜" 필드를 추가합니다.
1. "완료" 부울 필드를 완료 날짜가 현재 날짜 이후인지 평가하는 계산 함수로 변환합니다.
1. 완료된 부울이 true로 설정된 경우 완료 날짜를 현재 날짜로 설정하는 트리거를 추가합니다.

일련의 변경 내용은 레거시 코드가 계속해서 "있는 그대로" 실행되고 서버리스 함수가 새 필드를 활용할 수 있게 해줍니다.

서버리스 아키텍처의 데이터에 대한 자세한 내용은 [분산 데이터 관리에 대한 과제 및 해결 방법](../microservices/architect-microservice-container-applications/distributed-data-management.md)을 참조하세요.

## <a name="scaling"></a>배율 조정

서버리스가 "서버 없음"을 의미한다고 오해하는 경우가 많습니다. 실제로는 "매우 작은 서버"입니다. 지원 인프라가 있다는 사실을 이해하는 것이 크기 조정과 관련하여 중요합니다. 대부분의 서버리스 플랫폼에서는 이벤트 밀도가 증가할 때 인프라 크기를 조정하는 방법을 처리하는 컨트롤 집합을 제공합니다. 다양한 옵션 중에서 선택할 수 있지만 전략은 함수에 따라 달라질 수 있습니다. 또한 함수는 일반적으로 관련 호스트에서 실행되므로 동일한 호스트에서 실행되는 함수는 동일한 크기 조정 옵션을 사용할 수 있습니다. 따라서 크기 조정 요구 사항에 따라 함께 어떤 함수를 힘께 호스트할지 구성하고 전략을 수립해야 합니다.

규칙은 다양한 매개 변수에 따라 수직 확장(호스트 리소스 증가) 및 수평 확장(호스트 인스턴스 수 증가) 방법을 지정하는 경우가 많습니다. 크기 조정 트리거에는 일정, 요청 속도, CPU 사용률 및 메모리 사용이 포함될 수 있습니다. 성능이 높을수록 비용이 증가하는 것이 일반적입니다. 이보다 저렴한 사용 기반 접근 방식은 요청 속도가 갑자기 증가하는 경우 신속하게 확장되지 않을 수 있습니다. 미리 "보험 비용"을 지불하는 것과 엄격히 '종량제'로 지불하고 갑작스러운 수요 증가로 인한 응답 속도 저하를 감수하는 것 사이의 상반 관계가 있습니다.

## <a name="monitoring-tracing-and-logging"></a>모니터링, 추적 및 로깅

DevOps에서 자주 간과되는 측면 하나는 배포된 애플리케이션의 모니터링입니다. 서버리스 함수를 모니터링하기 위한 전략을 수립하는 것이 중요합니다. 가장 어려운 문제는 종종 상관 관계, 즉 사용자가 동일한 상호 작용의 일부로 여러 함수를 호출하는 경우를 인식하는 것입니다. 대부분의 서버리스 플랫폼에서는 타사 도구로 가져올 수 있는 콘솔 로깅을 허용합니다. 또한 원격 분석 컬렉션을 자동화하고, 상관 관계 ID를 생성 및 추적하고, 특정 작업을 모니터링하여 자세한 정보를 제공하는 옵션도 있습니다. Azure는 모니터링 및 분석을 위한 고급 [Application Insights 플랫폼](https://docs.microsoft.com/azure/azure-functions/functions-monitoring)을 제공합니다.

## <a name="inter-service-dependencies"></a>서비스 간 종속성

서버리스 아키텍처에는 다른 함수에 의존하는 함수가 포함될 수 있습니다. 실제로 서버리스 아키텍처에서 여러 서비스가 상호 작용 또는 분산 트랜잭션의 일부로 서로 호출 하는 경우가 드물지 않습니다. 강력한 결합을 방지하려면 서비스가 서로를 직접 참조하지 않는 것이 좋습니다. 서비스 엔드포인트를 변경해야 하는 경우 직접 참조로 인해 대규모 리팩터링이 필요할 수 있습니다. 권장하는 해결 방법은 요청 유형에 적합한 엔드포인트를 제공하는 서비스 검색 메커니즘(예: 레지스트리)을 제공하는 것입니다. 또 하나의 해결 방법은 서비스 간 통신에 큐 또는 토픽과 같은 메시징 서비스를 활용하는 것입니다.

## <a name="managing-failure-and-providing-resiliency"></a>실패 관리 및 복원력 제공

*회로 차단기 패턴*을 고려하는 것도 중요합니다. 어떤 이유로든 한 서비스가 계속 실패할 경우 해당 서비스를 반복해서 호출하지 않는 것이 좋습니다. 대신, 대체 서비스를 호출하거나 종속 서비스의 상태가 다시 설정될 때까지 메시지를 반환합니다. 서버리스 아키텍처는 서비스 간 종속성을 확인하고 관리하기 위한 전략을 고려해야 합니다.

회로 차단기 패턴을 계속하려면 서비스에 내결함성 및 복원력이 있어야 합니다. 내결함성은 예기치 않은 예외 또는 잘못된 상태 발생 후에도 애플리케이션을 계속 실행하는 기능을 말합니다. 내결함성은 일반적으로 코드 자체의 기능이며 예외를 처리하기 위해 코드가 작성되는 방법입니다. 복원력은 애플리케이션에서 얼마나 실패를 복구할 수 있는지를 나타냅니다. 복원력은 종종 서버리스 플랫폼에 의해 관리됩니다. 플랫폼은 기존 서버리스 함수 인스턴스가 실패할 경우 새 인스턴스를 실행할 수 있어야 합니다. 또한 플랫폼은 모든 새 인스턴스가 실패할 경우 새 인스턴스 시작을 중지할 수 있을 정도로 지능적이어야 합니다.

자세한 내용은 [회로 차단기 패턴 구현](../microservices/implement-resilient-applications/implement-circuit-breaker-pattern.md)을 참조하세요.

## <a name="versioning-and-greenblue-deployments"></a>버전 관리 및 그린/블루 배포

서버리스의 주요 이점 한 가지는 전체 애플리케이션을 다시 배포하지 않고 특정 함수를 업그레이드하는 기능입니다. 업그레이드가 성공하려면 함수를 호출하는 서비스가 올바른 버전의 코드로 라우팅되도록 함수 버전을 관리해야 합니다. 새 버전을 배포하는 전략도 중요합니다. 일반적인 접근 방식은 "그린/블루 배포"를 사용하는 것입니다. 그린 배포는 현재 함수입니다. 새 "블루" 버전이 프로덕션에 배포되고 테스트됩니다. 테스트를 통과하면 그린 버전과 블루 버전이 교체되어 새 버전이 활성 상태가 됩니다. 문제가 발생하는 경우 다시 바꿀 수 있습니다. 버전 관리 및 그린/블루 배포를 지원하려면 버전 변경을 수용하고 서버리스 플랫폼을 사용하여 배포를 처리하는 함수를 작성해야 합니다.

>[!div class="step-by-step"]
>[이전](serverless-architecture.md)
>[다음](serverless-design-examples.md)
