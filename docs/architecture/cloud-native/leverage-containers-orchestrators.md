---
title: 컨테이너 및 오케스트레이터 활용
description: Azure에서 Docker 컨테이너 및 Kubernetes Orchestrator 활용
ms.date: 05/31/2020
ms.openlocfilehash: 07e66ece1d1d1b3f252e56789461ae2922d9649a
ms.sourcegitcommit: eb7e87496f42361b1da98562dd75b516c9d58bbc
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/09/2020
ms.locfileid: "91877576"
---
# <a name="leveraging-containers-and-orchestrators"></a><span data-ttu-id="d4208-103">컨테이너 및 오케스트레이터 활용</span><span class="sxs-lookup"><span data-stu-id="d4208-103">Leveraging containers and orchestrators</span></span>

<span data-ttu-id="d4208-104">컨테이너 및 orchestrator는 모놀리식 배포 방법에 일반적으로 발생 하는 문제를 해결 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-104">Containers and orchestrators are designed to solve problems common to monolithic deployment approaches.</span></span>

## <a name="challenges-with-monolithic-deployments"></a><span data-ttu-id="d4208-105">모놀리식 배포 문제</span><span class="sxs-lookup"><span data-stu-id="d4208-105">Challenges with monolithic deployments</span></span>

<span data-ttu-id="d4208-106">일반적으로 대부분의 응용 프로그램은 단일 단위로 배포 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-106">Traditionally, most applications have been deployed as a single unit.</span></span> <span data-ttu-id="d4208-107">이러한 응용 프로그램을 monolith 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-107">Such applications are referred to as a monolith.</span></span> <span data-ttu-id="d4208-108">그림 3-1에 표시 된 것 처럼 여러 모듈 또는 어셈블리로 구성 된 경우에도 응용 프로그램을 단일 단위로 배포 하는 일반적인 방법은 모놀리식 architecture 이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-108">This general approach of deploying applications as single units even if they're composed of multiple modules or assemblies is known as monolithic architecture, as shown in Figure 3-1.</span></span>

![모놀리식 아키텍처.](./media/monolithic-design.png)

<span data-ttu-id="d4208-110">**그림 3-1**.</span><span class="sxs-lookup"><span data-stu-id="d4208-110">**Figure 3-1**.</span></span> <span data-ttu-id="d4208-111">모놀리식 아키텍처.</span><span class="sxs-lookup"><span data-stu-id="d4208-111">Monolithic architecture.</span></span>

<span data-ttu-id="d4208-112">모놀리식 아키텍처는 간단 하지만 다음과 같은 다양 한 문제를 겪고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-112">Although they have the benefit of simplicity, monolithic architectures face a number of challenges:</span></span>

### <a name="deployment"></a><span data-ttu-id="d4208-113">배포</span><span class="sxs-lookup"><span data-stu-id="d4208-113">Deployment</span></span>

<span data-ttu-id="d4208-114">또한 응용 프로그램을 다시 시작 해야 합니다 .이 경우 배포 하는 동안 가동 중지 시간이 0 인 기술이 적용 되지 않으면 가용성에 일시적으로 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-114">Additionally, they require a restart of the application, which may temporarily impact availability if zero-downtime techniques are not applied while deploying.</span></span>

### <a name="scaling"></a><span data-ttu-id="d4208-115">확장</span><span class="sxs-lookup"><span data-stu-id="d4208-115">Scaling</span></span>

<span data-ttu-id="d4208-116">모놀리식 응용 프로그램은 전적으로 많은 기능을 필요로 하는 단일 컴퓨터 인스턴스에서 호스팅됩니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-116">A monolithic application is hosted entirely on a single machine instance, often requiring high-capability hardware.</span></span> <span data-ttu-id="d4208-117">모놀리식의 어느 부분에서 확장이 필요한 경우에는 다른 컴퓨터에 전체 응용 프로그램의 다른 복사본을 배포 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-117">If any part of the monolith requires scaling, another copy of the entire application must be deployed to another machine.</span></span> <span data-ttu-id="d4208-118">Monolith를 사용 하면 응용 프로그램 구성 요소를 개별적으로 규모를 조정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-118">With a monolith, you can't scale application components individually - it's all or nothing.</span></span> <span data-ttu-id="d4208-119">크기를 조정 하지 않아도 되는 구성 요소는 비효율적 이며 비용이 많이 드는 리소스 사용량을 초래 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-119">Scaling components that don't require scaling results in inefficient and costly resource usage.</span></span>

### <a name="environment"></a><span data-ttu-id="d4208-120">Environment</span><span class="sxs-lookup"><span data-stu-id="d4208-120">Environment</span></span>

<span data-ttu-id="d4208-121">모놀리식 응용 프로그램은 일반적으로 미리 설치 된 운영 체제, 런타임 및 라이브러리 종속성이 있는 호스팅 환경에 배포 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-121">Monolithic applications are typically deployed to a hosting environment with a pre-installed operating system, runtime, and library dependencies.</span></span> <span data-ttu-id="d4208-122">이 환경은 응용 프로그램을 개발 하거나 테스트할 때와 일치 하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-122">This environment may not match that upon which the application was developed or tested.</span></span> <span data-ttu-id="d4208-123">응용 프로그램 환경에서의 불일치는 모놀리식 배포에 대 한 문제의 일반적인 원인입니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-123">Inconsistencies across application environments are a common source of problems for monolithic deployments.</span></span>

### <a name="coupling"></a><span data-ttu-id="d4208-124">커플링</span><span class="sxs-lookup"><span data-stu-id="d4208-124">Coupling</span></span>

<span data-ttu-id="d4208-125">모놀리식 응용 프로그램은 기능 구성 요소에 대해 높은 결합을 경험할 가능성이 높습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-125">A monolithic application is likely to experience high coupling across its functional components.</span></span> <span data-ttu-id="d4208-126">하드 경계가 없으면 시스템 변경으로 인해 의도 하지 않은 부작용이 발생 하는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-126">Without hard boundaries, system changes often result in unintended and costly side effects.</span></span> <span data-ttu-id="d4208-127">새로운 기능/픽스는 복잡 하 고 시간이 많이 걸리고 구현 비용이 많이 듭니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-127">New features/fixes become tricky, time-consuming, and expensive to implement.</span></span> <span data-ttu-id="d4208-128">업데이트에는 광범위 한 테스트가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-128">Updates require extensive testing.</span></span> <span data-ttu-id="d4208-129">또한 결합을 사용 하면 구성 요소를 리팩터링 하거나 대체 구현에서 교환 하기가 어려워집니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-129">Coupling also makes it difficult to refactor components or swap in alternative implementations.</span></span> <span data-ttu-id="d4208-130">문제를 엄격 하 게 분리 하 여 생성 된 경우에도 아키텍처 erosion은의를 모놀리식 코드 베이스 deteriorates로 설정 하 고 "특수 한 경우"를 종료 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-130">Even when constructed with a strict separation of concerns, architectural erosion sets in as the monolithic code base deteriorates with never-ending "special cases."</span></span>

### <a name="platform-lock-in"></a><span data-ttu-id="d4208-131">플랫폼 잠금</span><span class="sxs-lookup"><span data-stu-id="d4208-131">Platform lock-in</span></span>

<span data-ttu-id="d4208-132">모놀리식 응용 프로그램은 단일 기술 스택을 사용 하 여 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-132">A monolithic application is constructed with a single technology stack.</span></span> <span data-ttu-id="d4208-133">일관성을 제공 하는 동안 이러한 약정은 혁신에 장벽이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-133">While offering uniformity, this commitment can become a barrier to innovation.</span></span> <span data-ttu-id="d4208-134">최신 기술이 더 적합 한 경우에도 응용 프로그램의 현재 스택을 사용 하 여 새로운 기능 및 구성 요소를 빌드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-134">New features and components will be built using the application's current stack - even when more modern technologies may be a better choice.</span></span> <span data-ttu-id="d4208-135">더 장기적인 위험은 기술 스택이 오래 되 고 사용 되지 않는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-135">A longer-term risk is your technology stack becoming outdated and obsolete.</span></span> <span data-ttu-id="d4208-136">전체 응용 프로그램을 새로운 최신 플랫폼으로 다시 설계 하는 것이 가장 저렴 하 고 위험 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-136">Rearchitecting an entire application to a new, more modern platform is at best expensive and risky.</span></span>

## <a name="what-are-the-benefits-of-containers-and-orchestrators"></a><span data-ttu-id="d4208-137">컨테이너와 orchestrator의 이점은 무엇 인가요?</span><span class="sxs-lookup"><span data-stu-id="d4208-137">What are the benefits of containers and orchestrators?</span></span>

<span data-ttu-id="d4208-138">1 장에서는 컨테이너를 소개 했습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-138">We introduced containers in Chapter 1.</span></span> <span data-ttu-id="d4208-139">클라우드 기본 [구조](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png) 를 시작 하는 엔터프라이즈에 대 한 지침-클라우드 네이티브 컨테이너 화에 대 한 첫 번째 단계인 cncf (Cloud Native 컴퓨팅 Foundation) 순위를 강조 했습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-139">We highlighted how the Cloud Native Computing Foundation (CNCF) ranks containerization as the first step in their [Cloud-Native Trail Map](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png) - guidance for enterprises beginning their cloud-native journey.</span></span> <span data-ttu-id="d4208-140">이 섹션에서는 컨테이너의 이점에 대해 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-140">In this section, we discuss the benefits of containers.</span></span>

<span data-ttu-id="d4208-141">Docker는 가장 인기 있는 컨테이너 관리 플랫폼입니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-141">Docker is the most popular container management platform.</span></span> <span data-ttu-id="d4208-142">Linux 또는 Windows의 컨테이너와 함께 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-142">It works with containers on both Linux or Windows.</span></span> <span data-ttu-id="d4208-143">컨테이너는 모든 시스템에서 동일한 방식으로 실행 되는 별도의 재현 가능한 응용 프로그램 환경을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-143">Containers provide separate but reproducible application environments that run the same way on any system.</span></span> <span data-ttu-id="d4208-144">이를 통해 클라우드 네이티브 서비스를 개발 및 호스트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-144">This aspect makes them perfect for developing and hosting cloud-native services.</span></span> <span data-ttu-id="d4208-145">컨테이너는 서로 격리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-145">Containers are isolated from one another.</span></span> <span data-ttu-id="d4208-146">동일한 호스트 하드웨어의 두 컨테이너는 충돌을 발생 시 키 지 않으면 서 다른 버전의 소프트웨어를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-146">Two containers on the same host hardware can have different versions of software, without causing conflicts.</span></span>

<span data-ttu-id="d4208-147">컨테이너는 프로젝트 아티팩트가 되며 소스 제어에 체크 인 되는 간단한 텍스트 기반 파일로 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-147">Containers are defined by simple text-based files that become project artifacts and are checked into source control.</span></span> <span data-ttu-id="d4208-148">전체 서버 및 가상 컴퓨터를 업데이트 하는 데 수동 작업이 필요 하지만 컨테이너는 쉽게 버전 제어 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-148">While full servers and virtual machines require manual effort to update, containers are easily version-controlled.</span></span> <span data-ttu-id="d4208-149">컨테이너에서 실행 되도록 빌드된 앱은 자동화 된 도구를 사용 하 여 빌드 파이프라인의 일부로 개발, 테스트 및 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-149">Apps built to run in containers can be developed, tested, and deployed using automated tools as part of a build pipeline.</span></span>

<span data-ttu-id="d4208-150">컨테이너는 변경할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-150">Containers are immutable.</span></span> <span data-ttu-id="d4208-151">컨테이너를 정의한 후에는 정확히 동일한 방식으로 다시 만들고 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-151">Once you define a container, you can recreate and run it exactly the same way.</span></span> <span data-ttu-id="d4208-152">이 불변성은 구성 요소 기반 디자인에 적합 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-152">This immutability lends itself to component-based design.</span></span> <span data-ttu-id="d4208-153">응용 프로그램의 일부가 다른 부분과 다르게 발전 하는 경우 가장 자주 변경 되는 파트를 배포할 수 있는 경우 전체 앱을 다시 배포 해야 하는 이유는 무엇 인가요?</span><span class="sxs-lookup"><span data-stu-id="d4208-153">If some parts of an application evolve differently than others, why redeploy the entire app when you can just deploy the parts that change most frequently?</span></span> <span data-ttu-id="d4208-154">앱의 다양 한 기능 및 교차를 분리 하는 작업은 별도의 단위로 나눌 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-154">Different features and cross-cutting concerns of an app can be broken up into separate units.</span></span> <span data-ttu-id="d4208-155">그림 3-2에서는 특정 기능이 나 기능을 위임 하 여 모놀리식 앱이 컨테이너 및 마이크로 서비스를 활용 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-155">Figure 3-2 shows how a monolithic app can take advantage of containers and microservices by delegating certain features or functionality.</span></span> <span data-ttu-id="d4208-156">앱 자체의 나머지 기능도 컨테이너 화 된 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-156">The remaining functionality in the app itself has also been containerized.</span></span>

![백 엔드에서 마이크로 서비스를 사용 하도록 모놀리식 앱을 분리 합니다.](./media/cloud-native-design.png)

<span data-ttu-id="d4208-158">**그림 3-2**.</span><span class="sxs-lookup"><span data-stu-id="d4208-158">**Figure 3-2**.</span></span> <span data-ttu-id="d4208-159">마이크로 서비스를 수용 하는 모놀리식 앱을 분해 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-159">Decomposing a monolithic app to embrace microservices.</span></span>

<span data-ttu-id="d4208-160">각 클라우드 네이티브 서비스는 별도의 컨테이너에 빌드 및 배포 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-160">Each cloud-native service is built and deployed in a separate container.</span></span> <span data-ttu-id="d4208-161">각는 필요에 따라 업데이트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-161">Each can update as needed.</span></span> <span data-ttu-id="d4208-162">각 서비스에 해당 하는 리소스가 있는 노드에서 개별 서비스를 호스트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-162">Individual services can be hosted on nodes with resources appropriate to each service.</span></span> <span data-ttu-id="d4208-163">각 서비스를 실행 하는 환경은 개발, 테스트 및 프로덕션 환경에서 공유 되 고 쉽게 버전이 관리 되는 변경 불가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-163">The environment each service runs in is immutable, shared across dev, test, and production environments, and easily versioned.</span></span> <span data-ttu-id="d4208-164">응용 프로그램의 서로 다른 영역 간 결합은 서비스 간 호출 또는 메시지로 명시적으로 발생 하며,이는 monolith 내에서 컴파일 타임 종속성이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-164">Coupling between different areas of the application occurs explicitly as calls or messages between services, not compile-time dependencies within the monolith.</span></span> <span data-ttu-id="d4208-165">응용 프로그램의 나머지 부분을 변경할 필요 없이 지정 된 기능에 가장 적합 한 기술을 선택할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-165">You can also choose the technology that best suites a given capability without requiring changes to the rest of the app.</span></span>

<span data-ttu-id="d4208-166">컨테이너 화 된 services에는 자동화 된 관리가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-166">Containerized services require automated management.</span></span> <span data-ttu-id="d4208-167">독립적으로 배포 된 컨테이너의 많은 집합을 수동으로 관리 하는 것은 불가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-167">It wouldn't be feasible to manually administer a large set of independently deployed containers.</span></span> <span data-ttu-id="d4208-168">예를 들어 다음 작업을 고려 하십시오.</span><span class="sxs-lookup"><span data-stu-id="d4208-168">For example, consider the following tasks:</span></span>

- <span data-ttu-id="d4208-169">여러 컴퓨터의 클러스터에서 컨테이너 인스턴스를 프로 비전 하는 방법</span><span class="sxs-lookup"><span data-stu-id="d4208-169">How will container instances be provisioned across a cluster of many machines?</span></span>
- <span data-ttu-id="d4208-170">배포 된 후 컨테이너는 어떻게 서로를 검색 하 고 통신할 수 있나요?</span><span class="sxs-lookup"><span data-stu-id="d4208-170">Once deployed, how will containers discover and communicate with each other?</span></span>
- <span data-ttu-id="d4208-171">컨테이너는 주문형으로 규모를 확장 하거나 축소할 수 있나요?</span><span class="sxs-lookup"><span data-stu-id="d4208-171">How can containers scale in or out on-demand?</span></span>
- <span data-ttu-id="d4208-172">각 컨테이너의 상태를 모니터링 하려면 어떻게 해야 하나요?</span><span class="sxs-lookup"><span data-stu-id="d4208-172">How do you monitor the health of each container?</span></span>
- <span data-ttu-id="d4208-173">하드웨어 및 소프트웨어 오류에 대해 컨테이너를 어떻게 보호 하나요?</span><span class="sxs-lookup"><span data-stu-id="d4208-173">How do you protect a container against hardware and software failures?</span></span>
- <span data-ttu-id="d4208-174">가동 중지 시간이 없는 라이브 응용 프로그램에 대해 컨테이너를 업그레이드 하려면 어떻게 해야 하나요?</span><span class="sxs-lookup"><span data-stu-id="d4208-174">How do upgrade containers for a live application with zero downtime?</span></span>

<span data-ttu-id="d4208-175">Container orchestrator는 이러한 문제를 해결 하 고 이러한 문제를 자동화 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-175">Container orchestrators address and automate these and other concerns.</span></span>

<span data-ttu-id="d4208-176">클라우드 네이티브 에코 시스템에서 Kubernetes는 사실상 컨테이너 orchestrator가 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-176">In the cloud-native eco-system, Kubernetes has become the de facto container orchestrator.</span></span> <span data-ttu-id="d4208-177">이 플랫폼은 CNCF (Cloud Native 컴퓨팅 Foundation)에서 관리 하는 오픈 소스 플랫폼입니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-177">It's an open-source platform managed by the Cloud Native Computing Foundation (CNCF).</span></span> <span data-ttu-id="d4208-178">Kubernetes는 컴퓨터 클러스터에서 컨테이너 화 된 워크 로드의 배포, 크기 조정 및 운영 문제를 자동화 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-178">Kubernetes automates the deployment, scaling, and operational concerns of containerized workloads across a machine cluster.</span></span> <span data-ttu-id="d4208-179">그러나 Kubernetes을 설치 하 고 관리 하는 것은 어렵습니다 복잡 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-179">However, installing and managing Kubernetes is notoriously complex.</span></span>

<span data-ttu-id="d4208-180">Kubernetes를 클라우드 공급 업체에서 관리 되는 서비스로 활용 하는 것이 훨씬 더 나은 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-180">A much better approach is to leverage Kubernetes as a managed service from a cloud vendor.</span></span> <span data-ttu-id="d4208-181">Azure 클라우드는 완전히 관리 되는 Kubernetes platform [Kubernetes Service (AKS)](https://azure.microsoft.com/services/kubernetes-service/)를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-181">The Azure cloud features a fully managed Kubernetes platform entitled [Azure Kubernetes Service (AKS)](https://azure.microsoft.com/services/kubernetes-service/).</span></span> <span data-ttu-id="d4208-182">AKS는 Kubernetes 관리의 복잡성 및 운영 오버 헤드를 요약 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-182">AKS abstracts the complexity and operational overhead of managing Kubernetes.</span></span> <span data-ttu-id="d4208-183">Kubernetes를 클라우드 서비스로 사용 합니다. Microsoft는이를 관리 하 고 지 원하는 작업을 담당 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-183">You consume Kubernetes as a cloud service; Microsoft takes responsibility for managing and supporting it.</span></span> <span data-ttu-id="d4208-184">또한 AKS는 다른 Azure 서비스 및 개발 도구와 긴밀 하 게 통합 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-184">AKS also tightly integrates with other Azure services and dev tools.</span></span>

<span data-ttu-id="d4208-185">AKS는 클러스터 기반 기술입니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-185">AKS is a cluster-based technology.</span></span> <span data-ttu-id="d4208-186">페더레이션된 가상 머신 또는 노드의 풀이 Azure 클라우드에 배포 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-186">A pool of federated virtual machines, or nodes, is deployed to the Azure cloud.</span></span> <span data-ttu-id="d4208-187">이들은 모두 항상 사용 가능한 환경 또는 클러스터를 형성 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-187">Together they form a highly available environment, or cluster.</span></span> <span data-ttu-id="d4208-188">클러스터는 클라우드 네이티브 응용 프로그램에 원활한 단일 엔터티로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-188">The cluster appears as a seamless, single entity to your cloud-native application.</span></span> <span data-ttu-id="d4208-189">내부적으로 AKS는 부하를 균등 하 게 분산 하는 미리 정의 된 전략에 따라 이러한 노드에서 컨테이너 화 된 서비스를 배포 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-189">Under the hood, AKS deploys your containerized services across these nodes following a predefined strategy that evenly distributes the load.</span></span>

## <a name="what-are-the-scaling-benefits"></a><span data-ttu-id="d4208-190">크기 조정 혜택은 무엇 인가요?</span><span class="sxs-lookup"><span data-stu-id="d4208-190">What are the scaling benefits?</span></span>

<span data-ttu-id="d4208-191">컨테이너를 기반으로 하는 서비스는 Kubernetes 같은 오케스트레이션 도구에서 제공 하는 크기 조정 혜택을 활용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-191">Services built on containers can leverage scaling benefits provided by orchestration tools like Kubernetes.</span></span> <span data-ttu-id="d4208-192">기본적으로 컨테이너는 자신에 대 한 정보를 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-192">By design containers only know about themselves.</span></span> <span data-ttu-id="d4208-193">여러 컨테이너를 함께 사용 해야 하는 경우에는 더 높은 수준으로 구성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-193">Once you have multiple containers that need to work together, you should organize them at a higher level.</span></span> <span data-ttu-id="d4208-194">많은 수의 컨테이너와 네트워크 구성과 같은 공유 종속성을 구성 하는 것은 오케스트레이션 도구가 날짜를 절약 하는 데 제공 되는 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-194">Organizing large numbers of containers and their shared dependencies, such as network configuration, is where orchestration tools come in to save the day!</span></span> <span data-ttu-id="d4208-195">Kubernetes는 컨테이너 그룹에 대 한 추상화 계층을 만들고 *pod*으로 구성 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-195">Kubernetes creates an abstraction layer over groups of containers and organizes them into *pods*.</span></span> <span data-ttu-id="d4208-196">Pod는 *노드라고*하는 작업자 컴퓨터에서 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-196">Pods run on worker machines referred to as *nodes*.</span></span> <span data-ttu-id="d4208-197">이 구성 된 구조를 *클러스터*라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-197">This organized structure is referred to as a *cluster*.</span></span> <span data-ttu-id="d4208-198">그림 3-3에서는 Kubernetes 클러스터의 여러 구성 요소를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-198">Figure 3-3 shows the different components of a Kubernetes cluster.</span></span>

<span data-ttu-id="d4208-199">![Kubernetes 클러스터 구성 요소 ](./media/kubernetes-cluster-components.png)
 **그림 3-3**.</span><span class="sxs-lookup"><span data-stu-id="d4208-199">![Kubernetes cluster components.](./media/kubernetes-cluster-components.png)
**Figure 3-3**.</span></span> <span data-ttu-id="d4208-200">Kubernetes 클러스터 구성 요소</span><span class="sxs-lookup"><span data-stu-id="d4208-200">Kubernetes cluster components.</span></span>

<span data-ttu-id="d4208-201">컨테이너 화 된 워크 로드 크기 조정은 컨테이너 orchestrator의 핵심 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-201">Scaling containerized workloads is a key feature of container orchestrators.</span></span> <span data-ttu-id="d4208-202">AKS는 두 차원 (컨테이너 인스턴스 및 계산 노드)에서 자동 크기 조정을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-202">AKS supports automatic scaling across two dimensions: Container instances and compute nodes.</span></span> <span data-ttu-id="d4208-203">AKS는 수요 급증에 신속 하 고 효율적으로 대응 하 고 리소스를 더 추가할 수 있는 기능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-203">Together they give AKS the ability to quickly and efficiently respond to spikes in demand and add additional resources.</span></span> <span data-ttu-id="d4208-204">AKS의 크기 조정에 대해서는이 장의 뒷부분에서 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-204">We discuss scaling in AKS later in this chapter.</span></span>

### <a name="declarative-versus-imperative"></a><span data-ttu-id="d4208-205">선언적 및 명령적</span><span class="sxs-lookup"><span data-stu-id="d4208-205">Declarative versus imperative</span></span>

<span data-ttu-id="d4208-206">Kubernetes는 선언적 및 명령적 구성을 모두 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-206">Kubernetes supports both declarative and imperative configuration.</span></span> <span data-ttu-id="d4208-207">명령적 방식에는 각 단계를 수행할 작업을 Kubernetes 알려주는 다양 한 명령이 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-207">The imperative approach involves running various commands that tell Kubernetes what to do each step of the way.</span></span> <span data-ttu-id="d4208-208">이 이미지를 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-208">Run this image.</span></span> <span data-ttu-id="d4208-209">이 pod를 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-209">Delete this pod.</span></span> <span data-ttu-id="d4208-210">이 포트를 노출 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-210">Expose this port.</span></span> <span data-ttu-id="d4208-211">선언적 접근법을 사용 하 여 수행할 작업 대신 원하는 작업을 설명 하는 매니페스트 라는 구성 파일을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-211">With the declarative approach, you create a configuration file, called a manifest, to describe what you want instead of what to do.</span></span> <span data-ttu-id="d4208-212">Kubernetes는 매니페스트를 읽고 원하는 최종 상태를 실제 끝 상태로 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-212">Kubernetes reads the manifest and transforms your desired end state into actual end state.</span></span>

<span data-ttu-id="d4208-213">명령적 명령은 학습 및 대화형 실험에 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-213">Imperative commands are great for learning and interactive experimentation.</span></span> <span data-ttu-id="d4208-214">그러나 Kubernetes 매니페스트 파일을 선언적으로 만들어 인프라를 코드 방법으로 사용 하 여 안정적이 고 반복 가능한 배포를 제공 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-214">However, you'll want to declaratively create Kubernetes manifest files to embrace an infrastructure as code approach, providing for reliable and repeatable deployments.</span></span> <span data-ttu-id="d4208-215">매니페스트 파일은 프로젝트 아티팩트가 되며 CI/CD 파이프라인에서 Kubernetes 배포를 자동화 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-215">The manifest file becomes a project artifact and is used in your CI/CD pipeline for automating Kubernetes deployments.</span></span>

<span data-ttu-id="d4208-216">명령적 명령을 사용 하 여 클러스터를 이미 구성한 경우를 사용 하 여 선언적 매니페스트를 내보낼 수 있습니다 `kubectl get svc SERVICENAME -o yaml > service.yaml` .</span><span class="sxs-lookup"><span data-stu-id="d4208-216">If you've already configured your cluster using imperative commands, you can export a declarative manifest by using `kubectl get svc SERVICENAME -o yaml > service.yaml`.</span></span> <span data-ttu-id="d4208-217">이 명령은 아래와 비슷한 매니페스트를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-217">This command produces a manifest similar to one shown below:</span></span>

```yaml
apiVersion: v1
kind: Service
metadata:
  creationTimestamp: "2019-09-13T13:58:47Z"
  labels:
    component: apiserver
    provider: kubernetes
  name: kubernetes
  namespace: default
  resourceVersion: "153"
  selfLink: /api/v1/namespaces/default/services/kubernetes
  uid: 9b1fac62-d62e-11e9-8968-00155d38010d
spec:
  clusterIP: 10.96.0.1
  ports:
  - name: https
    port: 443
    protocol: TCP
    targetPort: 6443
  sessionAffinity: None
  type: ClusterIP
status:
  loadBalancer: {}
```

<span data-ttu-id="d4208-218">선언적 구성을 사용 하는 경우 `kubectl diff -f FOLDERNAME` 구성 파일이 있는 폴더에 대해를 사용 하 여 커밋하기 전에 적용 되는 변경 내용을 미리 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-218">When using declarative configuration, you can preview the changes that will be made before committing them by using `kubectl diff -f FOLDERNAME` against the folder where your configuration files are located.</span></span> <span data-ttu-id="d4208-219">변경 내용을 적용 하려면를 실행 `kubectl apply -f FOLDERNAME` 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-219">Once you're sure you want to apply the changes, run `kubectl apply -f FOLDERNAME`.</span></span> <span data-ttu-id="d4208-220">`-R`를 추가 하 여 폴더 계층 구조를 재귀적으로 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-220">Add `-R` to recursively process a folder hierarchy.</span></span>

<span data-ttu-id="d4208-221">또한 배포 중인 다른 Kubernetes 기능과 함께 선언적 구성을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-221">You can also use declarative configuration with other Kubernetes features, one of which being deployments.</span></span> <span data-ttu-id="d4208-222">선언적 배포는 릴리스, 업데이트 및 크기 조정을 관리 하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-222">Declarative deployments help manage releases, updates, and scaling.</span></span> <span data-ttu-id="d4208-223">Kubernetes 배포 컨트롤러에 새 변경 내용을 배포 하거나, 부하를 확장 하거나, 이전 수정 버전으로 롤백하는 방법을 지시 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-223">They instruct the Kubernetes deployment controller on how to deploy new changes, scale out load, or roll back to a previous revision.</span></span> <span data-ttu-id="d4208-224">클러스터가 불안정 한 경우 선언적 배포에서 클러스터를 자동으로 원하는 상태로 되돌립니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-224">If a cluster is unstable, a declarative deployment will automatically return the cluster back to a desired state.</span></span> <span data-ttu-id="d4208-225">예를 들어 노드가 충돌 하는 경우 배포 메커니즘은 대체를 다시 배포 하 여 원하는 상태를 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-225">For example, if a node should crash, the deployment mechanism will redeploy a replacement to achieve your desired state</span></span>

<span data-ttu-id="d4208-226">선언적 구성을 사용 하면 응용 프로그램 코드와 함께 체크 인하고 버전을 지정할 수 있는 코드로 인프라를 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-226">Using declarative configuration allows infrastructure to be represented as code that can be checked in and versioned alongside the application code.</span></span> <span data-ttu-id="d4208-227">빌드 및 배포 파이프라인을 사용 하 여 지속적인 배포에 대 한 향상 된 변경 제어 및 향상 된 지원을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-227">It provides improved change control and better support for continuous deployment using a build and deploy pipeline.</span></span>

## <a name="what-scenarios-are-ideal-for-containers-and-orchestrators"></a><span data-ttu-id="d4208-228">컨테이너 및 orchestrator에 적합 한 시나리오는 무엇 인가요?</span><span class="sxs-lookup"><span data-stu-id="d4208-228">What scenarios are ideal for containers and orchestrators?</span></span>

<span data-ttu-id="d4208-229">다음 시나리오는 컨테이너 및 orchestrator를 사용 하는 데 적합 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-229">The following scenarios are ideal for using containers and orchestrators.</span></span>

### <a name="applications-requiring-high-uptime-and-scalability"></a><span data-ttu-id="d4208-230">높은 작동 시간 및 확장성을 필요로 하는 응용 프로그램</span><span class="sxs-lookup"><span data-stu-id="d4208-230">Applications requiring high uptime and scalability</span></span>

<span data-ttu-id="d4208-231">가동 시간 및 확장성 요구 사항이 높은 개별 응용 프로그램은 마이크로 서비스, 컨테이너 및 orchestrator를 사용 하는 클라우드 기본 아키텍처에 적합 한 후보입니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-231">Individual applications that have high uptime and scalability requirements are ideal candidates for cloud-native architectures using microservices, containers, and orchestrators.</span></span> <span data-ttu-id="d4208-232">컨테이너에서 개발 하 고, 버전이 있는 환경에서 테스트 하 고, 가동 중지 시간 없이 프로덕션에 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-232">They can be developed in containers, tested across versioned environments, and deployed into production with zero downtime.</span></span> <span data-ttu-id="d4208-233">Kubernetes 클러스터를 사용 하면 이러한 앱이 주문형으로 확장 되 고 노드 오류에서 자동으로 복구 될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-233">The use of Kubernetes clusters ensures such apps can also scale on demand and recover automatically from node failures.</span></span>

### <a name="large-numbers-of-applications"></a><span data-ttu-id="d4208-234">많은 수의 응용 프로그램</span><span class="sxs-lookup"><span data-stu-id="d4208-234">Large numbers of applications</span></span>

<span data-ttu-id="d4208-235">많은 수의 응용 프로그램을 배포 하 고 유지 관리 하는 조직은 컨테이너와 orchestrator의 이점을 누릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-235">Organizations that deploy and maintain large numbers of applications benefit from containers and orchestrators.</span></span> <span data-ttu-id="d4208-236">컨테이너 화 된 환경 및 Kubernetes 클러스터를 설정 하는 앞의 노력은 고정 비용입니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-236">The up front effort of setting up containerized environments and Kubernetes clusters is primarily a fixed cost.</span></span> <span data-ttu-id="d4208-237">개별 응용 프로그램을 배포, 유지 관리 및 업데이트 하면 응용 프로그램의 수에 따라 비용이 많이 듭니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-237">Deploying, maintaining, and updating individual applications has a cost that varies with the number of applications.</span></span> <span data-ttu-id="d4208-238">적은 수의 응용 프로그램을 통해 사용자 지정 응용 프로그램을 수동으로 유지 관리 하는 복잡성이 컨테이너 및 orchestrator를 사용 하 여 솔루션을 구현 하는 비용을 초과할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-238">Beyond a small number of applications, the complexity of maintaining custom applications manually exceeds the cost of implementing a solution using containers and orchestrators.</span></span>

## <a name="when-should-you-avoid-using-containers-and-orchestrators"></a><span data-ttu-id="d4208-239">컨테이너와 orchestrator를 사용 하지 않는 경우는 언제 인가요?</span><span class="sxs-lookup"><span data-stu-id="d4208-239">When should you avoid using containers and orchestrators?</span></span>

<span data-ttu-id="d4208-240">Twelve-Factor 앱 원칙에 따라 응용 프로그램을 빌드할 수 없는 경우 컨테이너와 orchestrator을 방지 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-240">If you're unable to build your application following the Twelve-Factor App principles, you should consider avoiding containers and orchestrators.</span></span> <span data-ttu-id="d4208-241">이러한 경우 VM 기반 호스팅 플랫폼 또는 일부 하이브리드 시스템을 고려해 야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-241">In these cases, consider a VM-based hosting platform, or possibly some hybrid system.</span></span> <span data-ttu-id="d4208-242">이를 통해 항상 특정 기능을 별도의 컨테이너 또는 서버를 사용 하지 않는 함수로 회전할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-242">With it, you can always spin off certain pieces of functionality into separate containers or even serverless functions.</span></span>

## <a name="development-resources"></a><span data-ttu-id="d4208-243">개발 리소스</span><span class="sxs-lookup"><span data-stu-id="d4208-243">Development resources</span></span>

<span data-ttu-id="d4208-244">이 섹션에서는 다음 응용 프로그램에 컨테이너 및 orchestrator 사용을 시작 하는 데 도움이 될 수 있는 간단한 개발 리소스 목록을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-244">This section shows a short list of development resources that may help you get started using containers and orchestrators for your next application.</span></span> <span data-ttu-id="d4208-245">클라우드 네이티브 마이크로 서비스 아키텍처 앱을 설계 하는 방법에 대 한 지침은이 설명서의 [.Net 마이크로 서비스: 컨테이너 화 된 .Net 응용 프로그램용 아키텍처](https://dotnet.microsoft.com/download/thank-you/microservices-architecture-ebook)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="d4208-245">If you're looking for guidance on how to design your cloud-native microservices architecture app, read this book's companion, [.NET Microservices: Architecture for Containerized .NET Applications](https://dotnet.microsoft.com/download/thank-you/microservices-architecture-ebook).</span></span>

### <a name="local-kubernetes-development"></a><span data-ttu-id="d4208-246">로컬 Kubernetes 개발</span><span class="sxs-lookup"><span data-stu-id="d4208-246">Local Kubernetes Development</span></span>

<span data-ttu-id="d4208-247">Kubernetes 배포는 프로덕션 환경에서 뛰어난 가치를 제공 하지만 개발 컴퓨터에서 로컬로 실행할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-247">Kubernetes deployments provide great value in production environments, but can also run locally on your development machine.</span></span> <span data-ttu-id="d4208-248">개별 마이크로 서비스를 독립적으로 사용할 수 있지만 프로덕션 환경에 배포할 때 실행 되는 것 처럼 전체 시스템을 로컬로 실행 해야 하는 경우가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-248">While you may work on individual microservices independently, there may be times when you'll need to run the entire system locally - just as it will run when deployed to production.</span></span> <span data-ttu-id="d4208-249">Minikube 및 Docker Desktop을 통해 도움이 되는 몇 가지 도구가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-249">There are several tools that can help: Minikube and Docker Desktop.</span></span> <span data-ttu-id="d4208-250">또한 Visual Studio는 Docker 개발용 도구를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-250">Visual Studio also provides tooling for Docker development.</span></span>

### <a name="minikube"></a><span data-ttu-id="d4208-251">Minikube</span><span class="sxs-lookup"><span data-stu-id="d4208-251">Minikube</span></span>

<span data-ttu-id="d4208-252">Minikube 란?</span><span class="sxs-lookup"><span data-stu-id="d4208-252">What is Minikube?</span></span> <span data-ttu-id="d4208-253">Minikube 프로젝트에서는 "Minikube가 macOS, Linux 및 Windows에서 로컬 Kubernetes 클러스터를 구현 합니다." 라고 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-253">The Minikube project says "Minikube implements a local Kubernetes cluster on macOS, Linux, and Windows."</span></span> <span data-ttu-id="d4208-254">주요 목표는 "로컬 Kubernetes 응용 프로그램 개발에 가장 적합 한 도구 이며이에 적합 한 모든 Kubernetes 기능을 지 원하는 것입니다."</span><span class="sxs-lookup"><span data-stu-id="d4208-254">Its primary goals are "to be the best tool for local Kubernetes application development and to support all Kubernetes features that fit."</span></span> <span data-ttu-id="d4208-255">Minikube 설치는 Docker와는 별개 이지만 Minikube는 Docker 데스크톱과 지원 되는 것과 다른 하이퍼바이저를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-255">Installing Minikube is separate from Docker, but Minikube supports different hypervisors than Docker Desktop supports.</span></span> <span data-ttu-id="d4208-256">Minikube에서 현재 지원 되는 Kubernetes 기능은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-256">The following Kubernetes features are currently supported by Minikube:</span></span>

- <span data-ttu-id="d4208-257">DNS</span><span class="sxs-lookup"><span data-stu-id="d4208-257">DNS</span></span>
- <span data-ttu-id="d4208-258">NodePorts</span><span class="sxs-lookup"><span data-stu-id="d4208-258">NodePorts</span></span>
- <span data-ttu-id="d4208-259">ConfigMaps 및 비밀</span><span class="sxs-lookup"><span data-stu-id="d4208-259">ConfigMaps and secrets</span></span>
- <span data-ttu-id="d4208-260">대시보드</span><span class="sxs-lookup"><span data-stu-id="d4208-260">Dashboards</span></span>
- <span data-ttu-id="d4208-261">컨테이너 런타임: Docker, rkt, CRI 및 containerd</span><span class="sxs-lookup"><span data-stu-id="d4208-261">Container runtimes: Docker, rkt, CRI-O, and containerd</span></span>
- <span data-ttu-id="d4208-262">CNI (컨테이너 네트워크 인터페이스)를 사용 하도록 설정</span><span class="sxs-lookup"><span data-stu-id="d4208-262">Enabling Container Network Interface (CNI)</span></span>
- <span data-ttu-id="d4208-263">수신</span><span class="sxs-lookup"><span data-stu-id="d4208-263">Ingress</span></span>

<span data-ttu-id="d4208-264">Minikube를 설치한 후 `minikube start` 이미지를 다운로드 하 고 로컬 Kubernetes 클러스터를 시작 하는 명령을 실행 하 여 사용을 빠르게 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-264">After installing Minikube, you can quickly start using it by running the `minikube start` command, which downloads an image and start the local Kubernetes cluster.</span></span> <span data-ttu-id="d4208-265">클러스터가 시작 되 면 표준 Kubernetes 명령을 사용 하 여 상호 작용 `kubectl` 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-265">Once the cluster is started, you interact with it using the standard Kubernetes `kubectl` commands.</span></span>

### <a name="docker-desktop"></a><span data-ttu-id="d4208-266">Docker Desktop</span><span class="sxs-lookup"><span data-stu-id="d4208-266">Docker Desktop</span></span>

<span data-ttu-id="d4208-267">Windows의 Docker Desktop에서 직접 Kubernetes 작업을 수행할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-267">You can also work with Kubernetes directly from Docker Desktop on Windows.</span></span> <span data-ttu-id="d4208-268">Windows 컨테이너를 사용 하는 경우에만 사용할 수 있는 옵션이 며 비 Windows 컨테이너에도 적합 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-268">It is your only option if you're using Windows Containers, and is a great choice for non-Windows containers as well.</span></span> <span data-ttu-id="d4208-269">그림 3-4에서는 Docker Desktop을 실행할 때 로컬 Kubernetes 지원을 사용 하도록 설정 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-269">Figure 3-4 shows how to enable local Kubernetes support when running Docker Desktop.</span></span>

![Docker Desktop에서 Kubernetes 구성](./media/docker-desktop-kubernetes.png)

<span data-ttu-id="d4208-271">**그림 3-4**.</span><span class="sxs-lookup"><span data-stu-id="d4208-271">**Figure 3-4**.</span></span> <span data-ttu-id="d4208-272">Docker Desktop에서 Kubernetes를 구성 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-272">Configuring Kubernetes in Docker Desktop.</span></span>

<span data-ttu-id="d4208-273">Docker Desktop은 컨테이너 화 된 apps를 로컬로 구성 하 고 실행 하는 데 가장 많이 사용 되는 도구입니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-273">Docker Desktop is the most popular tool for configuring and running containerized apps locally.</span></span> <span data-ttu-id="d4208-274">Docker Desktop을 사용 하는 경우 프로덕션 환경에 배포할 정확한 Docker 컨테이너 이미지 집합에 대해 로컬로 개발할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-274">When you work with Docker Desktop, you can develop locally against the exact same set of Docker container images that you'll deploy to production.</span></span> <span data-ttu-id="d4208-275">Docker Desktop은 컨테이너 화 된 apps를 로컬로 빌드, 테스트 및 제공 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-275">Docker Desktop is designed to "build, test, and ship" containerized apps locally.</span></span> <span data-ttu-id="d4208-276">Linux 및 Windows 컨테이너를 모두 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-276">It supports both Linux and Windows containers.</span></span> <span data-ttu-id="d4208-277">이미지를 Azure Container Registry 또는 Docker Hub와 같은 이미지 레지스트리로 푸시하는 경우 AKS에서 프로덕션으로 끌어오고 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-277">Once you push your images to an image registry, like Azure Container Registry or Docker Hub, AKS can pull and deploy them to production.</span></span>

### <a name="visual-studio-docker-tooling"></a><span data-ttu-id="d4208-278">Visual Studio Docker 도구</span><span class="sxs-lookup"><span data-stu-id="d4208-278">Visual Studio Docker Tooling</span></span>

<span data-ttu-id="d4208-279">Visual Studio는 웹 기반 응용 프로그램에 대 한 Docker 개발을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-279">Visual Studio supports Docker development for web-based applications.</span></span> <span data-ttu-id="d4208-280">새 ASP.NET Core 응용 프로그램을 만드는 경우 그림 3-5에 표시 된 것 처럼 Docker 지원으로 구성 하는 옵션을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-280">When you create a new ASP.NET Core application, you have an option to configure it with Docker support, as shown in Figure 3-5.</span></span>

![Visual Studio에서 Docker 지원 사용](./media/visual-studio-enable-docker-support.png)

<span data-ttu-id="d4208-282">**그림 3-5**.</span><span class="sxs-lookup"><span data-stu-id="d4208-282">**Figure 3-5**.</span></span> <span data-ttu-id="d4208-283">Visual Studio에서 Docker 지원 사용</span><span class="sxs-lookup"><span data-stu-id="d4208-283">Visual Studio Enable Docker Support</span></span>

<span data-ttu-id="d4208-284">이 옵션을 선택 하면 프로젝트는 해당 루트에를 사용 하 여 생성 됩니다 .이 프로젝트는 `Dockerfile` Docker 컨테이너에서 앱을 빌드하고 호스트 하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-284">When this option is selected, the project is created with a `Dockerfile` in its root, which can be used to build and host the app in a Docker container.</span></span> <span data-ttu-id="d4208-285">예제 Dockerfile은 그림 3 -6에 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-285">An example Dockerfile is shown in Figure 3-6.git</span></span>

```dockerfile
FROM mcr.microsoft.com/dotnet/core/aspnet:3.1-buster-slim AS base
WORKDIR /app
EXPOSE 80
EXPOSE 443

FROM mcr.microsoft.com/dotnet/core/sdk:3.1-buster AS build
WORKDIR /src
COPY ["eShopWeb/eShopWeb.csproj", "eShopWeb/"]
RUN dotnet restore "eShopWeb/eShopWeb.csproj"
COPY . .
WORKDIR "/src/eShopWeb"
RUN dotnet build "eShopWeb.csproj" -c Release -o /app/build

FROM build AS publish
RUN dotnet publish "eShopWeb.csproj" -c Release -o /app/publish

FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "eShopWeb.dll"]
```

<span data-ttu-id="d4208-286">**그림 3-6**.</span><span class="sxs-lookup"><span data-stu-id="d4208-286">**Figure 3-6**.</span></span> <span data-ttu-id="d4208-287">Visual Studio에서 Dockerfile을 생성 했습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-287">Visual Studio generated Dockerfile</span></span>

<span data-ttu-id="d4208-288">앱이 실행 되는 기본 동작은 Docker도 사용 하도록 구성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-288">The default behavior when the app runs is configured to use Docker as well.</span></span> <span data-ttu-id="d4208-289">그림 3-7에서는 Docker 지원을 추가 하 여 만든 새 ASP.NET Core 프로젝트에서 사용할 수 있는 다양 한 실행 옵션을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-289">Figure 3-7 shows the different run options available from a new ASP.NET Core project created with Docker support added.</span></span>

![Visual Studio Docker 실행 옵션](./media/visual-studio-docker-run-options.png)

<span data-ttu-id="d4208-291">**그림 3-7**.</span><span class="sxs-lookup"><span data-stu-id="d4208-291">**Figure 3-7**.</span></span> <span data-ttu-id="d4208-292">Visual Studio Docker 실행 옵션</span><span class="sxs-lookup"><span data-stu-id="d4208-292">Visual Studio Docker Run Options</span></span>

<span data-ttu-id="d4208-293">로컬 개발 외에도 [Azure Dev Spaces](/azure/dev-spaces/) 는 여러 개발자가 Azure 내에서 고유한 Kubernetes 구성으로 작업할 수 있는 편리한 방법을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-293">In addition to local development, [Azure Dev Spaces](/azure/dev-spaces/) provides a convenient way for multiple developers to work with their own Kubernetes configurations within Azure.</span></span> <span data-ttu-id="d4208-294">그림 3-7에서 볼 수 있듯이, Azure Dev Spaces에서 응용 프로그램을 실행할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-294">As you can see in Figure 3-7, you can also run the application in Azure Dev Spaces.</span></span>

<span data-ttu-id="d4208-295">또한 언제 든 지 기존 ASP.NET Core 응용 프로그램에 Docker 지원을 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-295">Also, at any time you can add Docker support to an existing ASP.NET Core application.</span></span> <span data-ttu-id="d4208-296">그림 3-8에 표시 된 것 처럼 Visual Studio 솔루션 탐색기에서 프로젝트를 마우스 **Add**오른쪽 단추로 클릭 하 고  >  **Docker 지원**추가를 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-296">From the Visual Studio Solution Explorer, right-click on the project and select **Add** > **Docker Support**, as shown in Figure 3-8.</span></span>

![Visual Studio Docker 지원 추가](./media/visual-studio-add-docker-support.png)

<span data-ttu-id="d4208-298">**그림 3-8**.</span><span class="sxs-lookup"><span data-stu-id="d4208-298">**Figure 3-8**.</span></span> <span data-ttu-id="d4208-299">Visual Studio에 Docker 지원 추가</span><span class="sxs-lookup"><span data-stu-id="d4208-299">Adding Docker support to Visual Studio</span></span>

<span data-ttu-id="d4208-300">그림 3-8에 표시 된 컨테이너 오케스트레이션 지원도 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-300">You can also add Container Orchestration Support, also shown in Figure 3-8.</span></span> <span data-ttu-id="d4208-301">기본적으로 orchestrator는 Kubernetes 및 투구를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-301">By default, the orchestrator uses Kubernetes and Helm.</span></span> <span data-ttu-id="d4208-302">Orchestrator를 선택 하면 `azds.yaml` 파일이 프로젝트 루트에 추가 되 고 `charts` Kubernetes에 응용 프로그램을 구성 하 고 배포 하는 데 사용 되는 투구 차트가 포함 된 폴더가 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-302">Once you've chosen the orchestrator, a `azds.yaml` file is added to the project root and a `charts` folder is added containing the Helm charts used to configure and deploy the application to Kubernetes.</span></span> <span data-ttu-id="d4208-303">그림 3-9에서는 새 프로젝트의 결과 파일을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-303">Figure 3-9 shows the resulting files in a new project.</span></span>

![Visual Studio Orchestrator 지원 추가](./media/visual-studio-add-orchestrator-support.png)

<span data-ttu-id="d4208-305">**그림 3-9**.</span><span class="sxs-lookup"><span data-stu-id="d4208-305">**Figure 3-9**.</span></span> <span data-ttu-id="d4208-306">Visual Studio에 오케스트레이션 지원 추가</span><span class="sxs-lookup"><span data-stu-id="d4208-306">Adding orchestration support to Visual Studio</span></span>

### <a name="visual-studio-code-docker-tooling"></a><span data-ttu-id="d4208-307">Visual Studio Code Docker 도구</span><span class="sxs-lookup"><span data-stu-id="d4208-307">Visual Studio Code Docker Tooling</span></span>

<span data-ttu-id="d4208-308">Docker 개발을 지 원하는 Visual Studio Code에 사용할 수 있는 다양 한 확장이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-308">There are a number of extensions available for Visual Studio Code that support Docker development.</span></span>

<span data-ttu-id="d4208-309">Microsoft는 [Visual Studio Code 확장을 위한 Docker](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-docker)를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-309">Microsoft provides the [Docker for Visual Studio Code extension](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-docker).</span></span> <span data-ttu-id="d4208-310">이 확장은 응용 프로그램에 컨테이너 지원을 추가 하는 프로세스를 간소화 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-310">This extension simplifies the process of adding container support to applications.</span></span> <span data-ttu-id="d4208-311">필수 파일을 스 캐 폴드 하 고, Docker 이미지를 빌드하고, 컨테이너 내에서 앱을 디버그할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-311">It scaffolds required files, builds Docker images, and enables you to debug your app inside a container.</span></span> <span data-ttu-id="d4208-312">확장에는 시작, 중지, 검사, 제거 등의 컨테이너 및 이미지에 대 한 작업을 쉽게 수행할 수 있도록 하는 visual explorer 기능이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-312">The extension features a visual explorer that makes it easy to take actions on containers and images such as start, stop, inspect, remove, and more.</span></span> <span data-ttu-id="d4208-313">또한 확장은 실행 중인 여러 컨테이너를 단일 단위로 관리할 수 있는 Docker Compose 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4208-313">The extension also supports Docker Compose enabling you to manage multiple running containers as a single unit.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="d4208-314">[이전](scale-applications.md)
>[다음](leverage-serverless-functions.md)</span><span class="sxs-lookup"><span data-stu-id="d4208-314">[Previous](scale-applications.md)
[Next](leverage-serverless-functions.md)</span></span>
