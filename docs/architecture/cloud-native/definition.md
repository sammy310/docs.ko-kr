---
title: 클라우드 네이티브 정의
description: 클라우드 기본 시스템용 bedrock을 제공 하는 기본 핵심 요소에 대해 알아봅니다.
author: robvet
ms.date: 05/13/2020
ms.openlocfilehash: e8b07fe7758d90f6ba97b81d0efa9d2fb5058d49
ms.sourcegitcommit: 27db07ffb26f76912feefba7b884313547410db5
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/19/2020
ms.locfileid: "83614180"
---
# <a name="defining-cloud-native"></a>클라우드 네이티브 정의

수행 하 고 있는 작업 및 동료의 10 자를 중지 합니다. "클라우드 네이티브" 라는 용어를 정의 하도록 요청 합니다. 10 개의 서로 다른 답을 얻을 수 있는 좋은 기회입니다.

클라우드 기본은 중요 한 비즈니스 시스템을 구성 하는 방법에 대 한 고려 사항입니다.

클라우드 네이티브 시스템은 신속한 변화, 대규모 및 복원 력을 수용 하도록 설계 되었습니다.

Cloud Native 컴퓨팅 Foundation은 [공식 정의](https://github.com/cncf/foundation/blob/master/charter.md)를 제공 합니다.

> *클라우드 기본 기술을 통해 조직은 공용, 사설 및 하이브리드 클라우드와 같은 최신의 동적 환경에서 확장 가능한 응용 프로그램을 빌드 및 실행할 수 있습니다. 컨테이너, 서비스 메시, 마이크로 서비스, 변경할 수 없는 인프라 및 선언적 Api는이 접근 방식을 exemplify 합니다.*

> *이러한 기술을 통해 탄력적이 고 관리 하기 쉽고 관찰 가능한 느슨하게 결합 된 시스템을 사용할 수 있습니다. 강력한 자동화와 결합 되어 엔지니어가 toil을 최소화 하면서 높은 영향을 미치는 변화를 자주 내릴 수 있습니다.*

응용 프로그램은 더 많은 사용자가 요구 하는 점점 점점 더 복잡 해지고 있습니다. 사용자는 신속한 응답성, 혁신적인 기능 및 가동 중지 시간을 예측할 수 있습니다. 성능 문제, 반복 되는 오류 및 빠르게 이동할 수 없는 것은 더 이상 허용 되지 않습니다. 경쟁 업체에 쉽게 이동할 수 있습니다.

Cloud native는 *속도* 와 *민첩성*에 대 한 것입니다. 비즈니스 시스템은 비즈니스 기능을 사용 하 여 전략적 변환의 무기로 비즈니스 속도와 성장을 가속화 하는 것부터 발전 하 고 있습니다. 시장에 즉시 아이디어를 얻는 것이 필수적입니다.

이러한 기술을 구현한 회사는 다음과 같습니다. 달성 한 속도, 민첩성 및 확장성을 고려 합니다.

| 회사 | 환경 |
| :-------- | :-------- |
| [Netflix](https://www.infoq.com/news/2013/06/netflix/) | 에는 프로덕션에서 600 개 이상의 서비스가 있습니다. 하루에 100 회 배포 합니다. |
| [Uber](https://eng.uber.com/micro-deploy/) | 에는 프로덕션 환경에서 1000 개 이상의 서비스가 있습니다. 매주 몇 천 번 배포 합니다. |
| [WeChat](https://www.cs.columbia.edu/~ruigu/papers/socc18-final100.pdf) | 에는 프로덕션 환경에서 300 개 이상의 서비스가 있습니다. 하루에 1000 번 배포 합니다. |

여기에서 볼 수 있듯이 Netflix, Uber 및 WeChat는 수많은 독립 마이크로 서비스로 구성 된 시스템을 노출 합니다. 이 아키텍처 스타일을 통해 시장 상황에 신속 하 게 대응할 수 있습니다. 이러한 사용자는 라이브, 복잡 한 응용 프로그램의 작은 영역을 즉시 업데이트 하 고 필요에 따라 이러한 영역을 개별적으로 확장할 수 있습니다.

Cloud native의 속도 및 민첩성은 다양 한 요소에서 제공 됩니다. 가장는 클라우드 인프라입니다. 그림 1-3에 표시 된 5 가지 추가 기본 핵심 요소 클라우드 기본 시스템에 대 한 bedrock을 제공 합니다.

![클라우드 네이티브 기본 핵심 요소](./media/cloud-native-foundational-pillars.png)

**그림 1-3**. 클라우드 네이티브 기본 핵심 요소

각 기둥의 중요도를 보다 잘 이해 하는 데 약간의 시간이 걸릴 수 있습니다.

## <a name="the-cloud"></a>클라우드 ...

클라우드 기본 시스템은 클라우드 서비스 모델을 최대한 활용 합니다.

가상화 된 동적 클라우드 환경에서 올립니다 설계 된 이러한 시스템은 [PaaS (Platform as a Service)](https://azure.microsoft.com/overview/what-is-paas/) 계산 인프라와 관리 되는 서비스를 광범위 하 게 사용 합니다. 기본 인프라를 몇 분 내에 *삭제* 가능 프로 비전 된 것으로 처리 하 고 자동화를 통해 필요에 따라 크기 조정, 크기 조정, 이동 또는 제거 합니다.

[애완 동물 vs. 결국](https://medium.com/@Joachim8675309/devops-concepts-pets-vs-cattle-2380b5aab313)에서 널리 승인 된 devops 개념을 고려 합니다. 기존 데이터 센터에서 서버는 *애완 동물*으로 처리 됩니다. 물리적 컴퓨터는 의미 있는 이름을 지정 하 고는 확인 개체만입니다. 동일한 컴퓨터에 리소스를 더 추가 하 여 크기를 조정 합니다 (확장). 서버를 병가로 전환 하면 간호사 됩니다. 서버를 사용할 수 없게 되 면 모든 사용자가 알림을 받을 수 있습니다.

*결국* 서비스 모델이 서로 다릅니다. 각 인스턴스를 가상 컴퓨터 또는 컨테이너로 프로 비전 합니다. 동일 하 고 서비스-01, 서비스-02 등의 시스템 식별자가 할당 됩니다. 이러한 항목을 더 만들어 크기를 조정 합니다 (규모 확장). 하나를 사용할 수 없게 되 면 아무도 알림을 하지 않습니다.

결국 모델은 변경할 수 없는 *인프라*를 수용 합니다. 서버가 복구 되거나 수정 되지 않습니다. 오류가 발생 하거나 업데이트가 필요한 경우에는 완전히 제거 되며 자동화를 통해 모두 프로 비전 됩니다.

클라우드 네이티브 시스템은 결국 서비스 모델을 수용 합니다. 인프라는 실행 중인 컴퓨터와 관계 없이 규모를 확장 하거나 축소할 때 계속 해 서 실행 됩니다.

Azure 클라우드 플랫폼은 자동 크기 조정, 자동 복구 및 모니터링 기능을 제공 하는 이러한 유형의 매우 탄력적 인프라를 지원 합니다.

## <a name="modern-design"></a>최신 디자인

클라우드 네이티브 앱을 어떻게 디자인 하나요? 아키텍처는 다음과 같습니다. 어떤 원칙, 패턴 및 모범 사례를 준수 하나요? 중요 한 인프라 및 운영 우려는 무엇 인가요?

### <a name="the-twelve-factor-application"></a>12 단계 응용 프로그램

클라우드 기반 응용 프로그램을 구성 하는 데 널리 사용 되는 방법은 [12 단계 응용 프로그램](https://12factor.net/)입니다. 개발자가 최신 클라우드 환경에 최적화 된 응용 프로그램을 만들기 위해 따라야 하는 원칙과 관행을 설명 합니다. 환경 및 선언적 자동화에서 이식성에 대 한 특별 한 주의가 제공 됩니다.

모든 웹 기반 응용 프로그램에 적용 가능 하지만 많은 전문가는 클라우드 네이티브 앱을 빌드하기 위한 견고한 기반으로 12 단계를 고려 합니다. 이러한 원칙을 바탕으로 구축 된 시스템은 신속 하 게 배포 하 고 확장할 수 있으며 시장 변화에 신속 하 게 대응할 수 있는 기능을 추가할

다음 표에서는 12 단계 방법을 중점적으로 설명 합니다.

|    |  요소 | 설명  |
| :-------- | :-------- | :-------- |
| 1 | 코드 베이스 | 자체 리포지토리에 저장 된 각 마이크로 서비스에 대 한 단일 코드 베이스입니다. 버전 제어로 추적 되 고 여러 환경 (QA, 스테이징, 프로덕션)에 배포할 수 있습니다. |
| 2 | 종속성 | 각 마이크로 서비스는 자체 종속성을 격리 하 고 패키지 하 여 전체 시스템에 영향을 주지 않고 변경 내용을 수용 합니다. |
| 3 | 구성  | 구성 정보는 코드 외부의 구성 관리 도구를 통해 마이크로 서비스 및 표면화 된 외부로 이동 됩니다. 동일한 배포가 올바른 구성이 적용 된 환경에서 전파 될 수 있습니다.  |
| 4 | 서비스 지원 | 보조 리소스 (데이터 저장소, 캐시, 메시지 브로커)는 주소 지정 가능 URL을 통해 노출 되어야 합니다. 이렇게 하면 응용 프로그램에서 리소스를 분리 하 여 상호 교환이 가능 합니다.  |
| 5 | 빌드, 릴리스, 실행 | 각 릴리스는 빌드, 릴리스 및 실행 단계에서 엄격한 분리를 적용 해야 합니다. 각에는 고유한 ID로 태그를 지정 하 고 롤백하는 기능을 지원 해야 합니다. 최신 CI/CD 시스템은이 원칙을 충족 하는 데 도움이 됩니다. |
| 6 | 프로세스 | 각 마이크로 서비스는 실행 중인 다른 서비스와 분리 된 자체 프로세스에서 실행 되어야 합니다. 분산 캐시 또는 데이터 저장소와 같은 지원 서비스에 필요한 상태를 외부화 합니다. |
| 7 | 포트 바인딩 | 각 마이크로 서비스는 자체 포트에서 노출 되는 인터페이스 및 기능과 함께 자체 포함 되어야 합니다. 이렇게 하면 다른 마이크로 서비스와의 격리가 제공 됩니다. |
| 8 | 동시성 | 서비스는 사용 가능한 가장 강력한 컴퓨터에서 단일 큰 인스턴스를 확장 하는 것과는 반대로, 많은 수의 작은 동일한 프로세스 (복사본)로 확장 됩니다. |
| 9 | Disposability | 서비스 인스턴스는 삭제 가능 해야 하며, 확장성 기회를 높이고 정상적인 종료를 찾은 다음 하 여 시스템을 올바른 상태로 유지 해야 합니다. Docker 컨테이너는 기본적으로이 요구 사항을 충족 합니다. |
| 10 | 개발/Prod 패리티 | 응용 프로그램 수명 주기 전반에 걸쳐 최대한 많은 바로 가기를 방지 하 여 환경을 최대한 유사 하 게 유지 합니다. 여기서는 컨테이너를 채택 하는 것이 동일한 실행 환경을 승격 하 여 크게 기여할 수 있습니다. |
| 11 | 로깅 | 마이크로 서비스에 의해 생성 된 로그를 이벤트 스트림으로 처리 합니다. 이벤트 집계를 사용 하 여 처리 하 고 데이터를 Azure Monitor 또는 Splunk 등의 데이터 마이닝/로그 관리 도구에 전파 하 고 결국 장기 보관 합니다. |
| 12 | 관리 프로세스 | 관리/관리 작업을 일회성 프로세스로 실행 합니다. 작업에는 보고서에 대 한 데이터 정리 및 끌어오기 분석이 포함 될 수 있습니다. 이러한 작업을 실행 하는 도구는 프로덕션 환경에서 호출 해야 하지만 응용 프로그램과는 별도로 호출 해야 합니다. |

이 책에서 [12 단계 앱 외](https://content.pivotal.io/blog/beyond-the-twelve-factor-app)의 작성자 Kevin hoffman은는 각각의 원래 12 가지 요소 (2011로 작성 됨)를 자세히 설명 합니다. 또한 오늘날의 최신 클라우드 응용 프로그램 디자인을 반영 하는 세 가지 추가 요소에 대해 설명 합니다.

|    |  새 요소 | 설명  |
| :-------- | :-------- | :-------- |
| 13 | API 우선 | 모든 것을 서비스로 설정 합니다. 프런트 엔드 클라이언트, 게이트웨이 또는 다른 서비스에서 코드를 사용 한다고 가정 합니다. |
| 14 | 원격 분석 | 워크스테이션에서는 응용 프로그램 및 해당 동작을 자세히 확인할 수 있습니다. 클라우드에서는 그렇지 않습니다. 디자인에 모니터링, 도메인별 및 상태/시스템 데이터 컬렉션이 포함 되어 있는지 확인 합니다. |
| 15 | 인증/권한 부여  | 시작에서 id를 구현 합니다. 공용 클라우드에서 사용할 수 있는 [RBAC (역할 기반 액세스 제어)](https://docs.microsoft.com/azure/role-based-access-control/overview) 기능을 고려 합니다.  |

이 장과 설명서 전체에서 12 개 이상의 요소를 모두 참조 합니다.

### <a name="critical-design-considerations"></a>중요 한 디자인 고려 사항

12 단계 방법에서 제공 하는 지침 외에도 분산 시스템을 구성할 때 몇 가지 중요 한 디자인 결정을 내려야 합니다.

*통신*

프런트 엔드 클라이언트 응용 프로그램은 백업 된 핵심 서비스와 통신 하는 방법 직접 통신을 허용 하 시겠습니까? 또는 유연성, 제어 및 보안을 제공 하는 게이트웨이 외관을 사용 하 여 백 엔드 서비스를 추상화할 수 있습니다.

백 엔드 핵심 서비스는 서로 통신 하는 방법 결합 및 성능에 영향을 주는 직접 HTTP 호출을 허용 하나요? 또는 큐 및 토픽 기술로 분리 된 메시징을 고려할 수 있습니다.

통신에 대 한 자세한 내용은 4 장 *클라우드 네이티브 통신 패턴*을 참조 하세요.

*복원력*

마이크로 서비스 아키텍처는 시스템을 in-process에서 out-of-process 네트워크 통신으로 이동 합니다. 분산 아키텍처에서 서비스 B가 서비스 A의 네트워크 호출에 응답 하지 않으면 어떻게 되나요? 또는 서비스 C를 일시적으로 사용할 수 없게 되 고이 서비스를 호출 하는 다른 서비스가 차단 되 면 어떻게 되나요?

복원 력은 6 장, *클라우드 기본 복원 력*에 자세히 설명 되어 있습니다.

*분산 데이터*

기본적으로 각 마이크로 서비스는 자체 데이터를 캡슐화 하 여 공용 인터페이스를 통해 작업을 노출 합니다. 그렇다면 여러 서비스에서 데이터를 쿼리하거나 트랜잭션을 구현 하는 방법은 무엇입니까?

분산 데이터에 대 한 자세한 내용은 5 장, *클라우드 네이티브 데이터 패턴*을 참조 하세요.

*ID*

서비스에서 액세스 하는 사용자 및 사용 권한을 식별 하는 방법은 무엇 인가요?

Id는 세부 정보 Chapter 8, *id*에 설명 되어 있습니다.

## <a name="microservices"></a>마이크로 서비스

클라우드 네이티브 시스템은 최신 응용 프로그램을 구성 하는 데 널리 사용 되는 아키텍처 스타일 인 마이크로 서비스를 수용 합니다.

공유 패브릭을 통해 상호 작용 하는 소규모 독립 서비스의 분산 된 집합으로 구축 된 마이크로 서비스는 다음과 같은 특징을 공유 합니다.

- 각는 더 큰 도메인 컨텍스트 내에서 특정 비즈니스 기능을 구현 합니다.

- 각은 자율적으로 개발 되며 독립적으로 배포할 수 있습니다.

- 각은 자체 데이터 저장소 기술 (SQL, NoSQL) 및 프로그래밍 플랫폼을 캡슐화 하는 자체 포함 됩니다.

- 각는 자체 프로세스에서 실행 되 고 HTTP/HTTPS, Websocket 또는 [Amqp](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol)와 같은 표준 통신 프로토콜을 사용 하 여 다른 사용자와 통신 합니다.

- 응용 프로그램을 구성 하기 위해 함께 구성 됩니다.

그림 1-4은 마이크로 서비스 접근 방식과 모놀리식 응용 프로그램 접근 방식을 대조 합니다. 단일 프로세스에서 실행 되는 계층화 된 아키텍처로 모놀리식를 구성 하는 방법을 확인 합니다. 일반적으로 관계형 데이터베이스를 사용 합니다. 그러나 마이크로 서비스 접근 방식은 논리와 데이터를 포함 하는 독립적인 서비스로 기능을 분리 합니다. 각 마이크로 서비스는 자체 데이터 저장소를 호스팅합니다.

![모놀리식 배포 및 마이크로 서비스](./media/monolithic-vs-microservices.png)

**그림 1-4.** 모놀리식 배포 및 마이크로 서비스

마이크로 서비스는 [12 단계 응용 프로그램](https://12factor.net/)에서 "한 코드 베이스, 한 응용 프로그램" 원칙을 승격 하는 방법에 대해 설명 합니다.

> *요소 \# 1은 자체 리포지토리에 저장 된 각 마이크로 서비스에 대해 단일 코드 베이스를 지정 합니다. 버전 제어로 추적 되 고 여러 환경에 배포할 수 있습니다. "*

### <a name="why-microservices"></a>마이크로 서비스를 사용하는 이유는 무엇인가요?

마이크로 서비스는 민첩성을 제공 합니다.

이 장에서는 마이크로 서비스를 사용 하 여 모놀리식로 빌드된 전자 상거래 응용 프로그램을 비교 했습니다. 이 예제에서는 다음과 같은 몇 가지 분명 한 이점이 있습니다.

- 각 마이크로 서비스는 자치 수명 주기를 가지 며 독립적으로 발전 하 고 자주 배포할 수 있습니다. 분기별 릴리스가 새 기능이 나 업데이트를 배포할 때까지 기다릴 필요가 없습니다. 전체 시스템을 방해 하는 위험을 줄일 수 있는 복잡 한 응용 프로그램의 작은 영역을 업데이트할 수 있습니다.

- 각 마이크로 서비스은 독립적으로 확장 될 수 있습니다. 전체 응용 프로그램을 단일 단위로 확장 하는 대신 더 많은 처리 능력 또는 네트워크 대역폭이 필요한 서비스만 확장할 수 있습니다. 크기 조정에 대 한이 세분화 된 접근 방식을 사용 하면 시스템을 보다 효과적으로 제어할 수 있으며, 모든 것이 아니라 시스템의 일부를 확장할 때 전체 비용을 줄일 수 있습니다.

마이크로 서비스를 이해 하기 위한 뛰어난 참조 가이드는 [.Net 마이크로 서비스: 컨테이너 화 된 .Net 응용 프로그램용 아키텍처](https://dotnet.microsoft.com/download/thank-you/microservices-architecture-ebook)입니다. 책은 마이크로 서비스 디자인 및 아키텍처로 다이브. Microsoft에서 제공 하는 무료 다운로드로 제공 되는 [전체 스택 마이크로 서비스 참조 아키텍처](https://github.com/dotnet-architecture/eShopOnContainers) 에 대 한 부록입니다.

### <a name="developing-microservices"></a>마이크로 서비스 개발

마이크로 서비스는 모든 최신 개발 플랫폼을 사용 하 여 만들 수 있습니다.

Microsoft .NET Core 플랫폼을 선택 하는 것이 좋습니다. 무료 오픈 소스는 마이크로 서비스 개발을 간소화 하는 여러 가지 기본 제공 기능을 제공 합니다. .NET Core는 플랫폼 간입니다. Windows, macOS 및 대부분의 Linux에서 응용 프로그램을 빌드하고 실행할 수 있습니다.

.NET Core는 성능이 뛰어나고 node.js 및 기타 경쟁 플랫폼과 비교 하 여 잘 점수가 매겨집니다. 흥미롭게도 [TechEmpower](https://www.techempower.com/) 는 여러 웹 응용 프로그램 플랫폼 및 프레임 워크에서 광범위 한 [성능 벤치 마크](https://www.techempower.com/benchmarks/#section=data-r17&hw=ph&test=plaintext) 를 수행 했습니다. .NET Core는 상위 10 개 이상의 node.js 및 기타 경쟁 플랫폼에서 점수가 매겨집니다.

.NET Core는 Microsoft 및 GitHub의 .NET 커뮤니티에서 유지 관리 됩니다.

## <a name="containers"></a>컨테이너

오늘날 *cloud native*와 관련 된 모든 대화에서 언급 된 용어 *컨테이너* 를 듣게 됩니다. 책의 [클라우드 네이티브 패턴](https://www.manning.com/books/cloud-native-patterns)에서 Davis는 "컨테이너는 클라우드 네이티브 소프트웨어를 잘 실현할 수 있습니다." 라는 것을 관찰 합니다. 클라우드 네이티브 컴퓨팅 파운데이션은 마이크로 서비스 컨테이너 화를 [클라우드 기본 구조](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png) 에 첫 번째 단계로 제공 합니다. 즉, 클라우드 기본 전환을 시작 하는 기업에 대 한 지침을 제공 합니다.

컨테이너 화 a 마이크로 서비스는 간단 하 고 간단 합니다. 코드, 해당 종속성 및 런타임은 [컨테이너 이미지](https://docs.docker.com/glossary/?term=image)라는 이진으로 패키지 됩니다. 이미지는 이미지에 대 한 리포지토리 또는 라이브러리 역할을 하는 [컨테이너 레지스트리에](https://caylent.com/container-registries/)저장 됩니다. 레지스트리는 개발 컴퓨터, 데이터 센터 또는 공용 클라우드에서 찾을 수 있습니다. Docker 자체는 [Docker 허브](https://hub.docker.com/)를 통해 공용 레지스트리를 유지 관리 합니다. Azure cloud는 컨테이너를 실행 하는 클라우드 응용 프로그램에 가까운 컨테이너 이미지를 저장 하는 [컨테이너 레지스트리](https://azure.microsoft.com/services/container-registry/) 기능을 제공 합니다.

필요한 경우 이미지를 실행 중인 컨테이너 인스턴스로 변환 합니다. 인스턴스는 [컨테이너 런타임](https://kubernetes.io/docs/setup/production-environment/container-runtimes/) 엔진이 설치 된 모든 컴퓨터에서 실행 됩니다. 필요에 따라 컨테이너 화 된 서비스의 인스턴스를 여러 개 포함할 수 있습니다.

그림 1-5은 단일 호스트에서 실행 되는 각각의 고유한 컨테이너에 있는 세 가지 마이크로 서비스를 보여 줍니다.

![컨테이너 호스트에서 실행되는 여러 컨테이너](./media/hosting-mulitple-containers.png)

**그림 1-5**. 컨테이너 호스트에서 실행되는 여러 컨테이너

각 컨테이너가 서로 다를 수 있는 고유한 종속성 및 런타임 집합을 유지 관리 하는 방법을 확인 합니다. 여기에는 동일한 호스트에서 실행 되는 여러 버전의 제품 마이크로 서비스이 표시 됩니다. 각 컨테이너는 기본 호스트 운영 체제, 메모리 및 프로세서의 조각을 공유 하지만 서로 격리 되어 있습니다.

컨테이너 모델이 [12 단계 응용 프로그램](https://12factor.net/)에서 "종속성" 원칙을 수용 하는 정도를 확인 합니다.

> *요소 \# 2는 "각 마이크로 서비스 자체 종속성을 격리 하 고 패키지 하 여 전체 시스템에 영향을 주지 않고 변경 내용을 수용 하도록 지정 합니다."*

컨테이너는 Linux 및 Windows 작업을 모두 지원 합니다. Azure 클라우드는 모두 개방적으로 수용 합니다. 흥미롭게도 Azure에서 가장 인기 있는 운영 체제가 되기 때문에 Windows Server가 아닌 Linux입니다.

여러 컨테이너 공급 업체가 존재 하는 반면 Docker는 사자의 시장 공유를 캡처 했습니다. 회사에서 소프트웨어 컨테이너 이동을 구동 했습니다. 클라우드 네이티브 응용 프로그램을 패키지, 배포 및 실행 하기 위한 사실상 표준이 되었습니다.

### <a name="why-containers"></a>컨테이너는 무엇 인가요?

컨테이너는 이식성을 제공 하 고 환경 간에 일관성을 보장 합니다. 모든 항목을 단일 패키지로 캡슐화 하 여 기본 인프라에서 마이크로 서비스 및 해당 종속성을 *격리* 합니다.

Docker 런타임 엔진을 포함 하는 모든 환경에서 동일한 컨테이너를 배포할 수 있습니다. 또한 컨테이너 화 된 워크 로드는 프레임 워크, 소프트웨어 라이브러리 및 런타임 엔진을 사용 하 여 각 환경에 대 한 사전 구성 비용을 제거 합니다.

기본 운영 체제 및 호스트 리소스를 공유 하 여 컨테이너는 전체 가상 컴퓨터 보다 훨씬 적은 공간을 차지 합니다. 크기가 작을수록 지정 된 호스트를 한 번에 실행할 수 있는 마이크로 서비스 수 또는 *밀도가*높아집니다.

### <a name="container-orchestration"></a>컨테이너 오케스트레이션

Docker와 같은 도구는 이미지를 만들고 컨테이너를 실행 하는 동안 관리 하는 도구도 필요 합니다. 컨테이너 관리는 컨테이너 orchestrator 라는 특수 소프트웨어 프로그램을 사용 하 여 수행 됩니다. 규모에 맞게 작동 하는 경우 컨테이너 오케스트레이션이 필수적입니다.

그림 1-6에서는 컨테이너 orchestrator 제공 하는 관리 작업을 보여 줍니다.

![컨테이너 orchestrator](./media/what-container-orchestrators-do.png)

**그림 1-6**. 컨테이너 orchestrator

다음 표에서는 일반적인 오케스트레이션 작업을 설명 합니다.

|  작업 | 설명  |
| :-------- | :-------- |
| 일정 계획 | 컨테이너 인스턴스를 자동으로 프로 비전 합니다.|
| 선호도/선호도 방지 | 컨테이너를 서로 가까운 곳 이나 멀리 프로 비전 하 여 가용성과 성능을 지원 합니다. |
| 상태 모니터링 | 자동으로 오류를 검색 하 고 수정 합니다.|
| 장애 조치 | 실패 한 인스턴스를 정상 컴퓨터에 자동으로 다시 구축.|
| 확장 | 필요에 맞게 컨테이너 인스턴스를 자동으로 추가 또는 제거 합니다.|
| 네트워킹 | 컨테이너 통신을 위한 네트워킹 오버레이를 관리 합니다.|
| 서비스 검색 | 컨테이너를 사용 하 여 서로를 찾습니다.|
| 롤링 업그레이드 | 가동 중지 시간이 0 인 증분 업그레이드를 조정 합니다. 문제가 있는 변경 내용을 자동으로 롤백합니다.|

Orchestrator는이 장의 앞부분에서 설명한 [12 단계 응용 프로그램](https://12factor.net/)에서 disposability 및 동시성 원리를 수용 하는 방법에 유의 하세요.

> *요소 \# 9는 "서비스 인스턴스를 삭제 가능 하도록 지정 하 여 확장성 기회를 높이고 정상적인 종료를 찾은 다음 하 여 시스템을 올바른 상태로 유지 하도록 지정 합니다. Docker 컨테이너는 기본적으로이 요구 사항을 충족 합니다. "*

> *요소 \# 8은 "서비스가 사용 가능한 가장 강력한 컴퓨터에서 단일 큰 인스턴스를 확장 하는 것과는 달리, 많은 수의 작은 동일한 프로세스 (복사본)에 걸쳐 규모를 확장 하도록 지정 합니다."*

여러 컨테이너 orchestrator 있는 동안 [Kubernetes](https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/) 는 클라우드 네이티브 세계에 대 한 사실상의 표준이 되었습니다. 컨테이너 화 된 워크 로드를 관리 하기 위한 이식 가능 하 고 확장 가능한 오픈 소스 플랫폼입니다.

Kubernetes의 고유한 인스턴스를 호스트할 수 있지만이를 위해 리소스를 프로 비전 하 고 관리 해야 합니다 .이는 복잡할 수 있습니다. Azure cloud Kubernetes는 관리 서비스인 [AKS (Azure Kubernetes service)](https://azure.microsoft.com/services/kubernetes-service/)로 제공 됩니다. 관리 서비스를 사용 하면 해당 기능을 설치 및 유지 관리 하지 않고도 해당 기능을 완벽 하 게 활용할 수 있습니다.

Azure Kubernetes 서비스는 *클라우드 네이티브 응용 프로그램 크기 조정*2 장에서 설명 합니다.

## <a name="backing-services"></a>서비스 지원

클라우드 네이티브 시스템은 데이터 저장소, 메시지 브로커, 모니터링 및 id 서비스와 같은 다양 한 보조 리소스에 따라 달라 집니다. 이러한 서비스를 [지원 서비스](https://12factor.net/backing-services)라고 합니다.

 그림 1-7은 클라우드 네이티브 시스템에서 사용 하는 여러 일반적인 지원 서비스를 보여 줍니다.

![일반적인 지원 서비스](./media/common-backing-services.png)

**그림 1-7**. 일반적인 지원 서비스

지원 서비스는 [12 단계 응용 프로그램](https://12factor.net/)에서 "상태 비저장" 원칙을 승격 합니다 .이에 대해서는이 장의 앞부분에서 설명 했습니다.

>*요소 \# 6* 은 "각 마이크로 서비스가 실행 중인 다른 서비스와 격리 된 자체 프로세스에서 실행 되도록 지정 합니다. 분산 캐시 또는 데이터 저장소와 같은 지원 서비스에 필요한 상태를 외부화. "

자신의 지원 서비스를 호스트할 수 있지만 이러한 리소스를 라이선싱, 프로 비전 및 관리할 책임이 있습니다.

클라우드 공급자는 다양 한 *관리 지원 서비스를 제공 합니다.* 서비스를 소유 하는 대신 서비스를 사용 하기만 하면 됩니다. 공급자는 리소스를 대규모로 작동 하 고 성능, 보안 및 유지 관리에 대 한 책임을 집니다. 모니터링, 중복성 및 가용성은 서비스에 기본 제공 됩니다. 공급자는 관리 되는 서비스를 완전히 지원 합니다. 티켓을 열고 문제를 해결 합니다.

클라우드 기본 시스템은 클라우드 공급 업체의 관리 되는 백업 서비스를 선호 합니다. 시간과 노력이 절약 됩니다. 사용자가 직접 호스트 하 고 문제를 발생 시킬 위험이 있습니다.

가장 좋은 방법은 지원 서비스를 *연결 된 리소스로*처리 하는 것입니다 .이는 외부 구성에 저장 된 정보 (URL 및 자격 증명)를 사용 하 여 마이크로 서비스에 동적으로 바인딩됩니다. 이 지침은이 장에서 설명 하는 [12 단계 응용 프로그램](https://12factor.net/)에서 설명 합니다.

>*요소 \# 4* 는 주소 지정 가능 URL을 통해 지원 서비스를 노출 하도록 지정 합니다. 이렇게 하면 응용 프로그램에서 리소스를 분리 하 여 상호 교환이 가능 합니다. "

>*요소 \# 3* 은 "구성 정보를 코드 외부의 구성 관리 도구를 통해 마이크로 서비스 및 표면화 된 외부로 이동" 하도록 지정 합니다.

이 패턴을 사용 하면 코드를 변경 하지 않고 지원 서비스를 연결 및 분리할 수 있습니다. 마이크로 서비스를 QA에서 스테이징 환경으로 승격할 수 있습니다. 준비의 지원 서비스를 가리키도록 마이크로 서비스 구성을 업데이트 하 고 환경 변수를 통해 컨테이너에 설정을 삽입 합니다.

클라우드 공급 업체는 자체 지원 서비스와 통신할 수 있는 Api를 제공 합니다. 이러한 라이브러리는 배관 및 복잡성을 캡슐화 합니다. 이러한 Api와 직접 통신 하는 것은 코드를 백업 서비스에 긴밀 하 게 두는 것입니다. 공급 업체 API의 구현 세부 정보를 안전 하 게 유지 하는 것이 더 좋습니다. Intermediation 계층 또는 중간 API를 도입 하 여 서비스 코드에 일반 작업을 노출 합니다. 이러한 느슨한 결합을 통해 한 지원 서비스를 다른 서비스 코드를 변경 하지 않고도 다른 공용 클라우드로 전환할 수 있습니다.

지원 서비스에 대 한 자세한 내용은 5 장, *클라우드 네이티브 데이터 패턴*및 4 장, *클라우드 네이티브 통신 패턴*을 참조 하세요.

## <a name="automation"></a>Automation

앞서 살펴본 것 처럼 클라우드 네이티브 시스템은 마이크로 서비스, 컨테이너 및 최신 시스템 디자인을 수용 하 여 속도와 민첩성을 구현 합니다. 그러나이는 스토리의 일부일 뿐입니다. 이러한 시스템이 실행 되는 클라우드 환경을 프로 비전 하려면 어떻게 해야 하나요? 앱 기능 및 업데이트를 신속 하 게 배포 하려면 어떻게 해야 하나요? 전체 사진을 어떻게 반올림 하나요?

널리 승인 된 인프라 사례를 [코드](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code)또는 IaC로 입력 합니다.

IaC를 사용 하 여 플랫폼 프로 비전 및 응용 프로그램 배포를 자동화 합니다. 기본적으로 DevOps 사례에 테스트 및 버전 관리와 같은 소프트웨어 엔지니어링 사례를 적용 합니다. 인프라 및 배포는 자동화 되 고 일관 되며 반복 가능 합니다.

### <a name="automating-infrastructure"></a>인프라 자동화

[Azure Resource Manager](https://azure.microsoft.com/documentation/articles/resource-group-overview/), terraform 및 [Azure CLI](https://docs.microsoft.com/cli/azure/)와 같은 도구를 사용 하 여 필요한 클라우드 인프라를 선언적으로 스크립팅할 수 있습니다. 리소스 이름, 위치, 용량 및 암호는 매개 변수화 된 및 동적입니다. 이 스크립트는 프로젝트의 아티팩트로 버전이 지정 되 고 소스 제어에 체크 인 됩니다. 스크립트를 호출 하 여 QA, 스테이징 및 프로덕션과 같은 시스템 환경에서 일관 되 고 반복 가능한 인프라를 프로 비전 합니다.

내부적으로, IaC는 idempotent 이며,이는 부작용 없이 동일한 스크립트를 반복 해 서 실행할 수 있음을 의미 합니다. 팀에서 변경 해야 하는 경우 스크립트를 편집 하 고 다시 실행 합니다. 업데이트 된 리소스만 영향을 받습니다.

문서에서 [코드로 서의 인프라 란 무엇](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code)이며, 제작자 Sam Guckenheimer는 "IaC를 구현 하는 팀이 안정적인 환경을 신속 하 고 대규모로 제공할 수 있는 방법에 대해 설명 합니다. 팀은 환경을 수동으로 구성 하는 것을 방지 하 고 코드를 통해 환경의 원하는 상태를 표시 하 여 일관성을 적용 합니다. IaC를 사용 하 여 인프라를 배포 하는 것은 반복 가능 하며, 구성 드리프트 또는 누락 종속성으로 인 한 런타임 문제를 방지 DevOps 팀은 통합 된 사례 및 도구 집합과 함께 작업 하 여 응용 프로그램 및 지원 인프라를 신속 하 고 안정적 이며 대규모로 제공할 수 있습니다. "

### <a name="automating-deployments"></a>배포 자동화

앞에서 설명한 [12 단계 응용 프로그램](https://12factor.net/)은 완성 된 코드를 실행 중인 응용 프로그램으로 변환할 때 별도의 단계를 호출 합니다.

> *요소 \# 5* 는 "각 릴리스가 빌드, 릴리스 및 실행 단계에서 엄격한 분리를 적용 해야 함을 지정 합니다. 각각은 고유한 ID로 태그를 지정 하 고 롤백하는 기능을 지원 해야 합니다. "

최신 CI/CD 시스템은이 원칙을 충족 하는 데 도움이 됩니다. 별도의 배포 단계를 제공 하 고 사용자가 쉽게 사용할 수 있는 일관 되 고 품질 코드를 보장 하는 데 도움이 됩니다.

그림 1-8에서는 배포 프로세스를 분리 하는 방법을 보여 줍니다.

![CI/CD 파이프라인의 배포 단계](./media/build-release-run-pipeline.png)

**그림 1-8**. CI/CD 파이프라인의 배포 단계

위의 그림에서는 작업 분리에 특히 주의를 기울여야 합니다.

개발자는 개발 환경에서 기능을 생성 하 여 코드의 "내부 루프", 실행 및 디버그를 반복 합니다. 완료 되 면 코드는 GitHub, Azure DevOps 또는 BitBucket와 같은 코드 리포지토리로 *푸시됩니다* .

푸시는 코드를 이진 아티팩트로 변환 하는 빌드 단계를 트리거합니다. 작업은 [CI (지속적인 통합](https://martinfowler.com/articles/continuousIntegration.html) ) 파이프라인을 사용 하 여 구현 됩니다. 응용 프로그램을 자동으로 빌드, 테스트 및 패키지 합니다.

릴리스 단계는 이진 아티팩트를 선택 하 고, 외부 응용 프로그램 및 환경 구성 정보를 적용 하 고, 변경할 수 없는 릴리스를 생성 합니다. 릴리스가 지정 된 환경에 배포 됩니다. 작업은 CD (지속적인 업데이트 [)](https://martinfowler.com/bliki/ContinuousDelivery.html) 파이프라인을 사용 하 여 구현 됩니다. 각 릴리스를 식별할 수 있어야 합니다. "이 배포가 응용 프로그램의 릴리스 2.1.1을 실행 하 고 있습니다." 라고 표시 될 수 있습니다.

마지막으로, 릴리스된 기능은 대상 실행 환경에서 실행 됩니다. 릴리스를 변경할 수 없습니다. 즉, 모든 변경 내용은 새 릴리스를 만들어야 합니다.

이러한 사례를 적용 하면 조직에서 소프트웨어를 제공 하는 방법을 크게 진화 하 고 있습니다. 대다수는 분기별 릴리스에서 주문형 업데이트로 이동 했습니다. 목표는 수정 비용이 저렴 한 개발 주기의 초기에 문제를 파악 하는 것입니다. 통합 간의 지속 시간이 길수록 더 비싼 문제가 해결 됩니다.  통합 프로세스에서 일관성을 사용 하면 팀에서 코드 변경 내용을 더 자주 커밋할 수 있으므로 공동 작업 및 소프트웨어 품질을 높일 수 있습니다.

### <a name="azure-pipelines"></a>Azure Pipelines

Azure 클라우드에는 그림 1-9에 표시 된 [Azure DevOps](https://azure.microsoft.com/services/devops/) 제품의 일부인 [AZURE PIPELINES](https://azure.microsoft.com/services/devops/pipelines/)이라는 새로운 CI/CD 서비스가 포함 되어 있습니다.

![DevOps의 Azure Pipelines](./media/devops-components.png)

**그림 1-9**. Azure DevOps 제품

Azure Pipelines는 CI (지속적인 통합) 및 CD (지속적인 업데이트)를 결합 하는 클라우드 서비스입니다. 코드를 자동으로 테스트, 빌드 및 모든 대상에 제공할 수 있습니다.

앱에 대 한 코드의 나머지 부분과 함께 YAML 파일의 코드에서 파이프라인을 정의 합니다.

- 파이프라인은 코드를 사용 하 여 버전이 지정 되며 동일한 분기 구조를 따릅니다.
- 끌어오기 요청 및 분기 빌드 정책에서 코드 검토를 통해 변경 내용에 대 한 유효성을 검사 합니다.
- 사용 하는 모든 분기는 azure-pipelines 파일을 수정 하 여 빌드 정책을 사용자 지정할 수 있습니다.
- 파이프라인 파일이 버전 제어에 체크 인 되 고 문제가 있는 경우 조사할 수 있습니다.

Azure Pipelines 서비스는 대부분의 Git 공급자를 지원 하 고 Linux, macOS 또는 Windows 플랫폼에서 작성 된 응용 프로그램에 대 한 배포 파이프라인을 생성할 수 있습니다. 여기에는 Java, .NET, JavaScript, Python, PHP, Go, XCode 및 c + +에 대 한 지원이 포함 됩니다.

>[!div class="step-by-step"]
>[이전](introduction.md)
>[다음](candidate-apps.md)
