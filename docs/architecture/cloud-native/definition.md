---
title: 클라우드 네이티브 정의
description: 클라우드 기본 시스템용 bedrock을 제공 하는 기본 핵심 요소에 대해 알아봅니다.
author: robvet
ms.date: 08/20/2019
ms.openlocfilehash: 33977ff736fc5cbfcf86ed6479e8d0b927b87a63
ms.sourcegitcommit: 957c49696eaf048c284ef8f9f8ffeb562357ad95
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/07/2020
ms.locfileid: "82895612"
---
# <a name="defining-cloud-native"></a><span data-ttu-id="8c236-103">클라우드 네이티브 정의</span><span class="sxs-lookup"><span data-stu-id="8c236-103">Defining cloud native</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="8c236-104">수행 하 고 있는 작업 및 동료의 10 자를 중지 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-104">Stop what you're doing and text ten of your colleagues.</span></span> <span data-ttu-id="8c236-105">"클라우드 네이티브" 라는 용어를 정의 하도록 요청 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-105">Ask them to define the term "Cloud Native".</span></span> <span data-ttu-id="8c236-106">8 가지 다른 답을 얻을 수 있는 좋은 기회입니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-106">Good chance you'll get eight different answers.</span></span>

<span data-ttu-id="8c236-107">클라우드 기본은 중요 한 비즈니스 시스템을 구성 하는 방법에 대 한 고려 방식을 변경 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-107">Cloud native is all about changing the way we think about constructing critical business systems.</span></span>

<span data-ttu-id="8c236-108">클라우드 네이티브 시스템은 신속한 변화, 대규모 및 복원 력을 수용 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-108">Cloud-native systems are designed to embrace rapid change, large scale, and resilience.</span></span>

<span data-ttu-id="8c236-109">Cloud Native 컴퓨팅 Foundation은 [공식 정의](https://github.com/cncf/foundation/blob/master/charter.md)를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-109">The Cloud Native Computing Foundation provides an [official definition](https://github.com/cncf/foundation/blob/master/charter.md):</span></span>

> <span data-ttu-id="8c236-110">*클라우드 기본 기술을 통해 조직은 공용, 사설 및 하이브리드 클라우드와 같은 최신의 동적 환경에서 확장 가능한 응용 프로그램을 빌드 및 실행할 수 있습니다. 컨테이너, 서비스 메시, 마이크로 서비스, 변경할 수 없는 인프라 및 선언적 Api는이 접근 방식을 exemplify 합니다.*</span><span class="sxs-lookup"><span data-stu-id="8c236-110">*Cloud-native technologies empower organizations to build and run scalable applications in modern, dynamic environments such as public, private, and hybrid clouds. Containers, service meshes, microservices, immutable infrastructure, and declarative APIs exemplify this approach.*</span></span>

> <span data-ttu-id="8c236-111">*이러한 기술을 통해 탄력적이 고 관리 하기 쉽고 관찰 가능한 느슨하게 결합 된 시스템을 사용할 수 있습니다. 강력한 자동화와 결합 되어 엔지니어가 toil을 최소화 하면서 높은 영향을 미치는 변화를 자주 내릴 수 있습니다.*</span><span class="sxs-lookup"><span data-stu-id="8c236-111">*These techniques enable loosely coupled systems that are resilient, manageable, and observable. Combined with robust automation, they allow engineers to make high-impact changes frequently and predictably with minimal toil.*</span></span>

<span data-ttu-id="8c236-112">응용 프로그램은 더 많은 사용자가 요구 하는 점점 점점 더 복잡 해지고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-112">Applications have become increasingly complex with users demanding more and more.</span></span> <span data-ttu-id="8c236-113">사용자는 신속한 응답성, 혁신적인 기능 및 가동 중지 시간을 예측할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-113">Users expect rapid responsiveness, innovative features, and zero downtime.</span></span> <span data-ttu-id="8c236-114">성능 문제, 반복 되는 오류 및 빠르게 이동할 수 없는 것은 더 이상 허용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-114">Performance problems, recurring errors, and the inability to move fast are no longer acceptable.</span></span> <span data-ttu-id="8c236-115">경쟁 업체에 쉽게 이동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-115">They'll easily move to your competitor.</span></span>

<span data-ttu-id="8c236-116">Cloud native는 *속도* 와 *민첩성*에 대 한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-116">Cloud native is much about *speed* and *agility*.</span></span> <span data-ttu-id="8c236-117">비즈니스 시스템은 비즈니스 기능을 사용 하 여 전략적 변환의 무기로 비즈니스 속도와 성장을 가속화 하는 것부터 발전 하 고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-117">Business systems are evolving from enabling business capabilities to weapons of strategic transformation, accelerating business velocity and growth.</span></span> <span data-ttu-id="8c236-118">시장에 즉시 아이디어를 얻는 것이 필수적입니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-118">It's imperative to get ideas to market immediately.</span></span>

<span data-ttu-id="8c236-119">이러한 기술을 구현한 회사는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-119">Here are some companies who have implemented these techniques.</span></span> <span data-ttu-id="8c236-120">달성 한 속도, 민첩성 및 확장성을 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-120">Think about the speed, agility, and scalability they've achieved.</span></span>

| <span data-ttu-id="8c236-121">회사</span><span class="sxs-lookup"><span data-stu-id="8c236-121">Company</span></span> | <span data-ttu-id="8c236-122">환경</span><span class="sxs-lookup"><span data-stu-id="8c236-122">Experience</span></span> |
| :-------- | :-------- |
| [<span data-ttu-id="8c236-123">Netflix</span><span class="sxs-lookup"><span data-stu-id="8c236-123">Netflix</span></span>](https://www.infoq.com/news/2013/06/netflix/) | <span data-ttu-id="8c236-124">에는 프로덕션에서 600 개 이상의 서비스가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-124">Has 600+ services in production.</span></span> <span data-ttu-id="8c236-125">하루에 100 회 배포 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-125">Deploys hundred times per day.</span></span> |
| [<span data-ttu-id="8c236-126">Uber</span><span class="sxs-lookup"><span data-stu-id="8c236-126">Uber</span></span>](https://eng.uber.com/micro-deploy/) | <span data-ttu-id="8c236-127">에는 프로덕션 환경에서 1000 개 이상의 서비스가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-127">Has 1,000+ services in production.</span></span> <span data-ttu-id="8c236-128">매주 몇 천 번 배포 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-128">Deploys several thousand times each week.</span></span> |
| [<span data-ttu-id="8c236-129">WeChat</span><span class="sxs-lookup"><span data-stu-id="8c236-129">WeChat</span></span>](https://www.cs.columbia.edu/~ruigu/papers/socc18-final100.pdf) | <span data-ttu-id="8c236-130">에는 프로덕션 환경에서 300 개 이상의 서비스가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-130">Has 300+ services in production.</span></span> <span data-ttu-id="8c236-131">하루에 1000 번 배포 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-131">Deploys 1,000 times a day.</span></span> |

<span data-ttu-id="8c236-132">여기에서 볼 수 있듯이 Netflix, Uber 및 WeChat는 수많은 독립 마이크로 서비스로 구성 된 시스템을 노출 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-132">As you can see, Netflix, Uber, and WeChat expose systems that consist of hundreds of independent microservices.</span></span> <span data-ttu-id="8c236-133">이 아키텍처 스타일을 통해 시장 상황에 신속 하 게 대응할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-133">This architectural style enables them to rapidly respond to market conditions.</span></span> <span data-ttu-id="8c236-134">이러한 사용자는 라이브, 복잡 한 응용 프로그램의 작은 영역을 즉시 업데이트 하 고 필요에 따라 이러한 영역을 개별적으로 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-134">They can instantaneously update small areas of a live, complex application, and individually scale those areas as needed.</span></span>

<span data-ttu-id="8c236-135">Cloud native의 속도 및 민첩성은 다양 한 요소에서 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-135">The speed and agility of cloud native come about from a number of factors.</span></span> <span data-ttu-id="8c236-136">가장는 클라우드 인프라입니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-136">Foremost is cloud infrastructure.</span></span> <span data-ttu-id="8c236-137">그림 1-3에 표시 된 5 가지 추가 기본 핵심 요소 클라우드 기본 시스템에 대 한 bedrock을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-137">Five additional foundational pillars shown in Figure 1-3 also provide the bedrock for cloud-native systems.</span></span>

![클라우드 네이티브 기본 핵심 요소](./media/cloud-native-foundational-pillars.png)

<span data-ttu-id="8c236-139">**그림 1-3**.</span><span class="sxs-lookup"><span data-stu-id="8c236-139">**Figure 1-3**.</span></span> <span data-ttu-id="8c236-140">클라우드 네이티브 기본 핵심 요소</span><span class="sxs-lookup"><span data-stu-id="8c236-140">Cloud-native foundational pillars</span></span>

<span data-ttu-id="8c236-141">각 기둥의 중요도를 보다 잘 이해 하는 데 약간의 시간이 걸릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-141">Let's take some time to better understand the significance of each pillar.</span></span>

## <a name="the-cloud"></a><span data-ttu-id="8c236-142">클라우드 ...</span><span class="sxs-lookup"><span data-stu-id="8c236-142">The cloud…</span></span>

<span data-ttu-id="8c236-143">클라우드 기본 시스템은 클라우드 서비스 모델을 최대한 활용 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-143">Cloud-native systems take full advantage of the cloud service model.</span></span>

<span data-ttu-id="8c236-144">가상화 된 동적 클라우드 환경에서 올립니다 설계 된 이러한 시스템은 [PaaS (Platform as a Service)](https://azure.microsoft.com/overview/what-is-paas/) 계산 인프라와 관리 되는 서비스를 광범위 하 게 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-144">Designed to thrive in a dynamic, virtualized cloud environment, these systems make extensive use of [Platform as a Service (PaaS)](https://azure.microsoft.com/overview/what-is-paas/) compute infrastructure and managed services.</span></span> <span data-ttu-id="8c236-145">기본 인프라를 몇 분 내에 *삭제* 가능 프로 비전 된 것으로 처리 하 고 자동화를 통해 필요에 따라 크기 조정, 크기 조정, 이동 또는 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-145">They treat the underlying infrastructure as *disposable* - provisioned in minutes and resized, scaled, moved, or destroyed on demand – via automation.</span></span>

<span data-ttu-id="8c236-146">[애완 동물 vs. 결국](https://medium.com/@Joachim8675309/devops-concepts-pets-vs-cattle-2380b5aab313)에서 널리 승인 된 devops 개념을 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-146">Consider the widely accepted DevOps concept of [Pets vs. Cattle](https://medium.com/@Joachim8675309/devops-concepts-pets-vs-cattle-2380b5aab313).</span></span> <span data-ttu-id="8c236-147">기존 데이터 센터에서 서버는 *애완 동물*으로 처리 됩니다. 물리적 컴퓨터는 의미 있는 이름을 지정 하 고는 확인 개체만입니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-147">In a traditional data center, servers are treated as *Pets*: a physical machine, given a meaningful name, and cared for.</span></span> <span data-ttu-id="8c236-148">동일한 컴퓨터에 리소스를 더 추가 하 여 크기를 조정 합니다 (확장).</span><span class="sxs-lookup"><span data-stu-id="8c236-148">You scale by adding more resources to the same machine (scaling up).</span></span> <span data-ttu-id="8c236-149">서버를 병가로 전환 하면 간호사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-149">If the server becomes sick, you nurse it back to health.</span></span> <span data-ttu-id="8c236-150">서버를 사용할 수 없게 되 면 모든 사용자가 알림을 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-150">Should the server become unavailable, everyone notices.</span></span>

<span data-ttu-id="8c236-151">*결국* 서비스 모델이 서로 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-151">The *Cattle* service model is different.</span></span> <span data-ttu-id="8c236-152">각 인스턴스를 가상 컴퓨터 또는 컨테이너로 프로 비전 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-152">You provision each instance as a virtual machine or container.</span></span> <span data-ttu-id="8c236-153">동일 하 고 서비스-01, 서비스-02 등의 시스템 식별자가 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-153">They're identical and assigned a system identifier such as Service-01, Service-02, and so on.</span></span> <span data-ttu-id="8c236-154">이러한 항목을 더 만들어 크기를 조정 합니다 (규모 확장).</span><span class="sxs-lookup"><span data-stu-id="8c236-154">You scale by creating more of them (scaling out).</span></span> <span data-ttu-id="8c236-155">하나를 사용할 수 없게 되 면 아무도 알림을 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-155">When one becomes unavailable, nobody notices.</span></span>

<span data-ttu-id="8c236-156">결국 모델은 변경할 수 없는 *인프라*를 수용 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-156">The cattle model embraces *immutable infrastructure*.</span></span> <span data-ttu-id="8c236-157">서버가 복구 되거나 수정 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-157">Servers aren't repaired or modified.</span></span> <span data-ttu-id="8c236-158">오류가 발생 하거나 업데이트가 필요한 경우에는 완전히 제거 되며 자동화를 통해 모두 프로 비전 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-158">If one fails or requires updating, it's destroyed and a new one is provisioned – all done via automation.</span></span>

<span data-ttu-id="8c236-159">클라우드 네이티브 시스템은 결국 서비스 모델을 수용 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-159">Cloud-native systems embrace the Cattle service model.</span></span> <span data-ttu-id="8c236-160">인프라는 실행 중인 컴퓨터와 관계 없이 규모를 확장 하거나 축소할 때 계속 해 서 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-160">They continue to run as the infrastructure scales in or out with no regard to the machines upon which they're running.</span></span>

<span data-ttu-id="8c236-161">Azure 클라우드 플랫폼은 자동 크기 조정, 자동 복구 및 모니터링 기능을 제공 하는 이러한 유형의 매우 탄력적 인프라를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-161">The Azure cloud platform supports this type of highly elastic infrastructure with automatic scaling, self-healing, and monitoring capabilities.</span></span>

## <a name="modern-design"></a><span data-ttu-id="8c236-162">최신 디자인</span><span class="sxs-lookup"><span data-stu-id="8c236-162">Modern design</span></span>

<span data-ttu-id="8c236-163">클라우드 네이티브 앱을 어떻게 디자인 하나요?</span><span class="sxs-lookup"><span data-stu-id="8c236-163">How would you design a cloud-native app?</span></span> <span data-ttu-id="8c236-164">아키텍처는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-164">What would your architecture look like?</span></span> <span data-ttu-id="8c236-165">어떤 원칙, 패턴 및 모범 사례를 준수 하나요?</span><span class="sxs-lookup"><span data-stu-id="8c236-165">To what principles, patterns, and best practices would you adhere?</span></span> <span data-ttu-id="8c236-166">중요 한 인프라 및 운영 우려는 무엇 인가요?</span><span class="sxs-lookup"><span data-stu-id="8c236-166">What infrastructure and operational concerns would be important?</span></span>

### <a name="the-twelve-factor-application"></a><span data-ttu-id="8c236-167">12 단계 응용 프로그램</span><span class="sxs-lookup"><span data-stu-id="8c236-167">The Twelve-Factor Application</span></span>

<span data-ttu-id="8c236-168">클라우드 기반 응용 프로그램을 구성 하는 데 널리 사용 되는 방법은 [12 단계 응용 프로그램](https://12factor.net/)입니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-168">A widely accepted methodology for constructing cloud-based applications is the [Twelve-Factor Application](https://12factor.net/).</span></span> <span data-ttu-id="8c236-169">개발자가 최신 클라우드 환경에 최적화 된 응용 프로그램을 만들기 위해 따라야 하는 원칙과 관행을 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-169">It describes a set of principles and practices that developers follow to construct applications optimized for modern cloud environments.</span></span> <span data-ttu-id="8c236-170">환경 및 선언적 자동화에서 이식성에 대 한 특별 한 주의가 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-170">Special attention is given to portability across environments and declarative automation.</span></span>

<span data-ttu-id="8c236-171">모든 웹 기반 응용 프로그램에 적용할 수 있는 반면, 많은 전문가 클라우드 네이티브 앱을 빌드하기 위한 견고한 기반으로 간주 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-171">While applicable to any web-based application, many practitioners consider it as a solid foundation for building cloud-native apps.</span></span> <span data-ttu-id="8c236-172">이러한 원칙을 바탕으로 구축 된 시스템은 신속 하 게 배포 하 고 확장할 수 있으며 시장 변화에 신속 하 게 대응할 수 있는 기능을 추가할</span><span class="sxs-lookup"><span data-stu-id="8c236-172">Systems built upon these principles can deploy and scale rapidly and add features to react quickly to market changes.</span></span>

<span data-ttu-id="8c236-173">다음 표에서는 12 단계 방법을 중점적으로 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-173">The following table highlights the Twelve-Factor methodology:</span></span>

|    |  <span data-ttu-id="8c236-174">요소</span><span class="sxs-lookup"><span data-stu-id="8c236-174">Factor</span></span> | <span data-ttu-id="8c236-175">설명</span><span class="sxs-lookup"><span data-stu-id="8c236-175">Explanation</span></span>  |
| :-------- | :-------- | :-------- |
| <span data-ttu-id="8c236-176">1</span><span class="sxs-lookup"><span data-stu-id="8c236-176">1</span></span> | <span data-ttu-id="8c236-177">코드 베이스</span><span class="sxs-lookup"><span data-stu-id="8c236-177">Code Base</span></span> | <span data-ttu-id="8c236-178">자체 리포지토리에 저장 된 각 마이크로 서비스에 대 한 단일 코드 베이스입니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-178">A single code base for each microservice, stored in its own repository.</span></span> <span data-ttu-id="8c236-179">버전 제어로 추적 되 고 여러 환경 (QA, 스테이징, 프로덕션)에 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-179">Tracked with version control, it can deploy to multiple environments (QA, Staging, Production).</span></span> |
| <span data-ttu-id="8c236-180">2</span><span class="sxs-lookup"><span data-stu-id="8c236-180">2</span></span> | <span data-ttu-id="8c236-181">종속성</span><span class="sxs-lookup"><span data-stu-id="8c236-181">Dependencies</span></span> | <span data-ttu-id="8c236-182">각 마이크로 서비스는 자체 종속성을 격리 하 고 패키지 하 여 전체 시스템에 영향을 주지 않고 변경 내용을 수용 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-182">Each microservice isolates and packages its own dependencies, embracing changes without impacting the entire system.</span></span> |
| <span data-ttu-id="8c236-183">3</span><span class="sxs-lookup"><span data-stu-id="8c236-183">3</span></span> | <span data-ttu-id="8c236-184">구성</span><span class="sxs-lookup"><span data-stu-id="8c236-184">Configurations</span></span>  | <span data-ttu-id="8c236-185">구성 정보는 코드 외부의 구성 관리 도구를 통해 마이크로 서비스 및 표면화 된 외부로 이동 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-185">Configuration information is moved out of the microservice and externalized through a configuration management tool outside of the code.</span></span> <span data-ttu-id="8c236-186">동일한 배포가 올바른 구성이 적용 된 환경에서 전파 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-186">The same deployment can propagate across environments with the correct configuration applied.</span></span>  |
| <span data-ttu-id="8c236-187">4</span><span class="sxs-lookup"><span data-stu-id="8c236-187">4</span></span> | <span data-ttu-id="8c236-188">서비스 지원</span><span class="sxs-lookup"><span data-stu-id="8c236-188">Backing Services</span></span> | <span data-ttu-id="8c236-189">보조 리소스 (데이터 저장소, 캐시, 메시지 브로커)는 주소 지정 가능 URL을 통해 노출 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-189">Ancillary resources (data stores, caches, message brokers) should be exposed via an addressable URL.</span></span> <span data-ttu-id="8c236-190">이렇게 하면 응용 프로그램에서 리소스를 분리 하 여 상호 교환이 가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-190">Doing so decouples the resource from the application, enabling it to be interchangeable.</span></span>  |
| <span data-ttu-id="8c236-191">5</span><span class="sxs-lookup"><span data-stu-id="8c236-191">5</span></span> | <span data-ttu-id="8c236-192">빌드, 릴리스, 실행</span><span class="sxs-lookup"><span data-stu-id="8c236-192">Build, Release, Run</span></span> | <span data-ttu-id="8c236-193">각 릴리스는 빌드, 릴리스 및 실행 단계에서 엄격한 분리를 적용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-193">Each release must enforce a strict separation across the build, release, and run stages.</span></span> <span data-ttu-id="8c236-194">각에는 고유한 ID로 태그를 지정 하 고 롤백하는 기능을 지원 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-194">Each should be tagged with a unique ID and support the ability to roll back.</span></span> <span data-ttu-id="8c236-195">최신 CI/CD 시스템은이 원칙을 충족 하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-195">Modern CI/CD systems help fulfill this principle.</span></span> |
| <span data-ttu-id="8c236-196">6</span><span class="sxs-lookup"><span data-stu-id="8c236-196">6</span></span> | <span data-ttu-id="8c236-197">프로세스</span><span class="sxs-lookup"><span data-stu-id="8c236-197">Processes</span></span> | <span data-ttu-id="8c236-198">각 마이크로 서비스는 실행 중인 다른 서비스와 분리 된 자체 프로세스에서 실행 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-198">Each microservice should execute in its own process,  isolated from other running services.</span></span> <span data-ttu-id="8c236-199">분산 캐시 또는 데이터 저장소와 같은 지원 서비스에 필요한 상태를 외부화 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-199">Externalize required state to a backing service such as a distributed cache or data store.</span></span> |
| <span data-ttu-id="8c236-200">7</span><span class="sxs-lookup"><span data-stu-id="8c236-200">7</span></span> | <span data-ttu-id="8c236-201">포트 바인딩</span><span class="sxs-lookup"><span data-stu-id="8c236-201">Port Binding</span></span> | <span data-ttu-id="8c236-202">각 마이크로 서비스는 자체 포트에서 노출 되는 인터페이스 및 기능과 함께 자체 포함 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-202">Each microservice should be self-contained with its interfaces and functionality exposed on its own port.</span></span> <span data-ttu-id="8c236-203">이렇게 하면 다른 마이크로 서비스와의 격리가 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-203">Doing so provides isolation from other microservices.</span></span> |
| <span data-ttu-id="8c236-204">8</span><span class="sxs-lookup"><span data-stu-id="8c236-204">8</span></span> | <span data-ttu-id="8c236-205">동시성</span><span class="sxs-lookup"><span data-stu-id="8c236-205">Concurrency</span></span> | <span data-ttu-id="8c236-206">서비스는 사용 가능한 가장 강력한 컴퓨터에서 단일 큰 인스턴스를 확장 하는 것과는 반대로, 많은 수의 작은 동일한 프로세스 (복사본)로 확장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-206">Services scale out across a large number of small identical processes (copies) as opposed to scaling-up a single large instance on the most powerful machine available.</span></span> |
| <span data-ttu-id="8c236-207">9</span><span class="sxs-lookup"><span data-stu-id="8c236-207">9</span></span> | <span data-ttu-id="8c236-208">Disposability</span><span class="sxs-lookup"><span data-stu-id="8c236-208">Disposability</span></span> | <span data-ttu-id="8c236-209">서비스 인스턴스는 삭제 가능 해야 하며, 확장성 기회를 높이고 정상적인 종료를 찾은 다음 하 여 시스템을 올바른 상태로 유지 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-209">Service instances should be disposable, favoring fast startups to increase scalability opportunities and graceful shutdowns to leave the system in a correct state.</span></span> <span data-ttu-id="8c236-210">Docker 컨테이너는 기본적으로이 요구 사항을 충족 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-210">Docker containers along with an orchestrator inherently satisfy this requirement.</span></span> |
| <span data-ttu-id="8c236-211">10</span><span class="sxs-lookup"><span data-stu-id="8c236-211">10</span></span> | <span data-ttu-id="8c236-212">개발/Prod 패리티</span><span class="sxs-lookup"><span data-stu-id="8c236-212">Dev/Prod Parity</span></span> | <span data-ttu-id="8c236-213">응용 프로그램 수명 주기 전반에 걸쳐 최대한 많은 바로 가기를 방지 하 여 환경을 최대한 유사 하 게 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-213">Keep environments across the application lifecycle as similar as possible, avoiding costly shortcuts.</span></span> <span data-ttu-id="8c236-214">여기서는 컨테이너를 채택 하는 것이 동일한 실행 환경을 승격 하 여 크게 기여할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-214">Here, the adoption of containers can greatly contribute by promoting the same execution environment.</span></span> |
| <span data-ttu-id="8c236-215">11</span><span class="sxs-lookup"><span data-stu-id="8c236-215">11</span></span> | <span data-ttu-id="8c236-216">로깅</span><span class="sxs-lookup"><span data-stu-id="8c236-216">Logging</span></span> | <span data-ttu-id="8c236-217">마이크로 서비스에 의해 생성 된 로그를 이벤트 스트림으로 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-217">Treat logs generated by microservices as event streams.</span></span> <span data-ttu-id="8c236-218">이벤트 집계를 사용 하 여 처리 하 고 데이터를 Azure Monitor 또는 Splunk 등의 데이터 마이닝/로그 관리 도구에 전파 하 고 결국 장기 보관 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-218">Process them with an event aggregator and propagate the data to data-mining/log management tools like Azure Monitor or Splunk and eventually long-term archival.</span></span> |
| <span data-ttu-id="8c236-219">12</span><span class="sxs-lookup"><span data-stu-id="8c236-219">12</span></span> | <span data-ttu-id="8c236-220">관리 프로세스</span><span class="sxs-lookup"><span data-stu-id="8c236-220">Admin Processes</span></span> | <span data-ttu-id="8c236-221">관리/관리 작업을 일회성 프로세스로 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-221">Run administrative/management tasks as one-off processes.</span></span> <span data-ttu-id="8c236-222">작업에는 보고서에 대 한 데이터 정리 및 끌어오기 분석이 포함 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-222">Tasks can include data cleanup and pulling analytics for a report.</span></span> <span data-ttu-id="8c236-223">이러한 작업을 실행 하는 도구는 프로덕션 환경에서 호출 해야 하지만 응용 프로그램과는 별도로 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-223">Tools executing these tasks should be  invoked from the production environment, but separately from the application.</span></span> |

<span data-ttu-id="8c236-224">이 책에서 [12 단계 앱 외](https://content.pivotal.io/blog/beyond-the-twelve-factor-app)의 작성자 Kevin hoffman은는 각각의 원래 12 가지 요소 (2011로 작성 됨)를 자세히 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-224">In the book, [Beyond the Twelve-Factor App](https://content.pivotal.io/blog/beyond-the-twelve-factor-app), author Kevin Hoffman details each of the original 12 factors (written in 2011).</span></span> <span data-ttu-id="8c236-225">또한이 서적에서는 오늘날의 최신 클라우드 응용 프로그램 디자인을 반영 하는 세 가지 추가 요인을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-225">Additionally, the book provides three additional factors that reflect today's modern cloud application design.</span></span>

|    |  <span data-ttu-id="8c236-226">새 요소</span><span class="sxs-lookup"><span data-stu-id="8c236-226">New Factor</span></span> | <span data-ttu-id="8c236-227">설명</span><span class="sxs-lookup"><span data-stu-id="8c236-227">Explanation</span></span>  |
| :-------- | :-------- | :-------- |
| <span data-ttu-id="8c236-228">13</span><span class="sxs-lookup"><span data-stu-id="8c236-228">13</span></span> | <span data-ttu-id="8c236-229">API 우선</span><span class="sxs-lookup"><span data-stu-id="8c236-229">API First</span></span> | <span data-ttu-id="8c236-230">모든 것을 서비스로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-230">Make everything a service.</span></span> <span data-ttu-id="8c236-231">프런트 엔드 클라이언트, 게이트웨이 또는 다른 서비스에서 코드를 사용 한다고 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-231">Assume your code will be consumed by a front-end client, gateway, or another service.</span></span> |
| <span data-ttu-id="8c236-232">14</span><span class="sxs-lookup"><span data-stu-id="8c236-232">14</span></span> | <span data-ttu-id="8c236-233">원격 분석</span><span class="sxs-lookup"><span data-stu-id="8c236-233">Telemetry</span></span> | <span data-ttu-id="8c236-234">워크스테이션에서는 응용 프로그램 및 해당 동작을 자세히 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-234">On a workstation, you have deep visibility into your application and its behavior.</span></span> <span data-ttu-id="8c236-235">클라우드에서는 그렇지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-235">In the cloud, you don't.</span></span> <span data-ttu-id="8c236-236">디자인에 모니터링, 도메인별 및 상태/시스템 데이터 컬렉션이 포함 되어 있는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-236">Make sure your design includes the collection of monitoring, domain-specific, and health/system data.</span></span> |
| <span data-ttu-id="8c236-237">15</span><span class="sxs-lookup"><span data-stu-id="8c236-237">15</span></span> | <span data-ttu-id="8c236-238">인증/권한 부여</span><span class="sxs-lookup"><span data-stu-id="8c236-238">Authentication/ Authorization</span></span>  | <span data-ttu-id="8c236-239">시작에서 id를 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-239">Implement identity from the start.</span></span> <span data-ttu-id="8c236-240">공용 클라우드에서 사용할 수 있는 [RBAC (역할 기반 액세스 제어)](https://docs.microsoft.com/azure/role-based-access-control/overview) 기능을 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-240">Consider [RBAC (role-based access control)](https://docs.microsoft.com/azure/role-based-access-control/overview) features available in public clouds.</span></span>  |

<span data-ttu-id="8c236-241">이 장과 설명서 전체에서 12 개 이상의 요소를 모두 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-241">We'll refer to many of the 12+ factors in this chapter and throughout the book.</span></span>

### <a name="critical-design-considerations"></a><span data-ttu-id="8c236-242">중요 한 디자인 고려 사항</span><span class="sxs-lookup"><span data-stu-id="8c236-242">Critical Design Considerations</span></span>

<span data-ttu-id="8c236-243">12 단계 방법에서 제공 하는 지침 외에도 분산 시스템을 구성할 때 몇 가지 중요 한 디자인 결정을 내려야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-243">Beyond the guidance provided from the twelve-factor methodology, there are several critical design decisions you must make when constructing distributed systems.</span></span>

<span data-ttu-id="8c236-244">*통신이*</span><span class="sxs-lookup"><span data-stu-id="8c236-244">*Communication*</span></span>

<span data-ttu-id="8c236-245">프런트 엔드 클라이언트 응용 프로그램은 백업 된 핵심 서비스와 통신 하는 방법</span><span class="sxs-lookup"><span data-stu-id="8c236-245">How will front-end client applications communicate with backed-end core services?</span></span> <span data-ttu-id="8c236-246">직접 통신을 허용 하 시겠습니까?</span><span class="sxs-lookup"><span data-stu-id="8c236-246">Will you allow direct communication?</span></span> <span data-ttu-id="8c236-247">또는 유연성, 제어 및 보안을 제공 하는 게이트웨이 외관을 사용 하 여 백 엔드 서비스를 추상화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-247">Or, might you abstract the back-end services with a gateway façade that provides  flexibility, control, and security?</span></span>

<span data-ttu-id="8c236-248">백 엔드 핵심 서비스는 서로 통신 하는 방법</span><span class="sxs-lookup"><span data-stu-id="8c236-248">How will back-end core services communicate with each other?</span></span> <span data-ttu-id="8c236-249">결합 및 성능에 영향을 주는 직접 HTTP 호출을 허용 하나요?</span><span class="sxs-lookup"><span data-stu-id="8c236-249">Will you allow direct HTTP calls that lead to coupling and impact performance and agility?</span></span> <span data-ttu-id="8c236-250">또는 큐 및 토픽 기술로 분리 된 메시징을 고려할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-250">Or might you consider decoupled messaging with queue and topic technologies?</span></span>

<span data-ttu-id="8c236-251">통신에 대 한 자세한 내용은 4 장 *클라우드 네이티브 통신 패턴*을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="8c236-251">Communication is covered in detail Chapter 4, *Cloud-Native Communication Patterns*.</span></span>

<span data-ttu-id="8c236-252">*복원력*</span><span class="sxs-lookup"><span data-stu-id="8c236-252">*Resiliency*</span></span>

<span data-ttu-id="8c236-253">마이크로 서비스 아키텍처는 시스템을 in-process에서 out-of-process 네트워크 통신으로 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-253">A microservices architecture moves your system from in-process to out-of-process network communication.</span></span> <span data-ttu-id="8c236-254">분산 아키텍처에서 서비스 B가 서비스 A의 네트워크 호출에 응답 하지 않으면 어떻게 되나요?</span><span class="sxs-lookup"><span data-stu-id="8c236-254">In a distributed architecture, what happens when Service B isn't responding to a network call from Service A?</span></span> <span data-ttu-id="8c236-255">또는 서비스 C를 일시적으로 사용할 수 없게 되 고이 서비스를 호출 하는 다른 서비스가 차단 되 면 어떻게 되나요?</span><span class="sxs-lookup"><span data-stu-id="8c236-255">Or, what happens when Service C becomes temporarily unavailable and other services calling it are blocked?</span></span>

<span data-ttu-id="8c236-256">복원 력은 6 장, *클라우드 기본 복원 력*에 자세히 설명 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-256">Resiliency is covered in detail Chapter 6, *Cloud-Native Resiliency*.</span></span>

<span data-ttu-id="8c236-257">*분산 데이터*</span><span class="sxs-lookup"><span data-stu-id="8c236-257">*Distributed Data*</span></span>

<span data-ttu-id="8c236-258">기본적으로 각 마이크로 서비스는 자체 데이터를 캡슐화 하 여 공용 인터페이스를 통해 작업을 노출 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-258">By design, each microservice encapsulates its own data, exposing operations via its public interface.</span></span> <span data-ttu-id="8c236-259">그렇다면 여러 서비스에서 데이터를 쿼리하거나 트랜잭션을 구현 하는 방법은 무엇입니까?</span><span class="sxs-lookup"><span data-stu-id="8c236-259">If so, how do you query data or implement a transaction across multiple services?</span></span>

<span data-ttu-id="8c236-260">분산 데이터에 대 한 자세한 내용은 5 장, *클라우드 네이티브 데이터 패턴*을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="8c236-260">Distributed data is covered in detail Chapter 5, *Cloud-Native Data Patterns*.</span></span>

<span data-ttu-id="8c236-261">*ID*</span><span class="sxs-lookup"><span data-stu-id="8c236-261">*Identity*</span></span>

<span data-ttu-id="8c236-262">서비스에서 액세스 하는 사용자 및 사용 권한을 식별 하는 방법은 무엇 인가요?</span><span class="sxs-lookup"><span data-stu-id="8c236-262">How will your service identify who is accessing it and what permissions they have?</span></span>

<span data-ttu-id="8c236-263">Id는 세부 정보 Chapter 8, *id*에 설명 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-263">Identity is covered in detail Chapter 8, *Identity*.</span></span>

## <a name="microservices"></a><span data-ttu-id="8c236-264">마이크로 서비스</span><span class="sxs-lookup"><span data-stu-id="8c236-264">Microservices</span></span>

<span data-ttu-id="8c236-265">클라우드 네이티브 시스템은 최신 응용 프로그램을 구성 하는 데 널리 사용 되는 아키텍처 스타일 인 마이크로 서비스를 수용 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-265">Cloud-native systems embrace microservices, a popular architectural style for constructing modern applications.</span></span>

<span data-ttu-id="8c236-266">공유 패브릭을 통해 상호 작용 하는 소규모 독립 서비스의 분산 된 집합으로 구축 된 마이크로 서비스는 다음과 같은 특징을 공유 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-266">Built as a distributed set of small, independent services that interact through a shared fabric, microservices share the following characteristics:</span></span>

- <span data-ttu-id="8c236-267">각는 더 큰 도메인 컨텍스트 내에서 특정 비즈니스 기능을 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-267">Each implements a specific business capability within a larger domain context.</span></span>

- <span data-ttu-id="8c236-268">각은 자율적으로 개발 되며 독립적으로 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-268">Each is developed autonomously and can be deployed independently.</span></span>

- <span data-ttu-id="8c236-269">각은 자체 데이터 저장소 기술 (SQL, NoSQL) 및 프로그래밍 플랫폼을 캡슐화 하는 자체 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-269">Each is self-contained encapsulating its own data storage technology (SQL, NoSQL) and programming platform.</span></span>

- <span data-ttu-id="8c236-270">각는 자체 프로세스에서 실행 되 고 HTTP/HTTPS, Websocket 또는 [Amqp](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol)와 같은 표준 통신 프로토콜을 사용 하 여 다른 사용자와 통신 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-270">Each runs in its own process and communicates with others using standard communication protocols such as HTTP/HTTPS, WebSockets, or [AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol).</span></span>

- <span data-ttu-id="8c236-271">응용 프로그램을 구성 하기 위해 함께 구성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-271">They compose together to form an application.</span></span>

<span data-ttu-id="8c236-272">그림 1-4은 마이크로 서비스 접근 방식과 모놀리식 응용 프로그램 접근 방식을 대조 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-272">Figure 1-4 contrasts a monolithic application approach with a microservices approach.</span></span> <span data-ttu-id="8c236-273">단일 프로세스에서 실행 되는 계층화 된 아키텍처로 모놀리식를 구성 하는 방법을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-273">Note how the monolith is composed of a layered architecture, which executes in a single process.</span></span> <span data-ttu-id="8c236-274">일반적으로 관계형 데이터베이스를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-274">It typically consumes a relational database.</span></span> <span data-ttu-id="8c236-275">그러나 마이크로 서비스 접근 방식은 논리와 데이터를 포함 하는 독립적인 서비스로 기능을 분리 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-275">The microservice approach, however, segregates functionality into independent services that include logic and data.</span></span> <span data-ttu-id="8c236-276">각 마이크로 서비스는 자체 데이터 저장소를 호스팅합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-276">Each microservice hosts its own datastore.</span></span>

![모놀리식 배포 및 마이크로 서비스](./media/monolithic-vs-microservices.png)

<span data-ttu-id="8c236-278">**그림 1-4.**</span><span class="sxs-lookup"><span data-stu-id="8c236-278">**Figure 1-4.**</span></span> <span data-ttu-id="8c236-279">모놀리식 배포 및 마이크로 서비스</span><span class="sxs-lookup"><span data-stu-id="8c236-279">Monolithic deployment versus microservices</span></span>

<span data-ttu-id="8c236-280">마이크로 서비스는 [12 단계 응용 프로그램](https://12factor.net/)에서 "한 코드 베이스, 한 응용 프로그램" 원칙을 승격 하는 방법에 대해 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-280">Note how microservices promote the "One Codebase, One Application" principle from the [Twelve-Factor Application](https://12factor.net/), discussed earlier in the chapter.</span></span>

> <span data-ttu-id="8c236-281">*요소 \#1은 자체 리포지토리에 저장 된 각 마이크로 서비스에 대해 단일 코드 베이스를 지정 합니다. 버전 제어로 추적 되 고 여러 환경에 배포할 수 있습니다. "*</span><span class="sxs-lookup"><span data-stu-id="8c236-281">*Factor \#1  specifies "A single codebase for each microservice, stored in its own repository. Tracked with version control, it can deploy to multiple environments."*</span></span>

### <a name="why-microservices"></a><span data-ttu-id="8c236-282">마이크로 서비스를 사용하는 이유는 무엇인가요?</span><span class="sxs-lookup"><span data-stu-id="8c236-282">Why microservices?</span></span>

<span data-ttu-id="8c236-283">마이크로 서비스는 민첩성을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-283">Microservices provide agility.</span></span>

<span data-ttu-id="8c236-284">이 장에서는 마이크로 서비스를 사용 하 여 모놀리식로 빌드된 전자 상거래 응용 프로그램을 비교 했습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-284">Earlier in the chapter, we compared an eCommerce application built as a monolith to that with microservices.</span></span> <span data-ttu-id="8c236-285">이 예제에서는 다음과 같은 몇 가지 분명 한 이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-285">In the example, we saw some clear benefits:</span></span>

- <span data-ttu-id="8c236-286">각 마이크로 서비스는 자치 수명 주기를 가지 며 독립적으로 발전 하 고 자주 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-286">Each microservice has an autonomous lifecycle and can evolve independently and deploy frequently.</span></span> <span data-ttu-id="8c236-287">분기별 릴리스가 새 기능이 나 업데이트를 배포할 때까지 기다릴 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-287">You don't have to wait for a quarterly release to deploy a new features or update.</span></span> <span data-ttu-id="8c236-288">전체 시스템을 방해 하는 위험을 줄일 수 있는 복잡 한 응용 프로그램의 작은 영역을 업데이트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-288">You can update a small area of a complex application with less risk of disrupting the entire system.</span></span>

- <span data-ttu-id="8c236-289">각 마이크로 서비스은 독립적으로 확장 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-289">Each microservice can scale independently.</span></span> <span data-ttu-id="8c236-290">전체 응용 프로그램을 단일 단위로 확장 하는 대신 더 많은 처리 능력 또는 네트워크 대역폭이 필요한 서비스만 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-290">Instead of scaling the entire application as a single unit, you scale out only those services that require more processing power or network bandwidth.</span></span> <span data-ttu-id="8c236-291">크기 조정에 대 한이 세분화 된 접근 방식을 사용 하면 시스템을 보다 효과적으로 제어할 수 있으며, 모든 것이 아니라 시스템의 일부를 확장할 때 전체 비용을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-291">This  fine-grained approach to scaling provides for greater control of your system and helps to reduce overall costs as you scale portions of your system, not everything.</span></span>

<span data-ttu-id="8c236-292">마이크로 서비스를 이해 하기 위한 뛰어난 참조 가이드는 [.Net 마이크로 서비스: 컨테이너 화 된 .Net 응용 프로그램용 아키텍처](https://dotnet.microsoft.com/download/thank-you/microservices-architecture-ebook)입니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-292">An excellent reference guide for understanding microservices is [.NET Microservices: Architecture for Containerized .NET Applications](https://dotnet.microsoft.com/download/thank-you/microservices-architecture-ebook).</span></span> <span data-ttu-id="8c236-293">책은 마이크로 서비스 디자인 및 아키텍처로 다이브.</span><span class="sxs-lookup"><span data-stu-id="8c236-293">The book deep dives into microservices design and architecture.</span></span> <span data-ttu-id="8c236-294">Microsoft에서 제공 하는 무료 다운로드로 제공 되는 [전체 스택 마이크로 서비스 참조 아키텍처](https://github.com/dotnet-architecture/eShopOnContainers) 에 대 한 부록입니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-294">It's a companion for a [full-stack microservice reference architecture](https://github.com/dotnet-architecture/eShopOnContainers) available as a free download from Microsoft.</span></span>

### <a name="developing-microservices"></a><span data-ttu-id="8c236-295">마이크로 서비스 개발</span><span class="sxs-lookup"><span data-stu-id="8c236-295">Developing microservices</span></span>

<span data-ttu-id="8c236-296">마이크로 서비스는 모든 최신 개발 플랫폼을 사용 하 여 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-296">Microservices can be created with any modern development platform.</span></span>

<span data-ttu-id="8c236-297">Microsoft .NET Core 플랫폼을 선택 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-297">The Microsoft .NET Core platform is an excellent choice.</span></span> <span data-ttu-id="8c236-298">무료 오픈 소스는 마이크로 서비스 개발을 간소화 하는 여러 가지 기본 제공 기능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-298">Free and open source, it has many built-in features to simplify microservice development.</span></span> <span data-ttu-id="8c236-299">.NET Core는 플랫폼 간입니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-299">.NET Core is cross-platform.</span></span> <span data-ttu-id="8c236-300">Windows, macOS 및 대부분의 Linux에서 응용 프로그램을 빌드하고 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-300">Applications can be built and run on Windows, macOS, and most flavors of Linux.</span></span>

<span data-ttu-id="8c236-301">.NET Core는 성능이 뛰어나고 node.js 및 기타 경쟁 플랫폼과 비교 하 여 잘 점수가 매겨집니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-301">.NET Core is highly performant and has scored well in comparison to Node.js and other competing platforms.</span></span> <span data-ttu-id="8c236-302">흥미롭게도 [TechEmpower](https://www.techempower.com/) 는 여러 웹 응용 프로그램 플랫폼 및 프레임 워크에서 광범위 한 [성능 벤치 마크](https://www.techempower.com/benchmarks/#section=data-r17&hw=ph&test=plaintext) 를 수행 했습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-302">Interestingly, [TechEmpower](https://www.techempower.com/) conducted an extensive set of [performance benchmarks](https://www.techempower.com/benchmarks/#section=data-r17&hw=ph&test=plaintext) across many web application platforms and frameworks.</span></span> <span data-ttu-id="8c236-303">.NET Core는 상위 10 개 이상의 node.js 및 기타 경쟁 플랫폼에서 점수가 매겨집니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-303">.NET Core scored in the top 10 - well above Node.js and other competing platforms.</span></span>

<span data-ttu-id="8c236-304">.NET Core는 Microsoft 및 GitHub의 .NET 커뮤니티에서 유지 관리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-304">.NET Core is maintained by Microsoft and the .NET community on GitHub.</span></span>

## <a name="containers"></a><span data-ttu-id="8c236-305">컨테이너</span><span class="sxs-lookup"><span data-stu-id="8c236-305">Containers</span></span>

<span data-ttu-id="8c236-306">오늘날 *cloud native*와 관련 된 모든 대화에서 언급 된 용어 *컨테이너* 를 듣게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-306">Nowadays, it's natural to hear the term *container* mentioned in any conversation concerning *cloud native*.</span></span> <span data-ttu-id="8c236-307">책의 [클라우드 네이티브 패턴](https://www.manning.com/books/cloud-native-patterns)에서 Davis는 "컨테이너는 클라우드 네이티브 소프트웨어를 잘 실현할 수 있습니다." 라는 것을 관찰 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-307">In the book, [Cloud Native Patterns](https://www.manning.com/books/cloud-native-patterns), author Cornelia Davis observes that, "Containers are a great enabler of cloud-native software."</span></span> <span data-ttu-id="8c236-308">클라우드 네이티브 컴퓨팅 파운데이션은 마이크로 서비스 컨테이너 화를 [클라우드 기본 구조](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png) 에 첫 번째 단계로 제공 합니다. 즉, 클라우드 기본 전환을 시작 하는 기업에 대 한 지침을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-308">The Cloud Native Computing Foundation places microservice containerization as the first step in their [Cloud-Native Trail Map](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png) - guidance for enterprises beginning their cloud-native journey.</span></span>

<span data-ttu-id="8c236-309">컨테이너 화 a 마이크로 서비스는 간단 하 고 간단 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-309">Containerizing a microservice is simple and straightforward.</span></span> <span data-ttu-id="8c236-310">코드, 해당 종속성 및 런타임은 [컨테이너 이미지](https://docs.docker.com/glossary/?term=image)라는 이진으로 패키지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-310">The code, its dependencies, and runtime are packaged into a binary called a [container image](https://docs.docker.com/glossary/?term=image).</span></span> <span data-ttu-id="8c236-311">이미지는 이미지에 대 한 리포지토리 또는 라이브러리 역할을 하는 [컨테이너 레지스트리에](https://caylent.com/container-registries/)저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-311">Images are stored in a [container registry](https://caylent.com/container-registries/), which acts as a repository or library for images.</span></span> <span data-ttu-id="8c236-312">레지스트리는 개발 컴퓨터, 데이터 센터 또는 공용 클라우드에서 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-312">A registry can be located on your development computer, in your data center, or in a public cloud.</span></span> <span data-ttu-id="8c236-313">Docker 자체는 [Docker 허브](https://hub.docker.com/)를 통해 공용 레지스트리를 유지 관리 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-313">Docker itself maintains a public registry via [Docker Hub](https://hub.docker.com/).</span></span> <span data-ttu-id="8c236-314">Azure cloud는 컨테이너를 실행 하는 클라우드 응용 프로그램에 가까운 컨테이너 이미지를 저장 하는 [컨테이너 레지스트리](https://azure.microsoft.com/services/container-registry/) 기능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-314">The Azure cloud features a [container registry](https://azure.microsoft.com/services/container-registry/) to store container images close to the cloud applications that will run them.</span></span>

<span data-ttu-id="8c236-315">필요한 경우 이미지를 실행 중인 컨테이너 인스턴스로 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-315">When needed, you transform the image into a running container instance.</span></span> <span data-ttu-id="8c236-316">인스턴스는 [컨테이너 런타임](https://kubernetes.io/docs/setup/production-environment/container-runtimes/) 엔진이 설치 된 모든 컴퓨터에서 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-316">The instance runs on any computer that has a [container runtime](https://kubernetes.io/docs/setup/production-environment/container-runtimes/) engine installed.</span></span> <span data-ttu-id="8c236-317">필요에 따라 컨테이너 화 된 서비스의 인스턴스를 여러 개 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-317">You can have as many instances of the containerized service as needed.</span></span>

<span data-ttu-id="8c236-318">그림 1-5은 단일 호스트에서 실행 되는 각각의 고유한 컨테이너에 있는 세 가지 마이크로 서비스를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-318">Figure 1-5 shows three different microservices, each in its own container, running on a single host.</span></span>

![컨테이너 호스트에서 실행되는 여러 컨테이너](./media/hosting-mulitple-containers.png)

<span data-ttu-id="8c236-320">**그림 1-5**.</span><span class="sxs-lookup"><span data-stu-id="8c236-320">**Figure 1-5**.</span></span> <span data-ttu-id="8c236-321">컨테이너 호스트에서 실행되는 여러 컨테이너</span><span class="sxs-lookup"><span data-stu-id="8c236-321">Multiple containers running on a container host</span></span>

<span data-ttu-id="8c236-322">각 컨테이너가 서로 다를 수 있는 고유한 종속성 및 런타임 집합을 유지 관리 하는 방법을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-322">Note how each container maintains its own set of dependencies and runtime, which can be different.</span></span> <span data-ttu-id="8c236-323">여기에는 동일한 호스트에서 실행 되는 여러 버전의 제품 마이크로 서비스이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-323">Here, we see different versions of the Product microservice running on the same host.</span></span> <span data-ttu-id="8c236-324">각 컨테이너는 기본 호스트 운영 체제, 메모리 및 프로세서의 조각을 공유 하지만 서로 격리 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-324">Each container shares a slice of the underlying host operating system, memory, and processor, but is isolated from one another.</span></span>

<span data-ttu-id="8c236-325">컨테이너 모델이 [12 단계 응용 프로그램](https://12factor.net/)에서 "종속성" 원칙을 수용 하는 정도를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-325">Note how well the container model embraces the "Dependencies" principle from the [Twelve-Factor Application](https://12factor.net/).</span></span>

> <span data-ttu-id="8c236-326">*요소 \#2는 "각 마이크로 서비스 자체 종속성을 격리 하 고 패키지 하 여 전체 시스템에 영향을 주지 않고 변경 내용을 수용 하도록 지정 합니다."*</span><span class="sxs-lookup"><span data-stu-id="8c236-326">*Factor \#2  specifies that "Each microservice isolates and packages its own dependencies, embracing changes without impacting the entire system."*</span></span>

<span data-ttu-id="8c236-327">컨테이너는 Linux 및 Windows 작업을 모두 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-327">Containers support both Linux and Windows workloads.</span></span> <span data-ttu-id="8c236-328">Azure 클라우드는 모두 개방적으로 수용 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-328">The Azure cloud openly embraces both.</span></span> <span data-ttu-id="8c236-329">흥미롭게도 Azure에서 가장 인기 있는 운영 체제가 되기 때문에 Windows Server가 아닌 Linux입니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-329">Interestingly, it's Linux, not Windows Server, that has become the most popular operating system in Azure.</span></span>

<span data-ttu-id="8c236-330">여러 컨테이너 공급 업체가 존재 하는 반면 Docker는 사자의 시장 공유를 캡처 했습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-330">While several container vendors exist, Docker has captured the lion's share of the market.</span></span> <span data-ttu-id="8c236-331">회사에서 소프트웨어 컨테이너 이동을 구동 했습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-331">The company has been driving the software container movement.</span></span> <span data-ttu-id="8c236-332">클라우드 네이티브 응용 프로그램을 패키지, 배포 및 실행 하기 위한 사실상 표준이 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-332">It has become the de facto standard for packaging, deploying, and running cloud-native applications.</span></span>

### <a name="why-containers"></a><span data-ttu-id="8c236-333">컨테이너는 무엇 인가요?</span><span class="sxs-lookup"><span data-stu-id="8c236-333">Why containers?</span></span>

<span data-ttu-id="8c236-334">컨테이너는 이식성을 제공 하 고 환경 간에 일관성을 보장 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-334">Containers provide portability and guarantee consistency across environments.</span></span> <span data-ttu-id="8c236-335">모든 항목을 단일 패키지로 캡슐화 하 여 기본 인프라에서 마이크로 서비스 및 해당 종속성을 *격리* 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-335">By encapsulating everything into a single package, you *isolate* the microservice and its dependencies from the underlying infrastructure.</span></span>

<span data-ttu-id="8c236-336">Docker 런타임 엔진을 포함 하는 모든 환경에서 동일한 컨테이너를 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-336">You can deploy that same container in any environment that has the Docker runtime engine.</span></span> <span data-ttu-id="8c236-337">또한 컨테이너 화 된 워크 로드는 프레임 워크, 소프트웨어 라이브러리 및 런타임 엔진을 사용 하 여 각 환경에 대 한 사전 구성 비용을 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-337">Containerized workloads also eliminate the expense of pre-configuring each environment with frameworks, software libraries, and runtime engines.</span></span>

<span data-ttu-id="8c236-338">기본 운영 체제 및 호스트 리소스를 공유 하 여 컨테이너는 전체 가상 컴퓨터 보다 훨씬 적은 공간을 차지 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-338">By sharing the underlying operating system and host resources, containers have a much smaller footprint than a full virtual machine.</span></span> <span data-ttu-id="8c236-339">크기가 작을수록 지정 된 호스트를 한 번에 실행할 수 있는 마이크로 서비스 수 또는 *밀도가*높아집니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-339">The smaller size increases the *density*, or number of microservices, that a given host can run at one time.</span></span>

### <a name="container-orchestration"></a><span data-ttu-id="8c236-340">컨테이너 오케스트레이션</span><span class="sxs-lookup"><span data-stu-id="8c236-340">Container orchestration</span></span>

<span data-ttu-id="8c236-341">Docker와 같은 도구는 이미지를 만들고 컨테이너를 실행 하는 동안 관리 하는 도구도 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-341">While tools such as Docker create images and run containers, you also need tools to manage them.</span></span> <span data-ttu-id="8c236-342">컨테이너 관리는 컨테이너 orchestrator 라는 특수 소프트웨어 프로그램을 사용 하 여 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-342">Container management is done with a special software program called a container orchestrator.</span></span> <span data-ttu-id="8c236-343">규모에 맞게 작동 하는 경우 컨테이너 오케스트레이션이 필수적입니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-343">When operating at scale, container orchestration is essential.</span></span>

<span data-ttu-id="8c236-344">그림 1-6에서는 컨테이너 orchestrator 제공 하는 관리 작업을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-344">Figure 1-6 shows management tasks that container orchestrators provide.</span></span>

![컨테이너 orchestrator](./media/what-container-orchestrators-do.png)

<span data-ttu-id="8c236-346">**그림 1-6**.</span><span class="sxs-lookup"><span data-stu-id="8c236-346">**Figure 1-6**.</span></span> <span data-ttu-id="8c236-347">컨테이너 orchestrator</span><span class="sxs-lookup"><span data-stu-id="8c236-347">What container orchestrators do</span></span>

<span data-ttu-id="8c236-348">다음 표에서는 일반적인 오케스트레이션 작업을 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-348">The following table describes common orchestration tasks.</span></span>

|  <span data-ttu-id="8c236-349">작업</span><span class="sxs-lookup"><span data-stu-id="8c236-349">Tasks</span></span> | <span data-ttu-id="8c236-350">설명</span><span class="sxs-lookup"><span data-stu-id="8c236-350">Explanation</span></span>  |
| :-------- | :-------- |
| <span data-ttu-id="8c236-351">일정 계획</span><span class="sxs-lookup"><span data-stu-id="8c236-351">Scheduling</span></span> | <span data-ttu-id="8c236-352">컨테이너 인스턴스를 자동으로 프로 비전 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-352">Automatically provision container instances.</span></span>|
| <span data-ttu-id="8c236-353">선호도/선호도 방지</span><span class="sxs-lookup"><span data-stu-id="8c236-353">Affinity/anti-affinity</span></span> | <span data-ttu-id="8c236-354">컨테이너를 서로 가까운 곳 이나 멀리 프로 비전 하 여 가용성과 성능을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-354">Provision containers nearby or far apart from each other, helping  availability and performance.</span></span> |
| <span data-ttu-id="8c236-355">상태 모니터링</span><span class="sxs-lookup"><span data-stu-id="8c236-355">Health monitoring</span></span> | <span data-ttu-id="8c236-356">자동으로 오류를 검색 하 고 수정 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-356">Automatically detect and correct failures.</span></span>|
| <span data-ttu-id="8c236-357">장애 조치 </span><span class="sxs-lookup"><span data-stu-id="8c236-357">Failover</span></span> | <span data-ttu-id="8c236-358">실패 한 인스턴스를 정상 컴퓨터에 자동으로 다시 구축.</span><span class="sxs-lookup"><span data-stu-id="8c236-358">Automatically reprovision failed instance to healthy machines.</span></span>|
| <span data-ttu-id="8c236-359">확장</span><span class="sxs-lookup"><span data-stu-id="8c236-359">Scaling</span></span> | <span data-ttu-id="8c236-360">필요에 맞게 컨테이너 인스턴스를 자동으로 추가 또는 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-360">Automatically add or remove container instance to meet demand.</span></span>|
| <span data-ttu-id="8c236-361">네트워킹</span><span class="sxs-lookup"><span data-stu-id="8c236-361">Networking</span></span> | <span data-ttu-id="8c236-362">컨테이너 통신을 위한 네트워킹 오버레이를 관리 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-362">Manage a networking overlay for container communication.</span></span>|
| <span data-ttu-id="8c236-363">서비스 검색</span><span class="sxs-lookup"><span data-stu-id="8c236-363">Service Discovery</span></span> | <span data-ttu-id="8c236-364">컨테이너를 사용 하 여 서로를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-364">Enable containers to locate each other.</span></span>|
| <span data-ttu-id="8c236-365">롤링 업그레이드</span><span class="sxs-lookup"><span data-stu-id="8c236-365">Rolling Upgrades</span></span> | <span data-ttu-id="8c236-366">가동 중지 시간이 0 인 증분 업그레이드를 조정 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-366">Coordinate incremental upgrades with zero downtime deployment.</span></span> <span data-ttu-id="8c236-367">문제가 있는 변경 내용을 자동으로 롤백합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-367">Automatically roll back problematic changes.</span></span>|

<span data-ttu-id="8c236-368">Orchestrator는이 장의 앞부분에서 설명한 [12 단계 응용 프로그램](https://12factor.net/)에서 disposability 및 동시성 원리를 수용 하는 방법에 유의 하세요.</span><span class="sxs-lookup"><span data-stu-id="8c236-368">Note how orchestrators embrace the disposability and concurrency principles from the [Twelve-Factor Application](https://12factor.net/), discussed earlier in the chapter.</span></span>

> <span data-ttu-id="8c236-369">*요소 \#9는 "서비스 인스턴스를 삭제 가능 하도록 지정 하 여 확장성 기회를 높이고 정상적인 종료를 찾은 다음 하 여 시스템을 올바른 상태로 유지 하도록 지정 합니다. Docker 컨테이너는 기본적으로이 요구 사항을 충족 합니다. "*</span><span class="sxs-lookup"><span data-stu-id="8c236-369">*Factor \#9  specifies that "Service instances should be disposable, favoring fast startups to increase scalability opportunities and graceful shutdowns to leave the system in a correct state. Docker containers along with an orchestrator inherently satisfy this requirement."*</span></span>

> <span data-ttu-id="8c236-370">*요소 \#8은 "서비스가 사용 가능한 가장 강력한 컴퓨터에서 단일 큰 인스턴스를 확장 하는 것과는 달리, 많은 수의 작은 동일한 프로세스 (복사본)에 걸쳐 규모를 확장 하도록 지정 합니다."*</span><span class="sxs-lookup"><span data-stu-id="8c236-370">*Factor \#8  specifies that "Services scale out across a large number of small identical processes (copies) as opposed to scaling-up a single large instance on the most powerful machine available."*</span></span>

<span data-ttu-id="8c236-371">여러 컨테이너 orchestrator 있는 동안 [Kubernetes](https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/) 는 클라우드 네이티브 세계에 대 한 사실상의 표준이 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-371">While several container orchestrators exist, [Kubernetes](https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/) has become the de facto standard for the cloud-native world.</span></span> <span data-ttu-id="8c236-372">컨테이너 화 된 워크 로드를 관리 하기 위한 이식 가능 하 고 확장 가능한 오픈 소스 플랫폼입니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-372">It's a portable, extensible, open-source platform for managing containerized workloads.</span></span>

<span data-ttu-id="8c236-373">Kubernetes의 고유한 인스턴스를 호스트할 수 있지만이를 위해 리소스를 프로 비전 하 고 관리 해야 합니다 .이는 복잡할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-373">You could host your own instance of Kubernetes, but then you'd be responsible for provisioning and managing its resources - which can be complex.</span></span> <span data-ttu-id="8c236-374">Azure cloud Kubernetes는 관리 서비스인 [AKS (Azure Kubernetes service)](https://azure.microsoft.com/services/kubernetes-service/)로 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-374">The Azure cloud features Kubernetes as a managed service, [Azure Kubernetes Service (AKS)](https://azure.microsoft.com/services/kubernetes-service/).</span></span> <span data-ttu-id="8c236-375">관리 서비스를 사용 하면 해당 기능을 설치 및 유지 관리 하지 않고도 해당 기능을 완벽 하 게 활용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-375">A managed service allows you to fully leverage its features, without having to install and maintain it.</span></span>

<span data-ttu-id="8c236-376">Azure Kubernetes 서비스는 *클라우드 네이티브 응용 프로그램 크기 조정*2 장에서 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-376">Azure Kubernetes Services is covered in detail Chapter 2, *Scaling Cloud-Native Applications*.</span></span>

## <a name="backing-services"></a><span data-ttu-id="8c236-377">서비스 지원</span><span class="sxs-lookup"><span data-stu-id="8c236-377">Backing services</span></span>

<span data-ttu-id="8c236-378">클라우드 네이티브 시스템은 데이터 저장소, 메시지 브로커, 모니터링 및 id 서비스와 같은 다양 한 보조 리소스에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-378">Cloud-native systems depend upon many different ancillary resources, such as data stores, message brokers, monitoring, and identity services.</span></span> <span data-ttu-id="8c236-379">이러한 서비스를 [지원 서비스](https://12factor.net/backing-services)라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-379">These services are known as [backing services](https://12factor.net/backing-services).</span></span>

 <span data-ttu-id="8c236-380">그림 1-7은 클라우드 네이티브 시스템에서 사용 하는 여러 일반적인 지원 서비스를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-380">Figure 1-7 shows many common backing services that cloud-native systems consume.</span></span>

![일반적인 지원 서비스](./media/common-backing-services.png)

<span data-ttu-id="8c236-382">**그림 1-7**.</span><span class="sxs-lookup"><span data-stu-id="8c236-382">**Figure 1-7**.</span></span> <span data-ttu-id="8c236-383">일반적인 지원 서비스</span><span class="sxs-lookup"><span data-stu-id="8c236-383">Common backing services</span></span>

<span data-ttu-id="8c236-384">지원 서비스는 [12 단계 응용 프로그램](https://12factor.net/)에서 "상태 비저장" 원칙을 승격 합니다 .이에 대해서는이 장의 앞부분에서 설명 했습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-384">Backing services promote the "Statelessness" principle from the [Twelve-Factor Application](https://12factor.net/), discussed earlier in the chapter.</span></span>

><span data-ttu-id="8c236-385">*요소 \#6* 은 "각 마이크로 서비스가 실행 중인 다른 서비스와 격리 된 자체 프로세스에서 실행 되도록 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-385">*Factor \#6* specifies that, "Each microservice should execute in its own process, isolated from other running services.</span></span> <span data-ttu-id="8c236-386">분산 캐시 또는 데이터 저장소와 같은 지원 서비스에 필요한 상태를 외부화. "</span><span class="sxs-lookup"><span data-stu-id="8c236-386">Externalize required state to a backing service such as a distributed cache or data store."</span></span>

<span data-ttu-id="8c236-387">자신의 지원 서비스를 호스트할 수 있지만 이러한 리소스를 라이선싱, 프로 비전 및 관리할 책임이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-387">You could host your own backing services, but then you'd be responsible for licensing, provisioning, and managing those resources.</span></span>

<span data-ttu-id="8c236-388">클라우드 공급자는 다양 한 *관리 지원 서비스를 제공 합니다.*</span><span class="sxs-lookup"><span data-stu-id="8c236-388">Cloud providers offer a rich assortment of *managed backing services.*</span></span> <span data-ttu-id="8c236-389">서비스를 소유 하는 대신 서비스를 사용 하기만 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-389">Instead of owning the service, you simply consume it.</span></span> <span data-ttu-id="8c236-390">공급자는 리소스를 대규모로 작동 하 고 성능, 보안 및 유지 관리에 대 한 책임을 집니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-390">The provider operates the resource at scale and bears the responsibility for performance, security, and maintenance.</span></span> <span data-ttu-id="8c236-391">모니터링, 중복성 및 가용성은 서비스에 기본 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-391">Monitoring, redundancy, and availability are built into the service.</span></span> <span data-ttu-id="8c236-392">공급자는 관리 되는 서비스를 완전히 지원 합니다. 티켓을 열고 문제를 해결 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-392">Providers fully support their managed services - open a ticket and they fix your issue.</span></span>

<span data-ttu-id="8c236-393">클라우드 기본 시스템은 클라우드 공급 업체의 관리 되는 백업 서비스를 선호 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-393">Cloud-native systems favor managed backing services from cloud vendors.</span></span> <span data-ttu-id="8c236-394">시간과 노력이 절약 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-394">The savings in time and labor are great.</span></span> <span data-ttu-id="8c236-395">사용자가 직접 호스트 하 고 문제를 발생 시킬 위험이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-395">The operational risk of hosting your own and experiencing trouble can get expensive fast.</span></span>

<span data-ttu-id="8c236-396">가장 좋은 방법은 지원 서비스를 *연결 된 리소스로*처리 하는 것입니다 .이는 외부 구성에 저장 된 정보 (URL 및 자격 증명)를 사용 하 여 마이크로 서비스에 동적으로 바인딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-396">A best practice is to treat a backing service as an *attached resource*, dynamically bound to a microservice with information (a URL and credentials) stored in an external configuration.</span></span> <span data-ttu-id="8c236-397">이 지침은이 장에서 설명 하는 [12 단계 응용 프로그램](https://12factor.net/)에서 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-397">This guidance is spelled out in the [Twelve-Factor Application](https://12factor.net/), discussed earlier in the chapter.</span></span>

><span data-ttu-id="8c236-398">*요소 \#4* 는 주소 지정 가능 URL을 통해 지원 서비스를 노출 하도록 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-398">*Factor \#4* specifies that backing services "should be exposed via an addressable URL.</span></span> <span data-ttu-id="8c236-399">이렇게 하면 응용 프로그램에서 리소스를 분리 하 여 상호 교환이 가능 합니다. "</span><span class="sxs-lookup"><span data-stu-id="8c236-399">Doing so decouples the resource from the application, enabling it to be interchangeable."</span></span>

><span data-ttu-id="8c236-400">*요소 \#3* 은 "구성 정보를 코드 외부의 구성 관리 도구를 통해 마이크로 서비스 및 표면화 된 외부로 이동" 하도록 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-400">*Factor \#3* specifies that "Configuration information is moved out of the microservice and externalized through a configuration management tool outside of the code."</span></span>

<span data-ttu-id="8c236-401">이 패턴을 사용 하면 코드를 변경 하지 않고 지원 서비스를 연결 및 분리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-401">With this pattern, a backing service can be attached and detached without code changes.</span></span> <span data-ttu-id="8c236-402">마이크로 서비스를 QA에서 스테이징 환경으로 승격할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-402">You might promote a microservice from QA to a staging environment.</span></span> <span data-ttu-id="8c236-403">준비의 지원 서비스를 가리키도록 마이크로 서비스 구성을 업데이트 하 고 환경 변수를 통해 컨테이너에 설정을 삽입 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-403">You update the microservice configuration to point to the backing services in staging and inject the settings into your container through an environment variable.</span></span>

<span data-ttu-id="8c236-404">클라우드 공급 업체는 자체 지원 서비스와 통신할 수 있는 Api를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-404">Cloud vendors provide APIs for you to communicate with their proprietary backing services.</span></span> <span data-ttu-id="8c236-405">이러한 라이브러리는 배관 및 복잡성을 캡슐화 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-405">These libraries encapsulate the plumbing and complexity.</span></span> <span data-ttu-id="8c236-406">이러한 Api와 직접 통신 하는 것은 코드를 백업 서비스에 긴밀 하 게 두는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-406">Communicating directly with these APIs will tightly couple your code to the backing service.</span></span> <span data-ttu-id="8c236-407">공급 업체 API의 구현 세부 정보를 안전 하 게 유지 하는 것이 더 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-407">It's a better practice to insulate the implementation details of the vendor API.</span></span> <span data-ttu-id="8c236-408">Intermediation 계층 또는 중간 API를 도입 하 여 서비스 코드에 일반 작업을 노출 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-408">Introduce an intermediation layer, or intermediate API, exposing generic operations to your service code.</span></span> <span data-ttu-id="8c236-409">이러한 느슨한 결합을 통해 한 지원 서비스를 다른 서비스 코드를 변경 하지 않고도 다른 공용 클라우드로 전환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-409">This loose coupling enables you to swap out one backing service for another or move your code to a different public cloud without having to make changes to the mainline service code.</span></span>

<span data-ttu-id="8c236-410">지원 서비스에 대 한 자세한 내용은 5 장, *클라우드 네이티브 데이터 패턴*및 4 장, *클라우드 네이티브 통신 패턴*을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="8c236-410">Backing services are discussed in detail Chapter 5, *Cloud-Native Data Patterns*, and Chapter 4, *Cloud-Native Communication Patterns*.</span></span>

## <a name="automation"></a><span data-ttu-id="8c236-411">Automation</span><span class="sxs-lookup"><span data-stu-id="8c236-411">Automation</span></span>

<span data-ttu-id="8c236-412">앞서 살펴본 것 처럼 클라우드 네이티브 시스템은 마이크로 서비스, 컨테이너 및 최신 시스템 디자인을 수용 하 여 속도와 민첩성을 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-412">As you've seen, cloud-native systems embrace microservices, containers, and modern system design to achieve speed and agility.</span></span> <span data-ttu-id="8c236-413">그러나이는 스토리의 일부일 뿐입니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-413">But, that's only part of the story.</span></span> <span data-ttu-id="8c236-414">이러한 시스템이 실행 되는 클라우드 환경을 프로 비전 하려면 어떻게 해야 하나요?</span><span class="sxs-lookup"><span data-stu-id="8c236-414">How do you provision the cloud environments upon which these systems run?</span></span> <span data-ttu-id="8c236-415">앱 기능 및 업데이트를 신속 하 게 배포 하려면 어떻게 해야 하나요?</span><span class="sxs-lookup"><span data-stu-id="8c236-415">How do you rapidly deploy app features and updates?</span></span> <span data-ttu-id="8c236-416">전체 사진을 어떻게 반올림 하나요?</span><span class="sxs-lookup"><span data-stu-id="8c236-416">How do you round out the full picture?</span></span>

<span data-ttu-id="8c236-417">널리 승인 된 인프라 사례를 [코드](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code)또는 IaC로 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-417">Enter the widely accepted practice of [Infrastructure as Code](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code), or IaC.</span></span>

<span data-ttu-id="8c236-418">IaC를 사용 하 여 플랫폼 프로 비전 및 응용 프로그램 배포를 자동화 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-418">With IaC, you automate platform provisioning and application deployment.</span></span> <span data-ttu-id="8c236-419">기본적으로 DevOps 사례에 테스트 및 버전 관리와 같은 소프트웨어 엔지니어링 사례를 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-419">You essentially apply software engineering practices such as testing and versioning to your DevOps practices.</span></span> <span data-ttu-id="8c236-420">인프라 및 배포는 자동화 되 고 일관 되며 반복 가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-420">Your infrastructure and deployments are automated, consistent, and repeatable.</span></span>

### <a name="automating-infrastructure"></a><span data-ttu-id="8c236-421">인프라 자동화</span><span class="sxs-lookup"><span data-stu-id="8c236-421">Automating infrastructure</span></span>

<span data-ttu-id="8c236-422">[Azure Resource Manager](https://azure.microsoft.com/documentation/articles/resource-group-overview/), terraform 및 [Azure CLI](https://docs.microsoft.com/cli/azure/)와 같은 도구를 사용 하 여 필요한 클라우드 인프라를 선언적으로 스크립팅할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-422">Tools like [Azure Resource Manager](https://azure.microsoft.com/documentation/articles/resource-group-overview/), Terraform, and the [Azure CLI](https://docs.microsoft.com/cli/azure/), enable you to declaratively script the cloud infrastructure you require.</span></span> <span data-ttu-id="8c236-423">리소스 이름, 위치, 용량 및 암호는 매개 변수화 된 및 동적입니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-423">Resource names, locations, capacities, and secrets are parameterized and dynamic.</span></span> <span data-ttu-id="8c236-424">이 스크립트는 프로젝트의 아티팩트로 버전이 지정 되 고 소스 제어에 체크 인 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-424">The script is versioned and checked into source control as an artifact of your project.</span></span> <span data-ttu-id="8c236-425">스크립트를 호출 하 여 QA, 스테이징 및 프로덕션과 같은 시스템 환경에서 일관 되 고 반복 가능한 인프라를 프로 비전 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-425">You invoke the script to provision a consistent and repeatable infrastructure across system environments, such as QA, staging, and production.</span></span>

<span data-ttu-id="8c236-426">내부적으로, IaC는 idempotent 이며,이는 부작용 없이 동일한 스크립트를 반복 해 서 실행할 수 있음을 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-426">Under the hood, IaC is idempotent, meaning that you can run the same script over and over without side effects.</span></span> <span data-ttu-id="8c236-427">팀에서 변경 해야 하는 경우 스크립트를 편집 하 고 다시 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-427">If the team needs to make a change, they edit and rerun the script.</span></span> <span data-ttu-id="8c236-428">업데이트 된 리소스만 영향을 받습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-428">Only the updated resources are affected.</span></span>

<span data-ttu-id="8c236-429">문서에서 [코드로 서의 인프라 란 무엇](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code)이며, 제작자 Sam Guckenheimer는 "IaC를 구현 하는 팀이 안정적인 환경을 신속 하 고 대규모로 제공할 수 있는 방법에 대해 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-429">In the article, [What is Infrastructure as Code](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code), Author Sam Guckenheimer describes how, "Teams who implement IaC can deliver stable environments rapidly and at scale.</span></span> <span data-ttu-id="8c236-430">팀은 환경을 수동으로 구성 하는 것을 방지 하 고 코드를 통해 환경의 원하는 상태를 표시 하 여 일관성을 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-430">Teams avoid manual configuration of environments and enforce consistency by representing the desired state of their environments via code.</span></span> <span data-ttu-id="8c236-431">IaC를 사용 하 여 인프라를 배포 하는 것은 반복 가능 하며, 구성 드리프트 또는 누락 종속성으로 인 한 런타임 문제를 방지</span><span class="sxs-lookup"><span data-stu-id="8c236-431">Infrastructure deployments with IaC are repeatable and prevent runtime issues caused by configuration drift or missing dependencies.</span></span> <span data-ttu-id="8c236-432">DevOps 팀은 통합 된 사례 및 도구 집합과 함께 작업 하 여 응용 프로그램 및 지원 인프라를 신속 하 고 안정적 이며 대규모로 제공할 수 있습니다. "</span><span class="sxs-lookup"><span data-stu-id="8c236-432">DevOps teams can work together with a unified set of practices and tools to deliver applications and their supporting infrastructure rapidly, reliably, and at scale."</span></span>

### <a name="automating-deployments"></a><span data-ttu-id="8c236-433">배포 자동화</span><span class="sxs-lookup"><span data-stu-id="8c236-433">Automating deployments</span></span>

<span data-ttu-id="8c236-434">앞에서 설명한 [12 단계 응용 프로그램](https://12factor.net/)은 완성 된 코드를 실행 중인 응용 프로그램으로 변환할 때 별도의 단계를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-434">The [Twelve-Factor Application](https://12factor.net/), discussed earlier, calls for separate steps when transforming completed code into a running application.</span></span>

> <span data-ttu-id="8c236-435">*요소 \#5* 는 "각 릴리스가 빌드, 릴리스 및 실행 단계에서 엄격한 분리를 적용 해야 함을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-435">*Factor \#5* specifies that "Each release must enforce a strict separation across the build, release and run stages.</span></span> <span data-ttu-id="8c236-436">각각은 고유한 ID로 태그를 지정 하 고 롤백하는 기능을 지원 해야 합니다. "</span><span class="sxs-lookup"><span data-stu-id="8c236-436">Each should be tagged with a unique ID and support the ability to roll back."</span></span>

<span data-ttu-id="8c236-437">최신 CI/CD 시스템은이 원칙을 충족 하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-437">Modern CI/CD systems help fulfill this principle.</span></span> <span data-ttu-id="8c236-438">별도의 배포 단계를 제공 하 고 사용자가 쉽게 사용할 수 있는 일관 되 고 품질 코드를 보장 하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-438">They provide separate deployment steps and help ensure consistent and quality code that's readily available to users.</span></span>

<span data-ttu-id="8c236-439">그림 1-8에서는 배포 프로세스를 분리 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-439">Figure 1-8 shows the separation across the deployment process.</span></span>

![CI/CD 파이프라인의 배포 단계](./media/build-release-run-pipeline.png)

<span data-ttu-id="8c236-441">**그림 1-8**.</span><span class="sxs-lookup"><span data-stu-id="8c236-441">**Figure 1-8**.</span></span> <span data-ttu-id="8c236-442">CI/CD 파이프라인의 배포 단계</span><span class="sxs-lookup"><span data-stu-id="8c236-442">Deployment steps in a CI/CD Pipeline</span></span>

<span data-ttu-id="8c236-443">위의 그림에서는 작업 분리에 특히 주의를 기울여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-443">In the previous figure, pay special attention to separation of tasks.</span></span>

<span data-ttu-id="8c236-444">개발자는 개발 환경에서 기능을 생성 하 여 코드의 "내부 루프", 실행 및 디버그를 반복 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-444">The developer constructs a feature in their development environment, iterating through what is called the "inner loop" of code, run, and debug.</span></span> <span data-ttu-id="8c236-445">완료 되 면 코드는 GitHub, Azure DevOps 또는 BitBucket와 같은 코드 리포지토리로 *푸시됩니다* .</span><span class="sxs-lookup"><span data-stu-id="8c236-445">When complete, that code is *pushed* into a code repository, such as GitHub, Azure DevOps, or BitBucket.</span></span>

<span data-ttu-id="8c236-446">푸시는 코드를 이진 아티팩트로 변환 하는 빌드 단계를 트리거합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-446">The push triggers a build stage that transforms the code into a binary artifact.</span></span> <span data-ttu-id="8c236-447">작업은 [CI (지속적인 통합](https://martinfowler.com/articles/continuousIntegration.html) ) 파이프라인을 사용 하 여 구현 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-447">The work is implemented with a [Continuous Integration (CI)](https://martinfowler.com/articles/continuousIntegration.html) pipeline.</span></span> <span data-ttu-id="8c236-448">응용 프로그램을 자동으로 빌드, 테스트 및 패키지 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-448">It automatically builds, tests, and packages the application.</span></span>

<span data-ttu-id="8c236-449">릴리스 단계는 이진 아티팩트를 선택 하 고, 외부 응용 프로그램 및 환경 구성 정보를 적용 하 고, 변경할 수 없는 릴리스를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-449">The release stage picks up the binary artifact, applies external application and environment configuration information, and produces an immutable release.</span></span> <span data-ttu-id="8c236-450">릴리스가 지정 된 환경에 배포 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-450">The release is deployed to a specified environment.</span></span> <span data-ttu-id="8c236-451">작업은 CD (지속적인 업데이트 [)](https://martinfowler.com/bliki/ContinuousDelivery.html) 파이프라인을 사용 하 여 구현 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-451">The work is implemented with a [Continuous Delivery(CD)](https://martinfowler.com/bliki/ContinuousDelivery.html) pipeline.</span></span> <span data-ttu-id="8c236-452">각 릴리스를 식별할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-452">Each release should be identifiable.</span></span> <span data-ttu-id="8c236-453">"이 배포가 응용 프로그램의 릴리스 2.1.1을 실행 하 고 있습니다." 라고 표시 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-453">You can say, "This deployment is running Release 2.1.1 of the application."</span></span>

<span data-ttu-id="8c236-454">마지막으로, 릴리스된 기능은 대상 실행 환경에서 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-454">Finally, the released feature is run in the target execution environment.</span></span> <span data-ttu-id="8c236-455">릴리스를 변경할 수 없습니다. 즉, 모든 변경 내용은 새 릴리스를 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-455">Releases are immutable meaning that any change must create a new release.</span></span>

<span data-ttu-id="8c236-456">이러한 사례를 적용 하면 조직에서 소프트웨어를 제공 하는 방법을 크게 진화 하 고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-456">Applying these practices, organizations have radically evolved how they ship software.</span></span> <span data-ttu-id="8c236-457">대다수는 분기별 릴리스에서 주문형 업데이트로 이동 했습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-457">Many have moved from quarterly releases to on-demand updates.</span></span> <span data-ttu-id="8c236-458">목표는 수정 비용이 저렴 한 개발 주기의 초기에 문제를 파악 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-458">The goal is to catch problems early in the development cycle when they're less expensive to fix.</span></span> <span data-ttu-id="8c236-459">통합 간의 지속 시간이 길수록 더 비싼 문제가 해결 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-459">The longer the duration between integrations, the more expensive problems become to resolve.</span></span>  <span data-ttu-id="8c236-460">통합 프로세스에서 일관성을 사용 하면 팀에서 코드 변경 내용을 더 자주 커밋할 수 있으므로 공동 작업 및 소프트웨어 품질을 높일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-460">With consistency in the integration process, teams can commit code changes more frequently, leading to better collaboration and software quality.</span></span>

### <a name="azure-pipelines"></a><span data-ttu-id="8c236-461">Azure Pipelines</span><span class="sxs-lookup"><span data-stu-id="8c236-461">Azure Pipelines</span></span>

<span data-ttu-id="8c236-462">Azure 클라우드에는 그림 1-9에 표시 된 [Azure DevOps](https://azure.microsoft.com/services/devops/) 제품의 일부인 [AZURE PIPELINES](https://azure.microsoft.com/services/devops/pipelines/)이라는 새로운 CI/CD 서비스가 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-462">The Azure cloud includes a new CI/CD service entitled [Azure Pipelines](https://azure.microsoft.com/services/devops/pipelines/), which is part of the [Azure DevOps](https://azure.microsoft.com/services/devops/) offering shown in Figure 1-9.</span></span>

![DevOps의 Azure Pipelines](./media/devops-components.png)

<span data-ttu-id="8c236-464">**그림 1-9**.</span><span class="sxs-lookup"><span data-stu-id="8c236-464">**Figure 1-9**.</span></span> <span data-ttu-id="8c236-465">Azure DevOps 제품</span><span class="sxs-lookup"><span data-stu-id="8c236-465">Azure DevOps offerings</span></span>

<span data-ttu-id="8c236-466">Azure Pipelines는 CI (지속적인 통합) 및 CD (지속적인 업데이트)를 결합 하는 클라우드 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-466">Azure Pipelines is a cloud service that combines continuous integration (CI) and continuous delivery (CD).</span></span> <span data-ttu-id="8c236-467">코드를 자동으로 테스트, 빌드 및 모든 대상에 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-467">You can automatically test, build, and ship your code to any target.</span></span>

<span data-ttu-id="8c236-468">앱에 대 한 코드의 나머지 부분과 함께 YAML 파일의 코드에서 파이프라인을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-468">You define your pipeline in code in a YAML file alongside the rest of the code for your app.</span></span>

- <span data-ttu-id="8c236-469">파이프라인은 코드를 사용 하 여 버전이 지정 되며 동일한 분기 구조를 따릅니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-469">The pipeline is versioned with your code and follows the same branching structure.</span></span>
- <span data-ttu-id="8c236-470">끌어오기 요청 및 분기 빌드 정책에서 코드 검토를 통해 변경 내용에 대 한 유효성을 검사 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-470">You get validation of your changes through code reviews in pull requests and branch build policies.</span></span>
- <span data-ttu-id="8c236-471">사용 하는 모든 분기는 azure-pipelines 파일을 수정 하 여 빌드 정책을 사용자 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-471">Every branch you use can customize the build policy by modifying the azure-pipelines.yml file.</span></span>
- <span data-ttu-id="8c236-472">파이프라인 파일이 버전 제어에 체크 인 되 고 문제가 있는 경우 조사할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-472">The pipeline file is checked into version control and can be investigated if there's a problem.</span></span>

<span data-ttu-id="8c236-473">Azure Pipelines 서비스는 대부분의 Git 공급자를 지원 하 고 Linux, macOS 또는 Windows 플랫폼에서 작성 된 응용 프로그램에 대 한 배포 파이프라인을 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-473">The Azure Pipelines service supports most Git providers and can generate deployment pipelines for applications written on the Linux, macOS, or Windows platforms.</span></span> <span data-ttu-id="8c236-474">여기에는 Java, .NET, JavaScript, Python, PHP, Go, XCode 및 c + +에 대 한 지원이 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c236-474">It includes support for Java, .NET, JavaScript, Python, PHP, Go, XCode, and C++.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="8c236-475">[이전](introduction.md)
>[다음](candidate-apps.md)</span><span class="sxs-lookup"><span data-stu-id="8c236-475">[Previous](introduction.md)
[Next](candidate-apps.md)</span></span>
