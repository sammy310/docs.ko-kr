---
title: 클라우드 전용 앱에 대 한 Azure 보안
description: Azure 용 클라우드 네이티브 .NET 앱 설계 | 클라우드 네이티브 앱에 대 한 Azure 보안
ms.date: 05/13/2020
ms.openlocfilehash: 223d9e77aca611697958981bf2ee3a630fb9fffb
ms.sourcegitcommit: e7748001b1cee80ced691d8a76ca814c0b02dd9b
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/14/2020
ms.locfileid: "86374496"
---
# <a name="azure-security-for-cloud-native-apps"></a><span data-ttu-id="afd6c-103">클라우드 전용 앱에 대 한 Azure 보안</span><span class="sxs-lookup"><span data-stu-id="afd6c-103">Azure security for cloud-native apps</span></span>

<span data-ttu-id="afd6c-104">클라우드 네이티브 응용 프로그램은 기존의 응용 프로그램 보다 쉽고 안전 하 게 보호할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-104">Cloud-native applications can be both easier and more difficult to secure than traditional applications.</span></span> <span data-ttu-id="afd6c-105">단점은 더 작은 응용 프로그램의 보안을 유지 하 고 보안 인프라를 빌드하기 위한 추가 에너지를 추가 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-105">On the downside, you need to secure more smaller applications and dedicate more energy to build out the security infrastructure.</span></span> <span data-ttu-id="afd6c-106">대부분의 서비스 배포에서 사용 되는 프로그래밍 언어 및 스타일의 다른 특성은 다양 한 공급자의 보안 게시판에 더 주의 해야 한다는 의미 이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-106">The heterogeneous nature of programming languages and styles in most service deployments also means you need to pay more attention to security bulletins from many different providers.</span></span>

<span data-ttu-id="afd6c-107">대칭 이동 측에서 각각 고유한 데이터 저장소가 있는 작은 서비스는 공격의 범위를 제한 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-107">On the flip side, smaller services, each with their own data store, limit the scope of an attack.</span></span> <span data-ttu-id="afd6c-108">공격자가 한 시스템을 손상 시키는 경우 공격자가 모놀리식 응용 프로그램에 있는 것 보다 다른 시스템으로 이동 하는 것이 더 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-108">If an attacker compromises one system, it's probably more difficult for the attacker to make the jump to another system than it is in a monolithic application.</span></span> <span data-ttu-id="afd6c-109">프로세스 경계는 강력한 경계입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-109">Process boundaries are strong boundaries.</span></span> <span data-ttu-id="afd6c-110">또한 데이터베이스 백업이 누수 되 면 해당 데이터베이스는 데이터의 하위 집합만 포함 하 고 개인 데이터를 포함할 가능성이 없기 때문에 손상이 더 제한적입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-110">Also, if a database backup leaks, then the damage is more limited, as that database contains only a subset of data and is unlikely to contain personal data.</span></span>

## <a name="threat-modeling"></a><span data-ttu-id="afd6c-111">위협 모델링</span><span class="sxs-lookup"><span data-stu-id="afd6c-111">Threat modeling</span></span>

<span data-ttu-id="afd6c-112">클라우드 네이티브 응용 프로그램의 단점 보다 장점에 관계 없이 동일한 전체적인 보안 마음가짐을 따라야 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-112">No matter if the advantages outweigh the disadvantages of cloud-native applications, the same holistic security mindset must be followed.</span></span> <span data-ttu-id="afd6c-113">보안 및 보안 고려는 개발 및 운영 스토리의 모든 단계에 포함 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-113">Security and secure thinking must be part of every step of the development and operations story.</span></span> <span data-ttu-id="afd6c-114">응용 프로그램을 계획할 때 다음과 같은 질문을 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-114">When planning an application ask questions like:</span></span>

- <span data-ttu-id="afd6c-115">이 데이터가 손실 되는 영향은 무엇 인가요?</span><span class="sxs-lookup"><span data-stu-id="afd6c-115">What would be the impact of this data being lost?</span></span>
- <span data-ttu-id="afd6c-116">잘못 된 데이터를이 서비스에 삽입 하는 것을 제한 하려면 어떻게 해야 하나요?</span><span class="sxs-lookup"><span data-stu-id="afd6c-116">How can we limit the damage from bad data being injected into this service?</span></span>
- <span data-ttu-id="afd6c-117">이 데이터에 액세스할 수 있는 사용자는 누구 인가요?</span><span class="sxs-lookup"><span data-stu-id="afd6c-117">Who should have access to this data?</span></span>
- <span data-ttu-id="afd6c-118">개발 및 릴리스 프로세스를 진행 하는 동안 감사 정책이 있나요?</span><span class="sxs-lookup"><span data-stu-id="afd6c-118">Are there auditing policies in place around the development and release process?</span></span>

<span data-ttu-id="afd6c-119">이러한 모든 질문은 [위협 모델링](https://docs.microsoft.com/azure/security/azure-security-threat-modeling-tool)이라는 프로세스의 일부입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-119">All these questions are part of a process called [threat modeling](https://docs.microsoft.com/azure/security/azure-security-threat-modeling-tool).</span></span> <span data-ttu-id="afd6c-120">이 프로세스는 시스템에 발생 하는 위협에 대 한 질문과 대답을 시도 합니다 .이는 위협에 대 한 위협 및 잠재적 손상입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-120">This process tries to answer the question of what threats there are to the system, how likely the threats are, and the potential damage from them.</span></span>

<span data-ttu-id="afd6c-121">위협 목록이 설정 된 후에는 완화 가치가 있는지 여부를 결정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-121">Once the list of threats has been established, you need to decide whether they're worth mitigating.</span></span> <span data-ttu-id="afd6c-122">경우에 따라 위협은 에너지를 지출 하지 않아도 되는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-122">Sometimes a threat is so unlikely and expensive to plan for that it isn't worth spending energy on it.</span></span> <span data-ttu-id="afd6c-123">예를 들어 일부 상태 수준 행위자는 수백만 개의 장치에서 사용 하는 프로세스 디자인에 변경 내용을 주입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-123">For instance, some state level actor could inject changes into the design of a process that is used by millions of devices.</span></span> <span data-ttu-id="afd6c-124">이제 [링 3](https://en.wikipedia.org/wiki/Protection_ring)에서 코드의 특정 부분을 실행 하는 대신 링 0에서 코드를 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-124">Now, instead of running a certain piece of code in [Ring 3](https://en.wikipedia.org/wiki/Protection_ring), that code is run in Ring 0.</span></span> <span data-ttu-id="afd6c-125">따라서 하이퍼바이저를 우회 하 고 운영 체제 미 설치 컴퓨터에서 공격 코드를 실행 하 여 해당 하드웨어에서 실행 되는 모든 가상 컴퓨터에 대 한 공격을 허용 하는 익스플로잇을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-125">This allows an exploit that can bypass the hypervisor and run the attack code on the bare metal machines, allowing attacks on all the virtual machines that are running on that hardware.</span></span>

<span data-ttu-id="afd6c-126">변경 된 프로세서는 해당 프로세서의 실리콘 디자인에 대 한 microscope 및 고급 지식 없이 검색 하기가 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-126">The altered processors are difficult to detect without a microscope and advanced knowledge of the on silicon design of that processor.</span></span> <span data-ttu-id="afd6c-127">이 시나리오는 발생 가능성이 낮지만 완화 비용이 많이 들기 때문에 위협 모델에 대 한 exploit protection 빌드를 권장 하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-127">This scenario is unlikely to happen and expensive to mitigate, so probably no threat model would recommend building exploit protection for it.</span></span>

<span data-ttu-id="afd6c-128">보안 `Id` 공격 (URL에서로 대체) 또는 SQL 삽입을 허용 하는 중단 된 액세스 제어와 같이 더 많은 위협 요소 `Id=2` `Id=3` 는에 대 한 보호를 구축 하는 데 더 유리 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-128">More likely threats, such as broken access controls permitting `Id` incrementing attacks (replacing `Id=2` with `Id=3` in the URL) or SQL injection, are more attractive to build protections against.</span></span> <span data-ttu-id="afd6c-129">이러한 위협에 대 한 완화는 회사의 명성를 smear 하는 당혹 보안 허점을 빌드하고 방지 하는 데 매우 적합 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-129">The mitigations for these threats are quite reasonable to build and prevent embarrassing security holes that smear the company's reputation.</span></span>

## <a name="principle-of-least-privilege"></a><span data-ttu-id="afd6c-130">최소 권한 원칙</span><span class="sxs-lookup"><span data-stu-id="afd6c-130">Principle of least privilege</span></span>

<span data-ttu-id="afd6c-131">컴퓨터 보안의 창립 아이디어 중 하나는 최소 권한의 원칙 (정책 정책)입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-131">One of the founding ideas in computer security is the Principle of Least Privilege (POLP).</span></span> <span data-ttu-id="afd6c-132">실제로는 대부분의 보안에서 디지털 또는 물리적 형식으로 기본 개념입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-132">It's actually a foundational idea in most any form of security be it digital or physical.</span></span> <span data-ttu-id="afd6c-133">즉, 사용자 또는 프로세스에는 태스크를 실행할 수 있는 최소한의 권한만 있으면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-133">In short, the principle is that any user or process should have the smallest number of rights possible to execute its task.</span></span>

<span data-ttu-id="afd6c-134">예를 들어 은행에서 사용한 은행 직원을 생각해 보겠습니다. safe에 액세스 하는 것은 일반적이 지 않은 활동입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-134">As an example, think of the tellers at a bank: accessing the safe is an uncommon activity.</span></span> <span data-ttu-id="afd6c-135">따라서 평균 인출기은 안전 하 게 열 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-135">So, the average teller can't open the safe themselves.</span></span> <span data-ttu-id="afd6c-136">액세스 권한을 얻으려면 추가 보안 검사를 수행 하는 은행 관리자를 통해 요청을 에스컬레이션 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-136">To gain access, they need to escalate their request through a bank manager, who performs additional security checks.</span></span>

<span data-ttu-id="afd6c-137">컴퓨터 시스템에서 가장 훌륭한 예는 데이터베이스에 연결 하는 사용자의 권한입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-137">In a computer system, a fantastic example is the rights of a user connecting to a database.</span></span> <span data-ttu-id="afd6c-138">대부분의 경우에는 데이터베이스 구조를 빌드하고 응용 프로그램을 실행 하는 데 사용 되는 단일 사용자 계정이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-138">In many cases, there's a single user account used to both build the database structure and run the application.</span></span> <span data-ttu-id="afd6c-139">극단적인 경우를 제외 하 고 응용 프로그램을 실행 하는 계정에는 스키마 정보를 업데이트할 수 있는 기능이 필요 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-139">Except in extreme cases, the account running the application doesn't need the ability to update schema information.</span></span> <span data-ttu-id="afd6c-140">다양 한 수준의 권한을 제공 하는 여러 계정이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-140">There should be several accounts that provide different levels of privilege.</span></span> <span data-ttu-id="afd6c-141">응용 프로그램은 테이블의 데이터에 대 한 읽기 및 쓰기 권한을 부여 하는 권한 수준만 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-141">The application should only use the permission level that grants read and write access to the data in the tables.</span></span> <span data-ttu-id="afd6c-142">이러한 종류의 보호는 데이터베이스 테이블을 삭제 하거나 악의적인 트리거를 도입 하기 위한 공격을 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-142">This kind of protection would eliminate attacks that aimed to drop database tables or introduce malicious triggers.</span></span>

<span data-ttu-id="afd6c-143">클라우드 네이티브 응용 프로그램을 빌드하는 거의 모든 부분은 최소 권한의 원칙을 기억 하는 데 도움이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-143">Almost every part of building a cloud-native application can benefit from remembering the principle of least privilege.</span></span> <span data-ttu-id="afd6c-144">역할 기반 액세스 제어 (RBAC)에서 방화벽, 네트워크 보안 그룹, 역할 및 범위를 설정할 때 재생 시 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-144">You can find it at play when setting up firewalls, network security groups, roles, and scopes in Role-based access control (RBAC).</span></span>

## <a name="penetration-testing"></a><span data-ttu-id="afd6c-145">침투 테스트</span><span class="sxs-lookup"><span data-stu-id="afd6c-145">Penetration testing</span></span>

<span data-ttu-id="afd6c-146">응용 프로그램이 더 복잡해 지 면 공격 벡터 수가 오류가 심각한 증가 속도로 늘어납니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-146">As applications become more complicated the number of attack vectors increases at an alarming rate.</span></span> <span data-ttu-id="afd6c-147">위협 모델링은 시스템을 구축 하는 사용자가 실행 하는 경향이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-147">Threat modeling is flawed in that it tends to be executed by the same people building the system.</span></span> <span data-ttu-id="afd6c-148">많은 개발자가 사용자 상호 작용을 구상 하 고 사용할 수 없는 사용자 인터페이스를 빌드하는 것과 같은 방식으로 대부분의 개발자는 공격 벡터를 모두 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-148">In the same way that many developers have trouble envisioning user interactions and then build unusable user interfaces, most developers have difficulty seeing every attack vector.</span></span> <span data-ttu-id="afd6c-149">또한 시스템을 빌드하는 개발자가 공격 방법에서 잘 익숙한 하 고 중요 한 문제가 발생 하지 않을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-149">It's also possible that the developers building the system aren't well versed in attack methodologies and miss something crucial.</span></span>

<span data-ttu-id="afd6c-150">침투 테스트 또는 "펜 테스트"는 시스템 공격을 시도 하기 위해 외부 행위자를 가져오는 과정을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-150">Penetration testing or "pen testing" involves bringing in external actors to attempt to attack the system.</span></span> <span data-ttu-id="afd6c-151">이러한 공격자는 외부 컨설팅 회사 또는 다른 개발자가 비즈니스의 다른 부분 으로부터 보안에 대해 잘 알고 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-151">These attackers may be an external consulting company or other developers with good security knowledge from another part of the business.</span></span> <span data-ttu-id="afd6c-152">맞춤형 전권에 게 시스템을 방해할 시도 하는 것이 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-152">They're given carte blanche to attempt to subvert the system.</span></span> <span data-ttu-id="afd6c-153">패치를 적용 해야 하는 광범위 한 보안 허점을 발견할 수 있는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-153">Frequently, they'll find extensive security holes that need to be patched.</span></span> <span data-ttu-id="afd6c-154">경우에 따라 공격 벡터가 CEO에 대해 피싱 공격을 악용 하는 것과 같이 완전히 예기치 않은 것입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-154">Sometimes the attack vector will be something totally unexpected like exploiting a phishing attack against the CEO.</span></span>

<span data-ttu-id="afd6c-155">Azure 자체는 [Microsoft 내 해커 팀](https://azure.microsoft.com/resources/videos/red-vs-blue-internal-security-penetration-testing-of-microsoft-azure/)의 공격을 지속적으로 진행 하 고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-155">Azure itself is constantly undergoing attacks from a [team of hackers inside Microsoft](https://azure.microsoft.com/resources/videos/red-vs-blue-internal-security-penetration-testing-of-microsoft-azure/).</span></span> <span data-ttu-id="afd6c-156">몇 년 동안이는 잠재적으로 치명적인 공격 벡터를 수십 개 검색 하 여 외부에서 악용 되기 전에 종료 했습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-156">Over the years, they've been the first to find dozens of potentially catastrophic attack vectors, closing them before they can be exploited externally.</span></span> <span data-ttu-id="afd6c-157">목표를 더 많이 영구 행위자는이를 이용 하려고 할 가능성이 더 높습니다. Azure 보다는 전 세계에 몇 가지 대상이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-157">The more tempting a target, the more likely that eternal actors will attempt to exploit it and there are a few targets in the world more tempting than Azure.</span></span>

## <a name="monitoring"></a><span data-ttu-id="afd6c-158">모니터링</span><span class="sxs-lookup"><span data-stu-id="afd6c-158">Monitoring</span></span>

<span data-ttu-id="afd6c-159">공격자가 응용 프로그램을 침투 하려고 하면 경고가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-159">Should an attacker attempt to penetrate an application, there should be some warning of it.</span></span> <span data-ttu-id="afd6c-160">서비스에서 로그를 검사 하 여 공격을 검색할 수 있는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-160">Frequently, attacks can be spotted by examining the logs from services.</span></span> <span data-ttu-id="afd6c-161">공격은 성공 하기 전에 발견 될 수 있는 telltale 기호를 그대로 둡니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-161">Attacks leave telltale signs that can be spotted before they succeed.</span></span> <span data-ttu-id="afd6c-162">예를 들어 공격자가 암호를 추측 하려고 시도 하면 로그인 시스템에 많은 요청이 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-162">For instance, an attacker attempting to guess a password will make many requests to a login system.</span></span> <span data-ttu-id="afd6c-163">로그인 시스템을 모니터링 하면 일반적인 액세스 패턴에 맞지 않는 이상한 패턴을 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-163">Monitoring around the login system can detect weird patterns that are out of line with the typical access pattern.</span></span> <span data-ttu-id="afd6c-164">이 모니터링을 경고로 전환 하 여 작업 자가 일종의 대책을 활성화 하도록 경고할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-164">This monitoring can be turned into an alert that can, in turn, alert an operations person to activate some sort of countermeasure.</span></span> <span data-ttu-id="afd6c-165">매우 성숙한 모니터링 시스템은 요청을 차단 하는 규칙을 사전에 추가 하거나 응답을 제한 하는 작업을 수행할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-165">A highly mature monitoring system might even take action based on these deviations proactively adding rules to block requests or throttle responses.</span></span>

## <a name="securing-the-build"></a><span data-ttu-id="afd6c-166">빌드 보안</span><span class="sxs-lookup"><span data-stu-id="afd6c-166">Securing the build</span></span>

<span data-ttu-id="afd6c-167">보안이 종종 간과 되는 한 가지 위치는 빌드 프로세스를 중심으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-167">One place where security is often overlooked is around the build process.</span></span> <span data-ttu-id="afd6c-168">안전 하지 않은 코드 또는 체크 인 된 자격 증명을 검색 하는 것과 같이 빌드에서 보안 검사를 실행 해야 하는 것은 아니지만 빌드 자체를 안전 하 게 보호 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-168">Not only should the build run security checks, such as scanning for insecure code or checked-in credentials, but the build itself should be secure.</span></span> <span data-ttu-id="afd6c-169">빌드 서버가 손상 되 면 해당 제품에 임의의 코드를 도입 하기 위한 환상적인 벡터를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-169">If the build server is compromised, then it provides a fantastic vector for introducing arbitrary code into the product.</span></span>

<span data-ttu-id="afd6c-170">공격자가 웹 응용 프로그램에 로그인 하는 사람의 암호를 도용 하려고 한다고 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-170">Imagine that an attacker is looking to steal the passwords of people signing into a web application.</span></span> <span data-ttu-id="afd6c-171">체크 아웃 된 코드를 수정 하 여 다른 서버로 로그인 요청을 미러링 하는 빌드 단계를 도입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-171">They could introduce a build step that modifies the checked-out code to mirror any login request to another server.</span></span> <span data-ttu-id="afd6c-172">다음 번에 코드가 빌드를 거치 면 자동으로 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-172">The next time code goes through the build, it's silently updated.</span></span> <span data-ttu-id="afd6c-173">소스 코드 취약점 검사는 빌드 전에 실행 될 때이를 catch 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-173">The source code vulnerability scanning won't catch this as it runs before the build.</span></span> <span data-ttu-id="afd6c-174">빌드 단계가 빌드 서버에 살고 있으므로 코드 검토에서이를 catch 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-174">Equally, nobody will catch it in a code review because the build steps live on the build server.</span></span> <span data-ttu-id="afd6c-175">악용 된 코드는 암호를 수집할 수 있는 프로덕션으로 이동 됩니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-175">The exploited code will go to production where it can harvest passwords.</span></span> <span data-ttu-id="afd6c-176">빌드 프로세스 변경 내용에 대 한 감사 로그가 없거나 감사를 최소한으로 모니터링 하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-176">Probably there's no audit log of the build process changes, or at least nobody monitoring the audit.</span></span>

<span data-ttu-id="afd6c-177">이는 시스템에서 중단 하는 데 사용할 수 있는 보이는 낮은 값 대상의 완벽 한 예입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-177">This is a perfect example of a seemingly low value target that can be used to break into the system.</span></span> <span data-ttu-id="afd6c-178">공격자가 시스템의 경계를 위반 하면 사용 권한을 상승 하는 방법을 찾기 위해 작업을 시작 하 여 원하는 위치에서 실제 피해를 일으킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-178">Once an attacker breaches the perimeter of the system, they can start working on finding ways to elevate their permissions to the point that they can cause real harm anywhere they like.</span></span>

## <a name="building-secure-code"></a><span data-ttu-id="afd6c-179">보안 코드 빌드</span><span class="sxs-lookup"><span data-stu-id="afd6c-179">Building secure code</span></span>

<span data-ttu-id="afd6c-180">.NET Framework은 이미 매우 안전한 프레임 워크입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-180">.NET Framework is already a quite secure framework.</span></span> <span data-ttu-id="afd6c-181">배열의 끝을 탐색 하는 것과 같이 비관리 코드의 일부 문제를 방지 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-181">It avoids some of the pitfalls of unmanaged code, such as walking off the ends of arrays.</span></span> <span data-ttu-id="afd6c-182">검색 된 보안 허점을 해결 하기 위해 작업을 적극적으로 수행 하 고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-182">Work is actively done to fix security holes as they're discovered.</span></span> <span data-ttu-id="afd6c-183">프레임 워크에서 문제를 발견 하 고이를 악용 하는 대신 보고 하는 연구원을 지불 하는 [버그 포상 프로그램](https://www.microsoft.com/msrc/bounty) 도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-183">There's even a [bug bounty program](https://www.microsoft.com/msrc/bounty) that pays researchers to find issues in the framework and report them instead of exploiting them.</span></span>

<span data-ttu-id="afd6c-184">.NET 코드를 보다 안전 하 게 보호 하는 방법에는 여러 가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-184">There are many ways to make .NET code more secure.</span></span> <span data-ttu-id="afd6c-185">[.Net에 대 한 보안 코딩 지침](../../standard/security/secure-coding-guidelines.md) 과 같은 지침에 따라 코드를 처음부터 안전 하 게 유지 하기 위해 수행할 수 있는 적절 한 단계가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-185">Following guidelines such as the [Secure coding guidelines for .NET](../../standard/security/secure-coding-guidelines.md) article is a reasonable step to take to ensure that the code is secure from the ground up.</span></span> <span data-ttu-id="afd6c-186">[OWASP top 10](https://owasp.org/www-project-top-ten/) 은 보안 코드를 빌드하기 위한 또 다른 유용한 가이드입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-186">The [OWASP top 10](https://owasp.org/www-project-top-ten/) is another invaluable guide to build secure code.</span></span>

<span data-ttu-id="afd6c-187">빌드 프로세스는 검색 도구를 사용 하 여 프로덕션 환경으로 전환 하기 전에 소스 코드의 문제를 검색 하는 데 적합 한 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-187">The build process is a good place to put scanning tools to detect problems in source code before they make it into production.</span></span> <span data-ttu-id="afd6c-188">대부분의 프로젝트에는 일부 다른 패키지에 대 한 종속성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-188">Most every project has dependencies on some other packages.</span></span> <span data-ttu-id="afd6c-189">오래 된 패키지를 검색할 수 있는 도구는 야간 빌드의 문제를 파악 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-189">A tool that can scan for outdated packages will catch problems in a nightly build.</span></span> <span data-ttu-id="afd6c-190">Docker 이미지를 작성 하는 경우에도 기본 이미지에 알려진 취약성이 없는지 확인 하 고 확인 하는 것이 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-190">Even when building Docker images, it's useful to check and make sure that the base image doesn't have known vulnerabilities.</span></span> <span data-ttu-id="afd6c-191">어떤 경우에도 아무도 자격 증명을 체크 인하지 않았는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-191">Another thing to check is that nobody has accidentally checked in credentials.</span></span>

## <a name="built-in-security"></a><span data-ttu-id="afd6c-192">기본 제공 보안</span><span class="sxs-lookup"><span data-stu-id="afd6c-192">Built-in security</span></span>

<span data-ttu-id="afd6c-193">Azure는 대다수 사용자에 대 한 유용성 및 보안을 균형 있게 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-193">Azure is designed to balance usability and security for the majority of users.</span></span> <span data-ttu-id="afd6c-194">여러 사용자가 서로 다른 보안 요구 사항을 가지 므로 클라우드 보안에 대 한 접근 방식을 세밀 하 게 조정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-194">Different users are going to have different security requirements, so they need to fine-tune their approach to cloud security.</span></span> <span data-ttu-id="afd6c-195">Microsoft는 보안 [센터](https://azure.microsoft.com/support/trust-center/)에 상당한 보안 정보를 게시 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-195">Microsoft publishes a great deal of security information in the [Trust Center](https://azure.microsoft.com/support/trust-center/).</span></span> <span data-ttu-id="afd6c-196">이 리소스는 기본 제공 공격 완화 기술의 작동 방식을 이해 하는 데 관심이 있는 전문가를 위한 첫 번째 중지 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-196">This resource should be the first stop for those professionals interested in understanding how the built-in attack mitigation technologies work.</span></span>

<span data-ttu-id="afd6c-197">Azure Portal 내에서 [Azure Advisor](https://azure.microsoft.com/services/advisor/) 은 계속 해 서 환경을 검색 하 고 권장 사항을 적용 하는 시스템입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-197">Within the Azure portal, the [Azure Advisor](https://azure.microsoft.com/services/advisor/) is a system that is constantly scanning an environment and making recommendations.</span></span> <span data-ttu-id="afd6c-198">이러한 권장 사항 중 일부는 사용자의 비용을 절감할 수 있도록 설계 되었지만 다른 사용자는 저장소 컨테이너를 전 세계에 공개 하 고 Virtual Network으로 보호 하지 않는 등 안전 하지 않은 구성을 식별 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-198">Some of these recommendations are designed to save users money, but others are designed to identify potentially insecure configurations, such as having a storage container open to the world and not protected by a Virtual Network.</span></span>

## <a name="azure-network-infrastructure"></a><span data-ttu-id="afd6c-199">Azure 네트워크 인프라</span><span class="sxs-lookup"><span data-stu-id="afd6c-199">Azure network infrastructure</span></span>

<span data-ttu-id="afd6c-200">온-프레미스 배포 환경에서는 많은 양의 에너지를 네트워킹 설정 전용으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-200">In an on-premises deployment environment, a great deal of energy is dedicated to setting up networking.</span></span> <span data-ttu-id="afd6c-201">라우터, 스위치 등을 설정 하는 것은 복잡 한 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-201">Setting up routers, switches, and the such is complicated work.</span></span> <span data-ttu-id="afd6c-202">네트워크를 사용 하면 특정 리소스가 다른 리소스와 통신 하 고 일부 경우에는 액세스를 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-202">Networks allow certain resources to talk to other resources and prevent access in some cases.</span></span> <span data-ttu-id="afd6c-203">자주 발생 하는 네트워크 규칙은 개발 환경에서 프로덕션 환경에 대 한 액세스를 제한 하는 것입니다 .이는 awry 코드의 절반을 실행 하 고 swath 데이터를 삭제 하는 경우를 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-203">A frequent network rule is to restrict access to the production environment from the development environment on the off chance that a half-developed piece of code runs awry and deletes a swath of data.</span></span>

<span data-ttu-id="afd6c-204">기본적으로 대부분의 PaaS Azure 리소스에는 가장 기본적인 및 허용 네트워킹 설정만 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-204">Out of the box, most PaaS Azure resources have only the most basic and permissive networking setup.</span></span> <span data-ttu-id="afd6c-205">예를 들어 인터넷의 모든 사람이 app service에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-205">For instance, anybody on the Internet can access an app service.</span></span> <span data-ttu-id="afd6c-206">새 SQL Server 인스턴스는 일반적으로 제한 되므로 외부 당사자가 액세스할 수 없지만 Azure 자체에서 사용 되는 IP 주소 범위는를 통해 허용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-206">New SQL Server instances typically come restricted, so that external parties can't access them, but the IP address ranges used by Azure itself are permitted through.</span></span> <span data-ttu-id="afd6c-207">따라서 SQL server를 외부 위협 으로부터 보호 하는 동안 공격자는 azure의 모든 SQL 인스턴스에 대 한 공격을 시작할 수 있는 Azure 브리지 헤드를 설정 하기만 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-207">So, while the SQL server is protected from external threats, an attacker only needs to set up an Azure bridgehead from where they can launch attacks against all SQL instances on Azure.</span></span>

<span data-ttu-id="afd6c-208">다행히 대부분의 Azure 리소스를 Azure Virtual Network에 배치 하 여 보다 세분화 된 액세스 제어를 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-208">Fortunately, most Azure resources can be placed into an Azure Virtual Network that allows finer grained access control.</span></span> <span data-ttu-id="afd6c-209">온-프레미스 네트워크에서 광범위 하 게 보호 되는 개인 네트워크를 설정 하는 방식과 마찬가지로, 가상 네트워크는 Azure 네트워크 내에 있는 개인 IP 주소의 아일랜드입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-209">Similar to the way that on-premises networks establish private networks that are protected from the wider world, virtual networks are islands of private IP addresses that are located within the Azure network.</span></span>

![그림 9-1 Azure의 가상 네트워크](./media/virtual-network.png)

<span data-ttu-id="afd6c-211">**그림 9-1**.</span><span class="sxs-lookup"><span data-stu-id="afd6c-211">**Figure 9-1**.</span></span> <span data-ttu-id="afd6c-212">Azure의 가상 네트워크입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-212">A virtual network in Azure.</span></span>

<span data-ttu-id="afd6c-213">온-프레미스 네트워크에서 네트워크에 대 한 액세스를 관리 하는 방화벽을 사용 하는 것과 같은 방식으로 가상 네트워크의 경계에서 유사한 방화벽을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-213">In the same way that on-premises networks have a firewall governing access to the network, you can establish a similar firewall at the boundary of the virtual network.</span></span> <span data-ttu-id="afd6c-214">기본적으로 가상 네트워크의 모든 리소스는 인터넷에 계속 통신할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-214">By default, all the resources on a virtual network can still talk to the Internet.</span></span> <span data-ttu-id="afd6c-215">특정 형식의 명시적인 방화벽 예외가 필요한 들어오는 연결입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-215">It's only incoming connections that require some form of explicit firewall exception.</span></span>

<span data-ttu-id="afd6c-216">네트워크를 설정 하면 저장소 계정과 같은 내부 리소스를 설정 하 여 Virtual Network에도 있는 리소스만 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-216">With the network established, internal resources like storage accounts can be set up to only allow for access by resources that are also on the Virtual Network.</span></span> <span data-ttu-id="afd6c-217">이 방화벽은 추가 보안 수준을 제공 하며, 해당 저장소 계정에 대 한 키가 유출 되는 경우 공격자가 유출 된 키를 악용 하기 위해 연결 하지 못할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-217">This firewall provides an extra level of security, should the keys for that storage account be leaked, attackers wouldn't be able to connect to it to exploit the leaked keys.</span></span> <span data-ttu-id="afd6c-218">이는 최소 권한의 원칙에 대 한 또 다른 예입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-218">This is another example of the principle of least privilege.</span></span>

<span data-ttu-id="afd6c-219">Azure Kubernetes 클러스터의 노드는 Azure의 기본이 되는 다른 리소스와 마찬가지로 가상 네트워크에 참여할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-219">The nodes in an Azure Kubernetes cluster can participate in a virtual network just like other resources that are more native to Azure.</span></span> <span data-ttu-id="afd6c-220">이 기능을 [Azure Container 네트워킹 인터페이스](https://github.com/Azure/azure-container-networking/blob/master/docs/cni.md)라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-220">This functionality is called [Azure Container Networking Interface](https://github.com/Azure/azure-container-networking/blob/master/docs/cni.md).</span></span> <span data-ttu-id="afd6c-221">실제로 가상 컴퓨터 및 컨테이너 이미지가 할당 되는 가상 네트워크 내에서 서브넷을 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-221">In effect, it allocates a subnet within the virtual network on which virtual machines and container images are allocated.</span></span>

<span data-ttu-id="afd6c-222">최소 권한의 원칙을 설명 하는 경로를 계속 하 고 Virtual Network 내의 모든 리소스가 다른 모든 리소스와 통신 해야 하는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-222">Continuing down the path of illustrating the principle of least privilege, not every resource within a Virtual Network needs to talk to every other resource.</span></span> <span data-ttu-id="afd6c-223">예를 들어 저장소 계정 및 SQL database에 대해 web API를 제공 하는 응용 프로그램에서 데이터베이스와 저장소 계정이 서로 통신 해야 하는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-223">For instance, in an application that provides a web API over a storage account and a SQL database, it's unlikely that the database and the storage account need to talk to one another.</span></span> <span data-ttu-id="afd6c-224">이러한 데이터 간의 데이터 공유는 웹 응용 프로그램을 통해 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-224">Any data sharing between them would go through the web application.</span></span> <span data-ttu-id="afd6c-225">따라서 [NSG (네트워크 보안 그룹)](https://docs.microsoft.com/azure/virtual-network/security-overview) 를 사용 하 여 두 서비스 간의 트래픽을 거부할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-225">So, a [network security group (NSG)](https://docs.microsoft.com/azure/virtual-network/security-overview) could be used to deny traffic between the two services.</span></span>

<span data-ttu-id="afd6c-226">리소스 간의 통신을 거부 하는 정책은 특히 트래픽 제한 없이 Azure를 사용 하는 백그라운드에서 구현 하기에 방해가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-226">A policy of denying communication between resources can be annoying to implement, especially coming from a background of using Azure without traffic restrictions.</span></span> <span data-ttu-id="afd6c-227">일부 다른 클라우드에서는 네트워크 보안 그룹의 개념이 훨씬 더 널리 활용 되 고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-227">On some other clouds, the concept of network security groups is much more prevalent.</span></span> <span data-ttu-id="afd6c-228">예를 들어 AWS에 대 한 기본 정책은 NSG의 규칙에 의해 활성화 될 때까지 리소스가 자신 간에 통신할 수 없다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-228">For instance, the default policy on AWS is that resources can't communicate among themselves until enabled by rules in an NSG.</span></span> <span data-ttu-id="afd6c-229">이를 개발 하는 데는 느리지만 더 제한적인 환경에서 보다 안전한 기본값을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-229">While slower to develop this, more restrictive environment provides a more secure default.</span></span> <span data-ttu-id="afd6c-230">특히 [Azure Resource Manager 또는 Terraform](infrastructure-as-code.md) 을 사용 하 여 사용 권한을 관리 하는 적절 한 devops 방법을 사용 하면 규칙을 보다 쉽게 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-230">Making use of proper DevOps practices, especially using [Azure Resource Manager or Terraform](infrastructure-as-code.md) to manage permissions can make controlling the rules easier.</span></span>

<span data-ttu-id="afd6c-231">가상 네트워크는 온-프레미스와 클라우드 리소스 간에 통신을 설정 하는 경우에도 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-231">Virtual Networks can also be useful when setting up communication between on-premises and cloud resources.</span></span> <span data-ttu-id="afd6c-232">가상 개인 네트워크를 사용 하 여 두 네트워크를 원활 하 게 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-232">A virtual private network can be used to seamlessly attach the two networks together.</span></span> <span data-ttu-id="afd6c-233">이렇게 하면 모든 사용자가 사이트에 있는 시나리오에 대해 어떤 종류의 게이트웨이 없이도 가상 네트워크를 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-233">This allows running a virtual network without any sort of gateway for scenarios where all the users are on-site.</span></span> <span data-ttu-id="afd6c-234">이 네트워크를 설정 하는 데 사용할 수 있는 여러 기술이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-234">There are a number of technologies that can be used to establish this network.</span></span> <span data-ttu-id="afd6c-235">가장 간단한 방법은 많은 라우터와 Azure 간에 설정할 수 있는 [사이트 간 VPN](https://docs.microsoft.com/azure/vpn-gateway/vpn-gateway-about-vpngateways?toc=%2fazure%2fvirtual-network%2ftoc.json#s2smulti) 을 사용 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-235">The simplest is to use a [site-to-site VPN](https://docs.microsoft.com/azure/vpn-gateway/vpn-gateway-about-vpngateways?toc=%2fazure%2fvirtual-network%2ftoc.json#s2smulti) that can be established between many routers and Azure.</span></span> <span data-ttu-id="afd6c-236">트래픽은 인터넷을 통해 다른 트래픽과 동일한 요금으로 암호화 되 고 터널링 됩니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-236">Traffic is encrypted and tunneled over the Internet at the same cost per byte as any other traffic.</span></span> <span data-ttu-id="afd6c-237">더 많은 대역폭이 나 더 많은 보안이 필요한 시나리오의 경우 Azure는 온-프레미스 네트워크와 Azure 간에 개인 회로를 사용 하는 [Express Route](https://docs.microsoft.com/azure/vpn-gateway/vpn-gateway-about-vpngateways?toc=%2fazure%2fvirtual-network%2ftoc.json#ExpressRoute) 라는 서비스를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-237">For scenarios where more bandwidth or more security is desirable, Azure offers a service called [Express Route](https://docs.microsoft.com/azure/vpn-gateway/vpn-gateway-about-vpngateways?toc=%2fazure%2fvirtual-network%2ftoc.json#ExpressRoute) that uses a private circuit between an on-premises network and Azure.</span></span> <span data-ttu-id="afd6c-238">비용이 많이 들고 설정 하기가 어렵고 보안도 향상 됩니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-238">It's more costly and difficult to establish but also more secure.</span></span>

## <a name="role-based-access-control-for-restricting-access-to-azure-resources"></a><span data-ttu-id="afd6c-239">Azure 리소스에 대 한 액세스를 제한 하는 역할 기반 액세스 제어</span><span class="sxs-lookup"><span data-stu-id="afd6c-239">Role-based access control for restricting access to Azure resources</span></span>

<span data-ttu-id="afd6c-240">RBAC는 Azure에서 실행 되는 응용 프로그램에 id를 제공 하는 시스템입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-240">RBAC is a system that provides an identity to applications running in Azure.</span></span> <span data-ttu-id="afd6c-241">응용 프로그램은 키 또는 암호를 사용 하는 대신이 id를 사용 하 여 리소스에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-241">Applications can access resources using this identity instead of or in addition to using keys or passwords.</span></span>

## <a name="security-principals"></a><span data-ttu-id="afd6c-242">보안 주체</span><span class="sxs-lookup"><span data-stu-id="afd6c-242">Security Principals</span></span>

<span data-ttu-id="afd6c-243">RBAC의 첫 번째 구성 요소는 보안 주체입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-243">The first component in RBAC is a security principal.</span></span> <span data-ttu-id="afd6c-244">보안 주체는 사용자, 그룹, 서비스 주체 또는 관리 id 일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-244">A security principal can be a user, group, service principal, or managed identity.</span></span>

![그림 9-2 다양 한 유형의 보안 주체](./media/rbac-security-principal.png)

<span data-ttu-id="afd6c-246">**그림9-2**</span><span class="sxs-lookup"><span data-stu-id="afd6c-246">**Figure 9-2**.</span></span> <span data-ttu-id="afd6c-247">여러 유형의 보안 주체입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-247">Different types of security principals.</span></span>

- <span data-ttu-id="afd6c-248">사용자-Azure Active Directory 계정이 있는 사용자는 사용자입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-248">User - Any user who has an account in Azure Active Directory is a user.</span></span>
- <span data-ttu-id="afd6c-249">Group-Azure Active Directory의 사용자 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-249">Group - A collection of users from Azure Active Directory.</span></span> <span data-ttu-id="afd6c-250">사용자는 그룹의 멤버로 서 해당 그룹의 역할 뿐만 아니라 해당 그룹의 역할을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-250">As a member of a group, a user takes on the roles of that group in addition to their own.</span></span>
- <span data-ttu-id="afd6c-251">서비스 사용자-서비스 또는 응용 프로그램을 실행 하는 보안 id입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-251">Service principal - A security identity under which services or applications run.</span></span>
- <span data-ttu-id="afd6c-252">관리 id-Azure에서 관리 하는 Azure Active Directory id입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-252">Managed identity - An Azure Active Directory identity managed by Azure.</span></span> <span data-ttu-id="afd6c-253">관리 id는 Azure 서비스 인증을 위해 자격 증명을 관리 하는 클라우드 응용 프로그램을 개발할 때 일반적으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-253">Managed identities are typically used when developing cloud applications that manage the credentials for authenticating to Azure services.</span></span>

<span data-ttu-id="afd6c-254">보안 주체를 대부분의 리소스에 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-254">The security principal can be applied to most any resource.</span></span> <span data-ttu-id="afd6c-255">즉, Azure Kubernetes 내에서 실행 되는 컨테이너에 보안 주체를 할당 하 여 Key Vault에 저장 된 비밀에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-255">This means that it's possible to assign a security principal to a container running within Azure Kubernetes, allowing it to access secrets stored in Key Vault.</span></span> <span data-ttu-id="afd6c-256">Azure 함수는 호출 하는 사용자에 대 한 JWT의 유효성을 검사 하기 위해 Active Directory 인스턴스와 통신할 수 있는 권한을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-256">An Azure Function could take on a permission allowing it to talk to an Active Directory instance to validate a JWT for a calling user.</span></span> <span data-ttu-id="afd6c-257">서비스 주체를 사용 하 여 서비스를 사용 하도록 설정한 후에는 역할 및 범위를 사용 하 여 세부적으로 권한을 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-257">Once services are enabled with a service principal, their permissions can be managed granularly using roles and scopes.</span></span>

## <a name="roles"></a><span data-ttu-id="afd6c-258">역할</span><span class="sxs-lookup"><span data-stu-id="afd6c-258">Roles</span></span>

<span data-ttu-id="afd6c-259">보안 주체는 많은 역할을 수행 하거나 많은 sartorial를 사용 하 여 많은 모자를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-259">A security principal can take on many roles or, using a more sartorial analogy, wear many hats.</span></span> <span data-ttu-id="afd6c-260">각 역할은 "Azure Service Bus 끝점에서 메시지 읽기"와 같은 일련의 사용 권한을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-260">Each role defines a series of permissions such as "Read messages from Azure Service Bus endpoint".</span></span> <span data-ttu-id="afd6c-261">보안 주체의 유효 사용 권한 집합은 보안 주체가 갖는 모든 역할에 할당 된 모든 사용 권한의 조합입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-261">The effective permission set of a security principal is the combination of all the permissions assigned to all the roles that security principal has.</span></span> <span data-ttu-id="afd6c-262">Azure에는 다양 한 기본 제공 역할이 있으며 사용자는 자신의 역할을 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-262">Azure has a large number of built-in roles and users can define their own roles.</span></span>

![그림 9-3 RBAC 역할 정의](./media/rbac-role-definition.png)

<span data-ttu-id="afd6c-264">**그림 9-3**</span><span class="sxs-lookup"><span data-stu-id="afd6c-264">**Figure 9-3**.</span></span> <span data-ttu-id="afd6c-265">RBAC 역할 정의.</span><span class="sxs-lookup"><span data-stu-id="afd6c-265">RBAC role definitions.</span></span>

<span data-ttu-id="afd6c-266">또한 Azure에는 소유자, 참가자, 읽기 권한자 및 사용자 계정 관리자와 같은 많은 고급 역할이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-266">Built into Azure are also a number of high-level roles such as Owner, Contributor, Reader, and User Account Administrator.</span></span> <span data-ttu-id="afd6c-267">소유자 역할을 사용 하 여 보안 주체는 모든 리소스에 액세스 하 고 다른 사용자에 게 사용 권한을 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-267">With the Owner role, a security principal can access all resources and assign permissions to others.</span></span> <span data-ttu-id="afd6c-268">참여자는 모든 리소스에 대해 동일한 수준의 액세스를 갖지만 사용 권한을 할당할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-268">A contributor has the same level of access to all resources but they can't assign permissions.</span></span> <span data-ttu-id="afd6c-269">판독기는 기존 Azure 리소스만 볼 수 있으며 사용자 계정 관리자는 Azure 리소스에 대 한 액세스를 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-269">A Reader can only view existing Azure resources and a User Account Administrator can manage access to Azure resources.</span></span>

<span data-ttu-id="afd6c-270">[DNS 영역 참가자](https://docs.microsoft.com/azure/role-based-access-control/built-in-roles#dns-zone-contributor) 와 같은 보다 세부적인 기본 제공 역할에는 단일 서비스로 제한 된 권한이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-270">More granular built-in roles such as [DNS Zone Contributor](https://docs.microsoft.com/azure/role-based-access-control/built-in-roles#dns-zone-contributor) have rights limited to a single service.</span></span> <span data-ttu-id="afd6c-271">보안 주체는 원하는 수의 역할을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-271">Security principals can take on any number of roles.</span></span>

## <a name="scopes"></a><span data-ttu-id="afd6c-272">범위</span><span class="sxs-lookup"><span data-stu-id="afd6c-272">Scopes</span></span>

<span data-ttu-id="afd6c-273">역할은 Azure 내에서 제한 된 리소스 집합에 적용 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-273">Roles can be applied to a restricted set of resources within Azure.</span></span> <span data-ttu-id="afd6c-274">예를 들어 Service Bus 큐에서 읽기의 이전 예제에 범위를 적용 하면 단일 큐에 대 한 사용 권한을 좁힐 수 있습니다. "Azure Service Bus 끝점에서 메시지 읽기 `blah.servicebus.windows.net/queue1` "</span><span class="sxs-lookup"><span data-stu-id="afd6c-274">For instance, applying scope to the previous example of reading from a Service Bus queue, you can narrow the permission to a single queue: "Read messages from Azure Service Bus endpoint `blah.servicebus.windows.net/queue1`"</span></span>

<span data-ttu-id="afd6c-275">범위는 단일 리소스로 좁힐 수 있으며 전체 리소스 그룹, 구독 또는 관리 그룹에도 적용 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-275">The scope can be as narrow as a single resource or it can be applied to an entire resource group, subscription, or even management group.</span></span>

<span data-ttu-id="afd6c-276">보안 주체에 특정 사용 권한이 있는지 테스트할 때 역할 및 범위의 조합이 고려 됩니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-276">When testing if a security principal has a certain permission, the combination of role and scope are taken into account.</span></span> <span data-ttu-id="afd6c-277">이 조합은 강력한 권한 부여 메커니즘을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-277">This combination provides a powerful authorization mechanism.</span></span>

## <a name="deny"></a><span data-ttu-id="afd6c-278">Deny</span><span class="sxs-lookup"><span data-stu-id="afd6c-278">Deny</span></span>

<span data-ttu-id="afd6c-279">이전에는 RBAC에 대해 "허용" 규칙만 허용 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-279">Previously, only "allow" rules were permitted for RBAC.</span></span> <span data-ttu-id="afd6c-280">이 동작은 일부 범위를 빌드하기에 복잡 했습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-280">This behavior made some scopes complicated to build.</span></span> <span data-ttu-id="afd6c-281">예를 들어 잠재적으로 무한 한 저장소 계정 목록에 명시적 사용 권한을 부여 하는 것을 제외 하 고 모든 저장소 계정에 대 한 보안 주체 액세스를 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-281">For instance, allowing a security principal access to all storage accounts except one required granting explicit permission to a potentially endless list of storage accounts.</span></span> <span data-ttu-id="afd6c-282">새 저장소 계정을 만들 때마다이 계정 목록에 추가 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-282">Every time a new storage account was created, it would have to be added to this list of accounts.</span></span> <span data-ttu-id="afd6c-283">이로 인해 바람직하지 않은 관리 오버 헤드가 발생 했습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-283">This added management overhead that certainly wasn't desirable.</span></span>

<span data-ttu-id="afd6c-284">거부 규칙은 허용 규칙 보다 우선적으로 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-284">Deny rules take precedence over allow rules.</span></span> <span data-ttu-id="afd6c-285">이제 동일한 "모두 허용" 범위를 표시 하는 것이 두 개의 규칙 인 "모두 허용" 및 "특정 한 항목 거부"로 표시 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-285">Now representing the same "allow all but one" scope could be represented as two rules "allow all" and "deny this one specific one".</span></span> <span data-ttu-id="afd6c-286">거부 규칙은 관리를 용이 하 게 할 뿐만 아니라, 모든 사람에 대 한 액세스를 거부 하 여 추가 보안 된 리소스를 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-286">Deny rules not only ease management but allow for resources that are extra secure by denying access to everybody.</span></span>

## <a name="checking-access"></a><span data-ttu-id="afd6c-287">액세스 확인</span><span class="sxs-lookup"><span data-stu-id="afd6c-287">Checking access</span></span>

<span data-ttu-id="afd6c-288">짐작할 수 있듯이, 많은 수의 역할 및 범위를 사용 하는 경우 서비스 주체의 유효 사용 권한을 파악 하기가 매우 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-288">As you can imagine, having a large number of roles and scopes can make figuring out the effective permission of a service principal quite difficult.</span></span> <span data-ttu-id="afd6c-289">누적 거부 규칙을 기반으로 하 여 복잡성을 높이는 역할만 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-289">Piling deny rules on top of that, only serves to increase the complexity.</span></span> <span data-ttu-id="afd6c-290">다행히 모든 서비스 사용자에 대 한 유효 사용 권한을 표시할 수 있는 사용 권한 계산기가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-290">Fortunately, there's a permissions calculator that can show the effective permissions for any service principal.</span></span> <span data-ttu-id="afd6c-291">일반적으로 그림 10-3에 표시 된 것 처럼 포털의 IAM 탭 아래에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-291">It's typically found under the IAM tab in the portal, as shown in Figure 10-3.</span></span>

![그림 9-4 app service에 대 한 권한 계산기](./media/check-rbac.png)

<span data-ttu-id="afd6c-293">**그림 9-4**.</span><span class="sxs-lookup"><span data-stu-id="afd6c-293">**Figure 9-4**.</span></span> <span data-ttu-id="afd6c-294">App service에 대 한 사용 권한 계산기입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-294">Permission calculator for an app service.</span></span>

## <a name="securing-secrets"></a><span data-ttu-id="afd6c-295">비밀 보호</span><span class="sxs-lookup"><span data-stu-id="afd6c-295">Securing secrets</span></span>

<span data-ttu-id="afd6c-296">암호 및 인증서는 공격자를 위한 일반적인 공격 벡터입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-296">Passwords and certificates are a common attack vector for attackers.</span></span> <span data-ttu-id="afd6c-297">암호 크랙 하드웨어는 무차별 암호 대입 공격을 수행할 수 있으며 초당 수십억 개의 암호를 추측 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-297">Password-cracking hardware can do a  brute-force attack and try to guess billions of passwords per second.</span></span> <span data-ttu-id="afd6c-298">따라서 리소스에 액세스 하는 데 사용 되는 암호는 강력 하 고 다양 한 문자를 사용 하는 것이 중요 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-298">So it's important that the passwords that are used to access resources are strong, with a large variety of characters.</span></span> <span data-ttu-id="afd6c-299">이러한 암호는 기억할 수 없는 암호의 종류와 정확히 일치 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-299">These passwords are exactly the kind of passwords that are near impossible to remember.</span></span> <span data-ttu-id="afd6c-300">다행히 Azure의 암호는 실제로 사용자가 알 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-300">Fortunately, the passwords in Azure don't actually need to be known by any human.</span></span>

<span data-ttu-id="afd6c-301">대부분의 보안 전문가는 암호 관리자를 사용 하 여 자신의 암호를 유지 하는 것이 가장 좋은 방법 이라고 [제안](https://www.troyhunt.com/password-managers-dont-have-to-be-perfect-they-just-have-to-be-better-than-not-having-one/) 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-301">Many security [experts suggest](https://www.troyhunt.com/password-managers-dont-have-to-be-perfect-they-just-have-to-be-better-than-not-having-one/) that using a password manager to keep your own passwords is the best approach.</span></span> <span data-ttu-id="afd6c-302">암호를 한 위치에 중앙 집중화 하는 동안 매우 복잡 한 암호를 사용 하 고 각 계정에 대해 고유 하 게 보장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-302">While it centralizes your passwords in one location, it also allows using highly complex passwords and ensuring they're unique for each account.</span></span> <span data-ttu-id="afd6c-303">Azure 내에 동일한 시스템이 있습니다. 암호에 대 한 중앙 저장소입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-303">The same system exists within Azure: a central store for secrets.</span></span>

## <a name="azure-key-vault"></a><span data-ttu-id="afd6c-304">Azure Key Vault</span><span class="sxs-lookup"><span data-stu-id="afd6c-304">Azure Key Vault</span></span>

<span data-ttu-id="afd6c-305">Azure Key Vault는 데이터베이스, API 키 및 인증서와 같은 항목에 대 한 암호를 저장 하는 중앙 위치를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-305">Azure Key Vault provides a centralized location to store passwords for things such as databases, API keys, and certificates.</span></span> <span data-ttu-id="afd6c-306">자격 증명 모음에 암호를 입력 하면 다시 표시 되지 않으며 추출 하는 명령은 의도적으로 복잡 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-306">Once a secret is entered into the Vault, it's never shown again and the commands to extract and view it are purposefully complicated.</span></span> <span data-ttu-id="afd6c-307">Safe의 정보는 소프트웨어 암호화 또는 FIPS 140-2 수준 2의 유효성을 검사 한 하드웨어 보안 모듈을 사용 하 여 보호 됩니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-307">The information in the safe is protected using either software encryption or FIPS 140-2 Level 2 validated Hardware Security Modules.</span></span>

<span data-ttu-id="afd6c-308">키 자격 증명 모음에 대 한 액세스는 RBACs를 통해 제공 됩니다. 즉, 사용자가 자격 증명 모음에 있는 정보에 액세스할 수 있는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-308">Access to the key vault is provided through RBACs, meaning that not just any user can access the information in the vault.</span></span> <span data-ttu-id="afd6c-309">웹 응용 프로그램이 Azure Key Vault에 저장 된 데이터베이스 연결 문자열에 액세스 하려는 경우를 예로 들어 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-309">Say a web application wishes to access the database connection string stored in Azure Key Vault.</span></span> <span data-ttu-id="afd6c-310">액세스 권한을 얻으려면 응용 프로그램은 서비스 주체를 사용 하 여 실행 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-310">To gain access, applications need to run using a service principal.</span></span> <span data-ttu-id="afd6c-311">이로 간주 되는 역할에서는 안전한 암호를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-311">Under this assumed role, they can read the secrets from the safe.</span></span> <span data-ttu-id="afd6c-312">응용 프로그램에서 자격 증명 모음에 대 한 액세스를 추가로 제한할 수 있도록 하는 다양 한 보안 설정이 있습니다. 암호를 업데이트할 수는 없으며 읽기만 가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-312">There are a number of different security settings that can further limit the access that an application has to the vault, so that it can't update secrets but only read them.</span></span>

<span data-ttu-id="afd6c-313">주요 자격 증명 모음에 대 한 액세스를 모니터링 하 여 예상 되는 응용 프로그램만 자격 증명 모음에 액세스할 수 있도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-313">Access to the key vault can be monitored to ensure that only the expected applications are accessing the vault.</span></span> <span data-ttu-id="afd6c-314">로그를 Azure Monitor에 다시 통합 하 여 예기치 않은 조건이 발생 하는 경우 경고를 설정 하는 기능을 해제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-314">The logs can be integrated back into Azure Monitor, unlocking the ability to set up alerts when unexpected conditions are encountered.</span></span>

## <a name="kubernetes"></a><span data-ttu-id="afd6c-315">Kubernetes</span><span class="sxs-lookup"><span data-stu-id="afd6c-315">Kubernetes</span></span>

<span data-ttu-id="afd6c-316">Kubernetes 내에는 작은 암호 정보를 유지 관리 하기 위한 유사한 서비스가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-316">Within Kubernetes, there's a similar service for maintaining small pieces of secret information.</span></span> <span data-ttu-id="afd6c-317">Kubernetes 암호는 일반적인 실행 파일을 통해 설정할 수 있습니다 `kubectl` .</span><span class="sxs-lookup"><span data-stu-id="afd6c-317">Kubernetes Secrets can be set via the typical `kubectl` executable.</span></span>

<span data-ttu-id="afd6c-318">암호 만들기는 저장할 값의 base64 버전을 찾는 것 만큼 간단 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-318">Creating a secret is as simple as finding the base64 version of the values to be stored:</span></span>

```console
echo -n 'admin' | base64
YWRtaW4=
echo -n '1f2d1e2e67df' | base64
MWYyZDFlMmU2N2Rm
```

<span data-ttu-id="afd6c-319">그런 다음 예를 들어 다음 예제와 같이 이라는 암호 파일에 추가 `secret.yml` 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-319">Then adding it to a secrets file named `secret.yml` for example that looks similar to the following example:</span></span>

```yml
apiVersion: v1
kind: Secret
metadata:
  name: mysecret
type: Opaque
data:
  username: YWRtaW4=
  password: MWYyZDFlMmU2N2Rm
```

<span data-ttu-id="afd6c-320">마지막으로 다음 명령을 실행 하 여 Kubernetes에이 파일을 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-320">Finally, this file can be loaded into Kubernetes by running the following command:</span></span>

```console
kubectl apply -f ./secret.yaml
```

<span data-ttu-id="afd6c-321">그런 다음 이러한 암호를 볼륨에 탑재 하거나 환경 변수를 통해 컨테이너 프로세스에 노출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-321">These secrets can then be mounted into volumes or exposed to container processes through environment variables.</span></span> <span data-ttu-id="afd6c-322">응용 프로그램 빌드에 대 한 [12 단계 앱](https://12factor.net/) 접근 방식은 응용 프로그램에 설정을 전송 하는 데 가장 낮은 공통 분모를 사용 하는 것을 제안 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-322">The [Twelve-factor app](https://12factor.net/) approach to building applications suggests using the lowest common denominator to transmit settings to an application.</span></span> <span data-ttu-id="afd6c-323">환경 변수는 운영 체제 또는 응용 프로그램에 상관 없이 지원 되기 때문에 가장 낮은 공통 분모입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-323">Environment variables are the lowest common denominator, because they're supported no matter the operating system or application.</span></span>

<span data-ttu-id="afd6c-324">기본 제공 Kubernetes 암호를 사용 하는 대신 Kubernetes 내에서 Azure Key Vault의 비밀에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-324">An alternative to use the built-in Kubernetes secrets is to access the secrets in Azure Key Vault from within Kubernetes.</span></span> <span data-ttu-id="afd6c-325">이 작업을 수행 하는 가장 간단한 방법은 암호를 로드 하는 컨테이너에 RBAC 역할을 할당 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-325">The simplest way to do this is to assign an RBAC role to the container looking to load secrets.</span></span> <span data-ttu-id="afd6c-326">그런 다음 응용 프로그램은 Azure Key Vault Api를 사용 하 여 암호에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-326">The application can then use the Azure Key Vault APIs to access the secrets.</span></span> <span data-ttu-id="afd6c-327">그러나이 방법은 코드를 수정 해야 하며 환경 변수를 사용 하는 패턴을 따르지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-327">However, this approach requires modifications to the code and doesn't follow the pattern of using environment variables.</span></span> <span data-ttu-id="afd6c-328">대신 [Azure Key Vault 인젝터](https://mrdevops.io/introducing-azure-key-vault-to-kubernetes-931f82364354)를 사용 하 여 컨테이너에 값을 삽입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-328">Instead, it's possible to inject values into a container through the use of the [Azure Key Vault Injector](https://mrdevops.io/introducing-azure-key-vault-to-kubernetes-931f82364354).</span></span> <span data-ttu-id="afd6c-329">이 방법은 클러스터의 사용자가 액세스할 수 있으므로 Kubernetes 암호를 직접 사용 하는 것 보다 실제로 더 안전 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-329">This approach is actually more secure than using the Kubernetes secrets directly, as they can be accessed by users on the cluster.</span></span>

## <a name="encryption-in-transit-and-at-rest"></a><span data-ttu-id="afd6c-330">전송 중 및 미사용 암호화</span><span class="sxs-lookup"><span data-stu-id="afd6c-330">Encryption in transit and at rest</span></span>

<span data-ttu-id="afd6c-331">데이터를 안전 하 게 유지 하는 것은 디스크에 있든, 다양 한 다른 서비스 간에 전송을 관계 없이 중요 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-331">Keeping data safe is important whether it's on disk or transiting between various different services.</span></span> <span data-ttu-id="afd6c-332">데이터 누수를 방지 하는 가장 효과적인 방법은 다른 사람이 쉽게 읽을 수 없는 형식으로 암호화 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-332">The most effective way to keep data from leaking is to encrypt it into a format that can't be easily read by others.</span></span> <span data-ttu-id="afd6c-333">Azure는 다양 한 암호화 옵션을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-333">Azure supports a wide range of encryption options.</span></span>

### <a name="in-transit"></a><span data-ttu-id="afd6c-334">전송 중</span><span class="sxs-lookup"><span data-stu-id="afd6c-334">In transit</span></span>

<span data-ttu-id="afd6c-335">Azure에서 네트워크의 트래픽을 암호화 하는 방법에는 여러 가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-335">There are several ways to encrypt traffic on the network in Azure.</span></span> <span data-ttu-id="afd6c-336">Azure 서비스에 대 한 액세스는 일반적으로 TLS (전송 계층 보안)를 사용 하는 연결을 통해 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-336">The access to Azure services is typically done over connections that use Transport Layer Security (TLS).</span></span> <span data-ttu-id="afd6c-337">예를 들어 Azure Api에 대 한 모든 연결에는 TLS 연결이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-337">For instance, all the connections to the Azure APIs require TLS connections.</span></span> <span data-ttu-id="afd6c-338">동일 하 게 Azure storage의 끝점에 대 한 연결은 TLS 암호화 연결에 대해서만 작동 하도록 제한할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-338">Equally, connections to endpoints in Azure storage can be restricted to work only over TLS encrypted connections.</span></span>

<span data-ttu-id="afd6c-339">TLS는 복잡 한 프로토콜 이며, 연결에서 TLS를 사용 하는 것은 보안을 보장 하는 데 충분 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-339">TLS is a complicated protocol and simply knowing that the connection is using TLS isn't sufficient to ensure security.</span></span> <span data-ttu-id="afd6c-340">예를 들어 TLS 1.0은 장기간 안전 하지 않으며 TLS 1.1이 훨씬 더 낫습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-340">For instance, TLS 1.0 is chronically insecure, and TLS 1.1 isn't much better.</span></span> <span data-ttu-id="afd6c-341">TLS 버전 내 에서도 더 쉽게 암호를 해독할 수 있도록 하는 다양 한 설정이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-341">Even within the versions of TLS, there are various settings that can make the connections easier to decrypt.</span></span> <span data-ttu-id="afd6c-342">가장 좋은 조치는 서버 연결에서 최신 및 잘 구성 된 프로토콜을 사용 하 고 있는지 확인 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-342">The best course of action is to check and see if the server connection is using up-to-date and well configured protocols.</span></span>

<span data-ttu-id="afd6c-343">이 확인은 SSL labs의 SSL 서버 테스트와 같은 외부 서비스에서 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-343">This check can be done by an external service such as SSL labs' SSL Server Test.</span></span> <span data-ttu-id="afd6c-344">일반적인 Azure 끝점에 대 한 테스트 실행 (이 경우 service bus 끝점)은 거의 완벽 한 점수를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-344">A test run against a typical Azure endpoint, in this case a service bus endpoint, yields a near perfect score of A.</span></span>

<span data-ttu-id="afd6c-345">Azure SQL 데이터베이스와 같은 서비스도 TLS 암호화를 사용 하 여 데이터를 숨김 상태로 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-345">Even services like Azure SQL databases use TLS encryption to keep data hidden.</span></span> <span data-ttu-id="afd6c-346">TLS를 사용 하 여 전송 중인 데이터를 암호화 하는 흥미로운 부분은 Microsoft가 TLS를 실행 하는 컴퓨터 간의 연결에서 수신 대기 하는 것이 불가능 하다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-346">The interesting part about encrypting the data in transit using TLS is that it isn't possible, even for Microsoft, to listen in on the connection between computers running TLS.</span></span> <span data-ttu-id="afd6c-347">이는 해당 데이터가 Microsoft의 적절 한 위험이 나 표준 공격자 보다 많은 리소스를 포함 하는 상태 행위자가 될 수 있다는 것을 걱정 하는 회사에 게 편안 하 게 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-347">This should provide comfort for companies concerned that their data may be at risk from Microsoft proper or even a state actor with more resources than the standard attacker.</span></span>

![그림 9-5 Service Bus 끝점에 대 한의 점수를 보여 주는 SSL labs 보고서](./media/ssl-report.png)

<span data-ttu-id="afd6c-349">**그림 9-5**.</span><span class="sxs-lookup"><span data-stu-id="afd6c-349">**Figure 9-5**.</span></span> <span data-ttu-id="afd6c-350">Service Bus 끝점에 대 한의 점수를 보여 주는 SSL labs 보고서입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-350">SSL labs report showing a score of A for a Service Bus endpoint.</span></span>

<span data-ttu-id="afd6c-351">이 암호화 수준은 항상 충분 하지는 않지만 Azure TLS 연결이 매우 안전 하다는 확신을 영감 야 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-351">While this level of encryption isn't going to be sufficient for all time, it should inspire confidence that Azure TLS connections are quite secure.</span></span> <span data-ttu-id="afd6c-352">Azure는 암호화가 향상 됨에 따라 보안 표준을 지속적으로 개선 하 고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-352">Azure will continue to evolve its security standards as encryption improves.</span></span> <span data-ttu-id="afd6c-353">보안 표준을 감시 하 고 Azure가 개선 될 때 Azure를 업데이트 한다는 것을 알고 있는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-353">It's nice to know that there's somebody watching the security standards and updating Azure as they improve.</span></span>

### <a name="at-rest"></a><span data-ttu-id="afd6c-354">미사용</span><span class="sxs-lookup"><span data-stu-id="afd6c-354">At rest</span></span>

<span data-ttu-id="afd6c-355">모든 응용 프로그램에는 데이터를 디스크에 저장 하는 여러 위치가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-355">In any application, there are a number of places where data rests on disk.</span></span> <span data-ttu-id="afd6c-356">응용 프로그램 코드 자체는 일부 저장소 메커니즘에서 로드 됩니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-356">The application code itself is loaded from some storage mechanism.</span></span> <span data-ttu-id="afd6c-357">또한 대부분의 응용 프로그램은 SQL Server, Cosmos DB 또는 놀라울 만큼 가격 효율적인 Table Storage 같은 일종의 데이터베이스를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-357">Most applications also use some kind of database such as SQL Server, Cosmos DB, or even the amazingly price-efficient Table Storage.</span></span> <span data-ttu-id="afd6c-358">이러한 데이터베이스는 모두 고도로 암호화 된 저장소를 사용 하 여 적절 한 권한을 가진 응용 프로그램이 아닌 다른 사용자가 데이터를 읽을 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-358">These databases all use heavily encrypted storage to ensure that nobody other than the applications with proper permissions can read your data.</span></span> <span data-ttu-id="afd6c-359">시스템 연산자도 암호화 된 데이터를 읽을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-359">Even the system operators can't read data that has been encrypted.</span></span> <span data-ttu-id="afd6c-360">따라서 고객은 비밀 정보를 비밀로 유지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-360">So customers can remain confident their secret information remains secret.</span></span>

### <a name="storage"></a><span data-ttu-id="afd6c-361">스토리지</span><span class="sxs-lookup"><span data-stu-id="afd6c-361">Storage</span></span>

<span data-ttu-id="afd6c-362">Azure의 토대 인는 Azure Storage 엔진입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-362">The underpinning of much of Azure is the Azure Storage engine.</span></span> <span data-ttu-id="afd6c-363">가상 컴퓨터 디스크는 Azure Storage 위에 탑재 됩니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-363">Virtual machine disks are mounted on top of Azure Storage.</span></span> <span data-ttu-id="afd6c-364">Azure Kubernetes 서비스는 자체가 Azure Storage에 호스트 되는 가상 머신에서 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-364">Azure Kubernetes Services run on virtual machines that, themselves, are hosted on Azure Storage.</span></span> <span data-ttu-id="afd6c-365">Azure Functions Apps 및 Azure Container Instances와 같은 서버 리스 기술은 Azure Storage의 일부인 디스크를 모두 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-365">Even serverless technologies, such as Azure Functions Apps and Azure Container Instances, run out of disk that is part of Azure Storage.</span></span>

<span data-ttu-id="afd6c-366">Azure Storage 잘 암호화 된 경우에는 다른 모든 항목을 암호화 하기 위한 기반을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-366">If Azure Storage is well encrypted, then it provides for a foundation for most everything else to also be encrypted.</span></span> <span data-ttu-id="afd6c-367">Azure Storage는 [FIPS 140-2](https://en.wikipedia.org/wiki/FIPS_140) 규격 [256 비트 AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard)로 [암호화 됩니다](https://docs.microsoft.com/azure/storage/common/storage-service-encryption) .</span><span class="sxs-lookup"><span data-stu-id="afd6c-367">Azure Storage [is encrypted](https://docs.microsoft.com/azure/storage/common/storage-service-encryption) with [FIPS 140-2](https://en.wikipedia.org/wiki/FIPS_140) compliant [256-bit AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard).</span></span> <span data-ttu-id="afd6c-368">이는 지난 20 년 동안 광범위 한 교육을 받은 암호화 기술입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-368">This is a well-regarded encryption technology having been the subject of extensive academic scrutiny over the last 20 or so years.</span></span> <span data-ttu-id="afd6c-369">현재는 키를 모르는 사람이 AES로 암호화 된 데이터를 읽을 수 있도록 하는 알려진 실제 공격이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-369">At present, there's no known practical attack that would allow someone without knowledge of the key to read data encrypted by AES.</span></span>

<span data-ttu-id="afd6c-370">기본적으로 Azure Storage 암호화에 사용 되는 키는 Microsoft에서 관리 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-370">By default, the keys used for encrypting Azure Storage are managed by Microsoft.</span></span> <span data-ttu-id="afd6c-371">이러한 키에 대 한 악의적인 액세스를 방지 하기 위해 광범위 하 게 보호 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-371">There are extensive protections in place to ensure to prevent malicious access to these keys.</span></span> <span data-ttu-id="afd6c-372">그러나 특정 암호화 요구 사항이 있는 사용자는 Azure Key Vault에서 관리 되는 [자체 저장소 키를 제공할](https://docs.microsoft.com/azure/storage/common/storage-encryption-keys-powershell) 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-372">However, users with particular encryption requirements can also [provide their own storage keys](https://docs.microsoft.com/azure/storage/common/storage-encryption-keys-powershell) that are managed in Azure Key Vault.</span></span> <span data-ttu-id="afd6c-373">이러한 키는 언제 든 지 취소할 수 있으며,이 키를 사용 하 여 액세스할 수 없는 저장소 계정의 콘텐츠를 효과적으로 렌더링할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-373">These keys can be revoked at any time, which would effectively render the contents of the Storage account using them inaccessible.</span></span>

<span data-ttu-id="afd6c-374">가상 머신은 암호화 된 저장소를 사용 하지만 Windows의 BitLocker 또는 Linux의 DM-대/소문자와 같은 기술을 사용 하 여 다른 암호화 계층을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-374">Virtual machines use encrypted storage, but it's possible to provide another layer of encryption by using technologies like BitLocker on Windows or DM-Crypt on Linux.</span></span> <span data-ttu-id="afd6c-375">이러한 기술을 통해 디스크 이미지가 저장소에서 유출 된 경우에도 읽을 수 있을 때까지 거의 불가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-375">These technologies mean that even if the disk image was leaked off of storage, it would remain near impossible to read it.</span></span>

### <a name="azure-sql"></a><span data-ttu-id="afd6c-376">Azure SQL</span><span class="sxs-lookup"><span data-stu-id="afd6c-376">Azure SQL</span></span>

<span data-ttu-id="afd6c-377">Azure SQL에서 호스트 되는 데이터베이스는 [TDE (투명한 데이터 암호화)](/sql/relational-databases/security/encryption/transparent-data-encryption) 라는 기술을 사용 하 여 데이터가 암호화 된 상태로 유지 되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-377">Databases hosted on Azure SQL use a technology called [Transparent Data Encryption (TDE)](/sql/relational-databases/security/encryption/transparent-data-encryption) to ensure data remains encrypted.</span></span> <span data-ttu-id="afd6c-378">새로 만든 모든 SQL 데이터베이스에서 기본적으로 사용 하도록 설정 되어 있지만 레거시 데이터베이스에 대해서는 수동으로 설정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-378">It's enabled by default on all newly created SQL databases, but must be enabled manually for legacy databases.</span></span> <span data-ttu-id="afd6c-379">TDE는 데이터베이스 뿐만 아니라 백업과 트랜잭션 로그에 대 한 실시간 암호화 및 암호 해독을 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-379">TDE executes real-time encryption and decryption of not just the database, but also the backups and transaction logs.</span></span>

<span data-ttu-id="afd6c-380">암호화 매개 변수는 데이터베이스에 저장 되 `master` 고 시작 시 나머지 작업에 대해 메모리로 읽혀집니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-380">The encryption parameters are stored in the `master` database and, on startup, are read into memory for the remaining operations.</span></span> <span data-ttu-id="afd6c-381">즉, 데이터베이스는 `master` 암호화 되지 않은 상태로 유지 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-381">This means that the `master` database must remain unencrypted.</span></span> <span data-ttu-id="afd6c-382">실제 키는 Microsoft에서 관리 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-382">The actual key is managed by Microsoft.</span></span> <span data-ttu-id="afd6c-383">그러나 이루기 보안 요구 사항이 있는 사용자는 Azure Storage에 대해 수행 되는 것과 거의 동일한 방식으로 Key Vault의 고유한 키를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-383">However, users with exacting security requirements may provide their own key in Key Vault in much the same way as is done for Azure Storage.</span></span> <span data-ttu-id="afd6c-384">Key Vault는 키 회전 및 해지와 같은 서비스를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-384">The Key Vault provides for such services as key rotation and revocation.</span></span>

<span data-ttu-id="afd6c-385">TDS의 "투명" 부분은 암호화 된 데이터베이스를 사용 하는 데 필요한 클라이언트 변경이 없다는 사실에서 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-385">The "Transparent" part of TDS comes from the fact that there aren't client changes needed to use an encrypted database.</span></span> <span data-ttu-id="afd6c-386">이 방법은 보안을 위해 제공 되지만, 사용자가 데이터를 해독할 수 있도록 데이터베이스 암호 누수가 충분 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-386">While this approach provides for good security, leaking the database password is enough for users to be able to decrypt the data.</span></span> <span data-ttu-id="afd6c-387">데이터베이스의 개별 열 또는 테이블을 암호화 하는 또 다른 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-387">There's another approach that encrypts individual columns or tables in a database.</span></span> <span data-ttu-id="afd6c-388">[Always Encrypted](https://docs.microsoft.com/azure/sql-database/sql-database-always-encrypted-azure-key-vault) 는 암호화 된 데이터가 데이터베이스 내에서 일반 텍스트로 표시 되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-388">[Always Encrypted](https://docs.microsoft.com/azure/sql-database/sql-database-always-encrypted-azure-key-vault) ensures that at no point the encrypted data appears in plain text inside the database.</span></span>

<span data-ttu-id="afd6c-389">이 암호화 계층을 설정 하려면 SQL Server Management Studio의 마법사를 통해 실행 하 여 암호화의 종류를 선택 하 고 Key Vault에서 연결 된 키를 저장 하는 위치를 선택 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-389">Setting up this tier of encryption requires running through a wizard in SQL Server Management Studio to select the sort of encryption and where in Key Vault to store the associated keys.</span></span>

![그림 9-6 Always Encrypted를 사용 하 여 암호화할 테이블의 열 선택](./media/always-encrypted.png)

<span data-ttu-id="afd6c-391">**그림 9-6**.</span><span class="sxs-lookup"><span data-stu-id="afd6c-391">**Figure 9-6**.</span></span> <span data-ttu-id="afd6c-392">Always Encrypted를 사용 하 여 암호화할 테이블의 열 선택</span><span class="sxs-lookup"><span data-stu-id="afd6c-392">Selecting columns in a table to be encrypted using Always Encrypted.</span></span>

<span data-ttu-id="afd6c-393">암호화 된 열에서 정보를 읽는 클라이언트 응용 프로그램은 암호화 된 데이터를 읽을 수 있도록 특수 허용량 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-393">Client applications that read information from these encrypted columns need to make special allowances to read encrypted data.</span></span> <span data-ttu-id="afd6c-394">를 사용 하 여 연결 문자열을 업데이트 해야 `Column Encryption Setting=Enabled` 하며, Key Vault에서 클라이언트 자격 증명을 검색 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-394">Connection strings need to be updated with `Column Encryption Setting=Enabled` and client credentials must be retrieved from the Key Vault.</span></span> <span data-ttu-id="afd6c-395">그런 다음 SQL Server 클라이언트는 열 암호화 키를 사용 하 여 게이머 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-395">The SQL Server client must then be primed with the column encryption keys.</span></span> <span data-ttu-id="afd6c-396">이 작업이 완료 되 면 나머지 작업은 SQL 클라이언트에 표준 인터페이스를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-396">Once that is done, the remaining actions use the standard interfaces to SQL Client.</span></span> <span data-ttu-id="afd6c-397">즉, SQL 클라이언트를 기반으로 구축 된 Dapper 및 Entity Framework 같은 도구는 변경 없이 계속 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-397">That is, tools like Dapper and Entity Framework, which are built on top of SQL Client, will continue to work without changes.</span></span> <span data-ttu-id="afd6c-398">모든 언어의 SQL Server 드라이버 마다 Always Encrypted를 아직 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-398">Always Encrypted may not yet be available for every SQL Server driver on every language.</span></span>

<span data-ttu-id="afd6c-399">TDE와 Always Encrypted의 조합은 클라이언트 관련 키와 함께 사용할 수 있으므로 가장 이루기 암호화 요구 사항도 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-399">The combination of TDE and Always Encrypted, both of which can be used with client-specific keys, ensures that even the most exacting encryption requirements are supported.</span></span>

### <a name="cosmos-db"></a><span data-ttu-id="afd6c-400">Cosmos DB</span><span class="sxs-lookup"><span data-stu-id="afd6c-400">Cosmos DB</span></span>

<span data-ttu-id="afd6c-401">Cosmos DB은 Azure에서 Microsoft가 제공 하는 최신 데이터베이스입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-401">Cosmos DB is the newest database provided by Microsoft in Azure.</span></span> <span data-ttu-id="afd6c-402">보안 및 암호화를 고려 하 여 처음부터 새로 빌드 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-402">It has been built from the ground up with security and cryptography in mind.</span></span> <span data-ttu-id="afd6c-403">AES-256 비트 암호화는 모든 Cosmos DB 데이터베이스에 대 한 표준 이며 사용 하지 않도록 설정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-403">AES-256bit encryption is standard for all Cosmos DB databases and can't be disabled.</span></span> <span data-ttu-id="afd6c-404">통신을 위한 TLS 1.2 요구 사항과 결합 된 전체 저장소 솔루션은 암호화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-404">Coupled with the TLS 1.2 requirement for communication, the entire storage solution is encrypted.</span></span>

![그림 9-7 내의 데이터 암호화 흐름 Cosmos DB](./media/cosmos-encryption.png)

<span data-ttu-id="afd6c-406">**그림 9-7**.</span><span class="sxs-lookup"><span data-stu-id="afd6c-406">**Figure 9-7**.</span></span> <span data-ttu-id="afd6c-407">Cosmos DB 내의 데이터 암호화 흐름입니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-407">The flow of data encryption within Cosmos DB.</span></span>

<span data-ttu-id="afd6c-408">Cosmos DB에서 고객 암호화 키를 제공 하지 않는 동안 팀이이를 제외 하 고 PCI DSS 규격을 유지 하는지 확인 하는 데 상당한 작업이 수행 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-408">While Cosmos DB doesn't provide for supplying customer encryption keys, there has been significant work done by the team to ensure it remains PCI-DSS compliant without that.</span></span> <span data-ttu-id="afd6c-409">또한 Cosmos DB는 Azure SQL의 Always Encrypted와 유사한 단일 열 암호화의 정렬을 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-409">Cosmos DB also doesn't support any sort of single column encryption similar to Azure SQL's Always Encrypted yet.</span></span>

## <a name="keeping-secure"></a><span data-ttu-id="afd6c-410">보안 유지</span><span class="sxs-lookup"><span data-stu-id="afd6c-410">Keeping secure</span></span>

<span data-ttu-id="afd6c-411">Azure에는 높은 수준의 보안 제품을 릴리스 하는 데 필요한 모든 도구가 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-411">Azure has all the tools necessary to release a highly secure product.</span></span> <span data-ttu-id="afd6c-412">그러나 체인은 가장 약한 링크 만큼 강력 합니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-412">However, a chain is only as strong as its weakest link.</span></span> <span data-ttu-id="afd6c-413">Azure 위에 배포 된 응용 프로그램이 적절 한 보안 사고 및 좋은 보안 감사를 사용 하 여 개발 되지 않은 경우 체인에서 약한 링크가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-413">If the applications deployed on top of Azure aren't developed with a proper security mindset and good security audits, then they become the weak link in the chain.</span></span> <span data-ttu-id="afd6c-414">Azure에 설치 된 소프트웨어를 Azure 자체와 안전 하 게 보호 하는 데 사용할 수 있는 유용한 정적 분석 도구, 암호화 라이브러리 및 보안 사례가 많이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-414">There are many great static analysis tools, encryption libraries, and security practices that can be used to ensure that the software installed on Azure is as secure as Azure itself.</span></span> <span data-ttu-id="afd6c-415">예를 들면 [정적 분석 도구](https://www.whitesourcesoftware.com/), [암호화 라이브러리](https://www.libressl.org/)및 [보안 방법이](https://azure.microsoft.com/resources/videos/red-vs-blue-internal-security-penetration-testing-of-microsoft-azure/)있습니다.</span><span class="sxs-lookup"><span data-stu-id="afd6c-415">Examples include [static analysis tools](https://www.whitesourcesoftware.com/), [encryption libraries](https://www.libressl.org/), and [security practices](https://azure.microsoft.com/resources/videos/red-vs-blue-internal-security-penetration-testing-of-microsoft-azure/).</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="afd6c-416">[이전](security.md)
>[다음](devops.md)</span><span class="sxs-lookup"><span data-stu-id="afd6c-416">[Previous](security.md)
[Next](devops.md)</span></span>
