---
title: 클라우드 전용 앱에 대 한 Azure 보안
description: Azure 용 클라우드 네이티브 .NET 앱 설계 | 클라우드 네이티브 앱에 대 한 Azure 보안
ms.date: 06/30/2019
ms.openlocfilehash: 44e81bc91fa952448f501a29e9db8afb2dbda752
ms.sourcegitcommit: 559259da2738a7b33a46c0130e51d336091c2097
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/22/2019
ms.locfileid: "73841272"
---
# <a name="azure-security-for-cloud-native-apps"></a>클라우드 전용 앱에 대 한 Azure 보안

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

클라우드 네이티브 응용 프로그램은 기존의 응용 프로그램 보다 쉽고 안전 하 게 보호할 수 있습니다. 단점은 더 작은 응용 프로그램의 보안을 유지 하 고 보안 인프라를 빌드하기 위한 추가 에너지를 추가 해야 합니다. 대부분의 서비스 배포에서 사용 되는 프로그래밍 언어 및 스타일의 다른 특성은 다양 한 공급자의 보안 게시판에 더 주의 해야 한다는 의미 이기도 합니다.

대칭 이동 측에서 각각 고유한 데이터 저장소가 있는 작은 서비스는 공격의 범위를 제한 합니다. 공격자가 한 시스템을 손상 시키는 경우 공격자가 모놀리식 응용 프로그램에 있는 것 보다 다른 시스템으로 이동 하는 것이 더 어려울 수 있습니다. 프로세스 경계는 강력한 경계입니다. 또한 데이터베이스 백업이 누수 되 면 해당 데이터베이스는 데이터의 하위 집합만 포함 하 고 개인 데이터를 포함할 가능성이 없기 때문에 손상이 더 제한적입니다.

## <a name="threat-modeling"></a>위협 모델링

클라우드 네이티브 응용 프로그램의 단점 보다 장점에 관계 없이 동일한 전체적인 보안 마음가짐을 따라야 합니다. 보안 및 보안 고려는 개발 및 운영 스토리의 모든 단계에 포함 되어야 합니다. 응용 프로그램을 계획할 때 다음과 같은 질문을 합니다.

- 이 데이터가 손실 되는 영향은 무엇 인가요?
- 잘못 된 데이터를이 서비스에 삽입 하는 것을 제한 하려면 어떻게 해야 하나요?
- 이 데이터에 액세스할 수 있는 사용자는 누구 인가요?
- 개발 및 릴리스 프로세스를 진행 하는 동안 감사 정책이 있나요?

이러한 모든 질문은 [위협 모델링](https://docs.microsoft.com/azure/security/azure-security-threat-modeling-tool)이라는 프로세스의 일부입니다. 이 프로세스는 시스템에 발생 하는 위협에 대 한 질문과 대답을 시도 합니다 .이는 위협에 대 한 위협 및 잠재적 손상입니다.

위협 목록이 설정 된 후에는 완화 가치가 있는지 여부를 결정 해야 합니다. 경우에 따라 위협은 에너지를 지출 하지 않아도 되는 것이 좋습니다. 예를 들어 일부 상태 수준 행위자는 수백만 개의 장치에서 사용 하는 프로세스 디자인에 변경 내용을 주입할 수 있습니다. 이제 [링 3](https://en.wikipedia.org/wiki/Protection_ring)에서 코드의 특정 부분을 실행 하는 대신 링 0에서 코드를 실행 합니다. 따라서 하이퍼바이저를 우회 하 고 운영 체제 미 설치 컴퓨터에서 공격 코드를 실행 하 여 해당 하드웨어에서 실행 되는 모든 가상 컴퓨터에 대 한 공격을 허용 하는 익스플로잇을 사용할 수 있습니다.

변경 된 프로세서는 해당 프로세서의 실리콘 디자인에 대 한 microscope 및 고급 지식 없이 검색 하기가 어렵습니다. 이 시나리오는 발생 가능성이 낮지만 완화 비용이 많이 들기 때문에 위협 모델에 대 한 exploit protection 빌드를 권장 하지 않을 수 있습니다.

공격을 증가 시키는 `Id` (URL의 `Id=3` `Id=2` 대체) 또는 SQL 삽입을 허용 하는 손상 된 액세스 제어와 같은 위협 요소는에 대 한 보호를 구축 하는 데 더 유리 합니다. 이러한 위협에 대 한 완화는 회사의 명성를 smear 하는 당혹 보안 허점을 빌드하고 방지 하는 데 매우 적합 합니다.

## <a name="principle-of-least-privilege"></a>최소 권한의 원칙

컴퓨터 보안의 창립 아이디어 중 하나는 최소 권한의 원칙 (정책 정책)입니다. 실제로는 대부분의 보안에서 디지털 또는 물리적 형식으로 기본 개념입니다. 즉, 사용자 또는 프로세스에는 태스크를 실행할 수 있는 최소한의 권한만 있으면 됩니다.

예를 들어 은행에서 사용한 은행 직원을 생각해 보겠습니다. safe에 액세스 하는 것은 일반적이 지 않은 활동입니다. 따라서 평균 인출기은 안전 하 게 열 수 없습니다. 액세스 권한을 얻으려면 추가 보안 검사를 수행 하는 은행 관리자를 통해 요청을 에스컬레이션 해야 합니다.

컴퓨터 시스템에서 가장 훌륭한 예는 데이터베이스에 연결 하는 사용자의 권한입니다. 대부분의 경우에는 데이터베이스 구조를 빌드하고 응용 프로그램을 실행 하는 데 사용 되는 단일 사용자 계정이 있습니다. 극단적인 경우를 제외 하 고 응용 프로그램을 실행 하는 계정에는 스키마 정보를 업데이트할 수 있는 기능이 필요 하지 않습니다. 다양 한 수준의 권한을 제공 하는 여러 계정이 있어야 합니다. 응용 프로그램은 테이블의 데이터에 대 한 읽기 및 쓰기 권한을 부여 하는 권한 수준만 사용 해야 합니다. 이러한 종류의 보호는 데이터베이스 테이블을 삭제 하거나 악의적인 트리거를 도입 하기 위한 공격을 제거 합니다.

클라우드 네이티브 응용 프로그램을 빌드하는 거의 모든 부분은 최소 권한의 원칙을 기억 하는 데 도움이 될 수 있습니다. 역할 기반 액세스 제어 (RBAC)에서 방화벽, 네트워크 보안 그룹, 역할 및 범위를 설정할 때 재생 시 찾을 수 있습니다.

## <a name="penetration-testing"></a>침투 테스트

응용 프로그램이 더 복잡해 지 면 공격 벡터 수가 오류가 심각한 증가 속도로 늘어납니다. 위협 모델링은 시스템을 구축 하는 사용자가 실행 하는 경향이 있습니다. 많은 개발자가 사용자 상호 작용을 구상 하 고 사용할 수 없는 사용자 인터페이스를 빌드하는 것과 같은 방식으로 대부분의 개발자는 공격 벡터를 모두 볼 수 있습니다. 또한 시스템을 빌드하는 개발자가 공격 방법에서 잘 익숙한 하 고 중요 한 문제가 발생 하지 않을 수도 있습니다.

침투 테스트 또는 "펜 테스트"는 시스템 공격을 시도 하기 위해 외부 행위자를 가져오는 과정을 포함 합니다. 이러한 공격자는 외부 컨설팅 회사 또는 다른 개발자가 비즈니스의 다른 부분 으로부터 보안에 대해 잘 알고 있을 수 있습니다. 맞춤형 전권에 게 시스템을 방해할 시도 하는 것이 제공 됩니다. 패치를 적용 해야 하는 광범위 한 보안 허점을 발견할 수 있는 경우가 많습니다. 경우에 따라 공격 벡터가 CEO에 대해 피싱 공격을 악용 하는 것과 같이 완전히 예기치 않은 것입니다.

Azure 자체는 [Microsoft 내 해커 팀](https://azure.microsoft.com/resources/videos/red-vs-blue-internal-security-penetration-testing-of-microsoft-azure/)의 공격을 지속적으로 진행 하 고 있습니다. 몇 년 동안이는 잠재적으로 치명적인 공격 벡터를 수십 개 검색 하 여 외부에서 악용 되기 전에 종료 했습니다. 목표를 더 많이 영구 행위자는이를 이용 하려고 할 가능성이 더 높습니다. Azure 보다는 전 세계에 몇 가지 대상이 있습니다.

## <a name="monitoring"></a>모니터링

공격자가 응용 프로그램을 침투 하려고 하면 경고가 발생 합니다. 서비스에서 로그를 검사 하 여 공격을 검색할 수 있는 경우가 많습니다. 공격은 성공 하기 전에 발견 될 수 있는 telltale 기호를 그대로 둡니다. 예를 들어 공격자가 암호를 추측 하려고 시도 하면 로그인 시스템에 많은 요청이 발생 합니다. 로그인 시스템을 모니터링 하면 일반적인 액세스 패턴에 맞지 않는 이상한 패턴을 검색할 수 있습니다. 이 모니터링을 경고로 전환 하 여 작업 자가 일종의 대책을 활성화 하도록 경고할 수 있습니다. 매우 성숙한 모니터링 시스템은 요청을 차단 하는 규칙을 사전에 추가 하거나 응답을 제한 하는 작업을 수행할 수도 있습니다.

## <a name="securing-the-build"></a>빌드 보안

보안이 종종 간과 되는 한 가지 위치는 빌드 프로세스를 중심으로 합니다. 안전 하지 않은 코드 또는 체크 인 된 자격 증명을 검색 하는 것과 같이 빌드에서 보안 검사를 실행 해야 하는 것은 아니지만 빌드 자체를 안전 하 게 보호 해야 합니다. 빌드 서버가 손상 되 면 해당 제품에 임의의 코드를 도입 하기 위한 환상적인 벡터를 제공 합니다.

공격자가 웹 응용 프로그램에 로그인 하는 사람의 암호를 도용 하려고 한다고 가정 합니다. 체크 아웃 된 코드를 수정 하 여 다른 서버로 로그인 요청을 미러링 하는 빌드 단계를 도입할 수 있습니다. 다음 번에 코드가 빌드를 거치 면 자동으로 업데이트 됩니다. 소스 코드 취약점 검사는 빌드 전에 실행 될 때이를 catch 하지 않습니다. 빌드 단계가 빌드 서버에 살고 있으므로 코드 검토에서이를 catch 하지 않습니다. 악용 된 코드는 암호를 수집할 수 있는 프로덕션으로 이동 됩니다. 빌드 프로세스 변경 내용에 대 한 감사 로그가 없거나 감사를 최소한으로 모니터링 하지 않을 수 있습니다.

이는 시스템에서 중단 하는 데 사용할 수 있는 보이는 낮은 값 대상의 완벽 한 예입니다. 공격자가 시스템의 경계를 위반 하면 사용 권한을 상승 하는 방법을 찾기 위해 작업을 시작 하 여 원하는 위치에서 실제 피해를 일으킬 수 있습니다.

## <a name="building-secure-code"></a>보안 코드 빌드

.NET Framework은 이미 매우 안전한 프레임 워크입니다. 배열의 끝을 탐색 하는 것과 같이 비관리 코드의 일부 문제를 방지 합니다. 검색 된 보안 허점을 해결 하기 위해 작업을 적극적으로 수행 하 고 있습니다. 프레임 워크에서 문제를 발견 하 고이를 악용 하는 대신 보고 하는 연구원을 지불 하는 [버그 포상 프로그램](https://www.microsoft.com/msrc/bounty) 도 있습니다.

.NET 코드를 보다 안전 하 게 보호 하는 방법에는 여러 가지가 있습니다. [.Net에 대 한 보안 코딩 지침](https://docs.microsoft.com/dotnet/standard/security/secure-coding-guidelines) 과 같은 지침에 따라 코드를 처음부터 안전 하 게 유지 하기 위해 수행할 수 있는 적절 한 단계가 있습니다. [OWASP top 10](https://www.owasp.org/index.php/Category:OWASP_Top_Ten_2017_Project) 은 보안 코드를 빌드하기 위한 또 다른 유용한 가이드입니다.

빌드 프로세스는 검색 도구를 사용 하 여 프로덕션 환경으로 전환 하기 전에 소스 코드의 문제를 검색 하는 데 적합 한 위치입니다. 대부분의 프로젝트에는 일부 다른 패키지에 대 한 종속성이 있습니다. 오래 된 패키지를 검색할 수 있는 도구는 야간 빌드의 문제를 파악 합니다. Docker 이미지를 작성 하는 경우에도 기본 이미지에 알려진 취약성이 없는지 확인 하 고 확인 하는 것이 유용 합니다. 어떤 경우에도 아무도 자격 증명을 체크 인하지 않았는지 확인 해야 합니다.

## <a name="built-in-security"></a>기본 제공 보안

Azure는 대다수 사용자에 대 한 유용성 및 보안을 균형 있게 설계 되었습니다. 여러 사용자가 서로 다른 보안 요구 사항을 가지 므로 클라우드 보안에 대 한 접근 방식을 세밀 하 게 조정 해야 합니다. Microsoft는 보안 [센터](https://azure.microsoft.com/support/trust-center/)에 상당한 보안 정보를 게시 합니다. 이 리소스는 기본 제공 공격 완화 기술의 작동 방식을 이해 하는 데 관심이 있는 전문가를 위한 첫 번째 중지 여야 합니다.

Azure Portal 내에서 [Azure Advisor](https://azure.microsoft.com/services/advisor/) 은 계속 해 서 환경을 검색 하 고 권장 사항을 적용 하는 시스템입니다. 이러한 권장 사항 중 일부는 사용자의 비용을 절감할 수 있도록 설계 되었지만 다른 사용자는 저장소 컨테이너를 전 세계에 공개 하 고 Virtual Network으로 보호 하지 않는 등 안전 하지 않은 구성을 식별 하도록 설계 되었습니다.

## <a name="azure-network-infrastructure"></a>Azure 네트워크 인프라

온-프레미스 배포 환경에서는 많은 양의 에너지를 네트워킹 설정 전용으로 합니다. 라우터, 스위치 등을 설정 하는 것은 복잡 한 작업입니다. 네트워크를 사용 하면 특정 리소스가 다른 리소스와 통신 하 고 일부 경우에는 액세스를 방지할 수 있습니다. 자주 발생 하는 네트워크 규칙은 개발 환경에서 프로덕션 환경에 대 한 액세스를 제한 하는 것입니다 .이는 awry 코드의 절반을 실행 하 고 swath 데이터를 삭제 하는 경우를 방지할 수 있습니다.

기본적으로 대부분의 PaaS Azure 리소스에는 가장 기본적인 및 허용 네트워킹 설정만 있습니다. 예를 들어 인터넷의 모든 사람이 app service에 액세스할 수 있습니다. 새 SQL Server 인스턴스는 일반적으로 제한 되므로 외부 당사자가 액세스할 수 없지만 Azure 자체에서 사용 되는 IP 주소 범위는를 통해 허용 됩니다. 따라서 SQL server를 외부 위협 으로부터 보호 하는 동안 공격자는 azure의 모든 SQL 인스턴스에 대 한 공격을 시작할 수 있는 Azure 브리지 헤드를 설정 하기만 하면 됩니다.

다행히 대부분의 Azure 리소스를 Azure Virtual Network에 배치 하 여 보다 세분화 된 액세스 제어를 수행할 수 있습니다. 온-프레미스 네트워크에서 광범위 하 게 보호 되는 개인 네트워크를 설정 하는 방식과 마찬가지로, 가상 네트워크는 Azure 네트워크 내에 있는 개인 IP 주소의 아일랜드입니다.

그림 10-1](./media/virtual-network.png)
**그림 10-1**의 가상 네트워크를 ![. Azure의 가상 네트워크입니다.

온-프레미스 네트워크에서 네트워크에 대 한 액세스를 관리 하는 방화벽을 사용 하는 것과 같은 방식으로 가상 네트워크의 경계에서 유사한 방화벽을 설정할 수 있습니다. 기본적으로 가상 네트워크의 모든 리소스는 인터넷에 계속 통신할 수 있습니다. 특정 형식의 명시적인 방화벽 예외가 필요한 들어오는 연결입니다.

네트워크를 설정 하면 저장소 계정과 같은 내부 리소스를 설정 하 여 Virtual Network에도 있는 리소스만 액세스할 수 있습니다. 이 방화벽은 추가 보안 수준을 제공 하며, 해당 저장소 계정에 대 한 키가 유출 되는 경우 공격자가 유출 된 키를 악용 하기 위해 연결 하지 못할 수 있습니다. 이는 최소 권한의 원칙에 대 한 또 다른 예입니다.

Azure Kubernetes 클러스터의 노드는 Azure의 기본이 되는 다른 리소스와 마찬가지로 가상 네트워크에 참여할 수 있습니다. 이 기능을 [Azure Container 네트워킹 인터페이스](https://github.com/Azure/azure-container-networking/blob/master/docs/cni.md)라고 합니다. 실제로 가상 컴퓨터 및 컨테이너 이미지가 할당 되는 가상 네트워크 내에서 서브넷을 할당 합니다.

최소 권한의 원칙을 설명 하는 경로를 계속 하 고 Virtual Network 내의 모든 리소스가 다른 모든 리소스와 통신 해야 하는 것은 아닙니다. 예를 들어 저장소 계정 및 SQL database에 대해 web API를 제공 하는 응용 프로그램에서 데이터베이스와 저장소 계정이 서로 통신 해야 하는 것은 아닙니다. 이러한 데이터 간의 데이터 공유는 웹 응용 프로그램을 통해 수행 됩니다. 따라서 [NSG (네트워크 보안 그룹)](https://docs.microsoft.com/azure/virtual-network/security-overview) 를 사용 하 여 두 서비스 간의 트래픽을 거부할 수 있습니다.

리소스 간의 통신을 거부 하는 정책은 특히 트래픽 제한 없이 Azure를 사용 하는 백그라운드에서 구현 하기에 방해가 될 수 있습니다. 일부 다른 클라우드에서는 네트워크 보안 그룹의 개념이 훨씬 더 널리 활용 되 고 있습니다. 예를 들어 AWS에 대 한 기본 정책은 NSG의 규칙에 의해 활성화 될 때까지 리소스가 자신 간에 통신할 수 없다는 것입니다. 이를 개발 하는 데는 느리지만 더 제한적인 환경에서 보다 안전한 기본값을 제공 합니다. 특히 [Azure Resource Manager 또는 Terraform](infrastructure-as-code.md) 을 사용 하 여 사용 권한을 관리 하는 적절 한 devops 방법을 사용 하면 규칙을 보다 쉽게 제어할 수 있습니다.

가상 네트워크는 온-프레미스와 클라우드 리소스 간에 통신을 설정 하는 경우에도 유용할 수 있습니다. 가상 개인 네트워크를 사용 하 여 두 네트워크를 원활 하 게 연결할 수 있습니다. 이렇게 하면 모든 사용자가 사이트에 있는 시나리오에 대해 어떤 종류의 게이트웨이 없이도 가상 네트워크를 실행할 수 있습니다. 이 네트워크를 설정 하는 데 사용할 수 있는 여러 기술이 있습니다. 가장 간단한 방법은 많은 라우터와 Azure 간에 설정할 수 있는 [사이트 간 VPN](https://docs.microsoft.com/azure/vpn-gateway/vpn-gateway-about-vpngateways?toc=%2fazure%2fvirtual-network%2ftoc.json#s2smulti) 을 사용 하는 것입니다. 트래픽은 인터넷을 통해 다른 트래픽과 동일한 요금으로 암호화 되 고 터널링 됩니다. 더 많은 대역폭이 나 더 많은 보안이 필요한 시나리오의 경우 Azure는 온-프레미스 네트워크와 Azure 간에 개인 회로를 사용 하는 [Express Route](https://docs.microsoft.com/azure/vpn-gateway/vpn-gateway-about-vpngateways?toc=%2fazure%2fvirtual-network%2ftoc.json#ExpressRoute) 라는 서비스를 제공 합니다. 비용이 많이 들고 설정 하기가 어렵고 보안도 향상 됩니다.

## <a name="role-based-access-control-for-restricting-access-to-azure-resources"></a>Azure 리소스에 대 한 액세스를 제한 하는 역할 기반 액세스 제어

RBAC는 Azure에서 실행 되는 응용 프로그램에 id를 제공 하는 시스템입니다. 응용 프로그램은 키 또는 암호를 사용 하는 대신이 id를 사용 하 여 리소스에 액세스할 수 있습니다.

## <a name="security-principals"></a>보안 주체

RBAC의 첫 번째 구성 요소는 보안 주체입니다. 보안 주체는 사용자, 그룹, 서비스 주체 또는 관리 id 일 수 있습니다.

그림 10-2](./media/rbac-security-principal.png)
![그림에는 **그림 10-2**과 같은 다양 한 유형의 보안 주체가 있습니다. 여러 유형의 보안 주체입니다.

- 사용자-Azure Active Directory 계정이 있는 사용자는 사용자입니다.
- Group-Azure Active Directory의 사용자 컬렉션입니다. 사용자는 그룹의 멤버로 서 해당 그룹의 역할 뿐만 아니라 해당 그룹의 역할을 수행 합니다.
- 서비스 사용자-서비스 또는 응용 프로그램을 실행 하는 보안 id입니다.
- 관리 id-Azure에서 관리 하는 Azure Active Directory id입니다. 관리 id는 Azure 서비스 인증을 위해 자격 증명을 관리 하는 클라우드 응용 프로그램을 개발할 때 일반적으로 사용 됩니다.

보안 주체를 대부분의 리소스에 적용할 수 있습니다. 즉, Azure Kubernetes 내에서 실행 되는 컨테이너에 보안 주체를 할당 하 여 Key Vault에 저장 된 비밀에 액세스할 수 있습니다. Azure 함수는 호출 하는 사용자에 대 한 JWT의 유효성을 검사 하기 위해 Active Directory 인스턴스와 통신할 수 있는 권한을 사용할 수 있습니다. 서비스 주체를 사용 하 여 서비스를 사용 하도록 설정한 후에는 역할 및 범위를 사용 하 여 세부적으로 권한을 관리할 수 있습니다.

## <a name="roles"></a>역할

보안 주체는 많은 역할을 수행 하거나 많은 sartorial를 사용 하 여 많은 모자를 사용할 수 있습니다. 각 역할은 "Azure Service Bus 끝점에서 메시지 읽기"와 같은 일련의 사용 권한을 정의 합니다. 보안 주체의 유효 사용 권한 집합은 보안 주체가 갖는 모든 역할에 할당 된 모든 사용 권한의 조합입니다. Azure에는 다양 한 기본 제공 역할이 있으며 사용자는 자신의 역할을 정의할 수 있습니다.

![그림 10-3 RBAC 역할 정의](./media/rbac-role-definition.png)
**그림 10-3**. RBAC 역할 정의.

또한 Azure에는 소유자, 참가자, 읽기 권한자 및 사용자 계정 관리자와 같은 많은 고급 역할이 있습니다. 소유자 역할을 사용 하 여 보안 주체는 모든 리소스에 액세스 하 고 다른 사용자에 게 사용 권한을 할당할 수 있습니다. 참여자는 모든 리소스에 대해 동일한 수준의 액세스를 갖지만 사용 권한을 할당할 수 없습니다. 판독기는 기존 Azure 리소스만 볼 수 있으며 사용자 계정 관리자는 Azure 리소스에 대 한 액세스를 관리할 수 있습니다.

[DNS 영역 참가자](https://docs.microsoft.com/azure/role-based-access-control/built-in-roles#dns-zone-contributor) 와 같은 보다 세부적인 기본 제공 역할에는 단일 서비스로 제한 된 권한이 있습니다. 보안 주체는 원하는 수의 역할을 수행할 수 있습니다.

## <a name="scopes"></a>범위

역할은 Azure 내에서 제한 된 리소스 집합에 적용 될 수 있습니다. 예를 들어 Service Bus 큐에서 읽기의 이전 예제에 범위를 적용 하면 단일 큐에 대 한 사용 권한을 좁힐 수 있습니다. "Azure Service Bus 끝점에서 메시지 읽기" `blah.servicebus.windows.net/queue1`

범위는 단일 리소스로 좁힐 수 있으며 전체 리소스 그룹, 구독 또는 관리 그룹에도 적용 될 수 있습니다.

보안 주체에 특정 사용 권한이 있는지 테스트할 때 역할 및 범위의 조합이 고려 됩니다. 이 조합은 강력한 권한 부여 메커니즘을 제공 합니다.

## <a name="deny"></a>Deny

이전에는 RBAC에 대해 "허용" 규칙만 허용 되었습니다. 이 동작은 일부 범위를 빌드하기에 복잡 했습니다. 예를 들어 잠재적으로 무한 한 저장소 계정 목록에 명시적 사용 권한을 부여 하는 것을 제외 하 고 모든 저장소 계정에 대 한 보안 주체 액세스를 허용 합니다. 새 저장소 계정을 만들 때마다이 계정 목록에 추가 해야 합니다. 이로 인해 바람직하지 않은 관리 오버 헤드가 발생 했습니다.

거부 규칙은 허용 규칙 보다 우선적으로 적용 됩니다. 이제 동일한 "모두 허용" 범위를 표시 하는 것이 두 개의 규칙 인 "모두 허용" 및 "특정 한 항목 거부"로 표시 될 수 있습니다. 거부 규칙은 관리를 용이 하 게 할 뿐만 아니라, 모든 사람에 대 한 액세스를 거부 하 여 추가 보안 된 리소스를 허용 합니다.

## <a name="checking-access"></a>액세스 확인

짐작할 수 있듯이, 많은 수의 역할 및 범위를 사용 하는 경우 서비스 주체의 유효 사용 권한을 파악 하기가 매우 어렵습니다. 누적 거부 규칙을 기반으로 하 여 복잡성을 높이는 역할만 합니다. 다행히 모든 서비스 사용자에 대 한 유효 사용 권한을 표시할 수 있는 사용 권한 계산기가 있습니다. 일반적으로 그림 10-3에 표시 된 것 처럼 포털의 IAM 탭 아래에 있습니다.

![그림 10-4 app service에 대 한 권한 계산기](./media/check-rbac.png)
**그림 10-4**. App service에 대 한 사용 권한 계산기입니다.

## <a name="securing-secrets"></a>비밀 보호

암호 및 인증서는 공격자를 위한 일반적인 공격 벡터입니다. 암호 크랙 하드웨어는 무차별 암호 대입 공격을 수행할 수 있으며 초당 수십억 개의 암호를 추측 하려고 합니다. 따라서 리소스에 액세스 하는 데 사용 되는 암호는 강력 하 고 다양 한 문자를 사용 하는 것이 중요 합니다. 이러한 암호는 기억할 수 없는 암호의 종류와 정확히 일치 합니다. 다행히 Azure의 암호는 실제로 사용자가 알 필요가 없습니다.

대부분의 보안 전문가는 암호 관리자를 사용 하 여 자신의 암호를 유지 하는 것이 가장 좋은 방법 이라고 [제안](https://www.troyhunt.com/password-managers-dont-have-to-be-perfect-they-just-have-to-be-better-than-not-having-one/) 합니다. 암호를 한 위치에 중앙 집중화 하는 동안 매우 복잡 한 암호를 사용 하 고 각 계정에 대해 고유 하 게 보장할 수 있습니다. Azure 내에 동일한 시스템이 있습니다. 암호에 대 한 중앙 저장소입니다.

## <a name="azure-key-vault"></a>Azure Key Vault

Azure Key Vault는 데이터베이스, API 키 및 인증서와 같은 항목에 대 한 암호를 저장 하는 중앙 위치를 제공 합니다. 자격 증명 모음에 암호를 입력 하면 다시 표시 되지 않으며 추출 하는 명령은 의도적으로 복잡 합니다. Safe의 정보는 소프트웨어 암호화 또는 FIPS 140-2 수준 2의 유효성을 검사 한 하드웨어 보안 모듈을 사용 하 여 보호 됩니다.

키 자격 증명 모음에 대 한 액세스는 RBACs를 통해 제공 됩니다. 즉, 사용자가 자격 증명 모음에 있는 정보에 액세스할 수 있는 것은 아닙니다. 웹 응용 프로그램이 Azure Key Vault에 저장 된 데이터베이스 연결 문자열에 액세스 하려는 경우를 예로 들어 보겠습니다. 액세스 권한을 얻으려면 응용 프로그램은 서비스 주체를 사용 하 여 실행 해야 합니다. 이로 간주 되는 역할에서는 안전한 암호를 읽을 수 있습니다. 응용 프로그램에서 자격 증명 모음에 대 한 액세스를 추가로 제한할 수 있도록 하는 다양 한 보안 설정이 있습니다. 암호를 업데이트할 수는 없으며 읽기만 가능 합니다.

주요 자격 증명 모음에 대 한 액세스를 모니터링 하 여 예상 되는 응용 프로그램만 자격 증명 모음에 액세스할 수 있도록 할 수 있습니다. 로그를 Azure Monitor에 다시 통합 하 여 예기치 않은 조건이 발생 하는 경우 경고를 설정 하는 기능을 해제할 수 있습니다.

## <a name="kubernetes"></a>Kubernetes

Kubernetes 내에는 작은 암호 정보를 유지 관리 하기 위한 유사한 서비스가 있습니다. Kubernetes 암호는 일반적인 `kubectl` 실행 파일을 통해 설정할 수 있습니다.

암호 만들기는 저장할 값의 base64 버전을 찾는 것 만큼 간단 합니다.

```console
echo -n 'admin' | base64
YWRtaW4=
echo -n '1f2d1e2e67df' | base64
MWYyZDFlMmU2N2Rm
```

그런 다음 `secret.yml` 이라는 비밀 파일에 추가 합니다. 예를 들어 다음 예제와 같이 표시 됩니다.

```yml
apiVersion: v1
kind: Secret
metadata:
  name: mysecret
type: Opaque
data:
  username: YWRtaW4=
  password: MWYyZDFlMmU2N2Rm
```

마지막으로 다음 명령을 실행 하 여 Kubernetes에이 파일을 로드할 수 있습니다.

```console
kubectl apply -f ./secret.yaml
```

그런 다음 이러한 암호를 볼륨에 탑재 하거나 환경 변수를 통해 컨테이너 프로세스에 노출할 수 있습니다. 응용 프로그램 빌드에 대 한 [12 단계 앱](https://12factor.net/) 접근 방식은 응용 프로그램에 설정을 전송 하는 데 가장 낮은 공통 분모를 사용 하는 것을 제안 합니다. 환경 변수는 운영 체제 또는 응용 프로그램에 상관 없이 지원 되기 때문에 가장 낮은 공통 분모입니다.

기본 제공 Kubernetes 암호를 사용 하는 대신 Kubernetes 내에서 Azure Key Vault의 비밀에 액세스할 수 있습니다. 이 작업을 수행 하는 가장 간단한 방법은 암호를 로드 하는 컨테이너에 RBAC 역할을 할당 하는 것입니다. 그런 다음 응용 프로그램은 Azure Key Vault Api를 사용 하 여 암호에 액세스할 수 있습니다. 그러나이 방법은 코드를 수정 해야 하며 환경 변수를 사용 하는 패턴을 따르지 않습니다. 대신 [Azure Key Vault 인젝터](https://mrdevops.io/introducing-azure-key-vault-to-kubernetes-931f82364354)를 사용 하 여 컨테이너에 값을 삽입할 수 있습니다. 이 방법은 클러스터의 사용자가 액세스할 수 있으므로 Kubernetes 암호를 직접 사용 하는 것 보다 실제로 더 안전 합니다.

## <a name="encryption-in-transit-and-at-rest"></a>전송 중 및 미사용 암호화

데이터를 안전 하 게 유지 하는 것은 디스크에 있든, 다양 한 다른 서비스 간에 전송을 관계 없이 중요 합니다. 데이터 누수를 방지 하는 가장 효과적인 방법은 다른 사람이 쉽게 읽을 수 없는 형식으로 암호화 하는 것입니다. Azure는 다양 한 암호화 옵션을 지원 합니다.

### <a name="in-transit"></a>전송 중

Azure에서 네트워크의 트래픽을 암호화 하는 방법에는 여러 가지가 있습니다. Azure 서비스에 대 한 액세스는 일반적으로 TLS (전송 계층 보안)를 사용 하는 연결을 통해 수행 됩니다. 예를 들어 Azure Api에 대 한 모든 연결에는 TLS 연결이 필요 합니다. 동일 하 게 Azure storage의 끝점에 대 한 연결은 TLS 암호화 연결에 대해서만 작동 하도록 제한할 수 있습니다.

TLS는 복잡 한 프로토콜 이며, 연결에서 TLS를 사용 하는 것은 보안을 보장 하는 데 충분 하지 않습니다. 예를 들어 TLS 1.0은 장기간 안전 하지 않으며 TLS 1.1이 훨씬 더 낫습니다. TLS 버전 내 에서도 더 쉽게 암호를 해독할 수 있도록 하는 다양 한 설정이 있습니다. 가장 좋은 조치는 서버 연결에서 최신 및 잘 구성 된 프로토콜을 사용 하 고 있는지 확인 하는 것입니다.

이 확인은 SSL labs의 SSL 서버 테스트와 같은 외부 서비스에서 수행할 수 있습니다. 일반적인 Azure 끝점에 대 한 테스트 실행 (이 경우 service bus 끝점)은 거의 완벽 한 점수를 생성 합니다.

Azure SQL 데이터베이스와 같은 서비스도 TLS 암호화를 사용 하 여 데이터를 숨김 상태로 유지 합니다. TLS를 사용 하 여 전송 중인 데이터를 암호화 하는 흥미로운 부분은 Microsoft가 TLS를 실행 하는 컴퓨터 간의 연결에서 수신 대기 하는 것이 불가능 하다는 것입니다. 이는 해당 데이터가 Microsoft의 적절 한 위험이 나 표준 공격자 보다 많은 리소스를 포함 하는 상태 행위자가 될 수 있다는 것을 걱정 하는 회사에 게 편안 하 게 제공 됩니다.

![그림 10-5 Service Bus 끝점에 대 한의 점수를 보여 주는 SSL labs 보고서입니다. **그림 10-5**을](./media/ssl-report.png)
합니다. Service Bus 끝점에 대 한의 점수를 보여 주는 SSL labs 보고서입니다.

이 암호화 수준은 항상 충분 하지는 않지만 Azure TLS 연결이 매우 안전 하다는 확신을 영감 야 합니다. Azure는 암호화가 향상 됨에 따라 보안 표준을 지속적으로 개선 하 고 있습니다. 보안 표준을 감시 하 고 Azure가 개선 될 때 Azure를 업데이트 한다는 것을 알고 있는 것이 좋습니다.

### <a name="at-rest"></a>휴지 상태의

모든 응용 프로그램에는 데이터를 디스크에 저장 하는 여러 위치가 있습니다. 응용 프로그램 코드 자체는 일부 저장소 메커니즘에서 로드 됩니다. 또한 대부분의 응용 프로그램은 SQL Server, Cosmos DB 또는 놀라울 만큼 가격 효율적인 Table Storage 같은 일종의 데이터베이스를 사용 합니다. 이러한 데이터베이스는 모두 고도로 암호화 된 저장소를 사용 하 여 적절 한 권한을 가진 응용 프로그램이 아닌 다른 사용자가 데이터를 읽을 수 있도록 합니다. 시스템 연산자도 암호화 된 데이터를 읽을 수 없습니다. 따라서 고객은 비밀 정보를 비밀로 유지할 수 있습니다.

### <a name="storage"></a>스토리지

Azure의 토대 인는 Azure Storage 엔진입니다. 가상 컴퓨터 디스크는 Azure Storage 위에 탑재 됩니다. Azure Kubernetes 서비스는 자체가 Azure Storage에 호스트 되는 가상 머신에서 실행 됩니다. Azure Functions Apps 및 Azure Container Instances와 같은 서버 리스 기술은 Azure Storage의 일부인 디스크를 모두 사용 합니다.

Azure Storage 잘 암호화 된 경우에는 다른 모든 항목을 암호화 하기 위한 기반을 제공 합니다. Azure Storage는 [FIPS 140-2](https://en.wikipedia.org/wiki/FIPS_140) 규격 [256 비트 AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard)로 [암호화 됩니다](https://docs.microsoft.com/azure/storage/common/storage-service-encryption) . 이는 지난 20 년 동안 광범위 한 교육을 받은 암호화 기술입니다. 현재는 키를 모르는 사람이 AES로 암호화 된 데이터를 읽을 수 있도록 하는 알려진 실제 공격이 없습니다.

기본적으로 Azure Storage 암호화에 사용 되는 키는 Microsoft에서 관리 합니다. 이러한 키에 대 한 악의적인 액세스를 방지 하기 위해 광범위 하 게 보호 해야 합니다. 그러나 특정 암호화 요구 사항이 있는 사용자는 Azure Key Vault에서 관리 되는 [자체 저장소 키를 제공할](https://docs.microsoft.com/azure/storage/common/storage-encryption-keys-powershell) 수도 있습니다. 이러한 키는 언제 든 지 취소할 수 있으며,이 키를 사용 하 여 액세스할 수 없는 저장소 계정의 콘텐츠를 효과적으로 렌더링할 수 있습니다.

가상 머신은 암호화 된 저장소를 사용 하지만 Windows의 BitLocker 또는 Linux의 DM-대/소문자와 같은 기술을 사용 하 여 다른 암호화 계층을 제공할 수 있습니다. 이러한 기술을 통해 디스크 이미지가 저장소에서 유출 된 경우에도 읽을 수 있을 때까지 거의 불가능 합니다.

### <a name="azure-sql"></a>Azure SQL

Azure SQL에서 호스트 되는 데이터베이스는 [TDE (투명한 데이터 암호화)](/sql/relational-databases/security/encryption/transparent-data-encryption) 라는 기술을 사용 하 여 데이터가 암호화 된 상태로 유지 되도록 합니다. 새로 만든 모든 SQL 데이터베이스에서 기본적으로 사용 하도록 설정 되어 있지만 레거시 데이터베이스에 대해서는 수동으로 설정 해야 합니다. TDE는 데이터베이스 뿐만 아니라 백업과 트랜잭션 로그에 대 한 실시간 암호화 및 암호 해독을 실행 합니다.

암호화 매개 변수는 `master` 데이터베이스에 저장 되며 시작 시 나머지 작업에 대해 메모리로 읽혀집니다. 이는 `master` 데이터베이스를 암호화 되지 않은 상태로 유지 해야 함을 의미 합니다. 실제 키는 Microsoft에서 관리 합니다. 그러나 이루기 보안 요구 사항이 있는 사용자는 Azure Storage에 대해 수행 되는 것과 거의 동일한 방식으로 Key Vault의 고유한 키를 제공할 수 있습니다. Key Vault는 키 회전 및 해지와 같은 서비스를 제공 합니다.

TDS의 "투명" 부분은 암호화 된 데이터베이스를 사용 하는 데 필요한 클라이언트 변경이 없다는 사실에서 제공 됩니다. 이 방법은 보안을 위해 제공 되지만, 사용자가 데이터를 해독할 수 있도록 데이터베이스 암호 누수가 충분 합니다. 데이터베이스의 개별 열 또는 테이블을 암호화 하는 또 다른 방법이 있습니다. [Always Encrypted](https://docs.microsoft.com/azure/sql-database/sql-database-always-encrypted-azure-key-vault) 는 암호화 된 데이터가 데이터베이스 내에서 일반 텍스트로 표시 되도록 합니다.

이 암호화 계층을 설정 하려면 SQL Server Management Studio의 마법사를 통해 실행 하 여 암호화의 종류를 선택 하 고 Key Vault에서 연결 된 키를 저장 하는 위치를 선택 해야 합니다.

그림 10-6 ![Always Encrypted를 사용 하 여 테이블에서 암호화할 열을 선택](./media/always-encrypted.png)
**그림 10-6**을 사용 합니다. Always Encrypted를 사용 하 여 암호화할 테이블의 열 선택

암호화 된 열에서 정보를 읽는 클라이언트 응용 프로그램은 암호화 된 데이터를 읽을 수 있도록 특수 허용량 해야 합니다. `Column Encryption Setting=Enabled`를 사용 하 여 연결 문자열을 업데이트 하 고 Key Vault에서 클라이언트 자격 증명을 검색 해야 합니다. 그런 다음 SQL Server 클라이언트는 열 암호화 키를 사용 하 여 게이머 되어야 합니다. 이 작업이 완료 되 면 나머지 작업은 SQL 클라이언트에 표준 인터페이스를 사용 합니다. 즉, SQL 클라이언트를 기반으로 구축 된 Dapper 및 Entity Framework 같은 도구는 변경 없이 계속 작동 합니다. 모든 언어의 SQL Server 드라이버 마다 Always Encrypted를 아직 사용할 수 없습니다.

TDE와 Always Encrypted의 조합은 클라이언트 관련 키와 함께 사용할 수 있으므로 가장 이루기 암호화 요구 사항도 지원 됩니다.

### <a name="cosmos-db"></a>Cosmos DB

Cosmos DB은 Azure에서 Microsoft가 제공 하는 최신 데이터베이스입니다. 보안 및 암호화를 고려 하 여 처음부터 새로 빌드 되었습니다. AES-256 비트 암호화는 모든 Cosmos DB 데이터베이스에 대 한 표준 이며 사용 하지 않도록 설정할 수 없습니다. 통신을 위한 TLS 1.2 요구 사항과 결합 된 전체 저장소 솔루션은 암호화 됩니다.

![그림 10-7 Cosmos DB 내에서 데이터 암호화 흐름은 **그림 10-7**](./media/cosmos-encryption.png)
. Cosmos DB 내의 데이터 암호화 흐름입니다.

Cosmos DB에서 고객 암호화 키를 제공 하지 않는 동안 팀이이를 제외 하 고 PCI DSS 규격을 유지 하는지 확인 하는 데 상당한 작업이 수행 되었습니다. 또한 Cosmos DB는 Azure SQL의 Always Encrypted와 유사한 단일 열 암호화의 정렬을 지원 하지 않습니다.

## <a name="keeping-secure"></a>보안 유지

Azure에는 높은 수준의 보안 제품을 릴리스 하는 데 필요한 모든 도구가 포함 되어 있습니다. 그러나 체인은 가장 약한 링크 만큼 강력 합니다. Azure 위에 배포 된 응용 프로그램이 적절 한 보안 사고 및 좋은 보안 감사를 사용 하 여 개발 되지 않은 경우 체인에서 약한 링크가 됩니다. Azure에 설치 된 소프트웨어를 Azure 자체와 안전 하 게 보호 하는 데 사용할 수 있는 유용한 정적 분석 도구, 암호화 라이브러리 및 보안 사례가 많이 있습니다. 예를 들면 [정적 분석 도구](https://www.whitesourcesoftware.com/), [암호화 라이브러리](https://www.libressl.org/)및 [보안 방법이](https://azure.microsoft.com/resources/videos/red-vs-blue-internal-security-penetration-testing-of-microsoft-azure/)있습니다.

>[!div class="step-by-step"]
>[이전](security.md)
>[다음](devops.md)
