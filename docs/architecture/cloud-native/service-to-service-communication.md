---
title: 서비스 간 통신
description: 백 엔드 클라우드 네이티브 마이크로 서비스가 다른 백 엔드 마이크로 서비스와 통신 하는 방법에 대해 알아봅니다.
author: robvet
ms.date: 09/09/2019
ms.openlocfilehash: 6a7e72491cb56d925e684b94109b1aaa98e24df3
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/30/2019
ms.locfileid: "73842016"
---
# <a name="service-to-service-communication"></a><span data-ttu-id="d1c92-103">서비스 간 통신</span><span class="sxs-lookup"><span data-stu-id="d1c92-103">Service-to-service communication</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="d1c92-104">이제 프런트 엔드 클라이언트에서 이동 하 여 백 엔드 마이크로 서비스가 서로 통신 하 게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-104">Moving from the front-end client, we now address back-end microservices communicate with each other.</span></span>

<span data-ttu-id="d1c92-105">클라우드 네이티브 응용 프로그램을 구성 하는 경우 백 엔드 서비스가 서로 통신 하는 방법에 대 한 중요 한 정보가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-105">When constructing a cloud-native application, you'll want to be sensitive to how back-end services communicate with each other.</span></span> <span data-ttu-id="d1c92-106">이상적으로 서비스 간 통신은 더 효율적입니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-106">Ideally, the less inter-service communication, the better.</span></span> <span data-ttu-id="d1c92-107">그러나 백 엔드 서비스에서 작업을 완료 하는 데 종종 서로를 사용 하기 때문에 방지는 항상 가능 하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-107">However, avoidance isn't always possible as back-end services often rely on one another to complete an operation.</span></span>

<span data-ttu-id="d1c92-108">서비스 간 통신을 구현 하는 데 널리 허용 되는 여러 가지 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-108">There are several widely accepted approaches to implementing cross-service communication.</span></span> <span data-ttu-id="d1c92-109">*통신 상호 작용의 유형에* 따라 최상의 방법이 결정 되는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-109">The *type of communication interaction* will often determine the best approach.</span></span>

<span data-ttu-id="d1c92-110">다음 상호 작용 형식을 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-110">Consider the following interaction types:</span></span>

- <span data-ttu-id="d1c92-111">*쿼리* – 호출 마이크로 서비스에 호출 된 마이크로 서비스의 응답이 필요한 경우 (예: "안녕하세요, 지정 된 고객 Id에 대 한 구매자 정보를 제공 합니다.")</span><span class="sxs-lookup"><span data-stu-id="d1c92-111">*Query* – when a calling microservice requires a response from a called microservice, such as, "Hey, give me the buyer information for a given customer Id."</span></span>

- <span data-ttu-id="d1c92-112">*Command* – 호출 마이크로 서비스에서 작업을 실행 하는 다른 마이크로 서비스 필요 하지만 응답이 필요 하지 않은 경우 (예: "안녕하세요"는이 주문을 제공 합니다. ")</span><span class="sxs-lookup"><span data-stu-id="d1c92-112">*Command* – when the calling microservice needs another microservice to execute an action but doesn't require a response, such as, "Hey, just ship this order."</span></span>

- <span data-ttu-id="d1c92-113">*이벤트* – 게시자 라고 하는 마이크로 서비스가 상태가 변경 되었거나 작업이 발생 한 이벤트를 발생 시킵니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-113">*Event* – when a microservice, called the publisher, raises an event that state has changed or an action has occurred.</span></span> <span data-ttu-id="d1c92-114">관심이 있는 구독자 라고 하는 다른 마이크로 서비스는 이벤트에 적절 하 게 반응할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-114">Other microservices, called subscribers, who are interested, can react to the event appropriately.</span></span> <span data-ttu-id="d1c92-115">게시자와 구독자는 서로를 인식 하지 못합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-115">The publisher and the subscribers aren't aware of each other.</span></span>

<span data-ttu-id="d1c92-116">일반적으로 마이크로 서비스 시스템은 서비스 간 상호 작용이 필요한 작업을 실행할 때 이러한 상호 작용 유형을 조합 하 여 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-116">Microservice systems typically use a combination of these interaction types when executing operations that require cross-service interaction.</span></span> <span data-ttu-id="d1c92-117">각각에 대해 좀 더 자세히 살펴보고 구현 방법을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-117">Let's take a close look at each and how you might implement them.</span></span>

## <a name="queries"></a><span data-ttu-id="d1c92-118">쿼리</span><span class="sxs-lookup"><span data-stu-id="d1c92-118">Queries</span></span>

<span data-ttu-id="d1c92-119">한 번에 한 마이크로 서비스 다른 *쿼리* 를 실행 하 여 작업을 완료 하기 위해 즉각적인 응답이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-119">Many times, one microservice might need to *query* another, requiring an immediate response to complete an operation.</span></span> <span data-ttu-id="d1c92-120">시장 바구니 마이크로 서비스 제품 정보 및 바구니에 항목을 추가 하는 가격이 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-120">A shopping basket microservice may need product information and a price to add an item to its basket.</span></span> <span data-ttu-id="d1c92-121">쿼리 작업을 구현 하는 방법에는 여러 가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-121">There are a number of approaches for implementing query operations.</span></span>

### <a name="requestresponse-messaging"></a><span data-ttu-id="d1c92-122">요청/응답 메시징</span><span class="sxs-lookup"><span data-stu-id="d1c92-122">Request/Response Messaging</span></span>

<span data-ttu-id="d1c92-123">이 시나리오를 구현 하는 한 가지 옵션은 그림 4-8에 나와 있는 것 처럼 호출 백 엔드 마이크로 서비스에서 쿼리 해야 하는 마이크로 서비스에 대 한 직접 HTTP 요청을 수행 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-123">One option for implementing this scenario is for the calling back-end microservice to make direct HTTP requests to the microservices it needs to query, shown in Figure 4-8.</span></span>

![직접 HTTP 통신](./media/direct-http-communication.png)

<span data-ttu-id="d1c92-125">**그림 4-8**.</span><span class="sxs-lookup"><span data-stu-id="d1c92-125">**Figure 4-8**.</span></span> <span data-ttu-id="d1c92-126">직접 HTTP 통신</span><span class="sxs-lookup"><span data-stu-id="d1c92-126">Direct HTTP communication</span></span>

<span data-ttu-id="d1c92-127">마이크로 서비스 간의 직접 HTTP 호출은 간단 하 게 구현할 수 있지만이 방법을 최소화 하는 것은 주의를 기울여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-127">While direct HTTP calls between microservices are relatively simple to implement, care should be taken to minimize this practice.</span></span> <span data-ttu-id="d1c92-128">시작 하려면 이러한 호출은 항상 *동기* 이며 결과가 반환 되거나 요청 시간이 초과 될 때까지 작업을 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-128">To start, these calls are always *synchronous* and will block the operation until a result is returned or the request times outs.</span></span> <span data-ttu-id="d1c92-129">독립적으로 독립적으로 발전 하 고 자주 배포할 수 있는 독립적인 서비스는 이제 서로 연결 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-129">What were once self-contained, independent services, able to evolve independently and deploy frequently, now become coupled to each other.</span></span> <span data-ttu-id="d1c92-130">마이크로 서비스 간의 결합으로 증가 하면 아키텍처의 이점이 감소 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-130">As coupling among microservices increase, their architectural benefits diminish.</span></span>

<span data-ttu-id="d1c92-131">다른 마이크로 서비스에 대 한 단일 직접 HTTP 호출을 수행 하는 드물게 발생 하는 요청을 실행 하면 일부 시스템에서 허용 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-131">Executing an infrequent request that makes a single direct HTTP call to another microservice might be acceptable for some systems.</span></span> <span data-ttu-id="d1c92-132">그러나 여러 마이크로 서비스에 대 한 직접 HTTP 호출을 호출 하는 고용량 호출은 권장 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-132">However, high-volume calls that invoke direct HTTP calls to multiple microservices aren't advisable.</span></span> <span data-ttu-id="d1c92-133">대기 시간이 증가 하 고 시스템의 성능, 확장성 및 가용성에 부정적인 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-133">They can increase latency and negatively impact the performance, scalability, and availability of your system.</span></span> <span data-ttu-id="d1c92-134">좀 더 심각한 일련의 직접 HTTP 통신은 그림 4-9에 나와 있는 것 처럼 동기식 마이크로 서비스 호출의 깊이 및 복잡 한 체인을 초래할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-134">Even worse, a long series of direct HTTP communication can lead to deep and complex chains of synchronous microservices calls, shown in Figure 4-9:</span></span>

![HTTP 쿼리 체인](./media/chaining-http-queries.png)

<span data-ttu-id="d1c92-136">**그림 4-9**</span><span class="sxs-lookup"><span data-stu-id="d1c92-136">**Figure 4-9**.</span></span> <span data-ttu-id="d1c92-137">HTTP 쿼리 체인</span><span class="sxs-lookup"><span data-stu-id="d1c92-137">Chaining HTTP queries</span></span>

<span data-ttu-id="d1c92-138">이전 이미지에 표시 된 디자인의 위험을 분명히 생각해 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-138">You can certainly imagine the risk in the design shown in the previous image.</span></span> <span data-ttu-id="d1c92-139">\#3 단계가 실패 하면 어떻게 되나요?</span><span class="sxs-lookup"><span data-stu-id="d1c92-139">What happens if Step \#3 fails?</span></span> <span data-ttu-id="d1c92-140">또는 \#8 단계가 실패 하는 경우</span><span class="sxs-lookup"><span data-stu-id="d1c92-140">Or Step \#8 fails?</span></span> <span data-ttu-id="d1c92-141">어떻게 복구 하나요?</span><span class="sxs-lookup"><span data-stu-id="d1c92-141">How do you recover?</span></span> <span data-ttu-id="d1c92-142">기본 서비스가 사용 중 이기 때문에 \#6 단계가 느려지는 경우는 어떻게 되나요?</span><span class="sxs-lookup"><span data-stu-id="d1c92-142">What if Step \#6 is slow because the underlying service is busy?</span></span> <span data-ttu-id="d1c92-143">계속 하 시겠습니까?</span><span class="sxs-lookup"><span data-stu-id="d1c92-143">How do you continue?</span></span> <span data-ttu-id="d1c92-144">모든 것이 제대로 작동 하는 경우에도이 호출이 발생 하는 대기 시간을 고려해 야 합니다 .이는 각 단계의 대기 시간 합계입니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-144">Even if all works correctly, think of the latency this call would incur, which is the sum of the latency of each step.</span></span>

<span data-ttu-id="d1c92-145">이전 이미지에서 많은 결합은 서비스가 최적으로 모델링 되지 않은 것을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-145">The large degree of coupling in the previous image suggests the services weren't optimally modeled.</span></span> <span data-ttu-id="d1c92-146">팀이 해당 디자인을 다시 behoove 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-146">It would behoove the team to revisit their design.</span></span>

### <a name="materialized-view-pattern"></a><span data-ttu-id="d1c92-147">구체화 된 뷰 패턴</span><span class="sxs-lookup"><span data-stu-id="d1c92-147">Materialized View pattern</span></span>

<span data-ttu-id="d1c92-148">마이크로 서비스 커플링을 제거 하는 널리 사용 되는 옵션은 [구체화 된 뷰 패턴](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)입니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-148">A popular option for removing microservice coupling is the [Materialized View pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view).</span></span> <span data-ttu-id="d1c92-149">이 패턴을 사용 하면 마이크로 서비스는 다른 서비스에서 소유 하는 정규화 된 로컬 데이터 복사본을 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-149">With this pattern, a microservice stores its own local, denormalized copy of data that's owned by other services.</span></span> <span data-ttu-id="d1c92-150">제품 카탈로그 및 가격 마이크로 서비스를 쿼리 하는 시장 바구니 마이크로 서비스 대신 해당 데이터의 로컬 복사본을 유지 관리 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-150">Instead of the Shopping Basket microservice querying the Product Catalog and Pricing microservices, it maintains its own local copy of that data.</span></span> <span data-ttu-id="d1c92-151">이 패턴은 불필요 한 결합을 제거 하 고 안정성 및 응답 시간을 향상 시킵니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-151">This pattern eliminates unnecessary coupling and improves reliability and response time.</span></span> <span data-ttu-id="d1c92-152">전체 작업은 단일 프로세스 내에서 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-152">The entire operation executes inside a single process.</span></span> <span data-ttu-id="d1c92-153">5 장에서이 패턴 및 기타 데이터 문제를 살펴봅니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-153">We explore this pattern and other data concerns in Chapter 5.</span></span>

### <a name="service-aggregator-pattern"></a><span data-ttu-id="d1c92-154">서비스 집계 패턴</span><span class="sxs-lookup"><span data-stu-id="d1c92-154">Service Aggregator Pattern</span></span>

<span data-ttu-id="d1c92-155">마이크로 서비스-마이크로 서비스 결합을 제거 하는 또 다른 옵션은 그림 4-10에 자주색으로 표시 된 [집계 마이크로 서비스](https://devblogs.microsoft.com/cesardelatorre/designing-and-implementing-api-gateways-with-ocelot-in-a-microservices-and-container-based-architecture/)입니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-155">Another option for eliminating microservice-to-microservice coupling is an [Aggregator microservice](https://devblogs.microsoft.com/cesardelatorre/designing-and-implementing-api-gateways-with-ocelot-in-a-microservices-and-container-based-architecture/), shown in purple in Figure 4-10.</span></span>

![집계 서비스](./media/aggregator-service.png)

<span data-ttu-id="d1c92-157">**그림 4-10**</span><span class="sxs-lookup"><span data-stu-id="d1c92-157">**Figure 4-10**.</span></span> <span data-ttu-id="d1c92-158">집계 마이크로 서비스</span><span class="sxs-lookup"><span data-stu-id="d1c92-158">Aggregator microservice</span></span>

<span data-ttu-id="d1c92-159">패턴은 여러 백 엔드 마이크로 서비스를 호출 하는 작업을 격리 하 여 해당 논리를 특수화 된 마이크로 서비스 중앙 집중화 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-159">The pattern isolates an operation that makes calls to multiple back-end microservices, centralizing its logic into a specialized microservice.</span></span>  <span data-ttu-id="d1c92-160">이전 그림의 자주색 체크 아웃 집계 마이크로 서비스는 체크 아웃 작업에 대 한 워크플로를 오케스트레이션 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-160">The purple checkout aggregator microservice in the previous figure orchestrates the workflow for the Checkout operation.</span></span> <span data-ttu-id="d1c92-161">시퀀싱 된 순서로 여러 백 엔드 마이크로 서비스에 대 한 호출을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-161">It includes calls to several back-end microservices in a sequenced order.</span></span> <span data-ttu-id="d1c92-162">워크플로의 데이터가 집계 되 고 호출자에 게 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-162">Data from the workflow is aggregated and returned to the caller.</span></span> <span data-ttu-id="d1c92-163">직접 HTTP 호출을 구현 하는 동안 집계 마이크로 서비스 백 엔드 마이크로 서비스 간의 직접 종속성을 줄입니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-163">While it still implements direct HTTP calls, the aggregator microservice reduces direct dependencies among back-end microservices.</span></span>

### <a name="requestreply-pattern"></a><span data-ttu-id="d1c92-164">요청/회신 패턴</span><span class="sxs-lookup"><span data-stu-id="d1c92-164">Request/Reply Pattern</span></span>

<span data-ttu-id="d1c92-165">동기 HTTP 메시지를 분리 하는 또 다른 방법은 큐 통신을 사용 하는 [요청-회신 패턴](https://www.enterpriseintegrationpatterns.com/patterns/messaging/RequestReply.html)입니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-165">Another approach for decoupling synchronous HTTP messages is a [Request-Reply Pattern](https://www.enterpriseintegrationpatterns.com/patterns/messaging/RequestReply.html), which uses queuing communication.</span></span> <span data-ttu-id="d1c92-166">큐를 사용 하는 통신은 항상 단방향 채널 이며 생산자는 메시지와 소비자를 수신 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-166">Communication using a queue is always a one-way channel, with a producer sending the message and consumer receiving it.</span></span> <span data-ttu-id="d1c92-167">이 패턴을 사용 하 여 그림 4-11에 표시 된 요청 큐와 응답 큐를 모두 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-167">With this pattern, both a request queue and response queue are implemented, shown in Figure 4-11.</span></span>

![요청-회신 패턴](./media/request-reply-pattern.png)

<span data-ttu-id="d1c92-169">**그림 4-11**</span><span class="sxs-lookup"><span data-stu-id="d1c92-169">**Figure 4-11**.</span></span> <span data-ttu-id="d1c92-170">요청-회신 패턴</span><span class="sxs-lookup"><span data-stu-id="d1c92-170">Request-reply pattern</span></span>

<span data-ttu-id="d1c92-171">여기에서 메시지 생산자는 고유한 상관 관계 ID를 포함 하는 쿼리 기반 메시지를 만들어 요청 큐에 배치 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-171">Here, the message producer creates a query-based message that contains a unique correlation ID and places it into a request queue.</span></span> <span data-ttu-id="d1c92-172">소비 하는 서비스는 메시지를 큐에서 제거 하 고 처리 한 다음 응답을 동일한 상관 관계 ID를 사용 하 여 응답 큐에 배치 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-172">The consuming service dequeues the messages, processes it and places the response into the response queue with the same correlation ID.</span></span> <span data-ttu-id="d1c92-173">생산자 서비스는 메시지를 큐에 대기 시키고 상관 관계 ID와 일치 시키고 처리를 계속 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-173">The producer service dequeues the message, matches it with the correlation ID and continues processing.</span></span> <span data-ttu-id="d1c92-174">다음 섹션에서 큐를 자세히 다룹니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-174">We cover queues in detail in the next section.</span></span>

## <a name="commands"></a><span data-ttu-id="d1c92-175">명령</span><span class="sxs-lookup"><span data-stu-id="d1c92-175">Commands</span></span>

<span data-ttu-id="d1c92-176">또 다른 유형의 통신 상호 작용은 *명령*입니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-176">Another type of communication interaction is a *command*.</span></span> <span data-ttu-id="d1c92-177">마이크로 서비스는 작업을 수행 하는 다른 마이크로 서비스 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-177">A microservice may need another microservice to perform an action.</span></span> <span data-ttu-id="d1c92-178">주문 마이크로 서비스에서 승인 된 주문에 대 한 배송을 만들기 위해 배송 마이크로 서비스 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-178">The Ordering microservice may need the Shipping microservice to create a shipment for an approved order.</span></span> <span data-ttu-id="d1c92-179">그림 4-12에서 생산자 라는 하나의 마이크로 서비스는 다른 마이크로 서비스, 소비자에 게 메시지를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-179">In Figure 4-12, one microservice, called a Producer, sends a message to another microservice, the Consumer, commanding it to do something.</span></span>

![큐와의 명령 상호 작용](./media/command-interaction-with-queue.png)

<span data-ttu-id="d1c92-181">**그림 4-12**.</span><span class="sxs-lookup"><span data-stu-id="d1c92-181">**Figure 4-12**.</span></span> <span data-ttu-id="d1c92-182">큐와의 명령 상호 작용</span><span class="sxs-lookup"><span data-stu-id="d1c92-182">Command interaction with a queue</span></span>

<span data-ttu-id="d1c92-183">대부분의 경우 생산자는 응답이 필요 하지 않으며 메시지를 *발생 시키고 잊어버릴* 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-183">Most often, the Producer doesn't require a response and can *fire-and-forget* the message.</span></span> <span data-ttu-id="d1c92-184">회신이 필요한 경우 소비자는 다른 채널의 생산자에 게 개별 메시지를 다시 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-184">If a reply is needed, the Consumer sends a separate message back to Producer on another channel.</span></span> <span data-ttu-id="d1c92-185">명령 메시지는 메시지 큐를 사용 하 여 비동기적으로 전송 하는 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-185">A command message is best sent asynchronously with a message queue.</span></span> <span data-ttu-id="d1c92-186">경량 메시지 브로커에서 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-186">supported by a lightweight message broker.</span></span> <span data-ttu-id="d1c92-187">위의 다이어그램에서 큐가 두 서비스를 구분 하 고 분리 하는 방법을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-187">In the previous diagram, note how a queue separates and decouples both services.</span></span>

<span data-ttu-id="d1c92-188">메시지 큐는 생산자와 소비자가 메시지를 전달 하는 중간 구문입니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-188">A message queue is an intermediary construct through which a producer and consumer pass a message.</span></span> <span data-ttu-id="d1c92-189">큐는 비동기 지점 간 메시징 패턴을 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-189">Queues implement an asynchronous, point-to-point messaging pattern.</span></span> <span data-ttu-id="d1c92-190">생산자는 명령을 보내고 적절 하 게 라우팅하는 위치를 알고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-190">The Producer knows where a command needs to be sent and routes appropriately.</span></span> <span data-ttu-id="d1c92-191">큐는 채널에서 읽는 소비자 인스턴스 중 하나에서 메시지가 처리 되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-191">The queue guarantees that a message is processed by exactly one of the consumer instances that are reading from the channel.</span></span> <span data-ttu-id="d1c92-192">이 시나리오에서는 생산자 또는 소비자 서비스가 다른에 영향을 주지 않고 규모를 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-192">In this scenario, either the producer or consumer service can scale out without affecting the other.</span></span> <span data-ttu-id="d1c92-193">또한 기술은 서로 다를 수 있습니다. 즉, [Golang](https://golang.org) 마이크로 서비스를 호출 하는 Java 마이크로 서비스 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-193">As well, technologies can be disparate on each side, meaning that we might have a Java microservice calling a [Golang](https://golang.org) microservice.</span></span>

<span data-ttu-id="d1c92-194">1 장에서는 *서비스 지원*에 대해 설명 했습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-194">In chapter 1, we talked about *backing services*.</span></span> <span data-ttu-id="d1c92-195">지원 서비스는 클라우드 네이티브 시스템이 종속 되는 보조 리소스입니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-195">Backing services are ancillary resources upon which cloud-native systems depend.</span></span> <span data-ttu-id="d1c92-196">메시지 큐는 서비스를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-196">Message queues are backing services.</span></span> <span data-ttu-id="d1c92-197">Azure 클라우드는 클라우드 네이티브 시스템에서 명령 메시지를 구현 하는 데 사용할 수 있는 두 가지 유형의 메시지 큐 인 Azure Storage 큐 및 Azure Service Bus 큐를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-197">The Azure cloud supports two types of message queues that your cloud-native systems can consume to implement command messaging: Azure Storage Queues and Azure Service Bus Queues.</span></span>

### <a name="azure-storage-queues"></a><span data-ttu-id="d1c92-198">Azure Storage 큐</span><span class="sxs-lookup"><span data-stu-id="d1c92-198">Azure Storage Queues</span></span>

<span data-ttu-id="d1c92-199">Azure storage 큐는 빠르고 경제적 이며 Azure storage 계정으로 지원 되는 간단한 큐 인프라를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-199">Azure storage queues offer a simple queueing infrastructure that is fast, affordable, and backed by Azure storage accounts.</span></span>

<span data-ttu-id="d1c92-200">[Azure Storage 큐](https://docs.microsoft.com/azure/storage/queues/storage-queues-introduction) 는 안정적이 고 지속적인 메시징을 갖춘 REST 기반 큐 메커니즘을 기능 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-200">[Azure Storage Queues](https://docs.microsoft.com/azure/storage/queues/storage-queues-introduction) feature a REST-based queuing mechanism with reliable and persistent messaging.</span></span> <span data-ttu-id="d1c92-201">최소 기능 집합을 제공 하지만 저렴 하 고 수백만 개의 메시지를 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-201">They provide a minimal feature set, but are inexpensive and store millions of messages.</span></span> <span data-ttu-id="d1c92-202">용량 범위는 최대 500 TB입니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-202">Their capacity ranges up to 500 TB.</span></span> <span data-ttu-id="d1c92-203">단일 메시지의 크기는 최대 64 KB가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-203">A single message can be up to 64 KB in size.</span></span>

<span data-ttu-id="d1c92-204">HTTP 또는 HTTPS를 사용 하 여 인증 된 호출을 통해 전 세계 어디에서 나 메시지에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-204">You can access messages from anywhere in the world via authenticated calls using HTTP or HTTPS.</span></span> <span data-ttu-id="d1c92-205">저장소 큐는 많은 수의 동시 클라이언트로 확장 하 여 트래픽 급증을 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-205">Storage queues can scale out to large numbers of concurrent clients to handle traffic spikes.</span></span>

<span data-ttu-id="d1c92-206">즉, 서비스에는 다음과 같은 제한 사항이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-206">That said, there are limitations with the service:</span></span>

- <span data-ttu-id="d1c92-207">메시지 순서는 보장 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-207">Message order isn't guaranteed.</span></span>

- <span data-ttu-id="d1c92-208">메시지는 자동으로 제거 되기 7 일 동안만 지속 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-208">A message can only persist for seven days before it's automatically removed.</span></span>

- <span data-ttu-id="d1c92-209">상태 관리, 중복 검색 또는 트랜잭션을 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-209">Support for state management, duplicate detection, or transactions isn't available.</span></span>

<span data-ttu-id="d1c92-210">그림 4-13에서는 Azure Storage 큐의 계층 구조를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-210">Figure 4-13 shows the hierarchy of an Azure Storage Queue.</span></span>

![저장소 큐 계층 구조](./media/storage-queue-hierarchy.png)

<span data-ttu-id="d1c92-212">**그림 4-13**.</span><span class="sxs-lookup"><span data-stu-id="d1c92-212">**Figure 4-13**.</span></span> <span data-ttu-id="d1c92-213">저장소 큐 계층 구조</span><span class="sxs-lookup"><span data-stu-id="d1c92-213">Storage queue hierarchy</span></span>

<span data-ttu-id="d1c92-214">위의 그림에서 저장소 큐가 기본 Azure Storage 계정에 메시지를 저장 하는 방법을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-214">In the previous figure, note how storage queues store their messages in the underlying Azure Storage account.</span></span>

<span data-ttu-id="d1c92-215">개발자를 위해 Microsoft는 저장소 큐 처리를 위한 여러 클라이언트 및 서버 쪽 라이브러리를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-215">For developers, Microsoft provides several client and server-side libraries for Storage queue processing.</span></span> <span data-ttu-id="d1c92-216">.NET, Java, JavaScript, Ruby, Python 및 Go를 비롯 한 대부분의 주요 플랫폼이 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-216">Most major platforms are supported including .NET, Java, JavaScript, Ruby, Python, and Go.</span></span> <span data-ttu-id="d1c92-217">개발자는 이러한 라이브러리와 직접 통신 해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-217">Developers should never communicate directly with these libraries.</span></span> <span data-ttu-id="d1c92-218">이렇게 하면 마이크로 서비스 코드를 Azure Storage 큐 서비스에 긴밀 하 게 두는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-218">Doing so will tightly couple your microservice code to the Azure Storage Queue service.</span></span> <span data-ttu-id="d1c92-219">API의 구현 세부 정보를 안전 하 게 유지 하는 것이 더 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-219">It's a better practice to insulate the implementation details of the API.</span></span> <span data-ttu-id="d1c92-220">제네릭 작업을 노출 하 고 구체적인 라이브러리를 캡슐화 하는 intermediation 계층 또는 중간 API를 도입 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-220">Introduce an intermediation layer, or intermediate API, that exposes generic operations and encapsulates the concrete library.</span></span> <span data-ttu-id="d1c92-221">이러한 느슨한 결합을 사용 하면 중요 서비스 코드를 변경할 필요 없이 한 큐 서비스를 다른 큐로 교환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-221">This loose coupling enables you to swap out one queuing service for another without having to make changes to the mainline service code.</span></span>

<span data-ttu-id="d1c92-222">Azure Storage 큐는 클라우드 네이티브 응용 프로그램에서 명령 메시지를 구현 하는 경제적인 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-222">Azure Storage queues are an economical option to implement command messaging in your cloud-native applications.</span></span> <span data-ttu-id="d1c92-223">특히 큐 크기가 80 GB를 초과 하거나 간단한 기능 집합을 사용할 수 있는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-223">Especially when a queue size will exceed 80 GB, or a simple feature set is acceptable.</span></span> <span data-ttu-id="d1c92-224">메시지 저장소에 대해서만 비용을 지불 하면 됩니다. 고정 된 시간당 요금이 청구 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-224">You only pay for the storage of the messages; there are no fixed hourly charges.</span></span>

### <a name="azure-service-bus-queues"></a><span data-ttu-id="d1c92-225">Azure Service Bus 큐</span><span class="sxs-lookup"><span data-stu-id="d1c92-225">Azure Service Bus Queues</span></span>

<span data-ttu-id="d1c92-226">더 복잡 한 메시징 요구 사항은 큐를 Azure Service Bus 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-226">For more complex messaging requirements, consider Azure Service Bus queues.</span></span>

<span data-ttu-id="d1c92-227">[Azure Service Bus](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messaging-overview) 는 강력한 메시지 인프라를 기반으로 하며,이는 조정 된 *메시징 모델*을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-227">Sitting atop a robust message infrastructure, [Azure Service Bus](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messaging-overview) supports a *brokered messaging model*.</span></span> <span data-ttu-id="d1c92-228">메시지는 소비자가 받을 때까지 broker (큐)에 안정적으로 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-228">Messages are reliably stored in a broker (the queue) until received by the consumer.</span></span> <span data-ttu-id="d1c92-229">큐는 메시지를 큐에 추가 하는 순서에 따라 FIFO (선입 선출) 메시지 배달을 보장 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-229">The queue guarantees First-In/First-Out (FIFO) message delivery, respecting the order in which messages were added to the queue.</span></span>

<span data-ttu-id="d1c92-230">메시지 크기는 최대 256 KB까지 훨씬 클 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-230">The size of a message can be much larger, up to 256 KB.</span></span> <span data-ttu-id="d1c92-231">메시지는 무제한 시간 동안 큐에 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-231">Messages are persisted in the queue for an unlimited period of time.</span></span> <span data-ttu-id="d1c92-232">Service Bus는 HTTP 기반 호출만 지원 하며 [AMPQ 프로토콜](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-amqp-overview)에 대 한 완전 한 지원도 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-232">Service Bus supports not only HTTP-based calls, but also provides full support for the [AMPQ protocol](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-amqp-overview).</span></span> <span data-ttu-id="d1c92-233">AMPQ는 이진 프로토콜 및 높은 수준의 안정성을 지 원하는 공급 업체의 오픈 표준입니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-233">AMPQ is an open-standard across vendors that supports a binary protocol and higher degrees of reliability.</span></span>

<span data-ttu-id="d1c92-234">Service Bus은 [트랜잭션 지원](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions) 및 [중복 검색 기능](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection)을 비롯 한 다양 한 기능 집합을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-234">Service Bus provides a rich set of features, including [transaction support](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions) and a [duplicate detection feature](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection).</span></span> <span data-ttu-id="d1c92-235">큐는 메시지당 "최대 한 번의 배달"을 보장 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-235">The queue guarantees "at most once delivery" per message.</span></span> <span data-ttu-id="d1c92-236">이미 전송 된 메시지를 자동으로 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-236">It automatically discards a message that has already been sent.</span></span> <span data-ttu-id="d1c92-237">생산자가 확실 하지 않은 경우 동일한 메시지를 다시 보낼 수 있으며, Service Bus 한 개의 복사본만 처리 되도록 보장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-237">If a producer is in doubt, it can resend the same message, and Service Bus guarantees that only one copy will be processed.</span></span> <span data-ttu-id="d1c92-238">중복 검색을 통해 추가 인프라를 구축할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-238">Duplicate detection frees you from  having to build additional infrastructure plumbing.</span></span>

<span data-ttu-id="d1c92-239">두 가지 enterprise 기능인 분할 및 세션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-239">Two more enterprise features are partitioning and sessions.</span></span> <span data-ttu-id="d1c92-240">기존 Service Bus 큐는 단일 메시지 브로커에 의해 처리 되 고 단일 메시지 저장소에 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-240">A conventional Service Bus queue is handled by a single message broker and stored in a single message store.</span></span> <span data-ttu-id="d1c92-241">그러나 [Service Bus 분할](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning) 은 큐를 여러 메시지 브로커 및 메시지 저장소에 분산 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-241">But, [Service Bus Partitioning](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning) spreads the queue across multiple message brokers and message stores.</span></span> <span data-ttu-id="d1c92-242">전체 처리량은 더 이상 단일 메시지 브로커 또는 메시징 저장소의 성능으로 제한 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-242">The overall throughput is no longer limited by the performance of a single message broker or messaging store.</span></span> <span data-ttu-id="d1c92-243">메시징 저장소의 일시적인 중단은 분할 된 큐를 사용할 수 없게 렌더링 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-243">A temporary outage of a messaging store doesn't render a partitioned queue unavailable.</span></span>

<span data-ttu-id="d1c92-244">[Service Bus 세션](https://codingcanvas.com/azure-service-bus-sessions/) 은 관련 메시지를 그룹화 하는 방법을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-244">[Service Bus Sessions](https://codingcanvas.com/azure-service-bus-sessions/) provide a way to group-related messages.</span></span> <span data-ttu-id="d1c92-245">메시지를 함께 처리 하 고 작업을 끝에 완료 해야 하는 워크플로 시나리오를 가정해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-245">Imagine a workflow scenario where messages must be processed together and the operation completed at the end.</span></span> <span data-ttu-id="d1c92-246">이를 활용 하려면 큐에 대해 세션을 명시적으로 사용 하도록 설정 해야 하며 관련 된 각 메시지에 동일한 세션 ID가 포함 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-246">To take advantage, sessions must be explicitly enabled for the queue and each related messaged must contain the same session ID.</span></span>

<span data-ttu-id="d1c92-247">그러나 Service Bus 큐 크기는 80 GB로 제한 됩니다 .이는 저장소 큐에서 사용할 수 있는 것 보다 훨씬 더 작기 때문에 주의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-247">However, there are some important caveats: Service Bus queues size is limited to 80 GB, which is much smaller than what's available from store queues.</span></span> <span data-ttu-id="d1c92-248">또한 Service Bus 큐는 작업당 기본 비용 및 요금을 부과 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-248">Additionally, Service Bus queues incur a base cost and charge per operation.</span></span>

<span data-ttu-id="d1c92-249">그림 4-14에서는 Service Bus 큐의 상위 수준 아키텍처를 간략하게 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-249">Figure 4-14 outlines the high-level architecture of a Service Bus queue.</span></span>

![Service Bus 큐](./media/service-bus-queue.png)

<span data-ttu-id="d1c92-251">**그림 4-14**.</span><span class="sxs-lookup"><span data-stu-id="d1c92-251">**Figure 4-14**.</span></span> <span data-ttu-id="d1c92-252">Service Bus 큐</span><span class="sxs-lookup"><span data-stu-id="d1c92-252">Service Bus queue</span></span>

<span data-ttu-id="d1c92-253">위의 그림에서 지점 간 관계를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-253">In the previous figure, note the point-to-point relationship.</span></span> <span data-ttu-id="d1c92-254">동일한 공급자의 두 인스턴스는 메시지를 단일 Service Bus 큐로 예외로 인해 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-254">Two instances of the same provider are enqueuing messages into a single Service Bus queue.</span></span> <span data-ttu-id="d1c92-255">각 메시지는 오른쪽에 있는 세 개의 소비자 인스턴스 중 하나 에서만 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-255">Each message is consumed by only one of three consumer instances on the right.</span></span> <span data-ttu-id="d1c92-256">다음으로 여러 소비자가 동일한 메시지에 관심을 가질 수 있는 메시징을 구현 하는 방법을 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-256">Next, we discuss how to implement messaging where different consumers may all be interested the same message.</span></span>

## <a name="events"></a><span data-ttu-id="d1c92-257">이벤트</span><span class="sxs-lookup"><span data-stu-id="d1c92-257">Events</span></span>

<span data-ttu-id="d1c92-258">메시지 큐는 생산자가 소비자에 게 메시지를 비동기적으로 보낼 수 있는 통신을 구현 하는 효과적인 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-258">Message queuing is an effective way to implement communication where a producer can asynchronously send a consumer a message.</span></span> <span data-ttu-id="d1c92-259">그러나 여러 *소비자* 가 동일한 메시지에 관심이 있으면 어떻게 되나요?</span><span class="sxs-lookup"><span data-stu-id="d1c92-259">However, what happens when *many different consumers* are interested in the same message?</span></span> <span data-ttu-id="d1c92-260">각 소비자에 대 한 전용 메시지 큐가 제대로 확장 되지 않으며 관리가 어려워집니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-260">A dedicated message queue for each consumer wouldn't scale well and would become difficult to manage.</span></span>

<span data-ttu-id="d1c92-261">이 시나리오를 해결 하기 위해 이벤트 상호 작용의 세 번째 유형인 *이벤트*로 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-261">To address this scenario, we move to the third type of message interaction, the *event*.</span></span> <span data-ttu-id="d1c92-262">한 마이크로 서비스 작업이 발생 했음을 알립니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-262">One microservice announces that an action had occurred.</span></span> <span data-ttu-id="d1c92-263">다른 마이크로 서비스는 관심이 있으면 작업 또는 이벤트에 반응 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-263">Other microservices, if interested, react to the action, or event.</span></span>

<span data-ttu-id="d1c92-264">이벤트는 2 단계 프로세스입니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-264">Eventing is a two-step process.</span></span> <span data-ttu-id="d1c92-265">지정 된 상태 변경의 경우 마이크로 서비스은 메시지 브로커에 이벤트를 게시 하 여 관심 있는 다른 모든 마이크로 서비스에 사용할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-265">For a given state change, a microservice publishes an event to a message broker, making it available to any other interested microservice.</span></span> <span data-ttu-id="d1c92-266">관심 있는 마이크로 서비스는 메시지 브로커의 이벤트를 구독 하 여 알림을 받습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-266">The interested microservice is notified by subscribing to the event in the message broker.</span></span> <span data-ttu-id="d1c92-267">[게시/구독](https://docs.microsoft.com/azure/architecture/patterns/publisher-subscriber) 패턴을 사용 하 여 [이벤트 기반 통신](https://docs.microsoft.com/dotnet/standard/microservices-architecture/multi-container-microservice-net-applications/integration-event-based-microservice-communications)을 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-267">You use the [Publish/Subscribe](https://docs.microsoft.com/azure/architecture/patterns/publisher-subscriber) pattern to implement [event-based communication](https://docs.microsoft.com/dotnet/standard/microservices-architecture/multi-container-microservice-net-applications/integration-event-based-microservice-communications).</span></span>

<span data-ttu-id="d1c92-268">그림 4-15에는이를 구독 하는 다른 두 마이크로 서비스를 사용 하 여 이벤트를 게시 하는 시장 바구니 마이크로 서비스 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-268">Figure 4-15 shows a shopping basket microservice publishing an event with two other microservices subscribing to it.</span></span>

![이벤트 기반 메시징](./media/event-driven-messaging.png)

<span data-ttu-id="d1c92-270">**그림 4-15**.</span><span class="sxs-lookup"><span data-stu-id="d1c92-270">**Figure 4-15**.</span></span> <span data-ttu-id="d1c92-271">이벤트 기반 메시징</span><span class="sxs-lookup"><span data-stu-id="d1c92-271">Event-Driven messaging</span></span>

<span data-ttu-id="d1c92-272">통신 채널의 중간에 있는 *이벤트 버스* 구성 요소를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-272">Note the *event bus* component that sits in the middle of the communication channel.</span></span> <span data-ttu-id="d1c92-273">이 클래스는 메시지 브로커를 캡슐화 하 고 기본 응용 프로그램에서 분리 하는 사용자 지정 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-273">It's a custom class that encapsulates the message broker and decouples it from the underlying application.</span></span> <span data-ttu-id="d1c92-274">주문 및 인벤토리 마이크로 서비스는 서로에 대 한 지식 없이 이벤트와 시장 바구니 마이크로 서비스을 독립적으로 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-274">The ordering and inventory microservices independently operate the event with no knowledge of each other, nor the shopping basket microservice.</span></span> <span data-ttu-id="d1c92-275">등록 된 이벤트는 이벤트 버스에 게시 될 때 해당 이벤트에 대해 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-275">When the registered event is published to the event bus, they act upon it.</span></span>

<span data-ttu-id="d1c92-276">이벤트를 사용 하 여 큐 기술에서 *항목*으로 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-276">With eventing, we move from queuing technology to *topics*.</span></span> <span data-ttu-id="d1c92-277">[토픽](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions) 은 큐와 유사 하지만 일대다 메시징 패턴을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-277">A [topic](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions) is similar to a queue, but supports a one-to-many messaging pattern.</span></span> <span data-ttu-id="d1c92-278">한 마이크로 서비스 메시지를 게시 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-278">One microservice publishes a message.</span></span> <span data-ttu-id="d1c92-279">여러 구독 마이크로 서비스에서 해당 메시지를 수신 하 고 작업 하도록 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-279">Multiple subscribing microservices can choose to receive and act upon that message.</span></span> <span data-ttu-id="d1c92-280">그림 4-16에서는 항목 아키텍처를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-280">Figure 4-16 shows a topic architecture.</span></span>

![토픽 아키텍처](./media/topic-architecture.png)

<span data-ttu-id="d1c92-282">**그림 4-16**.</span><span class="sxs-lookup"><span data-stu-id="d1c92-282">**Figure 4-16**.</span></span> <span data-ttu-id="d1c92-283">토픽 아키텍처</span><span class="sxs-lookup"><span data-stu-id="d1c92-283">Topic architecture</span></span>

<span data-ttu-id="d1c92-284">위의 그림에서 게시자는 토픽에 메시지를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-284">In the previous figure, publishers send messages to the topic.</span></span> <span data-ttu-id="d1c92-285">결국 구독자는 구독에서 메시지를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-285">At the end, subscribers receive messages from subscriptions.</span></span> <span data-ttu-id="d1c92-286">가운데에서 항목은 진한 파란색 상자에 표시 된 *규칙*집합에 따라 구독에 메시지를 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-286">In the middle, the topic forwards messages to subscriptions based on a set of *rules*, shown in dark blue boxes.</span></span> <span data-ttu-id="d1c92-287">규칙은 특정 메시지를 구독으로 전달 하는 필터 역할을 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-287">Rules act as a filter that forward specific messages to a subscription.</span></span> <span data-ttu-id="d1c92-288">여기에서 "CreateOrder" 이벤트는 구독 \#1 및 구독 \#3으로 전송 되지만 구독 \#2로는 전송 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-288">Here, a "CreateOrder" event would be sent to Subscription \#1 and Subscription \#3, but not to Subscription \#2.</span></span> <span data-ttu-id="d1c92-289">"OrderCompleted" 이벤트는 Subscription \#2 및 Subscription \#3으로 전송 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-289">An "OrderCompleted" event would be sent to Subscription \#2 and Subscription \#3.</span></span>

<span data-ttu-id="d1c92-290">Azure 클라우드는 Azure Service Bus 토픽 및 Azure EventGrid와 같은 두 가지 토픽 서비스를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-290">The Azure cloud supports two different topic services: Azure Service Bus Topics and Azure EventGrid.</span></span>

### <a name="azure-service-bus-topics"></a><span data-ttu-id="d1c92-291">Azure Service Bus 항목</span><span class="sxs-lookup"><span data-stu-id="d1c92-291">Azure Service Bus Topics</span></span>

<span data-ttu-id="d1c92-292">Azure Service Bus 큐의 동일한 강력한 조정 된 메시지 모델 위에 있는 것은 [Azure Service Bus 토픽](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)입니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-292">Sitting on top of the same robust brokered message model of Azure Service Bus queues are [Azure Service Bus Topics](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span> <span data-ttu-id="d1c92-293">토픽은 여러 독립 게시자의 메시지를 수신 하 고 최대 2000 구독자에 게 메시지를 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-293">A topic can receive messages from multiple independent publishers and send messages to up to 2,000 subscribers.</span></span> <span data-ttu-id="d1c92-294">시스템을 중지 하거나 토픽을 다시 만들지 않고도 런타임에 구독을 동적으로 추가 하거나 제거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-294">Subscriptions can be dynamically added or removed at runtime without stopping the system or recreating the topic.</span></span>

<span data-ttu-id="d1c92-295">[중복 검색](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection) 및 [트랜잭션 지원을](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions)포함 하 여 항목에 대해서도 Azure Service Bus 큐의 많은 고급 기능을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-295">Many advanced features from Azure Service Bus queues are also available for topics, including [Duplicate Detection](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection) and [Transaction support](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions).</span></span> <span data-ttu-id="d1c92-296">기본적으로 Service Bus 토픽은 단일 메시지 브로커에 의해 처리 되 고 단일 메시지 저장소에 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-296">By default, Service Bus topics are handled by a single message broker and stored in a single message store.</span></span> <span data-ttu-id="d1c92-297">그러나 [Service Bus 분할](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning) 은 여러 메시지 브로커 및 메시지 저장소에 분산 하 여 토픽의 크기를 조정 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-297">But, [Service Bus Partitioning](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning) scales a topic by spreading it across many message brokers and message stores.</span></span>

<span data-ttu-id="d1c92-298">[예약 된 메시지 배달](https://docs.microsoft.com/azure/service-bus-messaging/message-sequencing) 는 특정 처리 시간을 가진 메시지에 태그를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-298">[Scheduled Message Delivery](https://docs.microsoft.com/azure/service-bus-messaging/message-sequencing) tags a message with a specific time for processing.</span></span> <span data-ttu-id="d1c92-299">이 메시지는 해당 시간 이전에 항목에 표시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-299">The message won't appear in the topic before that time.</span></span> <span data-ttu-id="d1c92-300">[메시지를 지연](https://docs.microsoft.com/azure/service-bus-messaging/message-deferral) 하면 나중에 메시지를 검색 하는 것을 연기할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-300">[Message Deferral](https://docs.microsoft.com/azure/service-bus-messaging/message-deferral) enables you to defer a retrieval of a message to a later time.</span></span> <span data-ttu-id="d1c92-301">둘 다 작업을 특정 순서로 처리 하는 워크플로 처리 시나리오에서 일반적으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-301">Both are commonly used in workflow processing scenarios where operations are processed in a particular order.</span></span> <span data-ttu-id="d1c92-302">이전 작업이 완료 될 때까지 받은 메시지의 처리를 연기할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-302">You can postpone processing of received messages until prior work has been completed.</span></span>

<span data-ttu-id="d1c92-303">Service Bus 토픽은 클라우드 네이티브 시스템에서 게시/구독 통신을 사용 하도록 설정 하는 강력 하 고 검증 된 기술입니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-303">Service Bus topics are a robust and proven technology for enabling publish/subscribe communication in your cloud-native systems.</span></span>

### <a name="azure-event-grid"></a><span data-ttu-id="d1c92-304">Azure Event Grid</span><span class="sxs-lookup"><span data-stu-id="d1c92-304">Azure Event Grid</span></span>

<span data-ttu-id="d1c92-305">Azure Service Bus는 전체 엔터프라이즈 기능 집합을 포함 하는 전투 테스트 된 메시징 브로커 이지만 [Azure Event Grid](https://docs.microsoft.com/azure/event-grid/overview) 는 블록에 대 한 새로운 어린이입니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-305">While Azure Service Bus is a battle-tested messaging broker with a full set of enterprise features, [Azure Event Grid](https://docs.microsoft.com/azure/event-grid/overview) is the new kid on the block.</span></span>

<span data-ttu-id="d1c92-306">처음에는 Event Grid 다른 토픽 기반 메시징 시스템 처럼 보일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-306">At first glance, Event Grid may look like just another topic-based messaging system.</span></span> <span data-ttu-id="d1c92-307">그러나 여러 가지 측면에서 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-307">However, it's different in many ways.</span></span> <span data-ttu-id="d1c92-308">이벤트 기반 워크 로드에 중점을 둔이 기능을 사용 하면 실시간 이벤트 처리, 심층 Azure 통합 및 서버 리스를 사용 하지 않는 인프라의 모든 기능을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-308">Focused on event-driven workloads, it enables real-time event processing, deep Azure integration, and an open-platform - all on serverless infrastructure.</span></span> <span data-ttu-id="d1c92-309">최신 클라우드 전용 및 서버 리스 응용 프로그램을 위해 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-309">It's designed for contemporary cloud-native and serverless applications</span></span>

<span data-ttu-id="d1c92-310">중앙 집중식 *이벤트 백플레인*또는 파이프 Event Grid는 Azure 리소스 및 사용자 고유의 서비스 내 이벤트에 반응 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-310">As a centralized *eventing backplane*, or pipe, Event Grid reacts to events inside Azure resources and from your own services.</span></span>

<span data-ttu-id="d1c92-311">이벤트 알림은 Event Grid 토픽에 게시 되며, 각 이벤트를 구독으로 라우팅합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-311">Event notifications are published to an Event Grid Topic, which, in turn, routes each event to a subscription.</span></span> <span data-ttu-id="d1c92-312">구독자는 구독에 매핑되고 이벤트를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-312">Subscribers map to subscriptions and consume the events.</span></span> <span data-ttu-id="d1c92-313">Service Bus와 마찬가지로 Event Grid는 구독에서 받으려는 이벤트에 대 한 규칙을 설정 하는 *필터링 된 구독자 모델* 을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-313">Like Service Bus, Event Grid supports a *filtered subscriber model* where a subscription sets rule for the events it wishes to receive.</span></span> <span data-ttu-id="d1c92-314">Event Grid은 Azure Service Bus 생성 될 수 있는 것 보다 거의 실시간으로 배달 되는 초당 1000만 이벤트를 보장 하 여 빠른 처리량을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-314">Event Grid provides fast throughput with a guarantee of 10 million events per second enabling near real-time delivery - far more than what Azure Service Bus can generate.</span></span>

<span data-ttu-id="d1c92-315">Event Grid에 대 한 자세한 지점은 Azure 인프라의 패브릭에 대 한 심층 통합입니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-315">A sweet spot for Event Grid is its deep integration into the fabric of Azure infrastructure.</span></span> <span data-ttu-id="d1c92-316">Azure 리소스 (예: Cosmos DB)는 사용자 지정 코드를 요구 하지 않고 다른 관심 있는 Azure 리소스에 직접 기본 제공 이벤트를 게시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-316">An Azure resource, such as Cosmos DB, can publish built-in events directly to other interested Azure resources - without the need for custom code.</span></span> <span data-ttu-id="d1c92-317">Event Grid는 Azure 구독, 리소스 그룹 또는 서비스에서 이벤트를 게시 하 여 개발자에 게 클라우드 리소스의 수명 주기를 세부적으로 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-317">Event Grid can publish events from an Azure Subscription, Resource Group, or Service, giving developers fine-grained control over the lifecycle of cloud resources.</span></span> <span data-ttu-id="d1c92-318">그러나 Event Grid는 Azure로 제한 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-318">However, Event Grid isn't limited to Azure.</span></span> <span data-ttu-id="d1c92-319">응용 프로그램 또는 타사 서비스에서 게시 된 사용자 지정 HTTP 이벤트를 사용 하 고 이벤트를 외부 구독자로 라우팅하는 개방형 플랫폼입니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-319">It's an open platform that can consume custom HTTP events published from applications or third-party services and route events to external subscribers.</span></span>

<span data-ttu-id="d1c92-320">Azure 리소스에서 네이티브 이벤트를 게시 하 고 구독할 때 코딩이 필요 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-320">When publishing and subscribing to native events from Azure resources, no coding is required.</span></span> <span data-ttu-id="d1c92-321">간단한 구성을 사용 하 여 토픽 및 구독에 대 한 기본 제공을 활용 하는 Azure 리소스 간에 이벤트를 통합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-321">With simple configuration, you can integrate events from one Azure resource to another leveraging built-in plumbing for Topics and Subscriptions.</span></span> <span data-ttu-id="d1c92-322">그림 4-17에서는 Event Grid 분석을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-322">Figure 4-17 shows the anatomy of Event Grid.</span></span>

![Event Grid 분석](./media/event-grid-anatomy.png)

<span data-ttu-id="d1c92-324">**그림 4-17**.</span><span class="sxs-lookup"><span data-stu-id="d1c92-324">**Figure 4-17**.</span></span> <span data-ttu-id="d1c92-325">Event Grid 분석</span><span class="sxs-lookup"><span data-stu-id="d1c92-325">Event Grid anatomy</span></span>

<span data-ttu-id="d1c92-326">EventGrid와 Service Bus의 주요 차이점은 기본 *메시지 교환 패턴*입니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-326">A major difference between EventGrid and Service Bus is the underlying *message exchange pattern*.</span></span>

<span data-ttu-id="d1c92-327">Service Bus는 다운스트림 구독자가 새 메시지에 대 한 토픽 구독을 적극적으로 폴링하는 이전 스타일 *끌어오기 모델* 을 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-327">Service Bus implements an older style *pull model* in which the downstream subscriber actively polls the topic subscription for new messages.</span></span> <span data-ttu-id="d1c92-328">이러한 접근 방식은 구독자가 메시지를 처리 하는 속도에 대 한 모든 권한을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-328">On the upside, this approach gives the subscriber full control of the pace at which it processes messages.</span></span> <span data-ttu-id="d1c92-329">지정 된 시간에 처리할 메시지의 수와 수를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-329">It controls when and how many messages to process at any given time.</span></span> <span data-ttu-id="d1c92-330">읽지 않은 메시지는 처리 될 때까지 구독에 남아 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-330">Unread messages remain in the subscription until processed.</span></span> <span data-ttu-id="d1c92-331">중요 한 차이점은 이벤트가 생성 된 시간과 처리를 위해 해당 메시지를 구독자로 가져오는 폴링 작업 사이의 대기 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-331">A significant shortcoming is the latency between the time the event is generated and the polling operation that pulls that message to the subscriber for processing.</span></span> <span data-ttu-id="d1c92-332">또한 다음 이벤트에 대 한 상수 폴링의 오버 헤드는 리소스와 비용을 소비 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-332">Also, the overhead of constant polling for the next event consumes resources and money.</span></span>

<span data-ttu-id="d1c92-333">그러나 EventGrid는 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-333">EventGrid, however, is different.</span></span> <span data-ttu-id="d1c92-334">이벤트를 수신 된 EventHandlers 전송 하 여 거의 실시간으로 이벤트를 전달 하는 *푸시 모델* 을 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-334">It implements a *push model* in which events are sent to the EventHandlers as received, giving near real-time event delivery.</span></span> <span data-ttu-id="d1c92-335">또한 이벤트를 사용 하는 데 필요한 경우에만 (폴링을 사용 하는 경우에만) 서비스가 트리거될 때 비용이 절감 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-335">It also reduces cost as the service is triggered only when it's needed to consume an event – not continually as with polling.</span></span> <span data-ttu-id="d1c92-336">즉, 이벤트 처리기는 들어오는 부하를 처리 하 고 제한 메커니즘을 제공 하 여 자신을 감당할 수 없도록 보호 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-336">That said, an event handler must handle the incoming load and provide throttling mechanisms to protect itself from becoming overwhelmed.</span></span> <span data-ttu-id="d1c92-337">Azure Functions 및 Logic Apps 같은 이러한 이벤트를 사용 하는 많은 Azure 서비스는 증가 하는 부하를 처리할 수 있는 자동 자동 크기 조정 기능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-337">Many Azure services that consume these events, such as Azure Functions and Logic Apps provide automatic autoscaling capabilities to handle increased loads.</span></span>  

<span data-ttu-id="d1c92-338">Event Grid는 완전히 관리 되는 서버 리스 클라우드 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-338">Event Grid is a fully managed serverless cloud service.</span></span> <span data-ttu-id="d1c92-339">사용자의 트래픽에 따라 동적으로 크기를 조정 하 고 사전 구매 된 용량을 사용 하지 않고 실제 사용량에 대해서만 요금을 청구 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-339">It dynamically scales based on your traffic and charges you only for your actual usage, not pre-purchased capacity.</span></span> <span data-ttu-id="d1c92-340">매월 처음 10만 작업은 무료입니다. 이벤트 수신 (들어오는 이벤트 알림), 구독 전달 시도, 관리 호출 및 제목별 필터링으로 정의 되는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-340">The first 100,000 operations per month are free – operations being defined as event ingress (incoming event notifications), subscription delivery attempts, management calls, and filtering by subject.</span></span> <span data-ttu-id="d1c92-341">99.99%의 가용성을 제공 하는 EventGrid는 24 시간 이내에 이벤트를 배달 하는 데 실패 한 배달에 대 한 기본 제공 재시도 기능을 보장 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-341">With 99.99% availability, EventGrid guarantees the delivery of an event within a 24-hour period, with built-in retry functionality for unsuccessful delivery.</span></span> <span data-ttu-id="d1c92-342">확인을 위해 배달 되지 않은 메시지를 "배달 못 한 편지" 큐로 이동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-342">Undelivered messages can be moved to a "dead-letter" queue for resolution.</span></span>  <span data-ttu-id="d1c92-343">Azure Service Bus와 달리 Event Grid는 빠른 성능을 위해 조정 되며 순차적 메시징, 트랜잭션 및 세션과 같은 기능을 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-343">Unlike Azure Service Bus, Event Grid is tuned for fast performance and doesn't support features like ordered messaging, transactions, and sessions.</span></span>

### <a name="streaming-messages-in-the-azure-cloud"></a><span data-ttu-id="d1c92-344">Azure 클라우드에서 메시지 스트리밍</span><span class="sxs-lookup"><span data-stu-id="d1c92-344">Streaming messages in the Azure cloud</span></span>

<span data-ttu-id="d1c92-345">Azure Service Bus 및 Event Grid는 새 문서를 Cosmos DB에 삽입 하는 것과 같은 단일 불연속 이벤트를 노출 하는 응용 프로그램에 대 한 뛰어난 지원을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-345">Azure Service Bus and Event Grid provide great support for applications that expose single, discrete events like a new document has been inserted into a Cosmos DB.</span></span> <span data-ttu-id="d1c92-346">그러나 클라우드 네이티브 시스템에서 *관련 이벤트 스트림을*처리 해야 하는 경우는 어떻게 되나요?</span><span class="sxs-lookup"><span data-stu-id="d1c92-346">But, what if your cloud-native system needs to process a *stream of related events*?</span></span> <span data-ttu-id="d1c92-347">[이벤트 스트림은](https://msdn.microsoft.com/magazine/dn904671) 더 복잡 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-347">[Event streams](https://msdn.microsoft.com/magazine/dn904671) are more complex.</span></span> <span data-ttu-id="d1c92-348">일반적으로 시간 순서를 지정 하 고 상호 관련 되며 그룹으로 처리 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-348">They're typically time-ordered, interrelated, and must be processed as a group.</span></span>

<span data-ttu-id="d1c92-349">[Azure Event Hub](https://azure.microsoft.com/services/event-hubs/) 는 이벤트를 수집, 변환 및 저장 하는 데이터 스트리밍 플랫폼 및 이벤트 수집 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-349">[Azure Event Hub](https://azure.microsoft.com/services/event-hubs/) is a data streaming platform and event ingestion service that collects, transforms, and stores events.</span></span> <span data-ttu-id="d1c92-350">원격 분석 컨텍스트에서 내보낸 연속 이벤트 알림과 같은 스트리밍 데이터를 캡처하기 위해 미세 하 게 조정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-350">It's fine-tuned to capture streaming data, such as continuous event notifications emitted from a telemetry context.</span></span> <span data-ttu-id="d1c92-351">서비스는 확장성이 뛰어나고 [초당 수백만 개의 이벤트](https://docs.microsoft.com/azure/event-hubs/event-hubs-about)를 저장 하 고 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-351">The service is highly scalable and can store and [process millions of events per second](https://docs.microsoft.com/azure/event-hubs/event-hubs-about).</span></span> <span data-ttu-id="d1c92-352">그림 4-18에 표시 된 것 처럼 이벤트 파이프라인에 대 한 전방 도어 이며 수집 스트림을 이벤트 사용에서 분리 하는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-352">Shown in Figure 4-18, it's often a front door for an event pipeline, decoupling ingest stream from event consumption.</span></span>

![Azure 이벤트 허브](./media/azure-event-hub.png)

<span data-ttu-id="d1c92-354">**그림 4-18**.</span><span class="sxs-lookup"><span data-stu-id="d1c92-354">**Figure 4-18**.</span></span> <span data-ttu-id="d1c92-355">Azure 이벤트 허브</span><span class="sxs-lookup"><span data-stu-id="d1c92-355">Azure Event Hub</span></span>

<span data-ttu-id="d1c92-356">이벤트 허브는 짧은 대기 시간과 구성 가능한 시간 보존을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-356">Event Hub supports low latency and configurable time retention.</span></span> <span data-ttu-id="d1c92-357">큐 및 항목과 달리 소비자가 읽은 후 이벤트 데이터를 유지 Event Hubs.</span><span class="sxs-lookup"><span data-stu-id="d1c92-357">Unlike queues and topics, Event Hubs keep event data after it's been read by a consumer.</span></span> <span data-ttu-id="d1c92-358">이 기능을 사용 하면 내부 및 외부의 다른 데이터 분석 서비스에서 추가 분석을 위해 데이터를 재생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-358">This feature enables other data analytic services, both internal and external, to replay the data for further analysis.</span></span> <span data-ttu-id="d1c92-359">이벤트 허브에 저장 된 이벤트는 보존 기간이 만료 되는 경우에만 삭제 됩니다. 즉, 기본적으로 1 일 이지만 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-359">Events stored in event hub are only deleted upon expiration of the retention period, which is one day by default, but configurable.</span></span>

<span data-ttu-id="d1c92-360">이벤트 허브는 HTTPS 및 AMQP를 비롯 한 일반적인 이벤트 게시 프로토콜을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-360">Event Hub supports common event publishing protocols including HTTPS and AMQP.</span></span> <span data-ttu-id="d1c92-361">Kafka 1.0도 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-361">It also supports Kafka 1.0.</span></span> <span data-ttu-id="d1c92-362">[기존 kafka 응용 프로그램](https://docs.microsoft.com/azure/event-hubs/event-hubs-for-kafka-ecosystem-overview) 은 대량 kafka 클러스터 관리에 대 한 대안을 제공 하는 kafka 프로토콜을 사용 하 여 이벤트 허브와 통신할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-362">[Existing Kafka applications can communicate with Event Hub](https://docs.microsoft.com/azure/event-hubs/event-hubs-for-kafka-ecosystem-overview) using the Kafka protocol providing an alternative to managing large Kafka clusters.</span></span> <span data-ttu-id="d1c92-363">많은 오픈 소스 클라우드 네이티브 시스템은 Kafka을 수용 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-363">Many open-source cloud-native systems embrace Kafka.</span></span>

<span data-ttu-id="d1c92-364">Event Hubs는 각 소비자가 메시지 스트림의 특정 하위 집합 또는 파티션만 읽는 [분할 된 소비자 모델](https://docs.microsoft.com/azure/event-hubs/event-hubs-features) 을 통해 메시지 스트리밍을 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-364">Event Hubs implements message streaming through a [partitioned consumer model](https://docs.microsoft.com/azure/event-hubs/event-hubs-features) in which each consumer only reads a specific subset, or partition, of the message stream.</span></span> <span data-ttu-id="d1c92-365">이 패턴은 이벤트 처리를 위한 다양 한 수평 확장을 가능 하 게 하며 큐 및 토픽에서 사용할 수 없는 기타 스트림 중심 기능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-365">This pattern enables tremendous horizontal scale for event processing and provides other stream-focused features that are unavailable in queues and topics.</span></span> <span data-ttu-id="d1c92-366">파티션은 이벤트 허브에 저장 되는 순서가 지정 된 이벤트 시퀀스입니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-366">A partition is an ordered sequence of events that is held in an event hub.</span></span> <span data-ttu-id="d1c92-367">최신 이벤트가 도착 하면이 시퀀스의 끝에 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-367">As newer events arrive, they're added to the end of this sequence.</span></span><span data-ttu-id="d1c92-368"> 그림 4-19에서는 이벤트 허브의 분할을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-368"> Figure 4-19 shows partitioning in an Event Hub.</span></span>

![이벤트 허브 분할](./media/event-hub-partitioning.png)

<span data-ttu-id="d1c92-370">**그림 4-19**.</span><span class="sxs-lookup"><span data-stu-id="d1c92-370">**Figure 4-19**.</span></span> <span data-ttu-id="d1c92-371">이벤트 허브 분할</span><span class="sxs-lookup"><span data-stu-id="d1c92-371">Event Hub partitioning</span></span>

<span data-ttu-id="d1c92-372">각 소비자 그룹은 동일한 리소스에서 읽는 대신 메시지 스트림의 하위 집합 또는 파티션 전체를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-372">Instead of reading from the same resource, each consumer group reads across a subset, or partition, of the message stream.</span></span>

<span data-ttu-id="d1c92-373">많은 수의 이벤트를 스트리밍하는 클라우드 네이티브 응용 프로그램의 경우 Azure Event Hub는 강력 하 고 경제적인 솔루션 일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1c92-373">For cloud-native applications that must stream large numbers of events, Azure Event Hub can be a robust and affordable solution.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="d1c92-374">[이전](front-end-communication.md)
>[다음](rest-grpc.md)</span><span class="sxs-lookup"><span data-stu-id="d1c92-374">[Previous](front-end-communication.md)
[Next](rest-grpc.md)</span></span>
