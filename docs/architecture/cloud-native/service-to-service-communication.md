---
title: 서비스 간 통신
description: 백 엔드 클라우드 네이티브 마이크로 서비스가 다른 백 엔드 마이크로 서비스와 통신 하는 방법에 대해 알아봅니다.
author: robvet
ms.date: 05/13/2020
ms.openlocfilehash: dec06cc28ac177381b882f9e441e19e5c51bd5ad
ms.sourcegitcommit: 27db07ffb26f76912feefba7b884313547410db5
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/19/2020
ms.locfileid: "83613709"
---
# <a name="service-to-service-communication"></a>서비스 간 통신

이제 프런트 엔드 클라이언트에서 이동 하 여 백 엔드 마이크로 서비스가 서로 통신 하 게 됩니다.

클라우드 네이티브 응용 프로그램을 구성 하는 경우 백 엔드 서비스가 서로 통신 하는 방법에 대 한 중요 한 정보가 필요 합니다. 이상적으로 서비스 간 통신은 더 효율적입니다. 그러나 백 엔드 서비스에서 작업을 완료 하는 데 종종 서로를 사용 하기 때문에 방지는 항상 가능 하지는 않습니다.

서비스 간 통신을 구현 하는 데 널리 허용 되는 여러 가지 방법이 있습니다. *통신 상호 작용의 유형에* 따라 최상의 방법이 결정 되는 경우가 많습니다.

다음 상호 작용 형식을 고려 합니다.

- *쿼리* – 호출 마이크로 서비스에 호출 된 마이크로 서비스의 응답이 필요한 경우 (예: "안녕하세요, 지정 된 고객 Id에 대 한 구매자 정보를 제공 합니다.")

- *Command* – 호출 마이크로 서비스에서 작업을 실행 하는 다른 마이크로 서비스 필요 하지만 응답이 필요 하지 않은 경우 (예: "안녕하세요"는이 주문을 제공 합니다. ")

- *이벤트* – 게시자 라고 하는 마이크로 서비스가 상태가 변경 되었거나 작업이 발생 한 이벤트를 발생 시킵니다. 관심이 있는 구독자 라고 하는 다른 마이크로 서비스는 이벤트에 적절 하 게 반응할 수 있습니다. 게시자와 구독자는 서로를 인식 하지 못합니다.

일반적으로 마이크로 서비스 시스템은 서비스 간 상호 작용이 필요한 작업을 실행할 때 이러한 상호 작용 유형을 조합 하 여 사용 합니다. 각각에 대해 좀 더 자세히 살펴보고 구현 방법을 살펴보겠습니다.

## <a name="queries"></a>쿼리

한 번에 한 마이크로 서비스 다른 *쿼리* 를 실행 하 여 작업을 완료 하기 위해 즉각적인 응답이 필요 합니다. 시장 바구니 마이크로 서비스 제품 정보 및 바구니에 항목을 추가 하는 가격이 필요할 수 있습니다. 쿼리 작업을 구현 하는 방법에는 여러 가지가 있습니다.

### <a name="requestresponse-messaging"></a>요청/응답 메시징

이 시나리오를 구현 하는 한 가지 옵션은 그림 4-8에 나와 있는 것 처럼 호출 백 엔드 마이크로 서비스에서 쿼리 해야 하는 마이크로 서비스에 대 한 직접 HTTP 요청을 수행 하는 것입니다.

![직접 HTTP 통신](./media/direct-http-communication.png)

**그림 4-8**. 직접 HTTP 통신

마이크로 서비스 간의 직접 HTTP 호출은 간단 하 게 구현할 수 있지만이 방법을 최소화 하는 것은 주의를 기울여야 합니다. 시작 하려면 이러한 호출은 항상 *동기* 이며 결과가 반환 되거나 요청 시간이 초과 될 때까지 작업을 차단 합니다. 독립적으로 독립적으로 발전 하 고 자주 배포할 수 있는 독립적인 서비스는 이제 서로 연결 될 수 있습니다. 마이크로 서비스 간의 결합으로 증가 하면 아키텍처의 이점이 감소 합니다.

다른 마이크로 서비스에 대 한 단일 직접 HTTP 호출을 수행 하는 드물게 발생 하는 요청을 실행 하면 일부 시스템에서 허용 될 수 있습니다. 그러나 여러 마이크로 서비스에 대 한 직접 HTTP 호출을 호출 하는 고용량 호출은 권장 되지 않습니다. 대기 시간이 증가 하 고 시스템의 성능, 확장성 및 가용성에 부정적인 영향을 줄 수 있습니다. 좀 더 심각한 일련의 직접 HTTP 통신은 그림 4-9에 나와 있는 것 처럼 동기식 마이크로 서비스 호출의 깊이 및 복잡 한 체인을 초래할 수 있습니다.

![HTTP 쿼리 체인](./media/chaining-http-queries.png)

**그림 4-9** HTTP 쿼리 체인

이전 이미지에 표시 된 디자인의 위험을 분명히 생각해 볼 수 있습니다. 3 단계에 실패 하는 경우 어떻게 되나요 \# ? 또는 \# 8 단계가 실패 하는 경우 어떻게 복구 하나요? \#기본 서비스가 사용 중 이므로 6 단계가 느려지는 경우 어떻게 하나요? 계속 하 시겠습니까? 모든 것이 제대로 작동 하는 경우에도이 호출이 발생 하는 대기 시간을 고려해 야 합니다 .이는 각 단계의 대기 시간 합계입니다.

이전 이미지에서 많은 결합은 서비스가 최적으로 모델링 되지 않은 것을 나타냅니다. 팀이 해당 디자인을 다시 behoove 합니다.

### <a name="materialized-view-pattern"></a>구체화된 뷰 패턴

마이크로 서비스 커플링을 제거 하는 널리 사용 되는 옵션은 [구체화 된 뷰 패턴](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)입니다. 이 패턴을 사용 하면 마이크로 서비스는 다른 서비스에서 소유 하는 정규화 된 로컬 데이터 복사본을 저장 합니다. 제품 카탈로그 및 가격 마이크로 서비스를 쿼리 하는 시장 바구니 마이크로 서비스 대신 해당 데이터의 로컬 복사본을 유지 관리 합니다. 이 패턴은 불필요 한 결합을 제거 하 고 안정성 및 응답 시간을 향상 시킵니다. 전체 작업은 단일 프로세스 내에서 실행 됩니다. 5 장에서이 패턴 및 기타 데이터 문제를 살펴봅니다.

### <a name="service-aggregator-pattern"></a>서비스 집계 패턴

마이크로 서비스-마이크로 서비스 결합을 제거 하는 또 다른 옵션은 그림 4-10에 자주색으로 표시 된 [집계 마이크로 서비스](https://devblogs.microsoft.com/cesardelatorre/designing-and-implementing-api-gateways-with-ocelot-in-a-microservices-and-container-based-architecture/)입니다.

![집계 서비스](./media/aggregator-service.png)

**그림 4-10** 집계 마이크로 서비스

패턴은 여러 백 엔드 마이크로 서비스를 호출 하는 작업을 격리 하 여 해당 논리를 특수화 된 마이크로 서비스 중앙 집중화 합니다.  이전 그림의 자주색 체크 아웃 집계 마이크로 서비스는 체크 아웃 작업에 대 한 워크플로를 오케스트레이션 합니다. 시퀀싱 된 순서로 여러 백 엔드 마이크로 서비스에 대 한 호출을 포함 합니다. 워크플로의 데이터가 집계 되 고 호출자에 게 반환 됩니다. 직접 HTTP 호출을 구현 하는 동안 집계 마이크로 서비스 백 엔드 마이크로 서비스 간의 직접 종속성을 줄입니다.

### <a name="requestreply-pattern"></a>요청/회신 패턴

동기 HTTP 메시지를 분리 하는 또 다른 방법은 큐 통신을 사용 하는 [요청-회신 패턴](https://www.enterpriseintegrationpatterns.com/patterns/messaging/RequestReply.html)입니다. 큐를 사용 하는 통신은 항상 단방향 채널 이며 생산자는 메시지와 소비자를 수신 합니다. 이 패턴을 사용 하 여 그림 4-11에 표시 된 요청 큐와 응답 큐를 모두 구현 합니다.

![요청-회신 패턴](./media/request-reply-pattern.png)

**그림 4-11** 요청-회신 패턴

여기에서 메시지 생산자는 고유한 상관 관계 ID를 포함 하는 쿼리 기반 메시지를 만들어 요청 큐에 배치 합니다. 소비 하는 서비스는 메시지를 큐에서 제거 하 고 처리 한 다음 응답을 동일한 상관 관계 ID를 사용 하 여 응답 큐에 배치 합니다. 생산자 서비스는 메시지를 큐에 대기 시키고 상관 관계 ID와 일치 시키고 처리를 계속 합니다. 다음 섹션에서 큐를 자세히 다룹니다.

## <a name="commands"></a>명령

또 다른 유형의 통신 상호 작용은 *명령*입니다. 마이크로 서비스는 작업을 수행 하는 다른 마이크로 서비스 필요할 수 있습니다. 주문 마이크로 서비스에서 승인 된 주문에 대 한 배송을 만들기 위해 배송 마이크로 서비스 필요할 수 있습니다. 그림 4-12에서 생산자 라는 하나의 마이크로 서비스는 다른 마이크로 서비스, 소비자에 게 메시지를 보냅니다.

![큐와의 명령 상호 작용](./media/command-interaction-with-queue.png)

**그림 4-12**. 큐와의 명령 상호 작용

대부분의 경우 생산자는 응답이 필요 하지 않으며 메시지를 *발생 시키고 잊어버릴* 수 있습니다. 회신이 필요한 경우 소비자는 다른 채널의 생산자에 게 개별 메시지를 다시 보냅니다. 명령 메시지는 메시지 큐를 사용 하 여 비동기적으로 전송 하는 것이 가장 좋습니다. 경량 메시지 브로커에서 지원 됩니다. 위의 다이어그램에서 큐가 두 서비스를 구분 하 고 분리 하는 방법을 확인 합니다.

메시지 큐는 생산자와 소비자가 메시지를 전달 하는 중간 구문입니다. 큐는 비동기 지점 간 메시징 패턴을 구현 합니다. 생산자는 명령을 보내고 적절 하 게 라우팅하는 위치를 알고 있습니다. 큐는 채널에서 읽는 소비자 인스턴스 중 하나에서 메시지가 처리 되도록 합니다. 이 시나리오에서는 생산자 또는 소비자 서비스가 다른에 영향을 주지 않고 규모를 확장할 수 있습니다. 또한 기술은 서로 다를 수 있습니다. 즉, [Golang](https://golang.org) 마이크로 서비스를 호출 하는 Java 마이크로 서비스 있을 수 있습니다.

1 장에서는 *서비스 지원*에 대해 설명 했습니다. 지원 서비스는 클라우드 네이티브 시스템이 종속 되는 보조 리소스입니다. 메시지 큐는 서비스를 지원 합니다. Azure 클라우드는 클라우드 네이티브 시스템에서 명령 메시지를 구현 하는 데 사용할 수 있는 두 가지 유형의 메시지 큐 인 Azure Storage 큐 및 Azure Service Bus 큐를 지원 합니다.

### <a name="azure-storage-queues"></a>Azure Storage 큐

Azure storage 큐는 빠르고 경제적 이며 Azure storage 계정으로 지원 되는 간단한 큐 인프라를 제공 합니다.

[Azure Storage 큐](https://docs.microsoft.com/azure/storage/queues/storage-queues-introduction) 는 안정적이 고 지속적인 메시징을 갖춘 REST 기반 큐 메커니즘을 기능 합니다. 최소 기능 집합을 제공 하지만 저렴 하 고 수백만 개의 메시지를 저장 합니다. 용량 범위는 최대 500 TB입니다. 단일 메시지의 크기는 최대 64 KB가 될 수 있습니다.

HTTP 또는 HTTPS를 사용 하 여 인증 된 호출을 통해 전 세계 어디에서 나 메시지에 액세스할 수 있습니다. 저장소 큐는 많은 수의 동시 클라이언트로 확장 하 여 트래픽 급증을 처리할 수 있습니다.

즉, 서비스에는 다음과 같은 제한 사항이 있습니다.

- 메시지 순서는 보장 되지 않습니다.

- 메시지는 자동으로 제거 되기 7 일 동안만 지속 될 수 있습니다.

- 상태 관리, 중복 검색 또는 트랜잭션을 지원 하지 않습니다.

그림 4-13에서는 Azure Storage 큐의 계층 구조를 보여 줍니다.

![저장소 큐 계층 구조](./media/storage-queue-hierarchy.png)

**그림 4-13**. 저장소 큐 계층 구조

위의 그림에서 저장소 큐가 기본 Azure Storage 계정에 메시지를 저장 하는 방법을 확인 합니다.

개발자를 위해 Microsoft는 저장소 큐 처리를 위한 여러 클라이언트 및 서버 쪽 라이브러리를 제공 합니다. .NET, Java, JavaScript, Ruby, Python 및 Go를 비롯 한 대부분의 주요 플랫폼이 지원 됩니다. 개발자는 이러한 라이브러리와 직접 통신 해서는 안 됩니다. 이렇게 하면 마이크로 서비스 코드를 Azure Storage 큐 서비스에 긴밀 하 게 두는 것입니다. API의 구현 세부 정보를 안전 하 게 유지 하는 것이 더 좋습니다. 제네릭 작업을 노출 하 고 구체적인 라이브러리를 캡슐화 하는 intermediation 계층 또는 중간 API를 도입 합니다. 이러한 느슨한 결합을 사용 하면 중요 서비스 코드를 변경할 필요 없이 한 큐 서비스를 다른 큐로 교환할 수 있습니다.

Azure Storage 큐는 클라우드 네이티브 응용 프로그램에서 명령 메시지를 구현 하는 경제적인 옵션입니다. 특히 큐 크기가 80 GB를 초과 하거나 간단한 기능 집합을 사용할 수 있는 경우입니다. 메시지 저장소에 대해서만 비용을 지불 하면 됩니다. 고정 된 시간당 요금이 청구 되지 않습니다.

### <a name="azure-service-bus-queues"></a>Azure Service Bus Queues

더 복잡 한 메시징 요구 사항은 큐를 Azure Service Bus 하는 것이 좋습니다.

[Azure Service Bus](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messaging-overview) 는 강력한 메시지 인프라를 기반으로 하며,이는 조정 된 *메시징 모델*을 지원 합니다. 메시지는 소비자가 받을 때까지 broker (큐)에 안정적으로 저장 됩니다. 큐는 메시지를 큐에 추가 하는 순서에 따라 FIFO (선입 선출) 메시지 배달을 보장 합니다.

메시지 크기는 최대 256 KB까지 훨씬 클 수 있습니다. 메시지는 무제한 시간 동안 큐에 유지 됩니다. Service Bus는 HTTP 기반 호출만 지원 하 고 [Amqp 프로토콜](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-amqp-overview)을 완벽 하 게 지원 합니다. AMQP는 이진 프로토콜 및 높은 수준의 안정성을 지 원하는 공급 업체 전체의 오픈 표준입니다.

Service Bus은 [트랜잭션 지원](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions) 및 [중복 검색 기능](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection)을 비롯 한 다양 한 기능 집합을 제공 합니다. 큐는 메시지당 "최대 한 번의 배달"을 보장 합니다. 이미 전송 된 메시지를 자동으로 삭제 합니다. 생산자가 확실 하지 않은 경우 동일한 메시지를 다시 보낼 수 있으며, Service Bus 한 개의 복사본만 처리 되도록 보장 됩니다. 중복 검색을 통해 추가 인프라를 구축할 필요가 없습니다.

두 가지 enterprise 기능인 분할 및 세션이 있습니다. 기존 Service Bus 큐는 단일 메시지 브로커에 의해 처리 되 고 단일 메시지 저장소에 저장 됩니다. 그러나 [Service Bus 분할](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning) 은 큐를 여러 메시지 브로커 및 메시지 저장소에 분산 합니다. 전체 처리량은 더 이상 단일 메시지 브로커 또는 메시징 저장소의 성능으로 제한 되지 않습니다. 메시징 저장소의 일시적인 중단은 분할 된 큐를 사용할 수 없게 렌더링 하지 않습니다.

[Service Bus 세션](https://codingcanvas.com/azure-service-bus-sessions/) 은 관련 메시지를 그룹화 하는 방법을 제공 합니다. 메시지를 함께 처리 하 고 작업을 끝에 완료 해야 하는 워크플로 시나리오를 가정해 보겠습니다. 이를 활용 하려면 큐에 대해 세션을 명시적으로 사용 하도록 설정 해야 하며 관련 된 각 메시지에 동일한 세션 ID가 포함 되어야 합니다.

그러나 Service Bus 큐 크기는 80 GB로 제한 됩니다 .이는 저장소 큐에서 사용할 수 있는 것 보다 훨씬 더 작기 때문에 주의 해야 합니다. 또한 Service Bus 큐는 작업당 기본 비용 및 요금을 부과 합니다.

그림 4-14에서는 Service Bus 큐의 상위 수준 아키텍처를 간략하게 설명 합니다.

![Service Bus 큐](./media/service-bus-queue.png)

**그림 4-14**. Service Bus 큐

위의 그림에서 지점 간 관계를 확인 합니다. 동일한 공급자의 두 인스턴스는 메시지를 단일 Service Bus 큐로 예외로 인해 합니다. 각 메시지는 오른쪽에 있는 세 개의 소비자 인스턴스 중 하나 에서만 사용 됩니다. 다음으로 여러 소비자가 동일한 메시지에 관심을 가질 수 있는 메시징을 구현 하는 방법을 설명 합니다.

## <a name="events"></a>이벤트

메시지 큐는 생산자가 소비자에 게 메시지를 비동기적으로 보낼 수 있는 통신을 구현 하는 효과적인 방법입니다. 그러나 여러 *소비자* 가 동일한 메시지에 관심이 있으면 어떻게 되나요? 각 소비자에 대 한 전용 메시지 큐가 제대로 확장 되지 않으며 관리가 어려워집니다.

이 시나리오를 해결 하기 위해 이벤트 상호 작용의 세 번째 유형인 *이벤트*로 이동 합니다. 한 마이크로 서비스 작업이 발생 했음을 알립니다. 다른 마이크로 서비스는 관심이 있으면 작업 또는 이벤트에 반응 합니다.

이벤트는 2 단계 프로세스입니다. 지정 된 상태 변경의 경우 마이크로 서비스은 메시지 브로커에 이벤트를 게시 하 여 관심 있는 다른 모든 마이크로 서비스에 사용할 수 있도록 합니다. 관심 있는 마이크로 서비스는 메시지 브로커의 이벤트를 구독 하 여 알림을 받습니다. [게시/구독](https://docs.microsoft.com/azure/architecture/patterns/publisher-subscriber) 패턴을 사용 하 여 [이벤트 기반 통신](https://docs.microsoft.com/dotnet/standard/microservices-architecture/multi-container-microservice-net-applications/integration-event-based-microservice-communications)을 구현 합니다.

그림 4-15에는이를 구독 하는 다른 두 마이크로 서비스를 사용 하 여 이벤트를 게시 하는 시장 바구니 마이크로 서비스 나와 있습니다.

![이벤트 기반 메시징](./media/event-driven-messaging.png)

**그림 4-15**. 이벤트 기반 메시징

통신 채널의 중간에 있는 *이벤트 버스* 구성 요소를 확인 합니다. 이 클래스는 메시지 브로커를 캡슐화 하 고 기본 응용 프로그램에서 분리 하는 사용자 지정 클래스입니다. 주문 및 인벤토리 마이크로 서비스는 서로에 대 한 지식 없이 이벤트와 시장 바구니 마이크로 서비스을 독립적으로 작동 합니다. 등록 된 이벤트는 이벤트 버스에 게시 될 때 해당 이벤트에 대해 작동 합니다.

이벤트를 사용 하 여 큐 기술에서 *항목*으로 이동 합니다. [토픽](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions) 은 큐와 유사 하지만 일대다 메시징 패턴을 지원 합니다. 한 마이크로 서비스 메시지를 게시 합니다. 여러 구독 마이크로 서비스에서 해당 메시지를 수신 하 고 작업 하도록 선택할 수 있습니다. 그림 4-16에서는 항목 아키텍처를 보여 줍니다.

![토픽 아키텍처](./media/topic-architecture.png)

**그림 4-16**. 토픽 아키텍처

위의 그림에서 게시자는 토픽에 메시지를 보냅니다. 결국 구독자는 구독에서 메시지를 받습니다. 가운데에서 항목은 진한 파란색 상자에 표시 된 *규칙*집합에 따라 구독에 메시지를 전달 합니다. 규칙은 특정 메시지를 구독으로 전달 하는 필터 역할을 합니다. 여기에서 "CreateOrder" 이벤트는 구독 \# 1 및 구독 3으로 전송 \# 되지만 구독 2에는 전송 되지 않습니다 \# . "OrderCompleted" 이벤트가 구독 \# 2 및 구독 3으로 전송 됩니다 \# .

Azure 클라우드는 Azure Service Bus 토픽 및 Azure EventGrid와 같은 두 가지 토픽 서비스를 지원 합니다.

### <a name="azure-service-bus-topics"></a>Azure Service Bus Topics

Azure Service Bus 큐의 동일한 강력한 조정 된 메시지 모델 위에 있는 것은 [Azure Service Bus 토픽](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)입니다. 토픽은 여러 독립 게시자의 메시지를 수신 하 고 최대 2000 구독자에 게 메시지를 보낼 수 있습니다. 시스템을 중지 하거나 토픽을 다시 만들지 않고도 런타임에 구독을 동적으로 추가 하거나 제거할 수 있습니다.

[중복 검색](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection) 및 [트랜잭션 지원을](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions)포함 하 여 항목에 대해서도 Azure Service Bus 큐의 많은 고급 기능을 사용할 수 있습니다. 기본적으로 Service Bus 토픽은 단일 메시지 브로커에 의해 처리 되 고 단일 메시지 저장소에 저장 됩니다. 그러나 [Service Bus 분할](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning) 은 여러 메시지 브로커 및 메시지 저장소에 분산 하 여 토픽의 크기를 조정 합니다.

[예약 된 메시지 배달](https://docs.microsoft.com/azure/service-bus-messaging/message-sequencing) 는 특정 처리 시간을 가진 메시지에 태그를 지정 합니다. 이 메시지는 해당 시간 이전에 항목에 표시 되지 않습니다. [메시지를 지연](https://docs.microsoft.com/azure/service-bus-messaging/message-deferral) 하면 나중에 메시지를 검색 하는 것을 연기할 수 있습니다. 둘 다 작업을 특정 순서로 처리 하는 워크플로 처리 시나리오에서 일반적으로 사용 됩니다. 이전 작업이 완료 될 때까지 받은 메시지의 처리를 연기할 수 있습니다.

Service Bus 토픽은 클라우드 네이티브 시스템에서 게시/구독 통신을 사용 하도록 설정 하는 강력 하 고 검증 된 기술입니다.

### <a name="azure-event-grid"></a>Azure Event Grid

Azure Service Bus는 전체 엔터프라이즈 기능 집합을 포함 하는 전투 테스트 된 메시징 브로커 이지만 [Azure Event Grid](https://docs.microsoft.com/azure/event-grid/overview) 는 블록에 대 한 새로운 어린이입니다.

처음에는 Event Grid 다른 토픽 기반 메시징 시스템 처럼 보일 수 있습니다. 그러나 여러 가지 측면에서 다릅니다. 이벤트 기반 워크 로드에 중점을 둔이 기능을 사용 하면 실시간 이벤트 처리, 심층 Azure 통합 및 서버 리스를 사용 하지 않는 인프라의 모든 기능을 사용할 수 있습니다. 최신 클라우드 전용 및 서버 리스 응용 프로그램을 위해 설계 되었습니다.

중앙 집중식 *이벤트 백플레인*또는 파이프 Event Grid는 Azure 리소스 및 사용자 고유의 서비스 내 이벤트에 반응 합니다.

이벤트 알림은 Event Grid 토픽에 게시 되며, 각 이벤트를 구독으로 라우팅합니다. 구독자는 구독에 매핑되고 이벤트를 사용 합니다. Service Bus와 마찬가지로 Event Grid는 구독에서 받으려는 이벤트에 대 한 규칙을 설정 하는 *필터링 된 구독자 모델* 을 지원 합니다. Event Grid은 Azure Service Bus 생성 될 수 있는 것 보다 거의 실시간으로 배달 되는 초당 1000만 이벤트를 보장 하 여 빠른 처리량을 제공 합니다.

Event Grid에 대 한 자세한 지점은 Azure 인프라의 패브릭에 대 한 심층 통합입니다. Azure 리소스 (예: Cosmos DB)는 사용자 지정 코드를 요구 하지 않고 다른 관심 있는 Azure 리소스에 직접 기본 제공 이벤트를 게시할 수 있습니다. Event Grid는 Azure 구독, 리소스 그룹 또는 서비스에서 이벤트를 게시 하 여 개발자에 게 클라우드 리소스의 수명 주기를 세부적으로 제어할 수 있습니다. 그러나 Event Grid는 Azure로 제한 되지 않습니다. 응용 프로그램 또는 타사 서비스에서 게시 된 사용자 지정 HTTP 이벤트를 사용 하 고 이벤트를 외부 구독자로 라우팅하는 개방형 플랫폼입니다.

Azure 리소스에서 네이티브 이벤트를 게시 하 고 구독할 때 코딩이 필요 하지 않습니다. 간단한 구성을 사용 하 여 토픽 및 구독에 대 한 기본 제공을 활용 하는 Azure 리소스 간에 이벤트를 통합할 수 있습니다. 그림 4-17에서는 Event Grid 분석을 보여 줍니다.

![Event Grid 분석](./media/event-grid-anatomy.png)

**그림 4-17**. Event Grid 분석

EventGrid와 Service Bus의 주요 차이점은 기본 *메시지 교환 패턴*입니다.

Service Bus는 다운스트림 구독자가 새 메시지에 대 한 토픽 구독을 적극적으로 폴링하는 이전 스타일 *끌어오기 모델* 을 구현 합니다. 이러한 접근 방식은 구독자가 메시지를 처리 하는 속도에 대 한 모든 권한을 제공 합니다. 지정 된 시간에 처리할 메시지의 수와 수를 제어 합니다. 읽지 않은 메시지는 처리 될 때까지 구독에 남아 있습니다. 중요 한 차이점은 이벤트가 생성 된 시간과 처리를 위해 해당 메시지를 구독자로 가져오는 폴링 작업 사이의 대기 시간입니다. 또한 다음 이벤트에 대 한 상수 폴링의 오버 헤드는 리소스와 비용을 소비 합니다.

그러나 EventGrid는 다릅니다. 이벤트를 수신 된 EventHandlers 전송 하 여 거의 실시간으로 이벤트를 전달 하는 *푸시 모델* 을 구현 합니다. 또한 이벤트를 사용 하는 데 필요한 경우에만 (폴링을 사용 하는 경우에만) 서비스가 트리거될 때 비용이 절감 됩니다. 즉, 이벤트 처리기는 들어오는 부하를 처리 하 고 제한 메커니즘을 제공 하 여 자신을 감당할 수 없도록 보호 해야 합니다. Azure Functions 및 Logic Apps 같은 이러한 이벤트를 사용 하는 많은 Azure 서비스는 증가 하는 부하를 처리할 수 있는 자동 자동 크기 조정 기능을 제공 합니다.  

Event Grid는 완전히 관리 되는 서버 리스 클라우드 서비스입니다. 사용자의 트래픽에 따라 동적으로 크기를 조정 하 고 사전 구매 된 용량을 사용 하지 않고 실제 사용량에 대해서만 요금을 청구 합니다. 매월 처음 10만 작업은 무료입니다. 이벤트 수신 (들어오는 이벤트 알림), 구독 전달 시도, 관리 호출 및 제목별 필터링으로 정의 되는 작업입니다. 99.99%의 가용성을 제공 하는 EventGrid는 24 시간 이내에 이벤트를 배달 하는 데 실패 한 배달에 대 한 기본 제공 재시도 기능을 보장 합니다. 확인을 위해 배달 되지 않은 메시지를 "배달 못 한 편지" 큐로 이동할 수 있습니다.  Azure Service Bus와 달리 Event Grid는 빠른 성능을 위해 조정 되며 순차적 메시징, 트랜잭션 및 세션과 같은 기능을 지원 하지 않습니다.

### <a name="streaming-messages-in-the-azure-cloud"></a>Azure 클라우드에서 메시지 스트리밍

Azure Service Bus 및 Event Grid는 새 문서를 Cosmos DB에 삽입 하는 것과 같은 단일 불연속 이벤트를 노출 하는 응용 프로그램에 대 한 뛰어난 지원을 제공 합니다. 그러나 클라우드 네이티브 시스템에서 *관련 이벤트 스트림을*처리 해야 하는 경우는 어떻게 되나요? [이벤트 스트림은](https://docs.microsoft.com/archive/msdn-magazine/2015/february/microsoft-azure-the-rise-of-event-stream-oriented-systems) 더 복잡 합니다. 일반적으로 시간 순서를 지정 하 고 상호 관련 되며 그룹으로 처리 되어야 합니다.

[Azure Event Hub](https://azure.microsoft.com/services/event-hubs/) 는 이벤트를 수집, 변환 및 저장 하는 데이터 스트리밍 플랫폼 및 이벤트 수집 서비스입니다. 원격 분석 컨텍스트에서 내보낸 연속 이벤트 알림과 같은 스트리밍 데이터를 캡처하기 위해 미세 하 게 조정 됩니다. 서비스는 확장성이 뛰어나고 [초당 수백만 개의 이벤트](https://docs.microsoft.com/azure/event-hubs/event-hubs-about)를 저장 하 고 처리할 수 있습니다. 그림 4-18에 표시 된 것 처럼 이벤트 파이프라인에 대 한 전방 도어 이며 수집 스트림을 이벤트 사용에서 분리 하는 경우가 많습니다.

![Azure Event Hub](./media/azure-event-hub.png)

**그림 4-18**. Azure Event Hub

이벤트 허브는 짧은 대기 시간과 구성 가능한 시간 보존을 지원 합니다. 큐 및 항목과 달리 소비자가 읽은 후 이벤트 데이터를 유지 Event Hubs. 이 기능을 사용 하면 내부 및 외부의 다른 데이터 분석 서비스에서 추가 분석을 위해 데이터를 재생할 수 있습니다. 이벤트 허브에 저장 된 이벤트는 보존 기간이 만료 되는 경우에만 삭제 됩니다. 즉, 기본적으로 1 일 이지만 구성할 수 있습니다.

이벤트 허브는 HTTPS 및 AMQP를 비롯 한 일반적인 이벤트 게시 프로토콜을 지원 합니다. Kafka 1.0도 지원 합니다. [기존 kafka 응용 프로그램](https://docs.microsoft.com/azure/event-hubs/event-hubs-for-kafka-ecosystem-overview) 은 대량 kafka 클러스터 관리에 대 한 대안을 제공 하는 kafka 프로토콜을 사용 하 여 이벤트 허브와 통신할 수 있습니다. 많은 오픈 소스 클라우드 네이티브 시스템은 Kafka을 수용 합니다.

Event Hubs는 각 소비자가 메시지 스트림의 특정 하위 집합 또는 파티션만 읽는 [분할 된 소비자 모델](https://docs.microsoft.com/azure/event-hubs/event-hubs-features) 을 통해 메시지 스트리밍을 구현 합니다. 이 패턴에서는 이벤트 처리를 위해 매우 폭넓은 수평 확장이 가능하며, 큐와 항목에서는 사용할 수 없는 기타 스트림 중심 기능이 제공됩니다. 파티션은 Event Hub에서 보유하는 순서가 지정된 이벤트 시퀀스입니다. 최신 이벤트가 도착 하면이 시퀀스의 끝에 추가 됩니다.그림 4-19에서는 이벤트 허브의 분할을 보여 줍니다.

![이벤트 허브 분할](./media/event-hub-partitioning.png)

**그림 4-19**. 이벤트 허브 분할

각 소비자 그룹은 동일한 리소스에서 읽는 대신 메시지 스트림의 하위 집합 또는 파티션 전체를 읽습니다.

많은 수의 이벤트를 스트리밍하는 클라우드 네이티브 응용 프로그램의 경우 Azure Event Hub는 강력 하 고 경제적인 솔루션 일 수 있습니다.

>[!div class="step-by-step"]
>[이전](front-end-communication.md)
>[다음](grpc.md)
