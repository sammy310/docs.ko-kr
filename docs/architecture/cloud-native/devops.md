---
title: DevOps
description: 클라우드 네이티브 응용 프로그램에 대 한 DevOps 고려 사항
ms.date: 05/13/2020
ms.openlocfilehash: e6e093a1847d3aec37ac5d4ca56f64e0091a9b6b
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/24/2020
ms.locfileid: "91164001"
---
# <a name="devops"></a><span data-ttu-id="9f3f3-103">DevOps</span><span class="sxs-lookup"><span data-stu-id="9f3f3-103">DevOps</span></span>

<span data-ttu-id="9f3f3-104">소프트웨어 컨설턴트의 모토은 발생 하는 모든 질문에 "It의 영향을 받습니다".</span><span class="sxs-lookup"><span data-stu-id="9f3f3-104">The favorite mantra of software consultants is to answer "It depends" to any question posed.</span></span> <span data-ttu-id="9f3f3-105">소프트웨어 컨설턴트는 위치를 글꼴 하지 않기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-105">It isn't because software consultants are fond of not taking a position.</span></span> <span data-ttu-id="9f3f3-106">소프트웨어의 질문에 대 한 하나의 진정한 답변이 없기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-106">It's because there's no one true answer to any questions in software.</span></span> <span data-ttu-id="9f3f3-107">절대 오른쪽 및 잘못 된 것은 아니지만 opposites 간에 균형을 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-107">There's no absolute right and wrong, but rather a balance between opposites.</span></span>

<span data-ttu-id="9f3f3-108">예를 들어 웹 응용 프로그램을 개발 하는 두 가지 주요 학교 인 SPAs (단일 페이지 응용 프로그램)와 서버 쪽 응용 프로그램을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-108">Take, for instance, the two major schools of developing web applications: Single Page Applications (SPAs) versus server-side applications.</span></span> <span data-ttu-id="9f3f3-109">한편, 사용자 환경은 SPAs를 사용 하는 것이 더 좋을 것 이며, 웹 서버에 대 한 트래픽 양을 최소화 하 여 정적 호스팅을 사용 하 여 간단 하 게 호스트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-109">On the one hand, the user experience tends to be better with SPAs and the amount of traffic to the web server can be minimized making it possible to host them on something as simple as static hosting.</span></span> <span data-ttu-id="9f3f3-110">반면에 SPAs는 개발 속도가 느려지고 테스트 하기가 더 어려워집니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-110">On the other hand, SPAs tend to be slower to develop and more difficult to test.</span></span> <span data-ttu-id="9f3f3-111">어떤 항목이 적합 한가요?</span><span class="sxs-lookup"><span data-stu-id="9f3f3-111">Which one is the right choice?</span></span> <span data-ttu-id="9f3f3-112">상황에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-112">Well, it depends on your situation.</span></span>

<span data-ttu-id="9f3f3-113">클라우드 네이티브 응용 프로그램은 동일한 dichotomy에 면역 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-113">Cloud-native applications aren't immune to that same dichotomy.</span></span> <span data-ttu-id="9f3f3-114">개발, 안정성 및 확장성의 속도 측면에서 분명 한 이점이 있지만이를 관리 하는 것은 매우 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-114">They have clear advantages in terms of speed of development, stability, and scalability, but managing them can be quite a bit more difficult.</span></span>

<span data-ttu-id="9f3f3-115">몇 년 전에 개발 환경에서 프로덕션 환경으로 응용 프로그램을 이동 하는 프로세스를 수행 하는 것이 일반적이 지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-115">Years ago, it wasn't uncommon for the process of moving an application from development to production to take a month, or even more.</span></span> <span data-ttu-id="9f3f3-116">회사는 6 개월 또는 매년 대비 하 여 소프트웨어를 출시 했습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-116">Companies released software on a 6-month or even every year cadence.</span></span> <span data-ttu-id="9f3f3-117">Windows 10의 녹색 일 이전에 허용 되는 릴리스 주기를 파악 하려면 Microsoft Windows 보다 더 이상 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-117">One needs to look no further than Microsoft Windows to get an idea for the cadence of releases that were acceptable before the ever-green days of Windows 10.</span></span> <span data-ttu-id="9f3f3-118">Windows XP와 Vista 사이에서 5 년 동안 통과 했습니다. Vista와 Windows 7의 추가 3입니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-118">Five years passed between Windows XP and Vista, a further 3 between Vista and Windows 7.</span></span>

<span data-ttu-id="9f3f3-119">이제는 소프트웨어를 신속 하 게 릴리스할 수 있는 것이 훨씬 잘 설정 되어 있어 신속 하 게 발전 하는 회사에서 sloth와 유사한 경쟁 우위를 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-119">It's now fairly well established that being able to release software rapidly gives fast-moving companies a huge market advantage over their more sloth-like competitors.</span></span> <span data-ttu-id="9f3f3-120">이제 Windows 10에 대 한 주요 업데이트가 약 6 개월 간격으로 진행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-120">It's for that reason that major updates to Windows 10 are now approximately every six months.</span></span>

<span data-ttu-id="9f3f3-121">비즈니스에 가치를 제공할 수 있는 보다 빠르고 안정적인 릴리스를 지 원하는 패턴 및 사례를 통칭 하 여 DevOps 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-121">The patterns and practices that enable faster, more reliable releases to deliver value to the business are collectively known as DevOps.</span></span> <span data-ttu-id="9f3f3-122">응용 프로그램을 제공 하 고 운영 하기 위해 응용 프로그램을 지정 하는 것부터 전체 소프트웨어 개발 수명 주기에 걸친 다양 한 아이디어를 구성 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-122">They consist of a wide range of ideas spanning the entire software development life cycle from specifying an application all the way up to delivering and operating that application.</span></span>

<span data-ttu-id="9f3f3-123">DevOps는 마이크로 서비스 앞에 등장 하 고 더 작은 환경에서 많은 응용 프로그램을 배포 하는 것이 용이 하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-123">DevOps emerged before microservices and it's likely that the movement towards smaller, more fit to purpose services wouldn't have been possible without DevOps to make releasing and operating not just one but many applications in production easier.</span></span>

![그림 10-1 검색 추세는 DevOps가 매우 잘 구성 된 아이디어가 될 때까지 마이크로 서비스 증가가 시작 되지 않는다는 것을 보여 줍니다.](./media/microservices-vs-devops.png)

<span data-ttu-id="9f3f3-125">**그림 10-1** -devops 및 마이크로 서비스.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-125">**Figure 10-1** - DevOps and microservices.</span></span>

<span data-ttu-id="9f3f3-126">적절 한 DevOps 방식을 통해 실제로 응용 프로그램을 운영 하는 suffocating 없이 클라우드 네이티브 응용 프로그램의 이점을 실현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-126">Through good DevOps practices, it's possible to realize the advantages of cloud-native applications without suffocating under a mountain of work actually operating the applications.</span></span>

<span data-ttu-id="9f3f3-127">DevOps에 대 한 골든 망치는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-127">There's no golden hammer when it comes to DevOps.</span></span> <span data-ttu-id="9f3f3-128">모든 기능을 통해 고품질 응용 프로그램을 릴리스 및 운영 하기 위한 완전 한 솔루션을 판매할 수 있는 사람은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-128">Nobody can sell a complete and all-encompassing solution for releasing and operating high-quality applications.</span></span> <span data-ttu-id="9f3f3-129">이는 각 응용 프로그램이 다른 모든 응용 프로그램과 무분별 서로 다르기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-129">This is because each application is wildly different from all others.</span></span> <span data-ttu-id="9f3f3-130">그러나 DevOps를 훨씬 저렴 하 게 사용할 수 있는 도구가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-130">However, there are tools that can make DevOps a far less daunting proposition.</span></span> <span data-ttu-id="9f3f3-131">이러한 도구 중 하나를 Azure DevOps 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-131">One of these tools is known as Azure DevOps.</span></span>

## <a name="azure-devops"></a><span data-ttu-id="9f3f3-132">Azure DevOps</span><span class="sxs-lookup"><span data-stu-id="9f3f3-132">Azure DevOps</span></span>

<span data-ttu-id="9f3f3-133">Azure DevOps에는 긴 계통 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-133">Azure DevOps has a long pedigree.</span></span> <span data-ttu-id="9f3f3-134">Team Foundation Server 처음으로 온라인으로 이동 하 고 다양 한 이름 변경 (Visual Studio Online 및 Visual Studio Team Services)을 통해 해당 루트를 다시 추적할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-134">It can trace its roots back to when Team Foundation Server first moved online and through the various name changes: Visual Studio Online and Visual Studio Team Services.</span></span> <span data-ttu-id="9f3f3-135">그러나 연도까지 이전 보다 훨씬 오래 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-135">Through the years, however, it has become far more than its predecessors.</span></span>

<span data-ttu-id="9f3f3-136">Azure DevOps는 다음과 같은 5 가지 주요 구성 요소로 구분 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-136">Azure DevOps is divided into five major components:</span></span>

![그림 10-2 Azure DevOps의 5 가지 주요 영역](./media/devops-components.png)

<span data-ttu-id="9f3f3-138">**그림 10-2** -Azure devops.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-138">**Figure 10-2** - Azure DevOps.</span></span>

<span data-ttu-id="9f3f3-139">TFVC (venerable Team Foundation 버전 제어) 및 업계에서 즐겨 사용 하는 [Git](https://en.wikipedia.org/wiki/Git)를 지 원하는 **Azure Repos** 소스 코드 관리입니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-139">**Azure Repos** - Source code management that supports the venerable Team Foundation Version Control (TFVC) and the industry favorite [Git](https://en.wikipedia.org/wiki/Git).</span></span> <span data-ttu-id="9f3f3-140">끌어오기 요청은 변경 내용에 대 한 토론을 빠르게 수행 소셜 코딩을 사용 하도록 설정 하는 방법을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-140">Pull requests provide a way to enable social coding by fostering discussion of changes as they're made.</span></span>

<span data-ttu-id="9f3f3-141">**Azure Boards** -사용자가 가장 잘 작동 하는 워크플로를 선택할 수 있도록 하는 문제 및 작업 항목 추적 도구를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-141">**Azure Boards** - Provides an issue and work item tracking tool that strives to allow users to pick the workflows that work best for them.</span></span> <span data-ttu-id="9f3f3-142">SCRUM 및 간판 스타일을 개발 하는 데 사용할 수 있는 몇 가지 미리 구성 된 템플릿과 함께 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-142">It comes with a number of pre-configured templates including ones to support SCRUM and Kanban styles of development.</span></span>

<span data-ttu-id="9f3f3-143">**Azure Pipelines** -Azure와의 긴밀 한 통합을 지 원하는 빌드 및 릴리스 관리 시스템입니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-143">**Azure Pipelines** - A build and release management system that supports tight integration with Azure.</span></span> <span data-ttu-id="9f3f3-144">빌드는 Windows에서 Linux, MacOS에 이르기까지 다양 한 플랫폼에서 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-144">Builds can be run on a variety of platforms from Windows to Linux to MacOS.</span></span> <span data-ttu-id="9f3f3-145">빌드 에이전트는 클라우드 또는 온-프레미스에서 프로 비전 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-145">Build agents may be provisioned in the cloud or on-premises.</span></span>

<span data-ttu-id="9f3f3-146">**Azure Test Plans** -Test Plans 기능에서 제공 하는 테스트 관리 및 예비 테스트 지원으로는 QA가 남아 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-146">**Azure Test Plans** - No QA person will be left behind with the test management and exploratory testing support offered by the Test Plans feature.</span></span>

<span data-ttu-id="9f3f3-147">**Azure Artifacts** -회사에서 자체의 NuGet, npm 및 기타 버전을 만들 수 있도록 하는 아티팩트 피드입니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-147">**Azure Artifacts** - An artifact feed that allows companies to create their own, internal, versions of NuGet, npm, and others.</span></span> <span data-ttu-id="9f3f3-148">중앙 집중식 리포지토리의 오류가 발생 한 경우 업스트림 패키지의 캐시 역할을 하는 두 가지 목적으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-148">It serves a double purpose of acting as a cache of upstream packages if there's a failure of a centralized repository.</span></span>

<span data-ttu-id="9f3f3-149">Azure DevOps의 최상위 조직 구성 단위를 프로젝트 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-149">The top-level organizational unit in Azure DevOps is known as a Project.</span></span> <span data-ttu-id="9f3f3-150">각 프로젝트 내에서 Azure Artifacts와 같은 다양 한 구성 요소를 설정 및 해제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-150">Within each project the various components, such as Azure Artifacts, can be turned on and off.</span></span> <span data-ttu-id="9f3f3-151">이러한 각 구성 요소는 클라우드 네이티브 응용 프로그램에 대해 서로 다른 이점을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-151">Each of these components provides different advantages for cloud-native applications.</span></span> <span data-ttu-id="9f3f3-152">가장 유용한 세 가지는 리포지토리, 보드 및 파이프라인입니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-152">The three most useful are repositories, boards, and pipelines.</span></span> <span data-ttu-id="9f3f3-153">사용자가 GitHub와 같은 다른 리포지토리 스택에서 소스 코드를 관리 하지만 Azure Pipelines 및 기타 구성 요소를 계속 활용 하려는 경우에는 가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-153">If users want to manage their source code in another repository stack, such as GitHub, but still take advantage of Azure Pipelines and other components, that's perfectly possible.</span></span>

<span data-ttu-id="9f3f3-154">다행히 개발 팀은 리포지토리를 선택할 때 많은 옵션을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-154">Fortunately, development teams have many options when selecting a repository.</span></span> <span data-ttu-id="9f3f3-155">그 중 하나는 GitHub입니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-155">One of them is GitHub.</span></span>

## <a name="github-actions"></a><span data-ttu-id="9f3f3-156">GitHub 작업</span><span class="sxs-lookup"><span data-stu-id="9f3f3-156">GitHub Actions</span></span>

<span data-ttu-id="9f3f3-157">2009에서 설립 된 GitHub는 프로젝트, 설명서 및 코드 호스팅을 위한 널리 사용 되는 웹 기반 리포지토리입니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-157">Founded in 2009, GitHub is a widely popular web-based repository for hosting projects, documentation, and code.</span></span> <span data-ttu-id="9f3f3-158">Apple, Amazon, Google 및 메인스트림 회사와 같은 많은 많은 기술 회사에서는 GitHub를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-158">Many large tech companies, such as Apple, Amazon, Google, and mainstream corporations use GitHub.</span></span> <span data-ttu-id="9f3f3-159">GitHub는 Git 이라는 오픈 소스 분산 버전 제어 시스템을 기반으로 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-159">GitHub uses the open-source, distributed version control system named Git as its foundation.</span></span> <span data-ttu-id="9f3f3-160">그런 다음, 각 코드 베이스에 대 한 결함 추적, 기능 및 끌어오기 요청, 작업 관리 및 wiki를 포함 하 여 고유한 기능 집합을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-160">On top, it then adds its own set of features, including defect tracking, feature and pull requests, tasks management, and wikis for each code base.</span></span>

<span data-ttu-id="9f3f3-161">GitHub가 발전 함에 따라 DevOps 기능을 추가 하는 중입니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-161">As GitHub evolves, it too is adding DevOps features.</span></span> <span data-ttu-id="9f3f3-162">예를 들어 GitHub에는 이라는 고유한 CI/CD (지속적인 통합/지속적인 업데이트) 파이프라인이 있습니다 `GitHub Actions` .</span><span class="sxs-lookup"><span data-stu-id="9f3f3-162">For example, GitHub has its own continuous integration/continuous delivery (CI/CD) pipeline, called `GitHub Actions`.</span></span> <span data-ttu-id="9f3f3-163">GitHub 작업은 커뮤니티 기반 워크플로 자동화 도구입니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-163">GitHub Actions is a community-powered workflow automation tool.</span></span> <span data-ttu-id="9f3f3-164">DevOps 팀은 기존 도구와 통합 하 고, 새 제품을 조합 하 고 일치 시키고, 기존 CI/CD 파트너를 비롯 한 소프트웨어 수명 주기에 연결할 수 있습니다. "</span><span class="sxs-lookup"><span data-stu-id="9f3f3-164">It lets DevOps teams integrate with their existing tooling, mix and match new products, and hook into their software lifecycle, including existing CI/CD partners."</span></span>

<span data-ttu-id="9f3f3-165">GitHub에는 4000만 명 이상의 사용자가 있으며, 전 세계에서 가장 큰 소스 코드 호스트로 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-165">GitHub has over 40 million users, making it the largest host of source code in the world.</span></span> <span data-ttu-id="9f3f3-166">2018 년 10 월에 Microsoft는 GitHub를 구매 했습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-166">In October of 2018, Microsoft purchased GitHub.</span></span> <span data-ttu-id="9f3f3-167">Microsoft는 개발자가 플러그인 하 고 확장할 수 있는 [오픈 플랫폼](https://techcrunch.com/2018/06/04/microsoft-promises-to-keep-github-independent-and-open/) 으로 GitHub를 pledged.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-167">Microsoft has pledged that GitHub will remain an [open platform](https://techcrunch.com/2018/06/04/microsoft-promises-to-keep-github-independent-and-open/) that any developer can plug into and extend.</span></span> <span data-ttu-id="9f3f3-168">계속 독립 된 회사로 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-168">It continues to operate as an independent company.</span></span> <span data-ttu-id="9f3f3-169">GitHub는 엔터프라이즈, 팀, 전문가 및 무료 계정에 대 한 요금제를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-169">GitHub offers plans for enterprise, team, professional, and free accounts.</span></span>

## <a name="source-control"></a><span data-ttu-id="9f3f3-170">원본 제어</span><span class="sxs-lookup"><span data-stu-id="9f3f3-170">Source control</span></span>

<span data-ttu-id="9f3f3-171">클라우드 네이티브 응용 프로그램에 대 한 코드를 구성 하는 것은 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-171">Organizing the code for a cloud-native application can be challenging.</span></span> <span data-ttu-id="9f3f3-172">클라우드 네이티브 응용 프로그램은 하나의 자이언트 응용 프로그램 대신 서로 통신 하는 소규모 응용 프로그램으로 구성 되는 경향이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-172">Instead of a single giant application, the cloud-native applications tend to be made up of a web of smaller applications that talk with one another.</span></span> <span data-ttu-id="9f3f3-173">컴퓨팅의 모든 작업에서와 마찬가지로 코드를 가장 잘 정렬 하는 것은 미해결 질문입니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-173">As with all things in computing, the best arrangement of code remains an open question.</span></span> <span data-ttu-id="9f3f3-174">다양 한 종류의 레이아웃을 사용 하는 성공적인 응용 프로그램의 예가 있지만 가장 인기 있는 두 가지 변형이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-174">There are examples of successful applications using different kinds of layouts, but two variants seem to have the most popularity.</span></span>

<span data-ttu-id="9f3f3-175">실제 소스 제어 자체를 시작 하기 전에 적절 한 프로젝트 수를 결정 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-175">Before getting down into the actual source control itself, it's probably worth deciding on how many projects are appropriate.</span></span> <span data-ttu-id="9f3f3-176">단일 프로젝트 내에서 여러 리포지토리 및 빌드 파이프라인에 대 한 지원이 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-176">Within a single project, there's support for multiple repositories, and build pipelines.</span></span> <span data-ttu-id="9f3f3-177">보드는 약간 더 복잡 하지만 단일 프로젝트 내에서 여러 팀에 작업을 쉽게 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-177">Boards are a little more complicated, but there too, the tasks can easily be assigned to multiple teams within a single project.</span></span> <span data-ttu-id="9f3f3-178">단일 Azure DevOps 프로젝트에서 수백, 수천 명의 개발자를 지원할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-178">It's possible to support hundreds, even thousands of developers, out of a single Azure DevOps project.</span></span> <span data-ttu-id="9f3f3-179">이렇게 하면 모든 개발자가 작업을 수행할 수 있는 단일 위치를 제공 하는 것이 가장 좋은 방법입니다. 개발자가 자신이 속한 프로젝트가 확실 하지 않을 경우 해당 응용 프로그램을 찾는 것이 혼란 스 러 울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-179">Doing so is likely the best approach as it provides a single place for all developer to work out of and reduces the confusion of finding that one application when developers are unsure in which project in which it resides.</span></span>

<span data-ttu-id="9f3f3-180">Azure DevOps 프로젝트 내에서 마이크로 서비스에 대 한 코드를 분할 하는 것은 약간 더 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-180">Splitting up code for microservices within the Azure DevOps project can be slightly more challenging.</span></span>

![그림 10-3 단일 및 여러 리포지토리](./media/single-repository-vs-multiple.png)

<span data-ttu-id="9f3f3-182">**그림 10-3** -하나 및 여러 개의 리포지토리가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-182">**Figure 10-3** - One vs. many repositories.</span></span>

### <a name="repository-per-microservice"></a><span data-ttu-id="9f3f3-183">마이크로 서비스 당 리포지토리</span><span class="sxs-lookup"><span data-stu-id="9f3f3-183">Repository per microservice</span></span>

<span data-ttu-id="9f3f3-184">처음에는 마이크로 서비스에 대 한 소스 코드를 분할 하는 것이 가장 논리적인 방법 처럼 보입니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-184">At first glance, this seems like the most logical approach to splitting up the source code for microservices.</span></span> <span data-ttu-id="9f3f3-185">각 리포지토리에는 하나의 마이크로 서비스를 빌드하는 데 필요한 코드가 포함 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-185">Each repository can contain the code needed to build the one microservice.</span></span> <span data-ttu-id="9f3f3-186">이 방법의 장점은 쉽게 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-186">The advantages to this approach are readily visible:</span></span>

1. <span data-ttu-id="9f3f3-187">응용 프로그램 빌드 및 유지 관리에 대 한 지침은 각 리포지토리의 루트에 있는 추가 정보 파일에 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-187">Instructions for building and maintaining the application can be added to a README file at the root of each repository.</span></span> <span data-ttu-id="9f3f3-188">리포지토리를 통해 대칭 이동 하는 경우 이러한 지침을 쉽게 찾아 개발자를 위한 스핀 시간을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-188">When flipping through the repositories, it's easy to find these instructions, reducing spin-up time for developers.</span></span>
2. <span data-ttu-id="9f3f3-189">모든 서비스는 논리적 위치에 있으며, 서비스의 이름을 알면 쉽게 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-189">Every service is located in a logical place, easily found by knowing the name of the service.</span></span>
3. <span data-ttu-id="9f3f3-190">빌드를 쉽게 설정 하 여 소유 하는 리포지토리가 변경 될 때만 트리거될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-190">Builds can easily be set up such that they're only triggered when a change is made to the owning repository.</span></span>
4. <span data-ttu-id="9f3f3-191">리포지토리에 들어오는 변경 수는 프로젝트에서 작업 하는 소수의 개발자로 제한 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-191">The number of changes coming into a repository is limited to the small number of developers working on the project.</span></span>
5. <span data-ttu-id="9f3f3-192">개발자가 읽기 및 쓰기 권한을 가진 리포지토리를 제한 하 여 보안을 설정 하는 것이 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-192">Security is easy to set up by restricting the repositories to which developers have read and write permissions.</span></span>
6. <span data-ttu-id="9f3f3-193">다른 사용자와의 토론을 최소화 하면서 소유 팀에서 리포지토리 수준 설정을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-193">Repository level settings can be changed by the owning team with a minimum of discussion with others.</span></span>

<span data-ttu-id="9f3f3-194">마이크로 서비스의 주요 개념 중 하나는 서비스를 사일로 하 고 서로 분리 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-194">One of the key ideas behind microservices is that services should be siloed and separated from each other.</span></span> <span data-ttu-id="9f3f3-195">도메인 기반 디자인을 사용 하 여 서비스가 트랜잭션 경계 역할을 하는 서비스의 경계를 결정 하는 경우</span><span class="sxs-lookup"><span data-stu-id="9f3f3-195">When using Domain Driven Design to decide on the boundaries for services the services act as transactional boundaries.</span></span> <span data-ttu-id="9f3f3-196">데이터베이스 업데이트는 여러 서비스에 걸쳐 있어서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-196">Database updates shouldn't span multiple services.</span></span> <span data-ttu-id="9f3f3-197">이 관련 데이터 컬렉션을 바인딩된 컨텍스트 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-197">This collection of related data is referred to as a bounded context.</span></span>  <span data-ttu-id="9f3f3-198">이 개념은 마이크로 서비스 데이터를 나머지 서비스와는 별개의 데이터베이스로 격리 하는 것에 의해 반영 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-198">This idea is reflected by the isolation of microservice data to a database separate and autonomous from the rest of the services.</span></span> <span data-ttu-id="9f3f3-199">이를 통해 소스 코드를 통해이 아이디어를 모두 이해할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-199">It makes a great deal of sense to carry this idea all the way through to the source code.</span></span>

<span data-ttu-id="9f3f3-200">그러나이 방법은 문제가 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-200">However, this approach isn't without its issues.</span></span> <span data-ttu-id="9f3f3-201">Microsoft 시간의 gnarly 개발 문제 중 하나는 종속성을 관리 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-201">One of the more gnarly development problems of our time is managing dependencies.</span></span> <span data-ttu-id="9f3f3-202">평균 디렉터리를 구성 하는 파일 수를 고려 합니다 `node_modules` .</span><span class="sxs-lookup"><span data-stu-id="9f3f3-202">Consider the number of files that make up the average `node_modules` directory.</span></span> <span data-ttu-id="9f3f3-203">와 같은 항목을 새로 설치 하는 경우 `create-react-app` 수천 개의 패키지를 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-203">A fresh install of something like `create-react-app` is likely to bring with it thousands of packages.</span></span> <span data-ttu-id="9f3f3-204">이러한 종속성을 관리 하는 방법에 대 한 질문은 어려운 일입니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-204">The question of how to manage these dependencies is a difficult one.</span></span>

<span data-ttu-id="9f3f3-205">종속성이 업데이트 되 면 다운스트림 패키지도이 종속성을 업데이트 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-205">If a dependency is updated, then downstream packages must also update this dependency.</span></span> <span data-ttu-id="9f3f3-206">불행 하 게도 개발 작업을 수행 하는 항상, `node_modules` 디렉터리는 단일 패키지의 여러 버전으로 끝나지만, 각각은 약간 다른 흐름에서 버전 관리 되는 다른 패키지에 대 한 종속성입니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-206">Unfortunately, that takes development work so, invariably, the `node_modules` directory ends up with multiple versions of a single package, each one a dependency of some other package that is versioned at a slightly different cadence.</span></span> <span data-ttu-id="9f3f3-207">응용 프로그램을 배포할 때 사용 해야 하는 종속성 버전은 무엇 인가요?</span><span class="sxs-lookup"><span data-stu-id="9f3f3-207">When deploying an application, which version of a dependency should be used?</span></span> <span data-ttu-id="9f3f3-208">현재 프로덕션 중인 버전은 무엇 인가요?</span><span class="sxs-lookup"><span data-stu-id="9f3f3-208">The version that is currently in production?</span></span> <span data-ttu-id="9f3f3-209">현재 베타 버전 이지만 소비자가 프로덕션 환경에 사용 하는 시간에 따라 프로덕션 환경에 있을 가능성이 높습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-209">The version that is currently in Beta but is likely to be in production by the time the consumer makes it to production?</span></span> <span data-ttu-id="9f3f3-210">마이크로 서비스를 사용 하 여 해결 되지 않는 어려운 문제</span><span class="sxs-lookup"><span data-stu-id="9f3f3-210">Difficult problems that aren't resolved by just using microservices.</span></span>

<span data-ttu-id="9f3f3-211">다양 한 프로젝트에 의존 하는 라이브러리가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-211">There are libraries that are depended upon by a wide variety of projects.</span></span> <span data-ttu-id="9f3f3-212">각 리포지토리의 마이크로 서비스를 하나씩 분할 하 여 내부 종속성을 Azure Artifacts 내부 리포지토리를 사용 하 여 가장 효과적으로 해결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-212">By dividing the microservices up with one in each repository the internal dependencies can best be resolved by using the internal repository, Azure Artifacts.</span></span> <span data-ttu-id="9f3f3-213">라이브러리에 대 한 빌드는 내부 사용을 위해 최신 버전을 Azure Artifacts로 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-213">Builds for libraries will push their latest versions into Azure Artifacts for internal consumption.</span></span> <span data-ttu-id="9f3f3-214">새로 업데이트 된 패키지에 대 한 종속성을 사용 하려면 다운스트림 프로젝트를 수동으로 업데이트 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-214">The downstream project must still be manually updated to take a dependency on the newly updated packages.</span></span>

<span data-ttu-id="9f3f3-215">서비스 간에 코드를 이동 하는 경우 또 다른 단점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-215">Another disadvantage presents itself when moving code between services.</span></span> <span data-ttu-id="9f3f3-216">응용 프로그램을 마이크로 서비스로 처음 분할 하는 것이 100% 정확 하다 고 생각 하는 것은 사실 이지만 실제로는 서비스 나누기를 사용 하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-216">Although it would be nice to believe that the first division of an application into microservices is 100% correct, the reality is that rarely we're so prescient as to make no service division mistakes.</span></span> <span data-ttu-id="9f3f3-217">따라서 기능 및 해당 기능을 구동 하는 코드를 서비스에서 리포지토리로 이동 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-217">Thus, functionality and the code that drives it will need to move from service to service: repository to repository.</span></span> <span data-ttu-id="9f3f3-218">한 리포지토리에서 다른 리포지토리로 달은 더 코드는 해당 기록을 잃게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-218">When leaping from one repository to another, the code loses its history.</span></span> <span data-ttu-id="9f3f3-219">특히 감사의 경우 코드 조각에 대 한 전체 기록을 포함 하는 것이 중요 한 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-219">There are many cases, especially in the event of an audit, where having full history on a piece of code is invaluable.</span></span>

<span data-ttu-id="9f3f3-220">마지막 및 가장 중요 한 단점은 변경 내용을 조정 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-220">The final and most important disadvantage is coordinating changes.</span></span> <span data-ttu-id="9f3f3-221">진정한 마이크로 서비스 응용 프로그램에서는 서비스 간에 배포 종속성이 없어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-221">In a true microservices application, there should be no deployment dependencies between services.</span></span> <span data-ttu-id="9f3f3-222">느슨한 결합을 포함 하는 모든 순서로 서비스 A, B 및 C를 배포할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-222">It should be possible to deploy services A, B, and C in any order as they have loose coupling.</span></span> <span data-ttu-id="9f3f3-223">그러나 실제로 여러 리포지토리를 동시에 교차 하는 변경을 수행 하는 것이 바람직한 경우가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-223">In reality, however, there are times when it's desirable to make a change that crosses multiple repositories at the same time.</span></span> <span data-ttu-id="9f3f3-224">일부 예에는 보안 허점을 닫거나 모든 서비스에서 사용 하는 통신 프로토콜을 변경 하기 위해 라이브러리를 업데이트 하는 작업이 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-224">Some examples include updating a library to close a security hole or changing a communication protocol used by all services.</span></span>

<span data-ttu-id="9f3f3-225">저장소 간 변경을 수행 하려면 연속 해 서 각 리포지토리에 대 한 커밋을 수행 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-225">To do a cross-repository change requires a commit to each repository be made in succession.</span></span> <span data-ttu-id="9f3f3-226">각 리포지토리의 각 변경 내용은 끌어오기 요청 및 별도로 검토 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-226">Each change in each repository will need to be pull-requested and reviewed separately.</span></span> <span data-ttu-id="9f3f3-227">이는 조정 하기 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-227">This can be difficult to coordinate.</span></span>

<span data-ttu-id="9f3f3-228">많은 리포지토리를 사용 하는 대신 모든 소스 코드를 모든 것을 단일 저장소에 포함 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-228">An alternative to using many repositories is to put all the source code together in a giant, all knowing, single repository.</span></span>

### <a name="single-repository"></a><span data-ttu-id="9f3f3-229">단일 리포지토리</span><span class="sxs-lookup"><span data-stu-id="9f3f3-229">Single repository</span></span>

<span data-ttu-id="9f3f3-230">이 방법에서는 [monorepository](https://danluu.com/monorepo/)라고도 하는 모든 서비스에 대 한 모든 소스 코드가 동일한 리포지토리에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-230">In this approach, sometimes referred to as a [monorepository](https://danluu.com/monorepo/), all the source code for every service is put into the same repository.</span></span> <span data-ttu-id="9f3f3-231">처음에는 소스 코드를 처리 하는 것이 어려울 수 있는 것 처럼 보일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-231">At first, this seems like a terrible idea likely to make dealing with source code unwieldy.</span></span> <span data-ttu-id="9f3f3-232">그러나 이러한 방식으로 작업 하는 데는 몇 가지 장점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-232">There are, however, some marked advantages to working this way.</span></span>

<span data-ttu-id="9f3f3-233">첫 번째 장점은 프로젝트 간의 종속성을 관리 하는 것이 더 쉽기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-233">The first advantage is that it's easier to manage dependencies between projects.</span></span> <span data-ttu-id="9f3f3-234">프로젝트는 외부 아티팩트 피드를 기반으로 하는 대신 서로 직접 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-234">Instead of relying on some external artifact feed, projects can directly import one another.</span></span> <span data-ttu-id="9f3f3-235">즉, 업데이트가 인스턴트 이며, 개발자 워크스테이션에서 컴파일 시간에 충돌 하는 버전을 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-235">This means that updates are instant, and conflicting versions are likely to be found at compile time on the developer's workstation.</span></span> <span data-ttu-id="9f3f3-236">실제로 일부 통합 테스트를 진행 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-236">In effect, shifting some of the integration testing left.</span></span>

<span data-ttu-id="9f3f3-237">프로젝트 간에 코드를 이동 하는 경우 파일이 다시 작성 되는 것이 아니라 이동 된 것으로 검색 되므로 기록을 유지 하는 것이 더 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-237">When moving code between projects, it's now easier to preserve the history as the files will be detected as having been moved rather than being rewritten.</span></span>

<span data-ttu-id="9f3f3-238">또 다른 이점은 서비스 경계를 교차 하는 광범위 한 변경을 단일 커밋으로 만들 수 있다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-238">Another advantage is that wide ranging changes that cross service boundaries can be made in a single commit.</span></span> <span data-ttu-id="9f3f3-239">이렇게 하면 수십 개의 변경 내용을 개별적으로 검토할 수 있는 오버 헤드를 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-239">This reduces the overhead of having potentially dozens of changes to review individually.</span></span>

<span data-ttu-id="9f3f3-240">코드에 대 한 정적 분석을 수행 하 여 안전 하지 않은 프로그래밍 관행 또는 문제가 있는 Api 사용을 검색할 수 있는 많은 도구가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-240">There are many tools that can perform static analysis of code to detect insecure programming practices or problematic use of APIs.</span></span> <span data-ttu-id="9f3f3-241">다중 리포지토리 환경의 경우 각 리포지토리를 반복 하 여 문제를 찾아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-241">In a multi-repository world, each repository will need to be iterated over to find the problems in them.</span></span> <span data-ttu-id="9f3f3-242">단일 리포지토리에서 모든 분석을 한 곳에서 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-242">The single repository allows running the analysis all in one place.</span></span>

<span data-ttu-id="9f3f3-243">단일 리포지토리 방법에도 많은 단점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-243">There are also many disadvantages to the single repository approach.</span></span> <span data-ttu-id="9f3f3-244">가장 중요 한 문제 중 하나는 단일 리포지토리가 있으면 보안 문제가 발생 한다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-244">One of the most worrying ones is that having a single repository raises security concerns.</span></span> <span data-ttu-id="9f3f3-245">리포지토리의 콘텐츠가 서비스 모델 당 리포지토리에서 유출 되는 경우 손실 되는 코드의 양은 최소화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-245">If the contents of a repository are leaked in a repository per service model, the amount of code lost is minimal.</span></span> <span data-ttu-id="9f3f3-246">단일 리포지토리가 있으면 회사가 소유 하 고 있는 모든 것이 손실 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-246">With a single repository, everything the company owns could be lost.</span></span> <span data-ttu-id="9f3f3-247">이러한 상황이 발생 하는 과거의 많은 예가 있으며 전체 게임 개발 노력을 치중.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-247">There have been many examples in the past of this happening and derailing entire game development efforts.</span></span> <span data-ttu-id="9f3f3-248">여러 리포지토리를 통해 노출 영역을 줄일 수 있습니다 .이는 대부분의 보안 작업에서 유용한 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-248">Having multiple repositories exposes less surface area, which is a desirable trait in most security practices.</span></span>

<span data-ttu-id="9f3f3-249">단일 리포지토리의 크기를 빠르게 관리할 수 없게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-249">The size of the single repository is likely to become unmanageable rapidly.</span></span> <span data-ttu-id="9f3f3-250">이렇게 하면 몇 가지 흥미로운 성능에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-250">This presents some interesting performance implications.</span></span> <span data-ttu-id="9f3f3-251">Windows 팀에서 개발자의 경험을 향상 시키기 위해 원래 설계 된 [Git 용 가상 파일 시스템과](https://vfsforgit.org/)같은 특수 도구를 사용 해야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-251">It may become necessary to use specialized tools such as [Virtual File System for Git](https://vfsforgit.org/), which was originally designed to improve the experience for developers on the Windows team.</span></span>

<span data-ttu-id="9f3f3-252">단일 리포지토리를 사용 하는 인수는 구축가 소스 코드 정렬에이 메서드를 사용 하는 인수를 사용 하는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-252">Frequently the argument for using a single repository boils down to an argument that Facebook or Google use this method for source code arrangement.</span></span> <span data-ttu-id="9f3f3-253">이러한 회사에서 접근 방식이 충분 한 경우 모든 회사에 대 한 올바른 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-253">If the approach is good enough for these companies, then, surely, it's the correct approach for all companies.</span></span> <span data-ttu-id="9f3f3-254">무엇 보다도 일부 회사는 Facebook 또는 Google의 규모와 같은 작업을 수행 하는 것이 중요 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-254">The truth of the matter is that few companies operate on anything like the scale of Facebook or Google.</span></span> <span data-ttu-id="9f3f3-255">이러한 규모에서 발생 하는 문제는 대부분의 개발자가 직면 하는 문제와 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-255">The problems that occur at those scales are different from those most developers will face.</span></span> <span data-ttu-id="9f3f3-256">Goose에 적합 한 것은 gander에 적합 하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-256">What is good for the goose may not be good for the gander.</span></span>

<span data-ttu-id="9f3f3-257">마지막으로, 두 솔루션을 사용 하 여 마이크로 서비스에 대 한 소스 코드를 호스트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-257">In the end, either solution can be used to host the source code for microservices.</span></span> <span data-ttu-id="9f3f3-258">그러나 대부분의 경우 단일 리포지토리에서 운영 하는 관리 및 엔지니어링 오버 헤드가 meager 이점을 얻을 가치가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-258">However, in most cases, the management, and engineering overhead of operating in a single repository isn't worth the meager advantages.</span></span> <span data-ttu-id="9f3f3-259">코드를 여러 리포지토리에 분할 하면 문제를 더 잘 분리 하 고 개발 팀 간에 자율성을 강화할 것을 권장 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-259">Splitting code up over multiple repositories encourages better separation of concerns and encourages autonomy among development teams.</span></span>  

### <a name="standard-directory-structure"></a><span data-ttu-id="9f3f3-260">표준 디렉터리 구조</span><span class="sxs-lookup"><span data-stu-id="9f3f3-260">Standard directory structure</span></span>

<span data-ttu-id="9f3f3-261">단일 및 다중 저장소에 관계 없이 각 서비스에는 고유한 디렉터리가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-261">Regardless of the single versus multiple repositories debate each service will have its own directory.</span></span> <span data-ttu-id="9f3f3-262">개발자가 프로젝트를 신속 하 게 교차 하 게 할 수 있도록 하는 최상의 최적화 중 하나는 표준 디렉터리 구조를 유지 관리 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-262">One of the best optimizations to allow developers to cross between projects quickly is to maintain a standard directory structure.</span></span>

![그림 10-4 전자 메일 및 로그인 서비스 모두에 대 한 표준 디렉터리 구조](./media/dir-struct.png)

<span data-ttu-id="9f3f3-264">**그림 10-4** -표준 디렉터리 구조</span><span class="sxs-lookup"><span data-stu-id="9f3f3-264">**Figure 10-4** - Standard directory structure.</span></span>

<span data-ttu-id="9f3f3-265">새 프로젝트를 만들 때마다 올바른 구조에 배치 하는 템플릿을 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-265">Whenever a new project is created, a template that puts in place the correct structure should be used.</span></span> <span data-ttu-id="9f3f3-266">이 템플릿에는 이러한 유용한 항목이 기본 추가 정보 파일과로 포함 될 수도 있습니다 `azure-pipelines.yml` .</span><span class="sxs-lookup"><span data-stu-id="9f3f3-266">This template can also include such useful items as a skeleton README file and an `azure-pipelines.yml`.</span></span> <span data-ttu-id="9f3f3-267">모든 마이크로 서비스 아키텍처에서 프로젝트 간의 분산이 높으면 서비스에 대해 대량 작업을 수행 하기가 더 어려워집니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-267">In any microservice architecture, a high degree of variance between projects makes bulk operations against the services more difficult.</span></span>

<span data-ttu-id="9f3f3-268">여러 소스 코드 디렉터리를 포함 하는 전체 디렉터리에 대 한 템플릿을 제공할 수 있는 많은 도구가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-268">There are many tools that can provide templating for an entire directory, containing several source code directories.</span></span> <span data-ttu-id="9f3f3-269">전 세계의는 JavaScript 세계에서 널리 [사용 되 고 GitHub에는 최근에](https://yeoman.io/) 동일한 기능을 제공 하는 [리포지토리 템플릿이](https://github.blog/2019-06-06-generate-new-repositories-with-repository-templates/)출시 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-269">[Yeoman](https://yeoman.io/) is popular in the JavaScript world and GitHub have recently released [Repository Templates](https://github.blog/2019-06-06-generate-new-repositories-with-repository-templates/), which provide much of the same functionality.</span></span>

## <a name="task-management"></a><span data-ttu-id="9f3f3-270">작업 관리</span><span class="sxs-lookup"><span data-stu-id="9f3f3-270">Task management</span></span>

<span data-ttu-id="9f3f3-271">모든 프로젝트에서 작업을 관리 하는 것은 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-271">Managing tasks in any project can be difficult.</span></span> <span data-ttu-id="9f3f3-272">앞에서 개발자의 생산성을 최적화 하기 위해 설정 하는 워크플로의 종류에 대 한 답변을 얻을 수 있는 다양 한 질문이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-272">Up front there are countless questions to be answered about the sort of workflows to set up to ensure optimal developer productivity.</span></span>

<span data-ttu-id="9f3f3-273">클라우드 네이티브 응용 프로그램은 기존 소프트웨어 제품 보다 작은 경향이 있거나 적어도 작은 서비스로 나뉩니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-273">Cloud-native applications tend to be smaller than traditional software products or at least they're divided into smaller services.</span></span> <span data-ttu-id="9f3f3-274">이러한 서비스와 관련 된 문제 또는 작업을 추적 하는 것은 다른 소프트웨어 프로젝트의 경우와 동일 하 게 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-274">Tracking of issues or tasks related to these services remains as important as with any other software project.</span></span> <span data-ttu-id="9f3f3-275">일부 작업 항목을 추적 하거나 문제를 제대로 기록 하지 않은 고객에 게 설명 하 려 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-275">Nobody wants to lose track of some work item or explain to a customer that their issue wasn't properly logged.</span></span> <span data-ttu-id="9f3f3-276">보드는 프로젝트 수준에서 구성 되지만 각 프로젝트 내에서 영역을 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-276">Boards are configured at the project level but within each project, areas can be defined.</span></span> <span data-ttu-id="9f3f3-277">이를 통해 여러 구성 요소에서 문제를 나눌 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-277">These allow breaking down issues across several components.</span></span> <span data-ttu-id="9f3f3-278">전체 응용 프로그램에 대 한 모든 작업을 한 곳에 유지 하는 이점은 작업 항목을 한 팀에서 다른 팀으로 이동 하는 것이 더 쉽기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-278">The advantage to keeping all the work for the entire application in one place is that it's easy to move work items from one team to another as they're understood better.</span></span>

<span data-ttu-id="9f3f3-279">Azure DevOps는 미리 구성 된 많은 인기 있는 템플릿을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-279">Azure DevOps comes with a number of popular templates pre-configured.</span></span> <span data-ttu-id="9f3f3-280">가장 기본적인 구성에서는 백로그, 사용자가 작업 하는 작업 및 완료 된 작업에 대 한 정보를 알고 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-280">In the most basic configuration, all that is needed to know is what's in the backlog, what people are working on, and what's done.</span></span> <span data-ttu-id="9f3f3-281">이를 통해 소프트웨어를 구축 하는 과정을 파악 하는 것이 중요 합니다. 따라서 해당 작업은 우선 순위가 지정 되 고 완료 된 작업을 고객에 게 보고할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-281">It's important to have this visibility into the process of building software, so that work can be prioritized and completed tasks reported to the customer.</span></span> <span data-ttu-id="9f3f3-282">물론 소수의 소프트웨어 프로젝트는, 및 처럼 간단 하 게 프로세스에 `to do` 집중 `doing` `done` 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-282">Of course, few software projects stick to a process as simple as `to do`, `doing`, and `done`.</span></span> <span data-ttu-id="9f3f3-283">사용자가 프로세스와 같은 단계를 추가 하는 데 오랜 시간이 걸리지 않습니다 `QA` `Detailed Specification` .</span><span class="sxs-lookup"><span data-stu-id="9f3f3-283">It doesn't take long for people to start adding steps like `QA` or `Detailed Specification` to the process.</span></span>

<span data-ttu-id="9f3f3-284">Agile 방법론의 중요 한 부분 중 하나는 일정 한 간격으로 자체 검사는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-284">One of the more important parts of Agile methodologies is self-introspection at regular intervals.</span></span> <span data-ttu-id="9f3f3-285">이러한 검토는 팀이 직면 하는 문제와 이러한 문제를 개선 하는 방법을 파악 하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-285">These reviews are meant to provide insight into what problems the team is facing and how they can be improved.</span></span> <span data-ttu-id="9f3f3-286">일반적으로이는 개발 프로세스를 통해 문제와 기능의 흐름을 변경 하는 것을 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-286">Frequently, this means changing the flow of issues and features through the development process.</span></span> <span data-ttu-id="9f3f3-287">따라서 추가 단계를 통해 보드의 레이아웃을 확장 하는 것은 완벽 하 게 정상입니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-287">So, it's perfectly healthy to expand the layouts of the boards with additional stages.</span></span>

<span data-ttu-id="9f3f3-288">보드의 단계는 유일한 조직 도구가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-288">The stages in the boards aren't the only organizational tool.</span></span> <span data-ttu-id="9f3f3-289">보드의 구성에 따라 작업 항목의 계층이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-289">Depending on the configuration of the board, there's a hierarchy of work items.</span></span> <span data-ttu-id="9f3f3-290">보드에 표시할 수 있는 가장 세분화 된 항목은 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-290">The most granular item that can appear on a board is a task.</span></span> <span data-ttu-id="9f3f3-291">기본적으로 작업에는 제목, 설명, 우선 순위, 남은 작업량의 예상 금액 및 다른 작업 항목 또는 개발 항목 (분기, 커밋, 끌어오기 요청, 빌드 등)에 연결할 수 있는 권한이 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-291">Out of the box a task contains fields for a title, description, a priority, an estimate of the amount of work remaining and the ability to link to other work items or development items (branches, commits, pull requests, builds, and so forth).</span></span> <span data-ttu-id="9f3f3-292">작업 항목을 응용 프로그램의 여러 영역으로 분류 하 고 다른 반복 (스 프린트)을 통해 쉽게 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-292">Work items can be classified into different areas of the application and different iterations (sprints) to make finding them easier.</span></span>

![그림 10-5 Azure DevOps의 예제 작업](./media/task-details.png)

<span data-ttu-id="9f3f3-294">**그림 10-5** -Azure devops의 작업</span><span class="sxs-lookup"><span data-stu-id="9f3f3-294">**Figure 10-5** - Task in Azure DevOps.</span></span>

<span data-ttu-id="9f3f3-295">설명 필드는 필요한 표준 스타일 (굵게, 기울임꼴 밑줄 및 취소선)과 이미지 삽입 기능을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-295">The description field supports the normal styles you'd expect (bold, italic underscore and strike through) and the ability to insert images.</span></span> <span data-ttu-id="9f3f3-296">이렇게 하면 작업 또는 버그를 지정할 때 사용할 수 있는 강력한 도구입니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-296">This makes it a powerful tool for use when specifying work or bugs.</span></span>

<span data-ttu-id="9f3f3-297">작업을 더 큰 작업 단위를 정의 하는 기능으로 롤업할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-297">Tasks can be rolled up into features, which define a larger unit of work.</span></span> <span data-ttu-id="9f3f3-298">그러면 기능이 [에픽으로 롤업](/azure/devops/boards/backlogs/define-features-epics?view=azure-devops)될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-298">Features, in turn, can be [rolled up into epics](/azure/devops/boards/backlogs/define-features-epics?view=azure-devops).</span></span> <span data-ttu-id="9f3f3-299">이 계층 구조에서 작업을 분류 하면 큰 기능이 롤아웃 되는 방법을 보다 쉽게 이해할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-299">Classifying tasks in this hierarchy makes it much easier to understand how close a large feature is to rolling out.</span></span>

![그림 10-6 기본 프로세스 템플릿에서 기본적으로 구성 된 작업 항목 형식](./media/board-issue-types.png)

<span data-ttu-id="9f3f3-301">**그림 10-6** -Azure devops의 작업 항목</span><span class="sxs-lookup"><span data-stu-id="9f3f3-301">**Figure 10-6** - Work item in Azure DevOps.</span></span>

<span data-ttu-id="9f3f3-302">Azure Boards 문제에 대 한 다양 한 종류의 보기가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-302">There are different kinds of views into the issues in Azure Boards.</span></span> <span data-ttu-id="9f3f3-303">아직 예약 되지 않은 항목은 백로그에 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-303">Items that aren't yet scheduled appear in the backlog.</span></span> <span data-ttu-id="9f3f3-304">여기에서 스 프린트에 할당 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-304">From there, they can be assigned to a sprint.</span></span> <span data-ttu-id="9f3f3-305">스 프린트는 작업의 일부를 완료 하는 데 필요한 시간 상자입니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-305">A sprint is a time box during which it's expected some quantity of work will be completed.</span></span> <span data-ttu-id="9f3f3-306">이러한 작업에는 작업 뿐만 아니라 티켓의 해상도도 포함 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-306">This work can include tasks but also the resolution of tickets.</span></span> <span data-ttu-id="9f3f3-307">완료 되 면 전체 스 프린트를 스 프린트 보드 섹션에서 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-307">Once there, the entire sprint can be managed from the Sprint board section.</span></span> <span data-ttu-id="9f3f3-308">이 보기는 작업이 진행 되는 방법을 보여 주고, 스 프린트에 성공 하는 경우 업데이트 예상 값을 제공 하는 굽는 차트를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-308">This view shows how work is progressing and includes a burn down chart to give an ever-updating estimate of if the sprint will be successful.</span></span>

![그림 10-7 스 프린트를 정의 하는 보드](./media/sprint-board.png)

<span data-ttu-id="9f3f3-310">**그림 10-7** -Azure devops의 보드.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-310">**Figure 10-7** - Board in Azure DevOps.</span></span>

<span data-ttu-id="9f3f3-311">지금까지 Azure DevOps의 보드에 상당한 전력이 있음을 분명히 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-311">By now, it should be apparent that there's a great deal of power in the Boards in Azure DevOps.</span></span> <span data-ttu-id="9f3f3-312">개발자를 위해 작업 중인 항목을 쉽게 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-312">For developers, there are easy views of what is being worked on.</span></span> <span data-ttu-id="9f3f3-313">프로젝트 관리자는 기존 작업에 대 한 개요 뿐만 아니라 예정 된 작업을 볼 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-313">For project managers views into upcoming work as well as an overview of existing work.</span></span> <span data-ttu-id="9f3f3-314">관리자의 경우 높아지면 및 용량에 대 한 다양 한 보고서가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-314">For managers, there are plenty of reports about resourcing and capacity.</span></span> <span data-ttu-id="9f3f3-315">아쉽게도 클라우드 네이티브 응용 프로그램은 작업을 추적할 필요가 없도록 하는 놀라운 작업이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-315">Unfortunately, there's nothing magical about cloud-native applications that eliminate the need to track work.</span></span> <span data-ttu-id="9f3f3-316">그러나 작업을 추적 해야 하는 경우 Azure DevOps 보다 성능이 좋은 몇 가지 위치가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-316">But if you must track work, there are a few places where the experience is better than in Azure DevOps.</span></span>

## <a name="cicd-pipelines"></a><span data-ttu-id="9f3f3-317">CI/CD 파이프라인</span><span class="sxs-lookup"><span data-stu-id="9f3f3-317">CI/CD pipelines</span></span>

<span data-ttu-id="9f3f3-318">소프트웨어 개발 수명 주기는 CI (지속적인 통합) 및 CD (지속적인 업데이트)의 출현으로 거의 변경 되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-318">Almost no change in the software development life cycle has been so revolutionary as the advent of continuous integration (CI) and continuous delivery (CD).</span></span> <span data-ttu-id="9f3f3-319">에서 변경 내용이 확인 되는 즉시 프로젝트의 소스 코드에 대해 자동화 된 테스트를 빌드하고 실행 하면 오류가 조기에 catch 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-319">Building and running automated tests against the source code of a project as soon as a change is checked in catches mistakes early.</span></span> <span data-ttu-id="9f3f3-320">연속 통합 빌드를 도입 하기 전에는 리포지토리에서 코드를 가져와서 테스트를 통과 하지 못했거나 빌드할 수 없다는 것이 일반적이 지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-320">Prior to the advent of continuous integration builds, it wouldn't be uncommon to pull code from the repository and find that it didn't pass tests or couldn't even be built.</span></span> <span data-ttu-id="9f3f3-321">이로 인해 중단의 원본이 추적 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-321">This resulted in tracking down the source of the breakage.</span></span>

<span data-ttu-id="9f3f3-322">일반적으로 프로덕션 환경에 소프트웨어를 출시 하려면 광범위 한 설명서와 단계 목록이 필요 했습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-322">Traditionally shipping software to the production environment required extensive documentation and a list of steps.</span></span> <span data-ttu-id="9f3f3-323">이러한 각 단계는 매우 오류가 발생 하기 쉬운 프로세스에서 수동으로 완료 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-323">Each one of these steps needed to be manually completed in a very error prone process.</span></span>

![그림 10-8 검사 목록](./media/checklist.png)

<span data-ttu-id="9f3f3-325">**그림 10-8** -검사 목록.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-325">**Figure 10-8** - Checklist.</span></span>

<span data-ttu-id="9f3f3-326">연속 통합의 대체는 새로 빌드된 패키지가 환경에 배포 되는 지속적인 업데이트입니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-326">The sister of continuous integration is continuous delivery in which the freshly built packages are deployed to an environment.</span></span> <span data-ttu-id="9f3f3-327">수동 프로세스는 개발 속도와 일치 하도록 확장할 수 없으므로 automation이 더 중요 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-327">The manual process can't scale to match the speed of development so automation becomes more important.</span></span> <span data-ttu-id="9f3f3-328">검사 목록은 모든 사용자가 보다 빠르고 정확 하 게 동일한 작업을 실행할 수 있는 스크립트로 대체 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-328">Checklists are replaced by scripts that can execute the same tasks faster and more accurately than any human.</span></span>

<span data-ttu-id="9f3f3-329">지속적인 배달이 제공 하는 환경은 테스트 환경 이거나 많은 주요 기술 회사에서 수행 하는 것 처럼 프로덕션 환경 일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-329">The environment to which continuous delivery delivers might be a test environment or, as is being done by many major technology companies, it could be the production environment.</span></span> <span data-ttu-id="9f3f3-330">후자를 사용 하는 경우에는 변경이 사용자를 위해 프로덕션이 중단 되지 않는다는 확신을 줄 수 있는 고품질 테스트에 대 한 투자가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-330">The latter requires an investment in high-quality tests that can give confidence that a change isn't going to break production for users.</span></span> <span data-ttu-id="9f3f3-331">연속 통합에서 코드의 문제를 발견 하는 것과 동일한 방식으로 초기에 배포 프로세스의 문제를 찾아냅니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-331">In the same way that continuous integration caught issues in the code early continuous delivery catches issues in the deployment process early.</span></span>

<span data-ttu-id="9f3f3-332">빌드 및 배달 프로세스 자동화의 중요성은 클라우드 네이티브 응용 프로그램에 의해 accentuated 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-332">The importance of automating the build and delivery process is accentuated by cloud-native applications.</span></span> <span data-ttu-id="9f3f3-333">배포는 더 자주 발생 하 고 더 많은 환경에서 수동으로 테두리를 배포할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-333">Deployments happen more frequently and to more environments so manually deploying borders on impossible.</span></span>

### <a name="azure-builds"></a><span data-ttu-id="9f3f3-334">Azure 빌드</span><span class="sxs-lookup"><span data-stu-id="9f3f3-334">Azure Builds</span></span>

<span data-ttu-id="9f3f3-335">Azure DevOps는 연속 통합 및 배포를 보다 쉽게 수행할 수 있는 일련의 도구를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-335">Azure DevOps provides a set of tools to make continuous integration and deployment easier than ever.</span></span> <span data-ttu-id="9f3f3-336">이러한 도구는 Azure Pipelines 아래에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-336">These tools are located under Azure Pipelines.</span></span> <span data-ttu-id="9f3f3-337">그 중 첫 번째는 Azure 빌드 이며, 대규모로 YAML 기반 빌드 정의를 실행 하는 데 사용 되는 도구입니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-337">The first of them is Azure Builds, which is a tool for running YAML-based build definitions at scale.</span></span> <span data-ttu-id="9f3f3-338">사용자는 자신의 빌드 컴퓨터를 가져올 수 있습니다 (빌드에 신중 설정 환경이 필요한 경우에 적합) 또는 Azure에서 호스트 되는 가상 컴퓨터의 지속적으로 새로 고쳐지는 풀에서 컴퓨터를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-338">Users can either bring their own build machines (great for if the build requires a meticulously set up environment) or use a machine from a constantly refreshed pool of Azure hosted virtual machines.</span></span> <span data-ttu-id="9f3f3-339">이러한 호스팅된 빌드 에이전트는 .NET 개발 뿐만 아니라 Java에서 Python으로 iPhone 개발에 이르기까지 광범위 한 개발 도구를 사용 하 여 미리 설치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-339">These hosted build agents come pre-installed with a wide range of development tools for not just .NET development but for everything from Java to Python to iPhone development.</span></span>

<span data-ttu-id="9f3f3-340">DevOps에는 모든 빌드에 대해 사용자 지정할 수 있는 다양 한 기본 빌드 정의가 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-340">DevOps includes a wide range of out of the box build definitions that can be customized for any build.</span></span> <span data-ttu-id="9f3f3-341">빌드 정의는 `azure-pipelines.yml` 소스 코드와 함께 버전을 지정할 수 있도록 이라는 파일에 정의 되 고 리포지토리에 체크 인 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-341">The build definitions are defined in a file called `azure-pipelines.yml` and checked into the repository so they can be versioned along with the source code.</span></span> <span data-ttu-id="9f3f3-342">이렇게 하면 변경 내용을 해당 분기에만 체크 인할 수 있으므로 분기의 빌드 파이프라인을 훨씬 쉽게 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-342">This makes it much easier to make changes to the build pipeline in a branch as the changes can be checked into just that branch.</span></span> <span data-ttu-id="9f3f3-343">`azure-pipelines.yml`전체 프레임 워크에서 ASP.NET 웹 응용 프로그램을 빌드하는 예제는 그림 10-9에 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-343">An example `azure-pipelines.yml` for building an ASP.NET web application on full framework is show in Figure 10-9.</span></span>

```yml
name: $(rev:r)

variables:
  version: 9.2.0.$(Build.BuildNumber)
  solution: Portals.sln
  artifactName: drop
  buildPlatform: any cpu
  buildConfiguration: release
  
pool:
  name: Hosted VS2017
  demands:
  - msbuild
  - visualstudio
  - vstest

steps:
- task: NuGetToolInstaller@0
  displayName: 'Use NuGet 4.4.1'
  inputs:
    versionSpec: 4.4.1

- task: NuGetCommand@2
  displayName: 'NuGet restore'
  inputs:
    restoreSolution: '$(solution)'

- task: VSBuild@1
  displayName: 'Build solution'
  inputs:
    solution: '$(solution)'
    msbuildArgs: '-p:DeployOnBuild=true -p:WebPublishMethod=Package -p:PackageAsSingleFile=true -p:SkipInvalidConfigurations=true -p:PackageLocation="$(build.artifactstagingdirectory)\\"'
    platform: '$(buildPlatform)'
    configuration: '$(buildConfiguration)'

- task: VSTest@2
  displayName: 'Test Assemblies'
  inputs:
    testAssemblyVer2: |
     **\$(buildConfiguration)\**\*test*.dll
     !**\obj\**
     !**\*testadapter.dll
    platform: '$(buildPlatform)'
    configuration: '$(buildConfiguration)'

- task: CopyFiles@2
  displayName: 'Copy UI Test Files to: $(build.artifactstagingdirectory)'
  inputs:
    SourceFolder: UITests
    TargetFolder: '$(build.artifactstagingdirectory)/uitests'

- task: PublishBuildArtifacts@1
  displayName: 'Publish Artifact'
  inputs:
    PathtoPublish: '$(build.artifactstagingdirectory)'
    ArtifactName: '$(artifactName)'
  condition: succeededOrFailed()
```

<span data-ttu-id="9f3f3-344">**그림 10-9** -azure-pipelines 샘플</span><span class="sxs-lookup"><span data-stu-id="9f3f3-344">**Figure 10-9** - A sample azure-pipelines.yml</span></span>

<span data-ttu-id="9f3f3-345">이 빌드 정의는 적합 한 집합을 구축 하는 것 처럼 간단 하 게 빌드를 만드는 데 사용할 수 있는 여러 기본 제공 작업을 사용 합니다 (자이언트 Millennium 비 Con 보다 간단).</span><span class="sxs-lookup"><span data-stu-id="9f3f3-345">This build definition uses a number of built-in tasks that make creating builds as simple as building a Lego set (simpler than the giant Millennium Falcon).</span></span> <span data-ttu-id="9f3f3-346">예를 들어 NuGet 작업은 NuGet 패키지를 복원 하는 반면 VSBuild 작업은 Visual Studio 빌드 도구를 호출 하 여 실제 컴파일을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-346">For instance, the NuGet task restores NuGet packages, while the VSBuild task calls the Visual Studio build tools to perform the actual compilation.</span></span> <span data-ttu-id="9f3f3-347">Azure DevOps에서 사용할 수 있는 수백 개의 작업은 커뮤니티에서 유지 관리 하는 수천 가지 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-347">There are hundreds of different tasks available in Azure DevOps, with thousands more that are maintained by the community.</span></span> <span data-ttu-id="9f3f3-348">어떤 빌드 작업을 실행 하 고 있는지에 관계 없이 다른 사람이 빌드 작업을 이미 빌드 했을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-348">It's likely that no matter what build tasks you're looking to run, somebody has built one already.</span></span>

<span data-ttu-id="9f3f3-349">빌드는 수동으로 또는 체크 인을 통해 일정에 따라 트리거하거나 다른 빌드가 완료 될 때 트리거될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-349">Builds can be triggered manually, by a check-in, on a schedule, or by the completion of another build.</span></span> <span data-ttu-id="9f3f3-350">대부분의 경우 모든 체크 인에 대 한 빌드를 선택 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-350">In most cases, building on every check-in is desirable.</span></span> <span data-ttu-id="9f3f3-351">여러 빌드를 리포지토리의 다른 부분이 나 다른 분기에 대해 실행 하도록 빌드를 필터링 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-351">Builds can be filtered so that different builds run against different parts of the repository or against different branches.</span></span> <span data-ttu-id="9f3f3-352">이를 통해 끌어오기 요청에 대 한 테스트를 줄이고 매일 밤에 대해 전체 회귀 도구 모음을 실행 하 여 빠른 빌드를 실행 하는 등의 시나리오를 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-352">This allows for scenarios like running fast builds with reduced testing on pull requests and running a full regression suite against the trunk on a nightly basis.</span></span>

<span data-ttu-id="9f3f3-353">빌드의 최종 결과는 빌드 아티팩트 라는 파일의 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-353">The end result of a build is a collection of files known as build artifacts.</span></span> <span data-ttu-id="9f3f3-354">이러한 아티팩트는 빌드 프로세스의 다음 단계에 따라 전달 되거나 Azure 아티팩트 피드에 추가 될 수 있으므로 다른 빌드에서 사용 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-354">These artifacts can be passed along to the next step in the build process or added to an Azure Artifact feed, so they can be consumed by other builds.</span></span>

### <a name="azure-devops-releases"></a><span data-ttu-id="9f3f3-355">Azure DevOps 릴리스</span><span class="sxs-lookup"><span data-stu-id="9f3f3-355">Azure DevOps releases</span></span>

<span data-ttu-id="9f3f3-356">빌드는 소프트웨어를 제공 가능한 패키지로 컴파일하는 데 주의를 기울여야 하지만 지속적인 업데이트를 완료 하려면 아티팩트를 테스트 환경에 푸시 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-356">Builds take care of compiling the software into a shippable package, but the artifacts still need to be pushed out to a testing environment to complete continuous delivery.</span></span> <span data-ttu-id="9f3f3-357">이를 위해 Azure DevOps는 릴리스 라는 별도의 도구를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-357">For this, Azure DevOps uses a separate tool called Releases.</span></span> <span data-ttu-id="9f3f3-358">릴리스 도구는 빌드에 사용할 수 있었지만 "스테이지" 라는 개념을 소개 하는 동일한 태스크 라이브러리를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-358">The Releases tool makes use of the same tasks' library that were available to the Build but introduce a concept of "stages".</span></span> <span data-ttu-id="9f3f3-359">단계는 패키지가 설치 되는 격리 된 환경입니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-359">A stage is an isolated environment into which the package is installed.</span></span> <span data-ttu-id="9f3f3-360">예를 들어 제품은 개발, QA 및 프로덕션 환경을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-360">For instance, a product might make use of a development, a QA, and a production environment.</span></span> <span data-ttu-id="9f3f3-361">코드는 자동화 된 테스트를 실행할 수 있는 개발 환경에 지속적으로 전달 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-361">Code is continuously delivered into the development environment where automated tests can be run against it.</span></span> <span data-ttu-id="9f3f3-362">이러한 테스트를 통과 하면 릴리스가 수동 테스트를 위한 QA 환경으로 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-362">Once those tests pass the release moves onto the QA environment for manual testing.</span></span> <span data-ttu-id="9f3f3-363">마지막으로 코드는 모든 사람에 게 표시 되는 프로덕션에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-363">Finally, the code is pushed to production where it's visible to everybody.</span></span>

![그림 10-10 개발, QA 및 프로덕션 단계를 포함 하는 예제 릴리스 파이프라인](./media/release-pipeline.png)

<span data-ttu-id="9f3f3-365">**그림 10-10** -릴리스 파이프라인</span><span class="sxs-lookup"><span data-stu-id="9f3f3-365">**Figure 10-10** - Release pipeline</span></span>

<span data-ttu-id="9f3f3-366">이전 단계를 완료 하면 빌드의 각 단계를 자동으로 트리거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-366">Each stage in the build can be automatically triggered by the completion of the previous phase.</span></span> <span data-ttu-id="9f3f3-367">그러나 대부분의 경우에는 이렇게 하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-367">In many cases, however, this isn't desirable.</span></span> <span data-ttu-id="9f3f3-368">코드를 프로덕션으로 이동 하려면 다른 사용자의 승인이 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-368">Moving code into production might require approval from somebody.</span></span> <span data-ttu-id="9f3f3-369">릴리스 도구는 릴리스 파이프라인의 각 단계에서 승인자를 허용 하 여이를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-369">The Releases tool supports this by allowing approvers at each step of the release pipeline.</span></span> <span data-ttu-id="9f3f3-370">규칙을 설정 하 여 특정 사용자 또는 사용자 그룹이 릴리스를 프로덕션 환경에 적용 하기 전에 로그 오프 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-370">Rules can be set up such that a specific person or group of people must sign off on a release before it makes into production.</span></span> <span data-ttu-id="9f3f3-371">이러한 게이트를 통해 수동 품질 검사를 수행할 수 있으며, 프로덕션으로 전환 되는 항목을 제어 하는 것과 관련 된 규정 요구 사항을 준수할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-371">These gates allow for manual quality checks and also for compliance with any regulatory requirements related to control what goes into production.</span></span>

### <a name="everybody-gets-a-build-pipeline"></a><span data-ttu-id="9f3f3-372">모든 사람이 빌드 파이프라인을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-372">Everybody gets a build pipeline</span></span>

<span data-ttu-id="9f3f3-373">많은 빌드 파이프라인을 구성 하는 데는 비용이 들지 않으므로 마이크로 서비스 당 빌드 파이프라인이 하나 이상 있는 것이 유리 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-373">There's no cost to configuring many build pipelines, so it's advantageous to have at least one build pipeline per microservice.</span></span> <span data-ttu-id="9f3f3-374">이상적으로는 마이크로 서비스를 모든 환경에 독립적으로 배포할 수 있으므로 관련 없는 코드를 해제 하지 않고 자체 파이프라인을 통해 각 항목을 릴리스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-374">Ideally, microservices are independently deployable to any environment so having each one able to be released via its own pipeline without releasing a mass of unrelated code is perfect.</span></span> <span data-ttu-id="9f3f3-375">각 파이프라인에는 각 서비스에 대 한 빌드 프로세스의 변형을 허용 하는 고유한 승인 집합이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-375">Each pipeline can have its own set of approvals allowing for variations in build process for each service.</span></span>

### <a name="versioning-releases"></a><span data-ttu-id="9f3f3-376">버전 관리 릴리스</span><span class="sxs-lookup"><span data-stu-id="9f3f3-376">Versioning releases</span></span>

<span data-ttu-id="9f3f3-377">릴리스 기능을 사용 하는 경우의 한 가지 단점은 체크 인 된 파일에 정의 될 수 없다는 것입니다 `azure-pipelines.yml` .</span><span class="sxs-lookup"><span data-stu-id="9f3f3-377">One drawback to using the Releases functionality is that it can't be defined in a checked-in `azure-pipelines.yml` file.</span></span> <span data-ttu-id="9f3f3-378">프로젝트 템플릿에서 릴리스 구조를 포함 하기 위해 분기 단위 릴리스 정의를 포함 하 여이 작업을 수행 하는 여러 가지 이유가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-378">There are many reasons you might want to do that from having per-branch release definitions to including a release skeleton in your project template.</span></span> <span data-ttu-id="9f3f3-379">다행히 작업을 진행 하 여 일부 단계 지원 기능을 빌드 구성 요소로 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="9f3f3-379">Fortunately, work is ongoing to shift some of the stages support into the Build component.</span></span> <span data-ttu-id="9f3f3-380">이를 다단계 빌드 라고 하 고 [첫 번째 버전을 지금 사용할 수 있습니다](https://devblogs.microsoft.com/devops/whats-new-with-azure-pipelines/).</span><span class="sxs-lookup"><span data-stu-id="9f3f3-380">This will be known as multi-stage build and the [first version is available now](https://devblogs.microsoft.com/devops/whats-new-with-azure-pipelines/)!</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="9f3f3-381">[이전](azure-security.md)
>[다음](feature-flags.md)</span><span class="sxs-lookup"><span data-stu-id="9f3f3-381">[Previous](azure-security.md)
[Next](feature-flags.md)</span></span>
