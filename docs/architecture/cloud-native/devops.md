---
title: DevOps
description: 클라우드 네이티브 응용 프로그램에 대 한 DevOps 고려 사항
ms.date: 05/13/2020
ms.openlocfilehash: e6e093a1847d3aec37ac5d4ca56f64e0091a9b6b
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/24/2020
ms.locfileid: "91164001"
---
# <a name="devops"></a>DevOps

소프트웨어 컨설턴트의 모토은 발생 하는 모든 질문에 "It의 영향을 받습니다". 소프트웨어 컨설턴트는 위치를 글꼴 하지 않기 때문입니다. 소프트웨어의 질문에 대 한 하나의 진정한 답변이 없기 때문입니다. 절대 오른쪽 및 잘못 된 것은 아니지만 opposites 간에 균형을 유지 합니다.

예를 들어 웹 응용 프로그램을 개발 하는 두 가지 주요 학교 인 SPAs (단일 페이지 응용 프로그램)와 서버 쪽 응용 프로그램을 사용 합니다. 한편, 사용자 환경은 SPAs를 사용 하는 것이 더 좋을 것 이며, 웹 서버에 대 한 트래픽 양을 최소화 하 여 정적 호스팅을 사용 하 여 간단 하 게 호스트할 수 있습니다. 반면에 SPAs는 개발 속도가 느려지고 테스트 하기가 더 어려워집니다. 어떤 항목이 적합 한가요? 상황에 따라 달라 집니다.

클라우드 네이티브 응용 프로그램은 동일한 dichotomy에 면역 되지 않습니다. 개발, 안정성 및 확장성의 속도 측면에서 분명 한 이점이 있지만이를 관리 하는 것은 매우 어려울 수 있습니다.

몇 년 전에 개발 환경에서 프로덕션 환경으로 응용 프로그램을 이동 하는 프로세스를 수행 하는 것이 일반적이 지 않습니다. 회사는 6 개월 또는 매년 대비 하 여 소프트웨어를 출시 했습니다. Windows 10의 녹색 일 이전에 허용 되는 릴리스 주기를 파악 하려면 Microsoft Windows 보다 더 이상 확인 해야 합니다. Windows XP와 Vista 사이에서 5 년 동안 통과 했습니다. Vista와 Windows 7의 추가 3입니다.

이제는 소프트웨어를 신속 하 게 릴리스할 수 있는 것이 훨씬 잘 설정 되어 있어 신속 하 게 발전 하는 회사에서 sloth와 유사한 경쟁 우위를 얻을 수 있습니다. 이제 Windows 10에 대 한 주요 업데이트가 약 6 개월 간격으로 진행 됩니다.

비즈니스에 가치를 제공할 수 있는 보다 빠르고 안정적인 릴리스를 지 원하는 패턴 및 사례를 통칭 하 여 DevOps 라고 합니다. 응용 프로그램을 제공 하 고 운영 하기 위해 응용 프로그램을 지정 하는 것부터 전체 소프트웨어 개발 수명 주기에 걸친 다양 한 아이디어를 구성 합니다.

DevOps는 마이크로 서비스 앞에 등장 하 고 더 작은 환경에서 많은 응용 프로그램을 배포 하는 것이 용이 하지 않을 수 있습니다.

![그림 10-1 검색 추세는 DevOps가 매우 잘 구성 된 아이디어가 될 때까지 마이크로 서비스 증가가 시작 되지 않는다는 것을 보여 줍니다.](./media/microservices-vs-devops.png)

**그림 10-1** -devops 및 마이크로 서비스.

적절 한 DevOps 방식을 통해 실제로 응용 프로그램을 운영 하는 suffocating 없이 클라우드 네이티브 응용 프로그램의 이점을 실현할 수 있습니다.

DevOps에 대 한 골든 망치는 없습니다. 모든 기능을 통해 고품질 응용 프로그램을 릴리스 및 운영 하기 위한 완전 한 솔루션을 판매할 수 있는 사람은 없습니다. 이는 각 응용 프로그램이 다른 모든 응용 프로그램과 무분별 서로 다르기 때문입니다. 그러나 DevOps를 훨씬 저렴 하 게 사용할 수 있는 도구가 있습니다. 이러한 도구 중 하나를 Azure DevOps 라고 합니다.

## <a name="azure-devops"></a>Azure DevOps

Azure DevOps에는 긴 계통 있습니다. Team Foundation Server 처음으로 온라인으로 이동 하 고 다양 한 이름 변경 (Visual Studio Online 및 Visual Studio Team Services)을 통해 해당 루트를 다시 추적할 수 있습니다. 그러나 연도까지 이전 보다 훨씬 오래 되었습니다.

Azure DevOps는 다음과 같은 5 가지 주요 구성 요소로 구분 됩니다.

![그림 10-2 Azure DevOps의 5 가지 주요 영역](./media/devops-components.png)

**그림 10-2** -Azure devops.

TFVC (venerable Team Foundation 버전 제어) 및 업계에서 즐겨 사용 하는 [Git](https://en.wikipedia.org/wiki/Git)를 지 원하는 **Azure Repos** 소스 코드 관리입니다. 끌어오기 요청은 변경 내용에 대 한 토론을 빠르게 수행 소셜 코딩을 사용 하도록 설정 하는 방법을 제공 합니다.

**Azure Boards** -사용자가 가장 잘 작동 하는 워크플로를 선택할 수 있도록 하는 문제 및 작업 항목 추적 도구를 제공 합니다. SCRUM 및 간판 스타일을 개발 하는 데 사용할 수 있는 몇 가지 미리 구성 된 템플릿과 함께 제공 됩니다.

**Azure Pipelines** -Azure와의 긴밀 한 통합을 지 원하는 빌드 및 릴리스 관리 시스템입니다. 빌드는 Windows에서 Linux, MacOS에 이르기까지 다양 한 플랫폼에서 실행할 수 있습니다. 빌드 에이전트는 클라우드 또는 온-프레미스에서 프로 비전 될 수 있습니다.

**Azure Test Plans** -Test Plans 기능에서 제공 하는 테스트 관리 및 예비 테스트 지원으로는 QA가 남아 있지 않습니다.

**Azure Artifacts** -회사에서 자체의 NuGet, npm 및 기타 버전을 만들 수 있도록 하는 아티팩트 피드입니다. 중앙 집중식 리포지토리의 오류가 발생 한 경우 업스트림 패키지의 캐시 역할을 하는 두 가지 목적으로 사용 됩니다.

Azure DevOps의 최상위 조직 구성 단위를 프로젝트 라고 합니다. 각 프로젝트 내에서 Azure Artifacts와 같은 다양 한 구성 요소를 설정 및 해제할 수 있습니다. 이러한 각 구성 요소는 클라우드 네이티브 응용 프로그램에 대해 서로 다른 이점을 제공 합니다. 가장 유용한 세 가지는 리포지토리, 보드 및 파이프라인입니다. 사용자가 GitHub와 같은 다른 리포지토리 스택에서 소스 코드를 관리 하지만 Azure Pipelines 및 기타 구성 요소를 계속 활용 하려는 경우에는 가능 합니다.

다행히 개발 팀은 리포지토리를 선택할 때 많은 옵션을 사용할 수 있습니다. 그 중 하나는 GitHub입니다.

## <a name="github-actions"></a>GitHub 작업

2009에서 설립 된 GitHub는 프로젝트, 설명서 및 코드 호스팅을 위한 널리 사용 되는 웹 기반 리포지토리입니다. Apple, Amazon, Google 및 메인스트림 회사와 같은 많은 많은 기술 회사에서는 GitHub를 사용 합니다. GitHub는 Git 이라는 오픈 소스 분산 버전 제어 시스템을 기반으로 사용 합니다. 그런 다음, 각 코드 베이스에 대 한 결함 추적, 기능 및 끌어오기 요청, 작업 관리 및 wiki를 포함 하 여 고유한 기능 집합을 추가 합니다.

GitHub가 발전 함에 따라 DevOps 기능을 추가 하는 중입니다. 예를 들어 GitHub에는 이라는 고유한 CI/CD (지속적인 통합/지속적인 업데이트) 파이프라인이 있습니다 `GitHub Actions` . GitHub 작업은 커뮤니티 기반 워크플로 자동화 도구입니다. DevOps 팀은 기존 도구와 통합 하 고, 새 제품을 조합 하 고 일치 시키고, 기존 CI/CD 파트너를 비롯 한 소프트웨어 수명 주기에 연결할 수 있습니다. "

GitHub에는 4000만 명 이상의 사용자가 있으며, 전 세계에서 가장 큰 소스 코드 호스트로 만듭니다. 2018 년 10 월에 Microsoft는 GitHub를 구매 했습니다. Microsoft는 개발자가 플러그인 하 고 확장할 수 있는 [오픈 플랫폼](https://techcrunch.com/2018/06/04/microsoft-promises-to-keep-github-independent-and-open/) 으로 GitHub를 pledged. 계속 독립 된 회사로 작동 합니다. GitHub는 엔터프라이즈, 팀, 전문가 및 무료 계정에 대 한 요금제를 제공 합니다.

## <a name="source-control"></a>원본 제어

클라우드 네이티브 응용 프로그램에 대 한 코드를 구성 하는 것은 어려울 수 있습니다. 클라우드 네이티브 응용 프로그램은 하나의 자이언트 응용 프로그램 대신 서로 통신 하는 소규모 응용 프로그램으로 구성 되는 경향이 있습니다. 컴퓨팅의 모든 작업에서와 마찬가지로 코드를 가장 잘 정렬 하는 것은 미해결 질문입니다. 다양 한 종류의 레이아웃을 사용 하는 성공적인 응용 프로그램의 예가 있지만 가장 인기 있는 두 가지 변형이 있습니다.

실제 소스 제어 자체를 시작 하기 전에 적절 한 프로젝트 수를 결정 하는 것이 좋습니다. 단일 프로젝트 내에서 여러 리포지토리 및 빌드 파이프라인에 대 한 지원이 제공 됩니다. 보드는 약간 더 복잡 하지만 단일 프로젝트 내에서 여러 팀에 작업을 쉽게 할당할 수 있습니다. 단일 Azure DevOps 프로젝트에서 수백, 수천 명의 개발자를 지원할 수 있습니다. 이렇게 하면 모든 개발자가 작업을 수행할 수 있는 단일 위치를 제공 하는 것이 가장 좋은 방법입니다. 개발자가 자신이 속한 프로젝트가 확실 하지 않을 경우 해당 응용 프로그램을 찾는 것이 혼란 스 러 울 수 있습니다.

Azure DevOps 프로젝트 내에서 마이크로 서비스에 대 한 코드를 분할 하는 것은 약간 더 어려울 수 있습니다.

![그림 10-3 단일 및 여러 리포지토리](./media/single-repository-vs-multiple.png)

**그림 10-3** -하나 및 여러 개의 리포지토리가 있습니다.

### <a name="repository-per-microservice"></a>마이크로 서비스 당 리포지토리

처음에는 마이크로 서비스에 대 한 소스 코드를 분할 하는 것이 가장 논리적인 방법 처럼 보입니다. 각 리포지토리에는 하나의 마이크로 서비스를 빌드하는 데 필요한 코드가 포함 될 수 있습니다. 이 방법의 장점은 쉽게 볼 수 있습니다.

1. 응용 프로그램 빌드 및 유지 관리에 대 한 지침은 각 리포지토리의 루트에 있는 추가 정보 파일에 추가할 수 있습니다. 리포지토리를 통해 대칭 이동 하는 경우 이러한 지침을 쉽게 찾아 개발자를 위한 스핀 시간을 줄일 수 있습니다.
2. 모든 서비스는 논리적 위치에 있으며, 서비스의 이름을 알면 쉽게 찾을 수 있습니다.
3. 빌드를 쉽게 설정 하 여 소유 하는 리포지토리가 변경 될 때만 트리거될 수 있습니다.
4. 리포지토리에 들어오는 변경 수는 프로젝트에서 작업 하는 소수의 개발자로 제한 됩니다.
5. 개발자가 읽기 및 쓰기 권한을 가진 리포지토리를 제한 하 여 보안을 설정 하는 것이 쉽습니다.
6. 다른 사용자와의 토론을 최소화 하면서 소유 팀에서 리포지토리 수준 설정을 변경할 수 있습니다.

마이크로 서비스의 주요 개념 중 하나는 서비스를 사일로 하 고 서로 분리 하는 것입니다. 도메인 기반 디자인을 사용 하 여 서비스가 트랜잭션 경계 역할을 하는 서비스의 경계를 결정 하는 경우 데이터베이스 업데이트는 여러 서비스에 걸쳐 있어서는 안 됩니다. 이 관련 데이터 컬렉션을 바인딩된 컨텍스트 라고 합니다.  이 개념은 마이크로 서비스 데이터를 나머지 서비스와는 별개의 데이터베이스로 격리 하는 것에 의해 반영 됩니다. 이를 통해 소스 코드를 통해이 아이디어를 모두 이해할 수 있습니다.

그러나이 방법은 문제가 되지 않습니다. Microsoft 시간의 gnarly 개발 문제 중 하나는 종속성을 관리 하는 것입니다. 평균 디렉터리를 구성 하는 파일 수를 고려 합니다 `node_modules` . 와 같은 항목을 새로 설치 하는 경우 `create-react-app` 수천 개의 패키지를 가져올 수 있습니다. 이러한 종속성을 관리 하는 방법에 대 한 질문은 어려운 일입니다.

종속성이 업데이트 되 면 다운스트림 패키지도이 종속성을 업데이트 해야 합니다. 불행 하 게도 개발 작업을 수행 하는 항상, `node_modules` 디렉터리는 단일 패키지의 여러 버전으로 끝나지만, 각각은 약간 다른 흐름에서 버전 관리 되는 다른 패키지에 대 한 종속성입니다. 응용 프로그램을 배포할 때 사용 해야 하는 종속성 버전은 무엇 인가요? 현재 프로덕션 중인 버전은 무엇 인가요? 현재 베타 버전 이지만 소비자가 프로덕션 환경에 사용 하는 시간에 따라 프로덕션 환경에 있을 가능성이 높습니다. 마이크로 서비스를 사용 하 여 해결 되지 않는 어려운 문제

다양 한 프로젝트에 의존 하는 라이브러리가 있습니다. 각 리포지토리의 마이크로 서비스를 하나씩 분할 하 여 내부 종속성을 Azure Artifacts 내부 리포지토리를 사용 하 여 가장 효과적으로 해결할 수 있습니다. 라이브러리에 대 한 빌드는 내부 사용을 위해 최신 버전을 Azure Artifacts로 푸시합니다. 새로 업데이트 된 패키지에 대 한 종속성을 사용 하려면 다운스트림 프로젝트를 수동으로 업데이트 해야 합니다.

서비스 간에 코드를 이동 하는 경우 또 다른 단점이 있습니다. 응용 프로그램을 마이크로 서비스로 처음 분할 하는 것이 100% 정확 하다 고 생각 하는 것은 사실 이지만 실제로는 서비스 나누기를 사용 하지 않는 것이 좋습니다. 따라서 기능 및 해당 기능을 구동 하는 코드를 서비스에서 리포지토리로 이동 해야 합니다. 한 리포지토리에서 다른 리포지토리로 달은 더 코드는 해당 기록을 잃게 됩니다. 특히 감사의 경우 코드 조각에 대 한 전체 기록을 포함 하는 것이 중요 한 경우가 많습니다.

마지막 및 가장 중요 한 단점은 변경 내용을 조정 하는 것입니다. 진정한 마이크로 서비스 응용 프로그램에서는 서비스 간에 배포 종속성이 없어야 합니다. 느슨한 결합을 포함 하는 모든 순서로 서비스 A, B 및 C를 배포할 수 있어야 합니다. 그러나 실제로 여러 리포지토리를 동시에 교차 하는 변경을 수행 하는 것이 바람직한 경우가 있습니다. 일부 예에는 보안 허점을 닫거나 모든 서비스에서 사용 하는 통신 프로토콜을 변경 하기 위해 라이브러리를 업데이트 하는 작업이 포함 됩니다.

저장소 간 변경을 수행 하려면 연속 해 서 각 리포지토리에 대 한 커밋을 수행 해야 합니다. 각 리포지토리의 각 변경 내용은 끌어오기 요청 및 별도로 검토 해야 합니다. 이는 조정 하기 어려울 수 있습니다.

많은 리포지토리를 사용 하는 대신 모든 소스 코드를 모든 것을 단일 저장소에 포함 하는 것이 좋습니다.

### <a name="single-repository"></a>단일 리포지토리

이 방법에서는 [monorepository](https://danluu.com/monorepo/)라고도 하는 모든 서비스에 대 한 모든 소스 코드가 동일한 리포지토리에 배치 됩니다. 처음에는 소스 코드를 처리 하는 것이 어려울 수 있는 것 처럼 보일 수 있습니다. 그러나 이러한 방식으로 작업 하는 데는 몇 가지 장점이 있습니다.

첫 번째 장점은 프로젝트 간의 종속성을 관리 하는 것이 더 쉽기 때문입니다. 프로젝트는 외부 아티팩트 피드를 기반으로 하는 대신 서로 직접 가져올 수 있습니다. 즉, 업데이트가 인스턴트 이며, 개발자 워크스테이션에서 컴파일 시간에 충돌 하는 버전을 찾을 수 있습니다. 실제로 일부 통합 테스트를 진행 합니다.

프로젝트 간에 코드를 이동 하는 경우 파일이 다시 작성 되는 것이 아니라 이동 된 것으로 검색 되므로 기록을 유지 하는 것이 더 쉽습니다.

또 다른 이점은 서비스 경계를 교차 하는 광범위 한 변경을 단일 커밋으로 만들 수 있다는 것입니다. 이렇게 하면 수십 개의 변경 내용을 개별적으로 검토할 수 있는 오버 헤드를 줄일 수 있습니다.

코드에 대 한 정적 분석을 수행 하 여 안전 하지 않은 프로그래밍 관행 또는 문제가 있는 Api 사용을 검색할 수 있는 많은 도구가 있습니다. 다중 리포지토리 환경의 경우 각 리포지토리를 반복 하 여 문제를 찾아야 합니다. 단일 리포지토리에서 모든 분석을 한 곳에서 실행할 수 있습니다.

단일 리포지토리 방법에도 많은 단점이 있습니다. 가장 중요 한 문제 중 하나는 단일 리포지토리가 있으면 보안 문제가 발생 한다는 것입니다. 리포지토리의 콘텐츠가 서비스 모델 당 리포지토리에서 유출 되는 경우 손실 되는 코드의 양은 최소화 됩니다. 단일 리포지토리가 있으면 회사가 소유 하 고 있는 모든 것이 손실 될 수 있습니다. 이러한 상황이 발생 하는 과거의 많은 예가 있으며 전체 게임 개발 노력을 치중. 여러 리포지토리를 통해 노출 영역을 줄일 수 있습니다 .이는 대부분의 보안 작업에서 유용한 특성입니다.

단일 리포지토리의 크기를 빠르게 관리할 수 없게 됩니다. 이렇게 하면 몇 가지 흥미로운 성능에 영향을 줍니다. Windows 팀에서 개발자의 경험을 향상 시키기 위해 원래 설계 된 [Git 용 가상 파일 시스템과](https://vfsforgit.org/)같은 특수 도구를 사용 해야 할 수도 있습니다.

단일 리포지토리를 사용 하는 인수는 구축가 소스 코드 정렬에이 메서드를 사용 하는 인수를 사용 하는 경우가 많습니다. 이러한 회사에서 접근 방식이 충분 한 경우 모든 회사에 대 한 올바른 방법입니다. 무엇 보다도 일부 회사는 Facebook 또는 Google의 규모와 같은 작업을 수행 하는 것이 중요 합니다. 이러한 규모에서 발생 하는 문제는 대부분의 개발자가 직면 하는 문제와 다릅니다. Goose에 적합 한 것은 gander에 적합 하지 않을 수 있습니다.

마지막으로, 두 솔루션을 사용 하 여 마이크로 서비스에 대 한 소스 코드를 호스트할 수 있습니다. 그러나 대부분의 경우 단일 리포지토리에서 운영 하는 관리 및 엔지니어링 오버 헤드가 meager 이점을 얻을 가치가 없습니다. 코드를 여러 리포지토리에 분할 하면 문제를 더 잘 분리 하 고 개발 팀 간에 자율성을 강화할 것을 권장 합니다.  

### <a name="standard-directory-structure"></a>표준 디렉터리 구조

단일 및 다중 저장소에 관계 없이 각 서비스에는 고유한 디렉터리가 있습니다. 개발자가 프로젝트를 신속 하 게 교차 하 게 할 수 있도록 하는 최상의 최적화 중 하나는 표준 디렉터리 구조를 유지 관리 하는 것입니다.

![그림 10-4 전자 메일 및 로그인 서비스 모두에 대 한 표준 디렉터리 구조](./media/dir-struct.png)

**그림 10-4** -표준 디렉터리 구조

새 프로젝트를 만들 때마다 올바른 구조에 배치 하는 템플릿을 사용 해야 합니다. 이 템플릿에는 이러한 유용한 항목이 기본 추가 정보 파일과로 포함 될 수도 있습니다 `azure-pipelines.yml` . 모든 마이크로 서비스 아키텍처에서 프로젝트 간의 분산이 높으면 서비스에 대해 대량 작업을 수행 하기가 더 어려워집니다.

여러 소스 코드 디렉터리를 포함 하는 전체 디렉터리에 대 한 템플릿을 제공할 수 있는 많은 도구가 있습니다. 전 세계의는 JavaScript 세계에서 널리 [사용 되 고 GitHub에는 최근에](https://yeoman.io/) 동일한 기능을 제공 하는 [리포지토리 템플릿이](https://github.blog/2019-06-06-generate-new-repositories-with-repository-templates/)출시 되었습니다.

## <a name="task-management"></a>작업 관리

모든 프로젝트에서 작업을 관리 하는 것은 어려울 수 있습니다. 앞에서 개발자의 생산성을 최적화 하기 위해 설정 하는 워크플로의 종류에 대 한 답변을 얻을 수 있는 다양 한 질문이 있습니다.

클라우드 네이티브 응용 프로그램은 기존 소프트웨어 제품 보다 작은 경향이 있거나 적어도 작은 서비스로 나뉩니다. 이러한 서비스와 관련 된 문제 또는 작업을 추적 하는 것은 다른 소프트웨어 프로젝트의 경우와 동일 하 게 유지 됩니다. 일부 작업 항목을 추적 하거나 문제를 제대로 기록 하지 않은 고객에 게 설명 하 려 합니다. 보드는 프로젝트 수준에서 구성 되지만 각 프로젝트 내에서 영역을 정의할 수 있습니다. 이를 통해 여러 구성 요소에서 문제를 나눌 수 있습니다. 전체 응용 프로그램에 대 한 모든 작업을 한 곳에 유지 하는 이점은 작업 항목을 한 팀에서 다른 팀으로 이동 하는 것이 더 쉽기 때문입니다.

Azure DevOps는 미리 구성 된 많은 인기 있는 템플릿을 제공 합니다. 가장 기본적인 구성에서는 백로그, 사용자가 작업 하는 작업 및 완료 된 작업에 대 한 정보를 알고 있어야 합니다. 이를 통해 소프트웨어를 구축 하는 과정을 파악 하는 것이 중요 합니다. 따라서 해당 작업은 우선 순위가 지정 되 고 완료 된 작업을 고객에 게 보고할 수 있습니다. 물론 소수의 소프트웨어 프로젝트는, 및 처럼 간단 하 게 프로세스에 `to do` 집중 `doing` `done` 됩니다. 사용자가 프로세스와 같은 단계를 추가 하는 데 오랜 시간이 걸리지 않습니다 `QA` `Detailed Specification` .

Agile 방법론의 중요 한 부분 중 하나는 일정 한 간격으로 자체 검사는 것입니다. 이러한 검토는 팀이 직면 하는 문제와 이러한 문제를 개선 하는 방법을 파악 하는 데 도움이 됩니다. 일반적으로이는 개발 프로세스를 통해 문제와 기능의 흐름을 변경 하는 것을 의미 합니다. 따라서 추가 단계를 통해 보드의 레이아웃을 확장 하는 것은 완벽 하 게 정상입니다.

보드의 단계는 유일한 조직 도구가 아닙니다. 보드의 구성에 따라 작업 항목의 계층이 있습니다. 보드에 표시할 수 있는 가장 세분화 된 항목은 작업입니다. 기본적으로 작업에는 제목, 설명, 우선 순위, 남은 작업량의 예상 금액 및 다른 작업 항목 또는 개발 항목 (분기, 커밋, 끌어오기 요청, 빌드 등)에 연결할 수 있는 권한이 포함 됩니다. 작업 항목을 응용 프로그램의 여러 영역으로 분류 하 고 다른 반복 (스 프린트)을 통해 쉽게 찾을 수 있습니다.

![그림 10-5 Azure DevOps의 예제 작업](./media/task-details.png)

**그림 10-5** -Azure devops의 작업

설명 필드는 필요한 표준 스타일 (굵게, 기울임꼴 밑줄 및 취소선)과 이미지 삽입 기능을 지원 합니다. 이렇게 하면 작업 또는 버그를 지정할 때 사용할 수 있는 강력한 도구입니다.

작업을 더 큰 작업 단위를 정의 하는 기능으로 롤업할 수 있습니다. 그러면 기능이 [에픽으로 롤업](/azure/devops/boards/backlogs/define-features-epics?view=azure-devops)될 수 있습니다. 이 계층 구조에서 작업을 분류 하면 큰 기능이 롤아웃 되는 방법을 보다 쉽게 이해할 수 있습니다.

![그림 10-6 기본 프로세스 템플릿에서 기본적으로 구성 된 작업 항목 형식](./media/board-issue-types.png)

**그림 10-6** -Azure devops의 작업 항목

Azure Boards 문제에 대 한 다양 한 종류의 보기가 있습니다. 아직 예약 되지 않은 항목은 백로그에 표시 됩니다. 여기에서 스 프린트에 할당 될 수 있습니다. 스 프린트는 작업의 일부를 완료 하는 데 필요한 시간 상자입니다. 이러한 작업에는 작업 뿐만 아니라 티켓의 해상도도 포함 될 수 있습니다. 완료 되 면 전체 스 프린트를 스 프린트 보드 섹션에서 관리할 수 있습니다. 이 보기는 작업이 진행 되는 방법을 보여 주고, 스 프린트에 성공 하는 경우 업데이트 예상 값을 제공 하는 굽는 차트를 포함 합니다.

![그림 10-7 스 프린트를 정의 하는 보드](./media/sprint-board.png)

**그림 10-7** -Azure devops의 보드.

지금까지 Azure DevOps의 보드에 상당한 전력이 있음을 분명히 해야 합니다. 개발자를 위해 작업 중인 항목을 쉽게 볼 수 있습니다. 프로젝트 관리자는 기존 작업에 대 한 개요 뿐만 아니라 예정 된 작업을 볼 수도 있습니다. 관리자의 경우 높아지면 및 용량에 대 한 다양 한 보고서가 있습니다. 아쉽게도 클라우드 네이티브 응용 프로그램은 작업을 추적할 필요가 없도록 하는 놀라운 작업이 없습니다. 그러나 작업을 추적 해야 하는 경우 Azure DevOps 보다 성능이 좋은 몇 가지 위치가 있습니다.

## <a name="cicd-pipelines"></a>CI/CD 파이프라인

소프트웨어 개발 수명 주기는 CI (지속적인 통합) 및 CD (지속적인 업데이트)의 출현으로 거의 변경 되지 않았습니다. 에서 변경 내용이 확인 되는 즉시 프로젝트의 소스 코드에 대해 자동화 된 테스트를 빌드하고 실행 하면 오류가 조기에 catch 됩니다. 연속 통합 빌드를 도입 하기 전에는 리포지토리에서 코드를 가져와서 테스트를 통과 하지 못했거나 빌드할 수 없다는 것이 일반적이 지 않습니다. 이로 인해 중단의 원본이 추적 되었습니다.

일반적으로 프로덕션 환경에 소프트웨어를 출시 하려면 광범위 한 설명서와 단계 목록이 필요 했습니다. 이러한 각 단계는 매우 오류가 발생 하기 쉬운 프로세스에서 수동으로 완료 해야 합니다.

![그림 10-8 검사 목록](./media/checklist.png)

**그림 10-8** -검사 목록.

연속 통합의 대체는 새로 빌드된 패키지가 환경에 배포 되는 지속적인 업데이트입니다. 수동 프로세스는 개발 속도와 일치 하도록 확장할 수 없으므로 automation이 더 중요 합니다. 검사 목록은 모든 사용자가 보다 빠르고 정확 하 게 동일한 작업을 실행할 수 있는 스크립트로 대체 됩니다.

지속적인 배달이 제공 하는 환경은 테스트 환경 이거나 많은 주요 기술 회사에서 수행 하는 것 처럼 프로덕션 환경 일 수 있습니다. 후자를 사용 하는 경우에는 변경이 사용자를 위해 프로덕션이 중단 되지 않는다는 확신을 줄 수 있는 고품질 테스트에 대 한 투자가 필요 합니다. 연속 통합에서 코드의 문제를 발견 하는 것과 동일한 방식으로 초기에 배포 프로세스의 문제를 찾아냅니다.

빌드 및 배달 프로세스 자동화의 중요성은 클라우드 네이티브 응용 프로그램에 의해 accentuated 됩니다. 배포는 더 자주 발생 하 고 더 많은 환경에서 수동으로 테두리를 배포할 수 없습니다.

### <a name="azure-builds"></a>Azure 빌드

Azure DevOps는 연속 통합 및 배포를 보다 쉽게 수행할 수 있는 일련의 도구를 제공 합니다. 이러한 도구는 Azure Pipelines 아래에 있습니다. 그 중 첫 번째는 Azure 빌드 이며, 대규모로 YAML 기반 빌드 정의를 실행 하는 데 사용 되는 도구입니다. 사용자는 자신의 빌드 컴퓨터를 가져올 수 있습니다 (빌드에 신중 설정 환경이 필요한 경우에 적합) 또는 Azure에서 호스트 되는 가상 컴퓨터의 지속적으로 새로 고쳐지는 풀에서 컴퓨터를 사용 합니다. 이러한 호스팅된 빌드 에이전트는 .NET 개발 뿐만 아니라 Java에서 Python으로 iPhone 개발에 이르기까지 광범위 한 개발 도구를 사용 하 여 미리 설치 됩니다.

DevOps에는 모든 빌드에 대해 사용자 지정할 수 있는 다양 한 기본 빌드 정의가 포함 되어 있습니다. 빌드 정의는 `azure-pipelines.yml` 소스 코드와 함께 버전을 지정할 수 있도록 이라는 파일에 정의 되 고 리포지토리에 체크 인 됩니다. 이렇게 하면 변경 내용을 해당 분기에만 체크 인할 수 있으므로 분기의 빌드 파이프라인을 훨씬 쉽게 변경할 수 있습니다. `azure-pipelines.yml`전체 프레임 워크에서 ASP.NET 웹 응용 프로그램을 빌드하는 예제는 그림 10-9에 나와 있습니다.

```yml
name: $(rev:r)

variables:
  version: 9.2.0.$(Build.BuildNumber)
  solution: Portals.sln
  artifactName: drop
  buildPlatform: any cpu
  buildConfiguration: release
  
pool:
  name: Hosted VS2017
  demands:
  - msbuild
  - visualstudio
  - vstest

steps:
- task: NuGetToolInstaller@0
  displayName: 'Use NuGet 4.4.1'
  inputs:
    versionSpec: 4.4.1

- task: NuGetCommand@2
  displayName: 'NuGet restore'
  inputs:
    restoreSolution: '$(solution)'

- task: VSBuild@1
  displayName: 'Build solution'
  inputs:
    solution: '$(solution)'
    msbuildArgs: '-p:DeployOnBuild=true -p:WebPublishMethod=Package -p:PackageAsSingleFile=true -p:SkipInvalidConfigurations=true -p:PackageLocation="$(build.artifactstagingdirectory)\\"'
    platform: '$(buildPlatform)'
    configuration: '$(buildConfiguration)'

- task: VSTest@2
  displayName: 'Test Assemblies'
  inputs:
    testAssemblyVer2: |
     **\$(buildConfiguration)\**\*test*.dll
     !**\obj\**
     !**\*testadapter.dll
    platform: '$(buildPlatform)'
    configuration: '$(buildConfiguration)'

- task: CopyFiles@2
  displayName: 'Copy UI Test Files to: $(build.artifactstagingdirectory)'
  inputs:
    SourceFolder: UITests
    TargetFolder: '$(build.artifactstagingdirectory)/uitests'

- task: PublishBuildArtifacts@1
  displayName: 'Publish Artifact'
  inputs:
    PathtoPublish: '$(build.artifactstagingdirectory)'
    ArtifactName: '$(artifactName)'
  condition: succeededOrFailed()
```

**그림 10-9** -azure-pipelines 샘플

이 빌드 정의는 적합 한 집합을 구축 하는 것 처럼 간단 하 게 빌드를 만드는 데 사용할 수 있는 여러 기본 제공 작업을 사용 합니다 (자이언트 Millennium 비 Con 보다 간단). 예를 들어 NuGet 작업은 NuGet 패키지를 복원 하는 반면 VSBuild 작업은 Visual Studio 빌드 도구를 호출 하 여 실제 컴파일을 수행 합니다. Azure DevOps에서 사용할 수 있는 수백 개의 작업은 커뮤니티에서 유지 관리 하는 수천 가지 작업입니다. 어떤 빌드 작업을 실행 하 고 있는지에 관계 없이 다른 사람이 빌드 작업을 이미 빌드 했을 수 있습니다.

빌드는 수동으로 또는 체크 인을 통해 일정에 따라 트리거하거나 다른 빌드가 완료 될 때 트리거될 수 있습니다. 대부분의 경우 모든 체크 인에 대 한 빌드를 선택 하는 것이 좋습니다. 여러 빌드를 리포지토리의 다른 부분이 나 다른 분기에 대해 실행 하도록 빌드를 필터링 할 수 있습니다. 이를 통해 끌어오기 요청에 대 한 테스트를 줄이고 매일 밤에 대해 전체 회귀 도구 모음을 실행 하 여 빠른 빌드를 실행 하는 등의 시나리오를 수행할 수 있습니다.

빌드의 최종 결과는 빌드 아티팩트 라는 파일의 컬렉션입니다. 이러한 아티팩트는 빌드 프로세스의 다음 단계에 따라 전달 되거나 Azure 아티팩트 피드에 추가 될 수 있으므로 다른 빌드에서 사용 될 수 있습니다.

### <a name="azure-devops-releases"></a>Azure DevOps 릴리스

빌드는 소프트웨어를 제공 가능한 패키지로 컴파일하는 데 주의를 기울여야 하지만 지속적인 업데이트를 완료 하려면 아티팩트를 테스트 환경에 푸시 해야 합니다. 이를 위해 Azure DevOps는 릴리스 라는 별도의 도구를 사용 합니다. 릴리스 도구는 빌드에 사용할 수 있었지만 "스테이지" 라는 개념을 소개 하는 동일한 태스크 라이브러리를 사용 합니다. 단계는 패키지가 설치 되는 격리 된 환경입니다. 예를 들어 제품은 개발, QA 및 프로덕션 환경을 사용할 수 있습니다. 코드는 자동화 된 테스트를 실행할 수 있는 개발 환경에 지속적으로 전달 됩니다. 이러한 테스트를 통과 하면 릴리스가 수동 테스트를 위한 QA 환경으로 이동 합니다. 마지막으로 코드는 모든 사람에 게 표시 되는 프로덕션에 푸시됩니다.

![그림 10-10 개발, QA 및 프로덕션 단계를 포함 하는 예제 릴리스 파이프라인](./media/release-pipeline.png)

**그림 10-10** -릴리스 파이프라인

이전 단계를 완료 하면 빌드의 각 단계를 자동으로 트리거할 수 있습니다. 그러나 대부분의 경우에는 이렇게 하지 않는 것이 좋습니다. 코드를 프로덕션으로 이동 하려면 다른 사용자의 승인이 필요할 수 있습니다. 릴리스 도구는 릴리스 파이프라인의 각 단계에서 승인자를 허용 하 여이를 지원 합니다. 규칙을 설정 하 여 특정 사용자 또는 사용자 그룹이 릴리스를 프로덕션 환경에 적용 하기 전에 로그 오프 해야 합니다. 이러한 게이트를 통해 수동 품질 검사를 수행할 수 있으며, 프로덕션으로 전환 되는 항목을 제어 하는 것과 관련 된 규정 요구 사항을 준수할 수 있습니다.

### <a name="everybody-gets-a-build-pipeline"></a>모든 사람이 빌드 파이프라인을 가져옵니다.

많은 빌드 파이프라인을 구성 하는 데는 비용이 들지 않으므로 마이크로 서비스 당 빌드 파이프라인이 하나 이상 있는 것이 유리 합니다. 이상적으로는 마이크로 서비스를 모든 환경에 독립적으로 배포할 수 있으므로 관련 없는 코드를 해제 하지 않고 자체 파이프라인을 통해 각 항목을 릴리스할 수 있습니다. 각 파이프라인에는 각 서비스에 대 한 빌드 프로세스의 변형을 허용 하는 고유한 승인 집합이 있을 수 있습니다.

### <a name="versioning-releases"></a>버전 관리 릴리스

릴리스 기능을 사용 하는 경우의 한 가지 단점은 체크 인 된 파일에 정의 될 수 없다는 것입니다 `azure-pipelines.yml` . 프로젝트 템플릿에서 릴리스 구조를 포함 하기 위해 분기 단위 릴리스 정의를 포함 하 여이 작업을 수행 하는 여러 가지 이유가 있습니다. 다행히 작업을 진행 하 여 일부 단계 지원 기능을 빌드 구성 요소로 이동 합니다. 이를 다단계 빌드 라고 하 고 [첫 번째 버전을 지금 사용할 수 있습니다](https://devblogs.microsoft.com/devops/whats-new-with-azure-pipelines/).

>[!div class="step-by-step"]
>[이전](azure-security.md)
>[다음](feature-flags.md)
