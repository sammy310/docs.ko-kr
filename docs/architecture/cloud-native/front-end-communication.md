---
title: 프런트 엔드 클라이언트 통신
description: 프런트 엔드 클라이언트가 클라우드 네이티브 시스템과 통신 하는 방법 알아보기
author: robvet
ms.date: 05/13/2020
ms.openlocfilehash: 97421e9b90b19c720b1ab0ff8dd1e5f029cba5e4
ms.sourcegitcommit: 27db07ffb26f76912feefba7b884313547410db5
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/19/2020
ms.locfileid: "83614060"
---
# <a name="front-end-client-communication"></a><span data-ttu-id="920ce-103">프런트 엔드 클라이언트 통신</span><span class="sxs-lookup"><span data-stu-id="920ce-103">Front-end client communication</span></span>

<span data-ttu-id="920ce-104">클라우드 네이티브 시스템에서 프런트 엔드 클라이언트 (모바일, 웹 및 데스크톱 응용 프로그램)는 독립적인 백 엔드 마이크로 서비스와 상호 작용 하기 위해 통신 채널이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-104">In a cloud-native system, front-end clients (mobile, web, and desktop applications) require a communication channel to interact with independent back-end microservices.</span></span>  

<span data-ttu-id="920ce-105">옵션은 무엇 인가요?</span><span class="sxs-lookup"><span data-stu-id="920ce-105">What are the options?</span></span>

<span data-ttu-id="920ce-106">간단히 하기 위해 프런트 엔드 클라이언트는 그림 4-2에 표시 된 백 엔드 마이크로 서비스와 *직접 통신할* 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-106">To keep things simple, a front-end client could *directly communicate* with the back-end microservices, shown in Figure 4-2.</span></span>

![클라이언트와 서비스 간 통신](./media/direct-client-to-service-communication.png)

<span data-ttu-id="920ce-108">**그림 4-2.**</span><span class="sxs-lookup"><span data-stu-id="920ce-108">**Figure 4-2.**</span></span> <span data-ttu-id="920ce-109">클라이언트와 서비스 간 통신</span><span class="sxs-lookup"><span data-stu-id="920ce-109">Direct client to service communication</span></span>

<span data-ttu-id="920ce-110">이 접근 방식을 사용 하는 경우 각 마이크로 서비스에는 프런트 엔드 클라이언트에서 액세스할 수 있는 공용 끝점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-110">With this approach, each microservice has a public endpoint that is accessible by front-end clients.</span></span> <span data-ttu-id="920ce-111">프로덕션 환경에서는 부하 분산 장치를 마이크로 서비스 앞에 놓고 트래픽을 비례적으로 라우팅합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-111">In a production environment, you'd place a load balancer in front of the microservices, routing traffic proportionately.</span></span>

<span data-ttu-id="920ce-112">간단 하 게 구현할 수 있는 반면, 직접 클라이언트 통신은 간단한 마이크로 서비스 응용 프로그램에만 허용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-112">While simple to implement, direct client communication would be acceptable only for simple microservice applications.</span></span> <span data-ttu-id="920ce-113">이 패턴은 프런트 엔드 클라이언트를 핵심 백 엔드 서비스에 긴밀 하 게 결합 다음을 비롯 한 다양 한 문제에 대 한 도어를 엽니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-113">This pattern tightly couples front-end clients to core back-end services, opening the door for a number of problems, including:</span></span>

- <span data-ttu-id="920ce-114">클라이언트에서 백 엔드 서비스 영향력 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-114">Client susceptibility to back-end service refactoring.</span></span>
- <span data-ttu-id="920ce-115">핵심 백 엔드 서비스가 직접 노출 되는 더 광범위 한 공격 노출 영역입니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-115">A wider attack surface as core back-end services are directly exposed.</span></span>
- <span data-ttu-id="920ce-116">각 마이크로 서비스 간 교차 자르기 문제를 복제 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-116">Duplication of cross-cutting concerns across each microservice.</span></span>
- <span data-ttu-id="920ce-117">과도 하 게 복잡 한 클라이언트 코드-클라이언트는 여러 끝점을 추적 하 고 복원 력 있는 방식으로 오류를 처리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-117">Overly complex client code - clients must keep track of multiple endpoints and handle failures in a resilient way.</span></span>

<span data-ttu-id="920ce-118">대신, 광범위 하 게 허용 되는 클라우드 디자인 패턴은 프런트 엔드 응용 프로그램과 백 엔드 서비스 간에 [API 게이트웨이 서비스](../microservices/architect-microservice-container-applications/direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md) 를 구현 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-118">Instead, a widely accepted cloud design pattern is to implement an [API Gateway Service](../microservices/architect-microservice-container-applications/direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md) between the front-end applications and back-end services.</span></span> <span data-ttu-id="920ce-119">이 패턴은 그림 4-3에 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-119">The pattern is shown in Figure 4-3.</span></span>

![API 게이트웨이 패턴](./media/api-gateway-pattern.png)

<span data-ttu-id="920ce-121">**그림 4-3.**</span><span class="sxs-lookup"><span data-stu-id="920ce-121">**Figure 4-3.**</span></span> <span data-ttu-id="920ce-122">API 게이트웨이 패턴</span><span class="sxs-lookup"><span data-stu-id="920ce-122">API gateway pattern</span></span>

<span data-ttu-id="920ce-123">위의 그림에서 API Gateway 서비스가 백 엔드 핵심 마이크로 서비스를 추상화 하는 방법을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-123">In the previous figure, note how the API Gateway service abstracts the back-end core microservices.</span></span> <span data-ttu-id="920ce-124">웹 API로 구현 되는 *역방향 프록시*역할을 하 여 들어오는 트래픽을 내부 마이크로 서비스로 라우팅합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-124">Implemented as a web API, it acts as a *reverse proxy*, routing incoming traffic to the internal microservices.</span></span>

<span data-ttu-id="920ce-125">게이트웨이는 내부 서비스 분할 및 리팩터링의 클라이언트를 분리 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-125">The gateway insulates the client from internal service partitioning and refactoring.</span></span> <span data-ttu-id="920ce-126">백 엔드 서비스를 변경 하는 경우 클라이언트를 중단 하지 않고 게이트웨이에서 해당 서비스를 수용 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-126">If you change a back-end service, you accommodate for it in the gateway without breaking the client.</span></span> <span data-ttu-id="920ce-127">또한 id, 캐싱, 복원 력, 계량, 제한과 같은 교차 절삭 문제에 대 한 첫 번째 방어선입니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-127">It's also your first line of defense for cross-cutting concerns, such as identity, caching, resiliency, metering, and throttling.</span></span> <span data-ttu-id="920ce-128">이러한 교차 잘라내기 문제는 대부분 백 엔드 핵심 서비스에서 게이트웨이로 오프 로드 되어 백 엔드 서비스를 간소화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-128">Many of these cross-cutting concerns can be off-loaded from the back-end core services to the gateway, simplifying the back-end services.</span></span>

<span data-ttu-id="920ce-129">API 게이트웨이를 간단 하 고 신속 하 게 유지 하기 위해 주의를 기울여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-129">Care must be taken to keep the API Gateway simple and fast.</span></span> <span data-ttu-id="920ce-130">일반적으로 비즈니스 논리는 게이트웨이에서 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-130">Typically, business logic is kept out of the gateway.</span></span> <span data-ttu-id="920ce-131">복잡 한 게이트웨이는 병목 상태가 되 고 궁극적으로는 모놀리식가 될 위험이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-131">A complex gateway risks becoming a bottleneck and eventually a monolith itself.</span></span> <span data-ttu-id="920ce-132">규모가 큰 시스템은 종종 클라이언트 유형 (모바일, 웹, 데스크톱) 또는 백 엔드 기능을 통해 분할 된 여러 API 게이트웨이를 노출 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-132">Larger systems often expose multiple API Gateways segmented by client type (mobile, web, desktop) or back-end functionality.</span></span> <span data-ttu-id="920ce-133">[백 엔드 For 프런트 엔드](https://docs.microsoft.com/azure/architecture/patterns/backends-for-frontends) 패턴은 여러 게이트웨이를 구현 하는 방향을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-133">The [Backend for Frontends](https://docs.microsoft.com/azure/architecture/patterns/backends-for-frontends) pattern provides direction for implementing multiple gateways.</span></span> <span data-ttu-id="920ce-134">이 패턴은 그림 4-4에 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-134">The pattern is shown in Figure 4-4.</span></span>

![API 게이트웨이 패턴](./media/backend-for-frontend-pattern.png)

<span data-ttu-id="920ce-136">**그림 4-4.**</span><span class="sxs-lookup"><span data-stu-id="920ce-136">**Figure 4-4.**</span></span> <span data-ttu-id="920ce-137">프런트 엔드 패턴의 백 엔드</span><span class="sxs-lookup"><span data-stu-id="920ce-137">Backend for frontend pattern</span></span>

<span data-ttu-id="920ce-138">위의 그림에서는 들어오는 트래픽이 클라이언트 유형 (웹, 모바일 또는 데스크톱 앱)에 따라 특정 API 게이트웨이로 전송 되는 방법을 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-138">Note in the previous figure how incoming traffic is sent to a specific API gateway - based upon client type: web, mobile, or desktop app.</span></span> <span data-ttu-id="920ce-139">이 방법은 각 장치의 기능이 폼 팩터, 성능 및 디스플레이 제한에서 크게 다를 수 있기 때문에 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-139">This approach makes sense as the capabilities of each device differ significantly across form factor, performance, and display limitations.</span></span> <span data-ttu-id="920ce-140">일반적으로 모바일 응용 프로그램은 브라우저 또는 데스크톱 응용 프로그램 보다 더 작은 기능을 노출 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-140">Typically mobile applications expose less functionality than a browser or desktop applications.</span></span> <span data-ttu-id="920ce-141">각 게이트웨이는 해당 장치의 기능 및 기능에 맞게 최적화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-141">Each gateway can be optimized to match the capabilities and functionality of the corresponding device.</span></span>

<span data-ttu-id="920ce-142">시작 하려면 고유한 API 게이트웨이 서비스를 빌드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-142">To start, you could build your own API Gateway service.</span></span> <span data-ttu-id="920ce-143">GitHub를 빠르게 검색 하면 많은 예제를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-143">A quick search of GitHub will provide many examples.</span></span> <span data-ttu-id="920ce-144">그러나 사용할 수 있는 프레임 워크와 상용 게이트웨이 제품은 여러 가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-144">However, there are several frameworks and commercial gateway products available.</span></span>

## <a name="ocelot-gateway"></a><span data-ttu-id="920ce-145">Ocelot 게이트웨이</span><span class="sxs-lookup"><span data-stu-id="920ce-145">Ocelot Gateway</span></span>

<span data-ttu-id="920ce-146">간단한 .NET 클라우드 네이티브 응용 프로그램의 경우 [Ocelot 게이트웨이](https://github.com/ThreeMammals/Ocelot)를 고려할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-146">For simple .NET cloud-native applications, you might consider the [Ocelot Gateway](https://github.com/ThreeMammals/Ocelot).</span></span> <span data-ttu-id="920ce-147">Ocelot는 시스템에 대 한 진입점을 통합 해야 하는 .NET 마이크로 서비스에 대해 생성 된 오픈 소스 API 게이트웨이입니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-147">Ocelot is an Open Source API Gateway created for .NET microservices that require a unified point of entry into their system.</span></span> <span data-ttu-id="920ce-148">간단 하 고 빠르게 확장 가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-148">It's lightweight, fast, scalable.</span></span>

<span data-ttu-id="920ce-149">모든 API 게이트웨이와 마찬가지로 기본 기능은 들어오는 HTTP 요청을 다운스트림 서비스에 전달 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-149">Like any API Gateway, its primary functionality is to forward incoming HTTP requests to downstream services.</span></span> <span data-ttu-id="920ce-150">또한 .NET Core 미들웨어 파이프라인에서 구성할 수 있는 다양 한 기능을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-150">Additionally, it supports a wide variety of capabilities that are configurable in a .NET Core middleware pipeline.</span></span> <span data-ttu-id="920ce-151">해당 기능 집합은 다음 표에 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-151">Its feature set is presented in following table.</span></span>

|<span data-ttu-id="920ce-152">Ocelot 기능</span><span class="sxs-lookup"><span data-stu-id="920ce-152">Ocelot Features</span></span>  | |
| :-------- | :-------- |
| <span data-ttu-id="920ce-153">라우팅</span><span class="sxs-lookup"><span data-stu-id="920ce-153">Routing</span></span> | <span data-ttu-id="920ce-154">인증</span><span class="sxs-lookup"><span data-stu-id="920ce-154">Authentication</span></span> |
| <span data-ttu-id="920ce-155">요청 집계</span><span class="sxs-lookup"><span data-stu-id="920ce-155">Request Aggregation</span></span> | <span data-ttu-id="920ce-156">권한 부여</span><span class="sxs-lookup"><span data-stu-id="920ce-156">Authorization</span></span> |
| <span data-ttu-id="920ce-157">서비스 검색 (Consul 및 Eureka 포함)</span><span class="sxs-lookup"><span data-stu-id="920ce-157">Service Discovery (with Consul and Eureka)</span></span> | <span data-ttu-id="920ce-158">제한</span><span class="sxs-lookup"><span data-stu-id="920ce-158">Throttling</span></span> |
| <span data-ttu-id="920ce-159">부하 분산</span><span class="sxs-lookup"><span data-stu-id="920ce-159">Load Balancing</span></span> | <span data-ttu-id="920ce-160">로깅, 추적</span><span class="sxs-lookup"><span data-stu-id="920ce-160">Logging, Tracing</span></span> |
| <span data-ttu-id="920ce-161">캐싱</span><span class="sxs-lookup"><span data-stu-id="920ce-161">Caching</span></span> | <span data-ttu-id="920ce-162">헤더/쿼리 문자열 변환</span><span class="sxs-lookup"><span data-stu-id="920ce-162">Headers/Query String Transformation</span></span> |
| <span data-ttu-id="920ce-163">상관 관계 통과</span><span class="sxs-lookup"><span data-stu-id="920ce-163">Correlation Pass-Through</span></span> | <span data-ttu-id="920ce-164">사용자 지정 미들웨어</span><span class="sxs-lookup"><span data-stu-id="920ce-164">Custom Middleware</span></span> |
| <span data-ttu-id="920ce-165">서비스 품질</span><span class="sxs-lookup"><span data-stu-id="920ce-165">Quality of Service</span></span> | <span data-ttu-id="920ce-166">다시 시도 정책</span><span class="sxs-lookup"><span data-stu-id="920ce-166">Retry Policies</span></span> |

<span data-ttu-id="920ce-167">각 Ocelot 게이트웨이는 JSON 구성 파일에서 업스트림 및 다운스트림 주소와 구성 가능한 기능을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-167">Each Ocelot gateway specifies the upstream and downstream addresses and configurable features in a JSON configuration file.</span></span> <span data-ttu-id="920ce-168">클라이언트는 HTTP 요청을 Ocelot 게이트웨이로 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-168">The client sends an HTTP request to the Ocelot gateway.</span></span> <span data-ttu-id="920ce-169">수신 되 면 Ocelot은 파이프라인을 통해 HttpRequest 개체를 전달 하 여 해당 구성에 지정 된 상태로 해당 개체를 조작 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-169">Once received, Ocelot passes the HttpRequest object through its pipeline manipulating it into the state specified by its configuration.</span></span> <span data-ttu-id="920ce-170">파이프라인의 끝에서 Ocelot는 새 HTTPResponseObject를 만들고 다운스트림 서비스에 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-170">At the end of pipeline, Ocelot creates a new HTTPResponseObject and passes it to the downstream service.</span></span> <span data-ttu-id="920ce-171">응답의 경우 Ocelot는 파이프라인을 반대로 되돌리고 응답을 클라이언트에 다시 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-171">For the response, Ocelot reverses the pipeline, sending the response back to client.</span></span>

<span data-ttu-id="920ce-172">Ocelot는 NuGet 패키지로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-172">Ocelot is available as a NuGet package.</span></span> <span data-ttu-id="920ce-173">NET Standard 2.0를 대상으로 하 여 .NET Core 2.0 + 및 .NET Framework 4.6.1 + 런타임과 호환 되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-173">It targets the NET Standard 2.0, making it compatible with both .NET Core 2.0+ and .NET Framework 4.6.1+ runtimes.</span></span> <span data-ttu-id="920ce-174">Ocelot는 HTTP를 말하는 것과 .NET Core에서 지 원하는 플랫폼 (Linux, macOS 및 Windows)에서 실행 되는 것과 통합 됩니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-174">Ocelot integrates with anything that speaks HTTP and runs on the platforms which .NET Core supports: Linux, macOS, and Windows.</span></span> <span data-ttu-id="920ce-175">Ocelot는 확장 가능 하며 Docker 컨테이너, Azure Kubernetes 서비스 또는 기타 공용 클라우드를 비롯 한 다양 한 최신 플랫폼을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-175">Ocelot is extensible and supports many modern platforms, including Docker containers, Azure Kubernetes Services, or other public clouds.</span></span>  <span data-ttu-id="920ce-176">Ocelot은 [Consul](https://www.consul.io), [GraphQL](https://graphql.org)및 Netflix [Eureka](https://github.com/Netflix/eureka)와 같은 오픈 소스 패키지와 통합 됩니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-176">Ocelot integrates with open-source packages like [Consul](https://www.consul.io), [GraphQL](https://graphql.org), and Netflix's [Eureka](https://github.com/Netflix/eureka).</span></span>

<span data-ttu-id="920ce-177">상업적 API 게이트웨이의 풍부한 기능 집합이 필요 하지 않은 간단한 클라우드 네이티브 응용 프로그램에 대해 Ocelot을 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-177">Consider Ocelot for simple cloud-native applications that don't require the rich feature-set of a commercial API gateway.</span></span>

## <a name="azure-application-gateway"></a><span data-ttu-id="920ce-178">Azure Application Gateway</span><span class="sxs-lookup"><span data-stu-id="920ce-178">Azure Application Gateway</span></span>

<span data-ttu-id="920ce-179">간단한 게이트웨이 요구 사항에 대 한 [Azure 애플리케이션 게이트웨이](https://docs.microsoft.com/azure/application-gateway/overview)를 고려할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-179">For simple gateway requirements, you may consider [Azure Application Gateway](https://docs.microsoft.com/azure/application-gateway/overview).</span></span> <span data-ttu-id="920ce-180">Azure [PaaS 서비스로](https://azure.microsoft.com/overview/what-is-paas/)사용할 수 있으며 URL 라우팅, SSL 종료 및 웹 응용 프로그램 방화벽과 같은 기본 게이트웨이 기능을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-180">Available as an Azure [PaaS service](https://azure.microsoft.com/overview/what-is-paas/), it includes basic gateway features such as URL routing, SSL termination, and a Web Application Firewall.</span></span> <span data-ttu-id="920ce-181">이 서비스는 [계층 7 부하 분산](https://www.nginx.com/resources/glossary/layer-7-load-balancing/) 기능을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-181">The service supports [Layer-7 load balancing](https://www.nginx.com/resources/glossary/layer-7-load-balancing/) capabilities.</span></span> <span data-ttu-id="920ce-182">계층 7을 사용 하면 하위 수준 TCP 네트워크 패킷 뿐만 아니라 HTTP 메시지의 실제 콘텐츠를 기반으로 요청을 라우팅할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-182">With Layer 7, you can route requests based on the actual content of an HTTP message, not just low-level TCP network packets.</span></span>

<span data-ttu-id="920ce-183">이 책 전체에서는 [Kubernetes](https://www.infoworld.com/article/3268073/what-is-kubernetes-your-next-application-platform.html)에서 클라우드 네이티브 시스템을 전도 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-183">Throughout this book, we evangelize hosting cloud-native systems in [Kubernetes](https://www.infoworld.com/article/3268073/what-is-kubernetes-your-next-application-platform.html).</span></span> <span data-ttu-id="920ce-184">컨테이너 오 케 스트레이 터 Kubernetes는 컨테이너 화 된 워크 로드의 배포, 크기 조정 및 운영 문제를 자동화 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-184">A container orchestrator, Kubernetes automates the deployment, scaling, and operational concerns of containerized workloads.</span></span> <span data-ttu-id="920ce-185">Azure 애플리케이션 게이트웨이는 [Azure Kubernetes Service](https://azure.microsoft.com/services/kubernetes-service/) 클러스터에 대 한 API 게이트웨이로 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-185">Azure Application Gateway can be configured as an API gateway for [Azure Kubernetes Service](https://azure.microsoft.com/services/kubernetes-service/) cluster.</span></span>

<span data-ttu-id="920ce-186">[Application Gateway 수신 컨트롤러](https://azure.github.io/application-gateway-kubernetes-ingress/) 를 사용 하면 Azure 애플리케이션 게이트웨이가 [Azure Kubernetes Service](https://azure.microsoft.com/services/kubernetes-service/)에서 직접 작업할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-186">The [Application Gateway Ingress Controller](https://azure.github.io/application-gateway-kubernetes-ingress/) enables Azure Application Gateway to work directly with [Azure Kubernetes Service](https://azure.microsoft.com/services/kubernetes-service/).</span></span> <span data-ttu-id="920ce-187">그림 4.5은 아키텍처를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-187">Figure 4.5 shows the architecture.</span></span>

![Application Gateway 수신 컨트롤러](./media/application-gateway-ingress-controller.png)

<span data-ttu-id="920ce-189">**그림 4-5.**</span><span class="sxs-lookup"><span data-stu-id="920ce-189">**Figure 4-5.**</span></span> <span data-ttu-id="920ce-190">Application Gateway 수신 컨트롤러</span><span class="sxs-lookup"><span data-stu-id="920ce-190">Application Gateway Ingress Controller</span></span>

<span data-ttu-id="920ce-191">Kubernetes에는 [수신](https://kubernetes.io/docs/concepts/services-networking/ingress/)이라고 하는 HTTP (수준 7) 부하 분산을 지 원하는 기본 제공 기능이 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-191">Kubernetes includes a built-in feature that supports HTTP (Level 7) load balancing, called [Ingress](https://kubernetes.io/docs/concepts/services-networking/ingress/).</span></span> <span data-ttu-id="920ce-192">수신은 AKS 내의 마이크로 서비스 인스턴스를 외부 세계에 노출 하는 방법에 대 한 규칙 집합을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-192">Ingress defines a set of rules for how microservice instances inside AKS can be exposed to the outside world.</span></span> <span data-ttu-id="920ce-193">이전 이미지에서 수신 컨트롤러는 클러스터에 대해 구성 된 수신 규칙을 해석 하 고 Azure 애플리케이션 게이트웨이를 자동으로 구성 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-193">In the previous image, the ingress controller interprets the ingress rules configured for the cluster and automatically configures the Azure Application Gateway.</span></span> <span data-ttu-id="920ce-194">이러한 규칙에 따라 Application Gateway는 AKS 내부에서 실행 되는 마이크로 서비스로 트래픽을 라우팅합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-194">Based on those rules, the Application Gateway routes traffic to microservices running inside AKS.</span></span> <span data-ttu-id="920ce-195">수신 컨트롤러는 수신 규칙에 대 한 변경 내용을 수신 대기 하 고 Azure 애플리케이션 게이트웨이의 적절 한 변경을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-195">The ingress controller listens for changes to ingress rules and makes the appropriate changes to the Azure Application Gateway.</span></span>

## <a name="azure-api-management"></a><span data-ttu-id="920ce-196">Azure API Management</span><span class="sxs-lookup"><span data-stu-id="920ce-196">Azure API Management</span></span>

<span data-ttu-id="920ce-197">중간 규모에서 대규모 클라우드 네이티브 시스템의 경우 [Azure API Management](https://azure.microsoft.com/services/api-management/)를 고려할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-197">For moderate to large-scale cloud-native systems, you may consider [Azure API Management](https://azure.microsoft.com/services/api-management/).</span></span> <span data-ttu-id="920ce-198">API 게이트웨이 요구 사항을 해결할 뿐만 아니라 모든 기능을 갖춘 개발자 및 관리 환경을 제공 하는 클라우드 기반 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-198">It's a cloud-based service that not only solves your API Gateway needs, but provides a full-featured developer and administrative experience.</span></span> <span data-ttu-id="920ce-199">API Management은 그림 4-6에 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-199">API Management is shown in Figure 4-6.</span></span>

![Azure API Management](./media/azure-api-management.png)

<span data-ttu-id="920ce-201">**그림 4-6.**</span><span class="sxs-lookup"><span data-stu-id="920ce-201">**Figure 4-6.**</span></span> <span data-ttu-id="920ce-202">Azure API Management</span><span class="sxs-lookup"><span data-stu-id="920ce-202">Azure API Management</span></span>

<span data-ttu-id="920ce-203">시작 하기 위해 구성 가능한 규칙 및 정책에 따라 백 엔드 서비스에 대 한 제어 된 액세스를 허용 하는 게이트웨이 서버를 API Management 노출 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-203">To start, API Management exposes a gateway server that allows controlled access to back-end services based upon configurable rules and policies.</span></span> <span data-ttu-id="920ce-204">이러한 서비스는 Azure cloud, 온-프레미스 데이터 센터 또는 다른 공용 클라우드에 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-204">These services can be in the Azure cloud, your on-prem data center, or other public clouds.</span></span> <span data-ttu-id="920ce-205">API 키와 JWT 토큰은 어떤 작업을 수행할 수 있는지를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-205">API keys and JWT tokens determine who can do what.</span></span> <span data-ttu-id="920ce-206">모든 트래픽은 분석 용도로 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-206">All traffic is logged for analytical purposes.</span></span>

<span data-ttu-id="920ce-207">개발자를 위한 API Management 서비스, 설명서 및이를 호출 하는 샘플 코드에 대 한 액세스를 제공 하는 개발자 포털을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-207">For developers, API Management offers a developer portal that provides access to services, documentation, and sample code for invoking them.</span></span> <span data-ttu-id="920ce-208">개발자는 Swagger/Open API를 사용 하 여 서비스 끝점을 검사 하 고 사용을 분석할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-208">Developers can use Swagger/Open API to inspect service endpoints and analyze their usage.</span></span> <span data-ttu-id="920ce-209">이 서비스는 .NET, Java, Golang 등의 주요 개발 플랫폼에서 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-209">The service works across the major development platforms: .NET, Java, Golang, and more.</span></span>

<span data-ttu-id="920ce-210">게시자 포털은 관리자가 Api를 노출 하 고 해당 동작을 관리 하는 관리 대시보드를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-210">The publisher portal exposes a management dashboard where administrators expose APIs and manage their behavior.</span></span> <span data-ttu-id="920ce-211">서비스 액세스를 부여 하 고, 서비스 상태를 모니터링 하 고, 수집 된 서비스 원격 분석을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-211">Service access can be granted, service health monitored, and service telemetry gathered.</span></span> <span data-ttu-id="920ce-212">관리자는 동작에 영향을 주기 위해 각 끝점에 *정책을* 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-212">Administrators apply *policies* to each endpoint to affect behavior.</span></span> <span data-ttu-id="920ce-213">[정책은](https://docs.microsoft.com/azure/api-management/api-management-howto-policies) 각 서비스 호출에 대해 순차적으로 실행 되는 미리 작성 된 문입니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-213">[Policies](https://docs.microsoft.com/azure/api-management/api-management-howto-policies) are pre-built statements that execute sequentially for each service call.</span></span>  <span data-ttu-id="920ce-214">정책은 인바운드 호출 또는 아웃 바운드 호출에 대해 구성 되거나 오류 발생 시 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-214">Policies are configured for an inbound call, outbound call, or invoked upon an error.</span></span> <span data-ttu-id="920ce-215">정책을 조합할 때 결정적 정렬을 사용 하도록 설정 하기 위해 다른 서비스 범위에 정책을 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-215">Policies can be applied at different service scopes as to enable deterministic ordering when combining policies.</span></span> <span data-ttu-id="920ce-216">제품은 미리 작성 된 많은 수의 [정책과](https://docs.microsoft.com/azure/api-management/api-management-policies)함께 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-216">The product ships with a large number of prebuilt [policies](https://docs.microsoft.com/azure/api-management/api-management-policies).</span></span>

<span data-ttu-id="920ce-217">정책에서 클라우드 네이티브 서비스의 동작에 영향을 주는 방법에 대 한 예는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-217">Here are examples of how policies can affect the behavior of your cloud-native services:</span></span>  

- <span data-ttu-id="920ce-218">서비스 액세스를 제한 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-218">Restrict service access.</span></span>
- <span data-ttu-id="920ce-219">인증을 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-219">Enforce authentication.</span></span>  
- <span data-ttu-id="920ce-220">필요한 경우 단일 소스에서 호출을 제한 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-220">Throttle calls from a single source, if necessary.</span></span>
- <span data-ttu-id="920ce-221">캐싱을 사용하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-221">Enable caching.</span></span>
- <span data-ttu-id="920ce-222">특정 IP 주소에서 호출을 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-222">Block calls from specific IP addresses.</span></span>
- <span data-ttu-id="920ce-223">서비스의 흐름을 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-223">Control the flow of the service.</span></span>
- <span data-ttu-id="920ce-224">요청을 SOAP에서 REST로 또는 다른 데이터 형식 (예: XML에서 JSON)으로 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-224">Convert requests from SOAP to REST or between different data formats, such as from XML to JSON.</span></span>

<span data-ttu-id="920ce-225">Azure API Management는 클라우드 또는 데이터 센터의 어디에서 나 호스트 되는 백 엔드 서비스를 노출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-225">Azure API Management can expose back-end services that are hosted anywhere – in the cloud or your data center.</span></span> <span data-ttu-id="920ce-226">클라우드 네이티브 시스템에 노출할 수 있는 레거시 서비스의 경우 REST 및 SOAP Api를 모두 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-226">For legacy services that you may expose in your cloud-native systems, it supports both REST and SOAP APIs.</span></span> <span data-ttu-id="920ce-227">API Management를 통해 다른 Azure 서비스를 노출할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-227">Even other Azure services can be exposed through API Management.</span></span> <span data-ttu-id="920ce-228">[Azure Service Bus](https://azure.microsoft.com/services/service-bus/) 또는 [Azure Logic Apps](https://azure.microsoft.com/services/logic-apps/)와 같이 Azure 지원 서비스 위에 관리 되는 API를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-228">You could place a managed API on top of an Azure backing service like [Azure Service Bus](https://azure.microsoft.com/services/service-bus/) or [Azure Logic Apps](https://azure.microsoft.com/services/logic-apps/).</span></span> <span data-ttu-id="920ce-229">Azure API Management에는 부하 분산 지원이 기본적으로 포함 되어 있지 않으며 부하 분산 서비스와 함께 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-229">Azure API Management doesn't include built-in load-balancing support and should be used in conjunction with a load-balancing service.</span></span>

<span data-ttu-id="920ce-230">Azure API Management는 다음과 같은 [네 가지 계층](https://azure.microsoft.com/pricing/details/api-management/)에서 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-230">Azure API Management is available across [four different tiers](https://azure.microsoft.com/pricing/details/api-management/):</span></span>

- <span data-ttu-id="920ce-231">개발자</span><span class="sxs-lookup"><span data-stu-id="920ce-231">Developer</span></span>
- <span data-ttu-id="920ce-232">Basic</span><span class="sxs-lookup"><span data-stu-id="920ce-232">Basic</span></span>
- <span data-ttu-id="920ce-233">Standard</span><span class="sxs-lookup"><span data-stu-id="920ce-233">Standard</span></span>
- <span data-ttu-id="920ce-234">Premium</span><span class="sxs-lookup"><span data-stu-id="920ce-234">Premium</span></span>

<span data-ttu-id="920ce-235">개발자 계층은 비프로덕션 워크 로드 및 평가를 위한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-235">The Developer tier is meant for non-production workloads and evaluation.</span></span> <span data-ttu-id="920ce-236">다른 계층은 점차적으로 더 많은 기능을 제공 하 고 Sla (서비스 수준 계약)를 더 많이 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-236">The other tiers offer progressively more power, features, and higher service level agreements (SLAs).</span></span> <span data-ttu-id="920ce-237">프리미엄 계층은 [Azure Virtual Network](https://docs.microsoft.com/azure/virtual-network/virtual-networks-overview) 및 [다중 지역 지원을](https://docs.microsoft.com/azure/api-management/api-management-howto-deploy-multi-region)제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-237">The Premium tier provides [Azure Virtual Network](https://docs.microsoft.com/azure/virtual-network/virtual-networks-overview) and [multi-region support](https://docs.microsoft.com/azure/api-management/api-management-howto-deploy-multi-region).</span></span> <span data-ttu-id="920ce-238">모든 계층에는 시간당 고정 가격이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-238">All tiers have a fixed price per hour.</span></span>

<span data-ttu-id="920ce-239">Azure 클라우드는 Azure API Management에 대 한 [서버 리스 계층](https://azure.microsoft.com/blog/announcing-azure-api-management-for-serverless-architectures/) 도 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-239">The Azure cloud also offers a [serverless tier](https://azure.microsoft.com/blog/announcing-azure-api-management-for-serverless-architectures/) for Azure API Management.</span></span> <span data-ttu-id="920ce-240">*소비 가격 책정 계층*이라고 하는 서비스는 서버 리스 컴퓨팅 모델을 중심으로 디자인 된 API Management의 변형입니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-240">Referred to as the *consumption pricing tier*, the service is a variant of API Management designed around the serverless computing model.</span></span> <span data-ttu-id="920ce-241">이전에 표시 된 "미리 할당 된" 가격 책정 계층과 달리 소비 계층은 즉각적인 프로 비전 및 작업별 요금 책정을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-241">Unlike the "pre-allocated" pricing tiers previously shown, the consumption tier provides  instant provisioning and pay-per-action pricing.</span></span>

<span data-ttu-id="920ce-242">다음 사용 사례에 대해 API 게이트웨이 기능을 사용 하도록 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-242">It enables API Gateway features for the following use cases:</span></span>

- <span data-ttu-id="920ce-243">[Azure Functions](https://docs.microsoft.com/azure/azure-functions/functions-overview) 및 [Azure Logic Apps](https://azure.microsoft.com/services/logic-apps/)와 같이 서버를 사용 하지 않는 기술을 사용 하 여 구현 된 마이크로 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-243">Microservices implemented using serverless technologies such as [Azure Functions](https://docs.microsoft.com/azure/azure-functions/functions-overview) and [Azure Logic Apps](https://azure.microsoft.com/services/logic-apps/).</span></span>
- <span data-ttu-id="920ce-244">Azure 지원 서비스 리소스 (예: 큐, 항목, Azure storage 및 기타)를 Service Bus 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-244">Azure backing service resources such as Service Bus queues and topics, Azure storage, and others.</span></span>
- <span data-ttu-id="920ce-245">트래픽이 크게 급증 하지만 대부분의 시간을 유지 하는 마이크로 서비스</span><span class="sxs-lookup"><span data-stu-id="920ce-245">Microservices where traffic has occasional large spikes but remains low the majority of the time.</span></span>

<span data-ttu-id="920ce-246">소비 계층은 동일한 기본 서비스 API Management 구성 요소를 사용 하지만 동적으로 할당 된 리소스에 따라 완전히 다른 아키텍처를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-246">The consumption tier uses the same underlying service API Management components, but employs an entirely different architecture based on dynamically allocated resources.</span></span> <span data-ttu-id="920ce-247">서버 리스 컴퓨팅 모델에 완벽 하 게 부합 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-247">It aligns perfectly with the serverless computing model:</span></span>

- <span data-ttu-id="920ce-248">관리할 인프라가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-248">No infrastructure to manage.</span></span>
- <span data-ttu-id="920ce-249">유휴 용량이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-249">No idle capacity.</span></span>
- <span data-ttu-id="920ce-250">고가용성.</span><span class="sxs-lookup"><span data-stu-id="920ce-250">High-availability.</span></span>
- <span data-ttu-id="920ce-251">자동 크기 조정.</span><span class="sxs-lookup"><span data-stu-id="920ce-251">Automatic scaling.</span></span>
- <span data-ttu-id="920ce-252">비용은 실제 사용량을 기준으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-252">Cost is based on actual usage.</span></span>
  
<span data-ttu-id="920ce-253">새 소비 계층은 서버를 사용 하지 않는 리소스를 Api로 노출 하는 클라우드 네이티브 시스템에 매우 적합 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-253">The new consumption tier is a great choice for cloud-native systems that expose serverless resources as APIs.</span></span>

## <a name="real-time-communication"></a><span data-ttu-id="920ce-254">실시간 통신</span><span class="sxs-lookup"><span data-stu-id="920ce-254">Real-time communication</span></span>

<span data-ttu-id="920ce-255">실시간 또는 푸시 통신은 HTTP를 통해 백 엔드 클라우드 네이티브 시스템과 통신 하는 프런트 엔드 응용 프로그램에 대 한 또 다른 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-255">Real-time, or push, communication is another option for front-end applications that communicate with back-end cloud-native systems over HTTP.</span></span> <span data-ttu-id="920ce-256">금융 시세표, 온라인 교육, 게임 및 작업 진행 상황 업데이트와 같은 응용 프로그램에는 즉시 백 엔드에서 실시간 응답이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-256">Applications, such as financial-tickers, online education, gaming, and job-progress updates, require instantaneous, real-time responses from the back-end.</span></span> <span data-ttu-id="920ce-257">정상적인 HTTP 통신을 사용 하는 경우 클라이언트에서 새 데이터를 사용할 수 있는 시기를 알 수 있는 방법이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-257">With normal HTTP communication, there's no way for the client to know when new data is available.</span></span> <span data-ttu-id="920ce-258">클라이언트는 지속적으로 요청을 *폴링하고* 서버로 요청을 보내야 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-258">The client must continually *poll* or send requests to the server.</span></span> <span data-ttu-id="920ce-259">*실시간* 통신을 사용 하면 서버는 언제 든 지 새 데이터를 클라이언트에 푸시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-259">With *real-time* communication, the server can push new data to the client at any time.</span></span>

<span data-ttu-id="920ce-260">실시간 시스템은 종종 높은 빈도의 데이터 흐름과 많은 동시 클라이언트 연결로 구분 됩니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-260">Real-time systems are often characterized by high-frequency data flows and large numbers of concurrent client connections.</span></span> <span data-ttu-id="920ce-261">실시간 연결을 수동으로 구현 하는 것이 복잡 해질 수 있으며, 연결 된 클라이언트에 대 한 확장성과 안정적인 메시징을 보장 하기 위해 단순한 인프라가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-261">Manually implementing real-time connectivity can quickly become complex, requiring non-trivial infrastructure to ensure scalability and reliable messaging to connected clients.</span></span> <span data-ttu-id="920ce-262">클라이언트 선호도에 대해 고정 세션으로 구성 된 부하 분산 장치 집합 및 Azure Redis Cache 인스턴스를 관리 하는 것을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-262">You could find yourself managing an  instance of Azure Redis Cache and a set of load balancers configured with sticky sessions for client affinity.</span></span>

<span data-ttu-id="920ce-263">[Azure SignalR service](https://azure.microsoft.com/services/signalr-service/) 는 클라우드 네이티브 응용 프로그램에 대 한 실시간 통신을 간소화 하는 완전히 관리 되는 azure 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-263">[Azure SignalR Service](https://azure.microsoft.com/services/signalr-service/) is a fully managed Azure service that simplifies real-time communication for your cloud-native applications.</span></span> <span data-ttu-id="920ce-264">용량 프로 비전, 크기 조정 및 영구 연결과 같은 기술 구현 정보를 추상화 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-264">Technical implementation details like capacity provisioning, scaling, and persistent connections are abstracted away.</span></span> <span data-ttu-id="920ce-265">99.9% 서비스 수준 계약을 사용 하 여 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-265">They're handled for you with a 99.9% service-level agreement.</span></span> <span data-ttu-id="920ce-266">인프라가 아닌 응용 프로그램 기능에 집중 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-266">You focus on application features, not infrastructure plumbing.</span></span>

<span data-ttu-id="920ce-267">사용 하도록 설정 되 면 클라우드 기반 HTTP 서비스는 브라우저, 모바일 및 데스크톱 응용 프로그램을 포함 하 여 콘텐츠 업데이트를 연결 된 클라이언트에 직접 푸시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-267">Once enabled, a cloud-based HTTP service can push content updates directly to connected clients, including browser, mobile and desktop applications.</span></span> <span data-ttu-id="920ce-268">클라이언트는 서버를 폴링할 필요 없이 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-268">Clients are updated without the need to poll the server.</span></span> <span data-ttu-id="920ce-269">Azure SignalR는 Websocket, 서버측 이벤트 및 긴 폴링을 포함 하 여 실시간 연결을 만드는 전송 기술을 추상화 합니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-269">Azure SignalR abstracts the transport technologies that create real-time connectivity, including WebSockets, Server-Side Events, and Long Polling.</span></span> <span data-ttu-id="920ce-270">개발자는 연결 된 클라이언트의 모든 또는 특정 하위 집합에 메시지를 보내는 데 중점을 둡니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-270">Developers focus on sending messages to all or specific subsets of connected clients.</span></span>

<span data-ttu-id="920ce-271">그림 4-7에서는 Azure SignalR를 사용 하는 클라우드 네이티브 응용 프로그램에 연결 하는 HTTP 클라이언트 집합을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-271">Figure 4-7 shows a set of HTTP Clients connecting to a Cloud-native application with Azure SignalR enabled.</span></span>

![Azure SignalR](./media/azure-signalr-service.png)

<span data-ttu-id="920ce-273">**그림 4-7.**</span><span class="sxs-lookup"><span data-stu-id="920ce-273">**Figure 4-7.**</span></span> <span data-ttu-id="920ce-274">Azure SignalR</span><span class="sxs-lookup"><span data-stu-id="920ce-274">Azure SignalR</span></span>

<span data-ttu-id="920ce-275">Azure SignalR 서비스의 또 다른 장점은 서버 리스 클라우드 네이티브 서비스를 구현 하는 것과 함께 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-275">Another advantage of Azure SignalR Service comes with implementing Serverless cloud-native services.</span></span> <span data-ttu-id="920ce-276">Azure Functions 트리거를 사용 하 여 요청 시 코드가 실행 될 것입니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-276">Perhaps your code is executed on demand with Azure Functions triggers.</span></span> <span data-ttu-id="920ce-277">코드가 클라이언트와 긴 연결을 유지 하지 않기 때문에이 시나리오는 복잡할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-277">This scenario can be tricky because your code doesn't maintain long connections with clients.</span></span> <span data-ttu-id="920ce-278">Azure SignalR Service는 이미 사용자를 위해 연결을 관리하므로 이러한 상황을 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-278">Azure SignalR Service can handle this situation since the service already manages connections for you.</span></span>

<span data-ttu-id="920ce-279">Azure SignalR Service는 Azure SQL Database, Service Bus, Redis Cache 등의 다른 Azure 서비스와 긴밀 하 게 통합 되어 클라우드 네이티브 응용 프로그램에 대 한 여러 가지 가능성을 엽니다.</span><span class="sxs-lookup"><span data-stu-id="920ce-279">Azure SignalR Service closely integrates with other Azure services, such as Azure SQL Database, Service Bus, or Redis Cache, opening up many possibilities for your cloud-native applications.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="920ce-280">[이전](communication-patterns.md)
>[다음](service-to-service-communication.md)</span><span class="sxs-lookup"><span data-stu-id="920ce-280">[Previous](communication-patterns.md)
[Next](service-to-service-communication.md)</span></span>
