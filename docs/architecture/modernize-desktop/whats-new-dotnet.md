---
title: 데스크톱용 .NET의 새로운 기능
description: .NET, .NET과 .NET Framework의 차이점, 추가 된 새로운 기능에 대해 알아봅니다.
ms.date: 12/29/2020
ms.openlocfilehash: 03dea849ad8a797b917dca953d93be6878d7ec72
ms.sourcegitcommit: 42d436ebc2a7ee02fc1848c7742bc7d80e13fc2f
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/04/2021
ms.locfileid: "102106183"
---
# <a name="whats-new-with-net-for-desktop"></a><span data-ttu-id="3b085-103">데스크톱용 .NET의 새로운 기능</span><span class="sxs-lookup"><span data-stu-id="3b085-103">What's new with .NET for Desktop?</span></span>

<span data-ttu-id="3b085-104">.NET Core 3.0부터 .NET은 Windows Forms 및 WPF를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-104">Starting with .NET Core 3.0, .NET supports Windows Forms and WPF.</span></span> <span data-ttu-id="3b085-105">따라서 이제 데스크톱 응용 프로그램에 대 한 .NET Framework와 .NET 중에서 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-105">So, now you have a choice between .NET Framework and .NET for your desktop applications.</span></span> <span data-ttu-id="3b085-106">이 장에서는 .NET 정의 및 데스크톱 응용 프로그램에 대 한 이점에 대해 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-106">This chapter will describe what is .NET and what are its benefits for desktop applications.</span></span>

## <a name="the-motivation-behind-net-core"></a><span data-ttu-id="3b085-107">.NET Core의 동기</span><span class="sxs-lookup"><span data-stu-id="3b085-107">The motivation behind .NET Core</span></span>

<span data-ttu-id="3b085-108">2002에서의 출시는 Windows Forms, ASP.NET, Entity Framework, Windows 스토어 등의 많은 기술을 지원 하기 위해 .NET Framework 년까지 발전 했습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-108">Since its launch in 2002, .NET Framework has evolved through the years to support many technologies like Windows Forms, ASP.NET, Entity Framework, Windows Store, and many others.</span></span> <span data-ttu-id="3b085-109">이러한 모든 것은 본질적으로 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-109">All of them are different in nature.</span></span> <span data-ttu-id="3b085-110">따라서 Microsoft는 .NET Framework의 일부를 수행 하 고 각 기술에 대해 다른 응용 프로그램 스택을 만들어 이러한 혁신에 참여 했습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-110">Therefore, Microsoft was approaching this evolution by taking parts of the .NET Framework and creating a different application stack for each technology.</span></span> <span data-ttu-id="3b085-111">이렇게 하면 특정 스택의 요구에 맞게 개발 기능을 사용자 지정 하 여 모든 플랫폼의 잠재력을 최대화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-111">That way, development capabilities could be customized for the needs of the specific stack, which maximized the potential of every platform.</span></span> <span data-ttu-id="3b085-112">이로 인해 서로 다른 독립적인 팀에서 유지 관리 하는 .NET Framework 버전의 조각화가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-112">That lead to fragmentation on the versions of the .NET Framework maintained by different independent teams.</span></span> <span data-ttu-id="3b085-113">이러한 모든 스택은 앱 모델, 프레임 워크 및 런타임을 포함 하는 공통 구조를 갖지만 이러한 각 파트의 구현에 차이가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-113">All these stacks have a common structure, containing an App Model, a Framework, and a Runtime, but they differ in the implementation of each of these parts.</span></span>

<span data-ttu-id="3b085-114">이러한 플랫폼 중 하나만 대상으로 지정 하는 경우이 모델을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-114">If you're targeting only one of these platforms, you can use this model.</span></span> <span data-ttu-id="3b085-115">그러나 대부분의 경우 동일한 솔루션에 둘 이상의 대상 플랫폼이 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-115">However, in many cases you might need more than one target platform in the same solution.</span></span> <span data-ttu-id="3b085-116">예를 들어 응용 프로그램에는 서버에서 실행 되는 백 엔드 논리와 모바일 클라이언트를 공유 하는 고객 관련 웹 사이트인 데스크톱 관리자 파트가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-116">For example, your application may have a desktop admin part, a customer-facing web site that shares the back-end logic running on a server, and even a mobile client.</span></span> <span data-ttu-id="3b085-117">이 경우이 .NET 감축할 모두 확장할 수 있는 통합 코딩 환경이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-117">In this case, you need a unified coding experience that can span all this .NET verticals.</span></span>

<span data-ttu-id="3b085-118">Windows 8이 출시 된 시간에는 PCLs (이식 가능한 클래스 라이브러리) 개념이 탄생 했습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-118">By the time Windows 8 was released, the concept of Portable Class Libraries (PCLs) was born.</span></span> <span data-ttu-id="3b085-119">.NET Framework 원래는 항상 단일 단위로 배포 될 것 이라는 가정을 중심으로 설계 [되었기 때문에](https://wikipedia.org/wiki/Decomposition_(computer_science)) 중요 한 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-119">Originally, the .NET Framework was designed around the assumption that it would always be deployed as a single unit, so [factoring](https://wikipedia.org/wiki/Decomposition_(computer_science)) wasn't a concern.</span></span> <span data-ttu-id="3b085-120">감축할 간에 코드를 공유 하는 문제를 해결 하기 위해 프레임 워크를 리팩터링 하는 방법에 대 한 주행 힘이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-120">To face the problem of code sharing between verticals, the driving force was on how to refactor the framework.</span></span> <span data-ttu-id="3b085-121">계약의 아이디어는 잘 구분 된 API 노출 영역을 제공 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-121">The idea of contracts is to provide a well-factored API surface area.</span></span> <span data-ttu-id="3b085-122">계약은 사용자가 컴파일하는 단순한 어셈블리 이며 적절 한 팩터링을 고려 하 여 디자인 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-122">Contracts are simply assemblies that you compile against and are designed with proper factoring in mind taking care of the dependencies between them.</span></span>

<span data-ttu-id="3b085-123">이로 인해 이전에 수행한 개별 API 수준과 달리 어셈블리 수준에서 감축할의 API 차이점을 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-123">This leads to reasoning about the API differences between verticals at the assembly level, as opposed to the individual API level that we had before.</span></span> <span data-ttu-id="3b085-124">이 측면에서는 이식 가능한 클래스 라이브러리 라고도 하는 여러 감축할를 대상으로 하는 클래스 라이브러리 환경을 사용 했습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-124">This aspect enabled a class library experience that can target multiple verticals, also known as portable class libraries.</span></span>

![.NET Framework의 릴리스 기록](./media/whats-new-dotnet-core/release-history.png)

<span data-ttu-id="3b085-126">PCL을 사용 하면 개발 환경이 API 셰이프를 기반으로 하는 감축할에서 통합 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-126">With PCL, the experience of development is unified across verticals based on the API shape.</span></span> <span data-ttu-id="3b085-127">그리고 다른 감축할에서 실행 되는 라이브러리를 만들어야 하는 경우에도 주소가 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-127">And the most pressing need to create libraries running on different verticals is also addressed.</span></span> <span data-ttu-id="3b085-128">그러나 많은 문제를 해결 해야 합니다. Api는 구현을 모든 감축할에서 앞으로 이동할 때만 이식 가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-128">But there's a great challenge: APIs are only portable when the implementation is moved forward across all the verticals.</span></span>

<span data-ttu-id="3b085-129">잘 구분 된 뷰 대신 잘 구분 된 구현을 제공 하 여 감축할 간에 구현을 통합 하는 것이 더 나은 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-129">A better approach is to unify the implementations across verticals by providing a well-factored implementation instead of a well-factored view.</span></span> <span data-ttu-id="3b085-130">특정 구성 요소를 소유 하는 각 팀에 게 일관 된 API 스택을 소급 하는 것 보다 모든 감축할에서 Api가 작동 하는 방식에 대해 생각 하는 것이 훨씬 더 간단 합니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-130">It's a lot simpler to ask each team that owns a specific component to think about how their APIs work across all verticals than trying to retroactively provide a consistent API stack on top.</span></span> <span data-ttu-id="3b085-131">여기서 .NET Standard 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-131">This is where .NET Standard comes in.</span></span> <span data-ttu-id="3b085-132">다음 섹션에서 세부 정보를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="3b085-132">See details on the next section.</span></span>

<span data-ttu-id="3b085-133">또 다른 큰 문제는 .NET Framework 배포 되는 방법에 대 한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-133">Another large challenge has to do with how the .NET Framework is deployed.</span></span> <span data-ttu-id="3b085-134">.NET Framework는 시스템 수준 프레임 워크입니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-134">The .NET Framework is a machine-wide framework.</span></span> <span data-ttu-id="3b085-135">이에 대 한 모든 변경 내용은 종속 된 모든 응용 프로그램에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-135">Any changes made to it affect all applications taking a dependency on it.</span></span> <span data-ttu-id="3b085-136">이 배포 모델에는 디스크 공간 절감 및 서비스에 대 한 중앙 액세스와 같이 많은 이점이 있지만 몇 가지 문제가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-136">Although this deployment model has many advantages, such as reducing disk space and centralized access to services, it presents some pitfalls.</span></span>

<span data-ttu-id="3b085-137">먼저 응용 프로그램 개발자가 최근 출시 된 프레임 워크에 대 한 종속성을 사용 하기 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-137">To start with, it's difficult for application developers to take a dependency on a recently released framework.</span></span> <span data-ttu-id="3b085-138">최신 OS에 대 한 종속성을 사용 하거나 응용 프로그램과 함께 .NET Framework를 설치 하는 응용 프로그램 설치 관리자를 제공 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-138">They either have to take a dependency on the latest OS or provide an application installer that installs the .NET Framework along with the application.</span></span> <span data-ttu-id="3b085-139">웹 개발자 인 경우 IT 부서에서 서버 지원 버전을 설정 하는 경우에도이 옵션을 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-139">If you are a web developer, you might not even have this option as the IT department establishes the server supported version.</span></span>

<span data-ttu-id="3b085-140">.NET Framework 설치 프로그램에 연결할 설치 관리자를 제공 하는 데 문제가 있는 경우에도 .NET Framework를 업그레이드 하면 다른 응용 프로그램이 중단 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-140">Even if you're willing to go through the trouble of providing an installer to chain in the .NET Framework setup, you may find that upgrading the .NET Framework can break other applications.</span></span>

<span data-ttu-id="3b085-141">이전 버전과 호환 되는 프레임 워크 버전을 제공 하는 데에도 불구 하 고 응용 프로그램을 중단할 수 있는 호환 되는 변경 내용이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-141">Despite the efforts to provide backward compatible versions of the framework, there are compatible changes that can break applications.</span></span> <span data-ttu-id="3b085-142">예를 들어 기존 형식에 인터페이스를 추가 하면이 형식이 serialize 되는 방식이 변경 되어 기존 코드에 따라 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-142">For example, adding an interface to an existing type can change how this type is serialized and cause breaking problems depending on the existing code.</span></span> <span data-ttu-id="3b085-143">.NET Framework가 설치 된 기본은 매우 다양 하기 때문에 이러한 주요 시나리오를 방지 하는 것이 .NET Framework 내 혁신의 속도를 저하 시킵니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-143">Because the NET Framework installed base is huge, fighting against these breaking scenarios slows down the pace of innovations inside the .NET Framework.</span></span>

<span data-ttu-id="3b085-144">이러한 모든 문제를 해결 하기 위해 Microsoft는 .net 플랫폼의 진화에 접근 하기 위해 .NET Core를 개발 했습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-144">To solve all these issues, Microsoft has developed .NET Core to approach the evolution of the .NET Platform.</span></span>

## <a name="introduction-to-net-core"></a><span data-ttu-id="3b085-145">.NET Core 소개</span><span class="sxs-lookup"><span data-stu-id="3b085-145">Introduction to .NET Core</span></span>

<span data-ttu-id="3b085-146">.NET Core는 Microsoft의 .NET 기술을 모듈식 플랫폼 간 오픈 소스 및 클라우드 준비 플랫폼으로 진화 하 고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-146">The .NET Core is the evolution of Microsoft's .NET technology into a modular, cross-platform, open source, and cloud-ready platform.</span></span> <span data-ttu-id="3b085-147">Windows, macOS 및 Linux에서 실행 되는 계획은 Android 및 IoT와 같은 ARM 기반 아키텍처 에서도 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-147">It runs on Windows, macOS, and Linux with plans to also run on ARM-based architectures like Android and IoT.</span></span>

<span data-ttu-id="3b085-148">.NET Core의 목적은 Windows, 플랫폼 간 및 모바일 응용 프로그램을 포함 하는 모든 유형의 응용 프로그램에 대해 통합 플랫폼을 제공 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-148">The purpose of .NET Core is to provide a unified platform for all types of applications, which includes Windows, cross-platform, and mobile applications.</span></span> <span data-ttu-id="3b085-149">이를 통해 모든 응용 프로그램 모델에 필요한 공유 기본 Api를 제공 하 고 응용 프로그램 모델용 API를 제외 하 여이 기능을 사용할 수 [.NET Standard](../../standard/net-standard.md) .</span><span class="sxs-lookup"><span data-stu-id="3b085-149">[.NET Standard](../../standard/net-standard.md) enables this by providing shared base APIs, which every application model needs, and excluding any application model-specific API.</span></span>

<span data-ttu-id="3b085-150">이 프레임 워크는 효율성과 성능 측면에서 많은 이점을 제공 하 여 지원 되는 다양 한 플랫폼에서 패키징 및 배포를 간소화 합니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-150">This framework gives applications many benefits in terms of efficiency and performance, simplifying the packaging and deployment in the different supported platforms.</span></span>

<span data-ttu-id="3b085-151">.NET Core의 이점은 다음과 같은 세 가지 특성에서 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-151">The benefits of .NET Core come from these three characteristics:</span></span>

- <span data-ttu-id="3b085-152">**플랫폼 간:** 다른 플랫폼 (Windows, macOS 및 Linux)에서 응용 프로그램을 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-152">**Cross-platform:** It allows application execution on different platforms (Windows, macOS, and Linux).</span></span>
- <span data-ttu-id="3b085-153">**오픈 소스:** .net Core 플랫폼은 오픈 소스 이며 GitHub, 빠르게 수행 투명 및 커뮤니티 기여를 통해 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-153">**Open source:** .NET Core platform is open source and available through GitHub, fostering transparency and community contributions.</span></span>
- <span data-ttu-id="3b085-154">**지원 됨:** Microsoft는 공식적으로 .NET Core를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-154">**Supported:** Microsoft officially supports .NET Core.</span></span>

<span data-ttu-id="3b085-155">.NET Core 3.0부터 웹 및 클라우드의 기존 지원 외에 데스크톱, IoT 및 AI 도메인도 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-155">Starting with .NET Core 3.0, besides the existing support for web and cloud, there's also support for desktop, IoT, and AI domains.</span></span> <span data-ttu-id="3b085-156">이 프레임 워크에 대 한 목표는 모든 유형의 .NET 개발 및 미래를 대상으로 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-156">The goal for this framework is impressive: to target every type of .NET development present and future.</span></span> <span data-ttu-id="3b085-157">Microsoft는 2020의 끝에 .NET 5로이 비전을 완료할 계획입니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-157">Microsoft plans to complete this vision with .NET 5 at the end of 2020.</span></span> <span data-ttu-id="3b085-158">.NET 환경의 고유성을 강화 하기 위해 "Core" 이름이 제거 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-158">The "Core" name was removed to reinforce its uniqueness in the .NET world.</span></span>

## <a name="net-5-is-net-core-vnext"></a><span data-ttu-id="3b085-159">.NET 5는 .NET Core vNext</span><span class="sxs-lookup"><span data-stu-id="3b085-159">.NET 5 is .NET Core vNext</span></span>

<span data-ttu-id="3b085-160">.Net 5는 .NET Core를 사용 하 여 다음 단계를 진행 합니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-160">.NET 5 is the next step forward with .NET Core.</span></span> <span data-ttu-id="3b085-161">.NET 5.0은 몇 가지 주요 방법으로 .NET을 개선 하는 것을 목표로 합니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-161">The .NET 5.0 aims to improve .NET in a few key ways:</span></span>

- <span data-ttu-id="3b085-162">어디서나 사용할 수 있고 일관성 있는 런타임 동작 및 개발자 환경을 제공하는 단일 .NET 런타임 및 프레임워크를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-162">Produce a single .NET runtime and framework that can be used everywhere and that has uniform runtime behaviors and developer experiences.</span></span>
- <span data-ttu-id="3b085-163">.NET Core, .NET Framework, Xamarin, Mono를 활용하여 .NET의 기능을 확장합니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-163">Expand the capabilities of .NET by taking the best of .NET Core, .NET Framework, Xamarin and Mono.</span></span>
- <span data-ttu-id="3b085-164">개발자(Microsoft 및 커뮤니티)가 함께 작업하고 확장할 수 있으며 모든 시나리오를 개선하는 단일 코드 베이스에서 해당 제품을 빌드합니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-164">Build that product out of a single code-base that developers (Microsoft and the community) can work on and expand together and that improves all scenarios.</span></span>

<span data-ttu-id="3b085-165">이 새 릴리스와 방향은 .NET 용 게임 교환기입니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-165">This new release and direction are a game-changer for .NET.</span></span> <span data-ttu-id="3b085-166">.NET 5에서 코드와 프로젝트 파일은 빌드하는 앱의 형식에 관계 없이 모양과 느낌이 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-166">With .NET 5, your code and project files will look and feel the same no matter which type of app you're building.</span></span> <span data-ttu-id="3b085-167">각 앱과 동일한 런타임, Api 및 언어 기능에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-167">You’ll have access to the same runtime, APIs, and language capabilities with each app.</span></span> <span data-ttu-id="3b085-168">여기에는 실제로 매일 매일 런타임에 커밋되는 새로운 [성능 향상](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-5/) 이 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-168">This includes new [performance improvements](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-5/) that get committed to the runtime, practically daily.</span></span> <span data-ttu-id="3b085-169">자세한 내용은 [.net 5의 새로운 기능](../../core/dotnet-five.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="3b085-169">For more details refer [What's new in .NET 5](../../core/dotnet-five.md).</span></span>

![.NET 5의 모든 도메인](./media/whats-new-dotnet-core/all-domains-of-dotnet5.png)

## <a name="net-framework-vs-net-5"></a><span data-ttu-id="3b085-171">.NET Framework와 .NET 5 비교</span><span class="sxs-lookup"><span data-stu-id="3b085-171">.NET Framework vs. .NET 5</span></span>

<span data-ttu-id="3b085-172">이제 .NET의 관련성을 이해 했으므로 .NET Framework 어떻게 되는지 궁금할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-172">So now that you understand the relevance of .NET, you might be wondering what happens with .NET Framework.</span></span> <span data-ttu-id="3b085-173">다음과 같은 질문을 할 수 있습니다. 중단 해야 하나요?</span><span class="sxs-lookup"><span data-stu-id="3b085-173">You could be asking questions like: do you have to abandon it?</span></span> <span data-ttu-id="3b085-174">사라져 갈 까 요?</span><span class="sxs-lookup"><span data-stu-id="3b085-174">Is it going to disappear?</span></span> <span data-ttu-id="3b085-175">.NET Framework에 있는 응용 프로그램을 현대화 하기 위한 선택 사항은 무엇 인가요?</span><span class="sxs-lookup"><span data-stu-id="3b085-175">What are my choices to modernize the applications I have on .NET Framework?</span></span>

<span data-ttu-id="3b085-176">2019에서는 **.NET Framework-4.8** 의 마지막 버전이 릴리스 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-176">In 2019 the last version of the **.NET Framework - 4.8** was released.</span></span> <span data-ttu-id="3b085-177">데스크톱 응용 프로그램에 대 한 세 가지 주요 개선 사항이 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-177">It included three major improvements for desktop applications:</span></span>

- <span data-ttu-id="3b085-178">**최신 브라우저 및 미디어 컨트롤**: 오늘날 .net 데스크톱 응용 프로그램은 HTML을 표시 하 고 미디어 파일을 재생 하는 데 Internet Explorer 및 Windows Media Player를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-178">**Modern browser and media controls**: Today, .NET desktop applications use Internet Explorer and Windows Media Player for showing HTML and playing media files.</span></span> <span data-ttu-id="3b085-179">이러한 레거시 컨트롤은 최신 HTML을 표시 하거나 최신 미디어 파일을 재생 하지 않으므로 최신 표준을 지 원하는 Microsoft Edge 및 최신 미디어 플레이어를 활용 하는 새 컨트롤이 추가 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-179">Since these legacy controls don't show the latest HTML or play the latest media files, new controls were added that take advantage of Microsoft Edge and newer media players that support the latest standards.</span></span>
- <span data-ttu-id="3b085-180">**Uwp 컨트롤에** 대 한 액세스: uwp에는 최신 Windows 기능 및 터치 디스플레이를 활용 하는 새로운 컨트롤이 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-180">**Access to UWP controls**: UWP contains new controls that take advantage of the latest Windows features and touch displays.</span></span> <span data-ttu-id="3b085-181">이러한 새 기능 및 컨트롤을 사용 하도록 응용 프로그램을 다시 작성할 필요가 없으므로 기존 WPF 또는 Windows Forms 코드에서 이러한 새 기능을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-181">You don't have to rewrite your applications to use these new features and controls, so you can use these new features in your existing WPF or Windows Forms code.</span></span>
- <span data-ttu-id="3b085-182">**높은 DPI의 향상 된 기능**: 디스플레이의 해상도는 4K 및 8k 해상도로 증가 합니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-182">**High-DPI improvements**: The resolution of displays is increasing to 4K and 8K resolutions.</span></span> <span data-ttu-id="3b085-183">따라서 .NET Framework 4.8에는 새로운 HDPI 기능이 추가 되어 기존 Windows Forms 및 WPF 응용 프로그램이 이러한 새 디스플레이에서 잘 보이도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-183">So, .NET Framework 4.8 adds new HDPI improvements to make sure your existing Windows Forms and WPF applications can look great on these new displays.</span></span>

<span data-ttu-id="3b085-184">.NET Framework는 수백만 대의 컴퓨터에 설치 되기 때문에 Microsoft는 계속 지원 하지만 새 기능을 추가 하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-184">Since .NET Framework is installed on millions of machines, Microsoft will continue to support it but won't add new features.</span></span>

<span data-ttu-id="3b085-185">.NET 5는 오픈 소스, 플랫폼 간 및 빠른 이동 버전의 .NET 제품군입니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-185">.NET 5 is the open-source, cross-platform, and fast-moving version of .NET family.</span></span> <span data-ttu-id="3b085-186">Side-by-side 특성으로 인해 응용 프로그램을 중단 하지 않고도 변경 내용을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-186">Because of its side-by-side nature, it can take changes without the fear of breaking any application.</span></span> <span data-ttu-id="3b085-187">즉, .NET에서는 시간이 지남에 따라 새 Api 및 언어 기능을 .NET Framework 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-187">This means that .NET will get new APIs and language features over time that .NET Framework won't.</span></span> <span data-ttu-id="3b085-188">또한 **.net** 에는 다음과 같이 .NET Framework에 불가능 한 기능이 이미 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-188">Also, **.NET** already has features that were impossible for .NET Framework, such as:</span></span>

- <span data-ttu-id="3b085-189">**Windows Forms 및 WPF를 지 원하는 .net의 side-by-side 버전**: 컴퓨터의 프레임 워크 버전을 업데이트할 때 의도 하지 않은 결과가 발생 하는 문제를 해결 합니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-189">**Side-by-side versions of .NET supporting Windows Forms and WPF**: This solves the problem of side effects when updating the machine's framework version.</span></span> <span data-ttu-id="3b085-190">여러 버전의 .NET을 동일한 컴퓨터에 설치할 수 있으며 각 응용 프로그램은 사용 해야 하는 .NET 버전을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-190">Multiple versions of .NET can be installed on the same machine and each application specifies which version of .NET it should use.</span></span> <span data-ttu-id="3b085-191">이제 .NET을 기반으로 Windows Forms 및 WPF를 개발 하 고 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-191">Even more, now you can develop and run Windows Forms and WPF on top of .NET.</span></span>
- <span data-ttu-id="3b085-192">**.Net을 응용 프로그램에 직접 포함**: 응용 프로그램 패키지의 일부로 .net을 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-192">**Embed .NET directly into an application**: You can deploy .NET as part of your application package.</span></span> <span data-ttu-id="3b085-193">이렇게 하면 컴퓨터에 특정 버전이 설치 될 때까지 기다리지 않고도 최신 버전, 기능 및 Api를 활용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-193">This enables you to take advantage of the latest version, features, and APIs without having to wait for a specific version to be installed on the machine.</span></span>
- <span data-ttu-id="3b085-194">.Net **기능 활용**: .net Core는 .net의 빠른 이동 오픈 소스 버전입니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-194">**Take advantage of .NET features**: .NET Core is the fast-moving, open-source version of .NET.</span></span> <span data-ttu-id="3b085-195">이러한 기능을 함께 사용 하면 새로운 혁신적인 Api 및 BCL (기본 클래스 라이브러리)을 빠르게 도입할 수 있으므로 호환성이 손상 될 위험이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-195">Its side-by-side nature enables fast introduction of new innovative APIs and Base Class Libraries (BCL) improvements without the risk of breaking compatibility.</span></span> <span data-ttu-id="3b085-196">이제 Windows Forms 및 WPF 응용 프로그램은 최신 .NET 기능을 활용할 수 있습니다. 여기에는 런타임 성능, 높은 DPI 지원 등을 위한 보다 기본적인 수정 사항도 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-196">Now Windows Forms and WPF applications can take advantage of the latest .NET features, which also includes more fundamental fixes for runtime performance, high-DPI support, and so on.</span></span>

<span data-ttu-id="3b085-197">Microsoft에 대 한 로드맵의 핵심 부분은 개발자가 응용 프로그램을 .NET Core로 이동 하 고 나중에 .NET 5로 이동 하는 것 이었습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-197">An essential part of the roadmap for Microsoft was to ease developers to move applications to .NET Core and in later to .NET 5.</span></span> <span data-ttu-id="3b085-198">그러나 기존 .NET Framework 응용 프로그램이 있는 경우 .NET 5로 이동 하지 늘어났습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-198">But if you have existing .NET Framework applications, you shouldn't feel pressured to move to .NET 5.</span></span> <span data-ttu-id="3b085-199">.NET Framework 완전히 지원 되며 항상 Windows의 일부가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-199">.NET Framework will be fully supported and will always be a part of Windows.</span></span> <span data-ttu-id="3b085-200">그러나 나중에 최신 언어 기능과 Api를 사용 하려는 경우 응용 프로그램을 .NET으로 이동 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-200">However, if you want to use the newest language features and APIs in the future, you'll need to move your applications to .NET.</span></span>

<span data-ttu-id="3b085-201">새로운 데스크톱 응용 프로그램의 경우 .NET 5에서 직접 시작 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-201">For your brand-new desktop applications, we recommend starting directly on .NET 5.</span></span> <span data-ttu-id="3b085-202">경량이 고 크로스 플랫폼 이며, side-by-side로 실행 되며, 성능이 높고, 컨테이너 및 마이크로 서비스 아키텍처에 완벽 하 게 부합 합니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-202">It's lightweight and cross platform, runs side by side, has high performance, and fits perfectly on containers and microservices architectures.</span></span>

![최신 .NET Framework 버전을 사용 하거나 응용 프로그램을 .NET Core로 이식 하 여 .NET Framework 응용 프로그램을 업데이트할 수 있습니다.](./media/whats-new-dotnet-core/framework-vs-core.png)

## <a name="net-standard-vs-pcl"></a><span data-ttu-id="3b085-204">.NET Standard 및 PCL</span><span class="sxs-lookup"><span data-stu-id="3b085-204">.NET Standard vs. PCL</span></span>

<span data-ttu-id="3b085-205">[.NET Standard](../../standard/net-standard.md)는 모든 .NET 구현체에서 사용할 수 있는 .NET API의 공식 규격입니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-205">[.NET Standard](../../standard/net-standard.md) is a formal specification of .NET APIs that are intended to be available on all .NET implementations.</span></span> <span data-ttu-id="3b085-206">.NET Standard는 .NET 에코시스템의 통일성을 높이기 위한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-206">The motivation behind .NET Standard is establishing greater uniformity in the .NET ecosystem.</span></span> <span data-ttu-id="3b085-207">.NET Standard은 코드를 컴파일할 일관 된 계약 집합을 구성 하는 .NET Api의 사양입니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-207">.NET Standard is a specification of .NET APIs that make up a uniform set of contracts to compile your code against.</span></span> <span data-ttu-id="3b085-208">이러한 계약은 각 .NET 버전에서 구현 되므로 다양 한 .NET 구현에서 이식성을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-208">These contracts are implemented in each .NET flavor, thus enabling portability across different .NET implementations.</span></span>

<span data-ttu-id="3b085-209">.NET Standard를 통해 다음과 같은 주요 시나리오를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-209">.NET Standard enables the following key scenarios:</span></span>

- <span data-ttu-id="3b085-210">작업에 독립적으로 구현할 모든 .NET 구현에 대해 일관 된 기본 클래스 라이브러리 Api 집합을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-210">Defines uniform set of base class libraries APIs for all .NET implementations to implement, independent of the workload.</span></span>
- <span data-ttu-id="3b085-211">개발자가 이와 같은 API를 사용하여 다양한 .NET 구현체에서 사용할 수 있는 이식 가능한 라이브러리를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-211">Enables developers to produce portable libraries that are usable across .NET implementations, using this same set of APIs.</span></span>

<span data-ttu-id="3b085-212">.NET Standard는 PCLs의 진화 이며 다음 목록은 .NET Standard와 PCLs 간의 기본적인 차이점을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-212">.NET Standard is the evolution of PCLs and the following list shows the fundamental differences between .NET Standard and PCLs:</span></span>

- <span data-ttu-id="3b085-213">.NET Standard은 Microsoft에서 선택 하는 큐 레이트 Api의 집합입니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-213">.NET Standard is a set of curated APIs, picked by Microsoft.</span></span> <span data-ttu-id="3b085-214">PCLs는 그렇지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-214">PCLs aren't.</span></span>
- <span data-ttu-id="3b085-215">PCL이 포함 하는 Api는이를 만들 때 대상으로 선택 하는 플랫폼에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-215">The APIs that a PCL contains are dependent on the platforms that you choose to target when you create it.</span></span> <span data-ttu-id="3b085-216">이렇게 하면 선택한 특정 대상에 대해서만 PCL을 공유할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-216">This makes a PCL only sharable for the specific targets that you choose.</span></span>
- <span data-ttu-id="3b085-217">.NET Standard은 플랫폼에 구애 받지 않으며 Windows, macOS, Linux 등 어디에서 나 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-217">.NET Standard is platform-agnostic, it can run anywhere, on Windows, macOS, Linux, and so on.</span></span>
- <span data-ttu-id="3b085-218">PCLs는 플랫폼 간도 실행할 수 있지만 더 제한적인 접근 방식을 가집니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-218">PCLs can also run cross-platform, but they have a more limited reach.</span></span> <span data-ttu-id="3b085-219">PCLs는 제한 된 플랫폼 집합만 대상으로 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-219">PCLs can only target a limited set of platforms.</span></span>

## <a name="new-desktop-features-in-net-core"></a><span data-ttu-id="3b085-220">.NET Core의 새로운 데스크톱 기능</span><span class="sxs-lookup"><span data-stu-id="3b085-220">New Desktop features in .NET Core</span></span>

### <a name="support-for-windows-forms-and-wpf"></a><span data-ttu-id="3b085-221">Windows Forms 및 WPF 지원</span><span class="sxs-lookup"><span data-stu-id="3b085-221">Support for Windows Forms and WPF</span></span>

<span data-ttu-id="3b085-222">Windows Forms 및 WPF는 버전 3.0부터 .NET Core의 일부입니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-222">Windows Forms and WPF are part of .NET Core since version 3.0.</span></span> <span data-ttu-id="3b085-223">두 프레젠테이션 프레임 워크는 모두 Windows 전용 이므로 플랫폼 간이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-223">Both presentation frameworks are for Windows only, so they aren't cross platform.</span></span> <span data-ttu-id="3b085-224">WPF를 DirectX에 대 한 풍부한 계층으로 생각할 수 있으며, GDI +를 통해 더 가늘게 계층으로 Windows Forms 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-224">You can think of WPF as a rich layer over DirectX and Windows Forms as a thinner layer over GDI+.</span></span> <span data-ttu-id="3b085-225">WPF 및 Windows Forms Windows에서 많은 데스크톱 응용 프로그램 기능을 제공 하 고 실행 하는 데 많은 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-225">WPF and Windows Forms do a great job of exposing and exercising much of the desktop application functionality in Windows.</span></span> <span data-ttu-id="3b085-226">따라서 Windows Forms 및 WPF는 .NET Core 및 .NET Framework에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-226">So Windows Forms and WPF are available for .NET Core and .NET Framework.</span></span> <span data-ttu-id="3b085-227">이제 .NET Core를 대상으로 하는 새 데스크톱 응용 프로그램을 시작 하 고 .NET Framework에서 .NET Core로 기존 응용 프로그램을 마이그레이션할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-227">Now you can start your new desktop applications targeting .NET Core and migrate your existing ones from .NET Framework to .NET Core.</span></span>

<span data-ttu-id="3b085-228">.NET Standard 버전 2.1의 새 버전이 .NET Core 3.0와 동시에 출시 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-228">A new version of .NET Standard, version 2.1, was released at the same time as .NET Core 3.0.</span></span> <span data-ttu-id="3b085-229">예상 대로 .NET Core 2.x 버전은 .NET Standard 2.1 이전 버전을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-229">As expected, .NET Core 3.x versions support .NET Standard 2.1 and earlier versions.</span></span>

<span data-ttu-id="3b085-230">또한 .NET Core에 대 한 Windows Forms 및 WPF 구현이 모두 오픈 소스 인지 확인 하는 것이 중요 합니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-230">Also, it's important to notice that both Windows Forms and WPF implementations for .NET Core are open source.</span></span>

### <a name="xaml-islands"></a><span data-ttu-id="3b085-231">XAML Islands</span><span class="sxs-lookup"><span data-stu-id="3b085-231">XAML Islands</span></span>

<span data-ttu-id="3b085-232">[XAML 아일랜드](/windows/apps/desktop/modernize/xaml-islands) 는 개발자가 현재 WPF, Windows Forms 및 네이티브 Win32 앱 (예: MFC)에서 새로운 Windows 10 컨트롤 (UWP XAML 컨트롤)을 사용할 수 있는 구성 요소 집합입니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-232">[XAML Islands](/windows/apps/desktop/modernize/xaml-islands) is a set of components for developers to use the new Windows 10 controls (UWP XAML controls) in their current WPF, Windows Forms, and native Win32 apps (like MFC).</span></span> <span data-ttu-id="3b085-233">Win32 앱 내에서 원하는 모든 위치에서 UWP XAML 컨트롤의 "아일랜드"를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-233">You can have your "islands" of UWP XAML controls wherever you want inside your Win32 apps.</span></span>

<span data-ttu-id="3b085-234">Windows 10, 버전 1903에서는 Hwnd (windows 처리기)를 사용 하 여 Win32 windows에서 UWP XAML 콘텐츠를 호스팅할 수 있도록 하는 Api 집합을 도입 하기 때문에 이러한 XAML 아일랜드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-234">These XAML Islands are possible because Windows 10, version 1903 introduces a set of APIs that allows hosting UWP XAML content in Win32 windows using windows handlers (HWnds).</span></span> <span data-ttu-id="3b085-235">Windows 10 1903 이상에서 실행 되는 앱만 XAML 아일랜드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-235">Notice that only apps running on Windows 10 1903 and above can use XAML Islands.</span></span>

<span data-ttu-id="3b085-236">Windows Forms 및 WPF 개발자를 위한 XAML 아일랜드를 보다 쉽게 만들 수 있도록 Windows 커뮤니티 도구 키트는 여러 NuGet 패키지에 일련의 .NET 래퍼를 도입 합니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-236">To make it easier to create XAML Islands for Windows Forms and WPF developers, the Windows Community Toolkit introduces a set of .NET wrappers in several NuGet packages.</span></span> <span data-ttu-id="3b085-237">이러한 래퍼는 래핑된 컨트롤과 호스팅 컨트롤입니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-237">Those wrappers are the wrapped and hosting controls:</span></span>

- <span data-ttu-id="3b085-238">[웹 보기](/windows/communitytoolkit/controls/wpf-winforms/webview), [webviewcompatible](/windows/communitytoolkit/controls/wpf-winforms/webviewcompatible), [InkCanvas](/windows/communitytoolkit/controls/wpf-winforms/inkcanvas), [MEDIAPLAYERELEMENT](/windows/communitytoolkit/controls/wpf-winforms/mediaplayerelement)및 [없습니다](/windows/communitytoolkit/controls/wpf-winforms/mapcontrol) 래핑된 컨트롤은 일부 uwp XAML 컨트롤을 WINDOWS FORMS 또는 WPF 컨트롤로 래핑하고 해당 개발자에 대 한 uwp 개념을 숨깁니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-238">The [WebView](/windows/communitytoolkit/controls/wpf-winforms/webview), [WebViewCompatible](/windows/communitytoolkit/controls/wpf-winforms/webviewcompatible), [InkCanvas](/windows/communitytoolkit/controls/wpf-winforms/inkcanvas), [MediaPlayerElement](/windows/communitytoolkit/controls/wpf-winforms/mediaplayerelement), and [MapControl](/windows/communitytoolkit/controls/wpf-winforms/mapcontrol) wrapped controls wrap some UWP XAML controls into Windows Forms or WPF controls, hiding UWP concepts for those developers.</span></span>
- <span data-ttu-id="3b085-239">Windows Forms 및 WPF를 위한 [Windowsxamlhost](/windows/communitytoolkit/controls/wpf-winforms/windowsxamlhost) 컨트롤은 래핑된 UWP xaml 컨트롤이 아닌 다른 사용자 지정 컨트롤을 사용할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-239">The [WindowsXamlHost](/windows/communitytoolkit/controls/wpf-winforms/windowsxamlhost) control for Windows Forms and WPF allows others not-wrapped UWP XAML controls and custom controls can be loaded into a XAML Island.</span></span>

### <a name="access-to-all-windows-10-apis"></a><span data-ttu-id="3b085-240">모든 Windows 10 Api에 대 한 액세스</span><span class="sxs-lookup"><span data-stu-id="3b085-240">Access to all Windows 10 APIs</span></span>

<span data-ttu-id="3b085-241">Windows 10에는 개발자가 작업할 수 있는 많은 API가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-241">Windows 10 has a great amount of API available for developers to work with.</span></span> <span data-ttu-id="3b085-242">이러한 Api는 인증, Bluetooth, 약속 및 연락처와 같은 다양 한 기능에 대 한 액세스를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-242">These APIs give access to a wide variety of functionality like Authentication, Bluetooth, Appointments, and Contacts.</span></span> <span data-ttu-id="3b085-243">이제 이러한 Api는 .NET Core를 통해 노출 되 고 windows 개발자에 게 Windows 10에 있는 기능을 활용 하 여 강력한 데스크톱 앱을 만들 수 있는 기회를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-243">Now these APIs are exposed through .NET Core and give Windows developers the chance to create powerful desktops apps leveraging the capabilities present on Windows 10.</span></span>

### <a name="side-by-side-support-and-self-contained-exes"></a><span data-ttu-id="3b085-244">Side-by-side 지원 및 자체 포함 Exe</span><span class="sxs-lookup"><span data-stu-id="3b085-244">Side-by-side support and self-contained EXEs</span></span>

<span data-ttu-id="3b085-245">.NET Core 배포 모델은 Windows 데스크톱 개발자가 .NET Core를 통해 경험할 수 있는 가장 큰 이점 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-245">The .NET Core deployment model is one of the biggest benefits that Windows desktop developers will experience with .NET Core.</span></span> <span data-ttu-id="3b085-246">.NET Core를 전역적으로 설치 하는 기능은 .NET Framework의 중앙 설치 및 서비스의 많은 이점을 제공 하지만 내부 업데이트는 필요 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-246">The ability to globally install .NET Core provides much of the same central installation and servicing benefits of .NET Framework, while not requiring in-place updates.</span></span>

<span data-ttu-id="3b085-247">새 .NET Core 버전이 릴리스되면 다른 응용 프로그램에 영향을 주지 않으면 서 필요에 따라 컴퓨터의 각 앱을 업데이트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-247">When a new .NET Core version is released, you can update each app on a machine as needed without any concern of affecting other applications.</span></span> <span data-ttu-id="3b085-248">새 .NET Core 버전은 자체 디렉터리에 설치 되며 서로 "나란히" 존재 합니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-248">New .NET Core versions are installed in their own directories and exist "side-by-side" with each other.</span></span>

<span data-ttu-id="3b085-249">격리를 사용 하 여 배포 해야 하는 경우 응용 프로그램을 사용 하 여 .NET Core를 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-249">If you need to deploy with isolation, you can deploy .NET Core with your application.</span></span> <span data-ttu-id="3b085-250">.NET Core는 .NET Core 런타임을 사용 하 여 앱을 단일 실행 파일로 묶습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-250">.NET Core will bundle your app with the .NET Core runtime as in a single executable.</span></span>

<span data-ttu-id="3b085-251">이러한 배포 옵션은 오랜 시간 동안 개발자가 요청 했지만 .NET Framework를 사용 하는 것은 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-251">These deployment options were requested by developers for quite a long time but were difficult to achieve using .NET Framework.</span></span> <span data-ttu-id="3b085-252">.NET Core에서 사용 되는 모듈식 아키텍처는 이러한 유연한 배포 옵션을 가능 하 게 합니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-252">The modular architecture used by .NET Core makes these flexible deployment options possible.</span></span>

### <a name="performance"></a><span data-ttu-id="3b085-253">성능</span><span class="sxs-lookup"><span data-stu-id="3b085-253">Performance</span></span>

<span data-ttu-id="3b085-254">웹 및 클라우드 워크 로드를 대상으로 하기 때문에 .NET Core는 해당 DNA에 연결 된 성능을 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-254">Since its start, targeting the web and cloud workloads, .NET Core has had performance plugged into its DNA.</span></span> <span data-ttu-id="3b085-255">서버 쪽 코드는 현재 업계 최고의 성능 웹 플랫폼으로 고성능 시나리오와 .NET Core 점수를 충족 하기에 충분 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-255">Server-side code must be performant enough to fulfill high-concurrency scenarios and .NET Core scores today as the best performance web platform in the market.</span></span>

<span data-ttu-id="3b085-256">.NET Core를 사용 하 여 차세대 데스크톱 응용 프로그램을 빌드하는 경우 이러한 성능 향상을 활용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-256">You can take advantage of these performance improvements when you use .NET Core to build your next generation of desktop applications.</span></span>

## <a name="benefits-of-open-source"></a><span data-ttu-id="3b085-257">오픈 소스 이점</span><span class="sxs-lookup"><span data-stu-id="3b085-257">Benefits of open source</span></span>

<span data-ttu-id="3b085-258">오픈 소스를 대상으로 하는 .NET Core에 대 한 몇 가지 단어만 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-258">Just a few words about .NET Core being open source.</span></span> <span data-ttu-id="3b085-259">플랫폼 간 stack 빌드는 각 대상 플랫폼에서 특수 팀의 상호 작용이 필요한 복잡 한 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-259">Building a cross-platform stack is something complex that needs the interaction of specialized teams on each of the targeted platforms.</span></span> <span data-ttu-id="3b085-260">이러한 활동은 Microsoft 내부 및 외부에서 많은 공동 작업을 필요로 합니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-260">This effort needs much collaboration from inside and outside of Microsoft.</span></span> <span data-ttu-id="3b085-261">오픈 소스를 만들어 공개 공동 작업을 진행 하면 궁극적으로 민첩 한 개발 스타일을 제공 하 여 방대한 개발자 커뮤니티에서 문제를 발견 한 후 품질 막대를 발생 시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-261">By making it open source and thus open to public collaboration, you get the ultimate agile development style in place, raising the quality bar since issues are detected by a huge and active community of developers.</span></span>

<span data-ttu-id="3b085-262">이는 앞에서 언급 한 로드맵의 속도를 지속적으로 높일 수 있는 .NET Core의 주요 성공 요소입니다. 모든 개발자가 응용 프로그램을 빌드하는 데 필요한 단일 .NET 플랫폼으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b085-262">This is a key success factor of .NET Core that will continue to speed up the roadmap previously mentioned: To be the single .NET platform that any developer will ever need to build any application.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="3b085-263">[이전](why-modern-applications.md)
>[다음](migrate-modern-applications.md)</span><span class="sxs-lookup"><span data-stu-id="3b085-263">[Previous](why-modern-applications.md)
[Next](migrate-modern-applications.md)</span></span>
