---
title: ASP.NET Core로 마이그레이션하는 경우의 배포 시나리오
description: ASP.NET에서 ASP.NET Core로 이식할 때 사용할 수 있는 배포에 대 한 다양 한 접근 방식에 대 한 개요는 side-by-side 마이그레이션과 단계별 마이그레이션을 허용 합니다.
author: ardalis
ms.date: 11/13/2020
ms.openlocfilehash: 589acd8c66baacc3aef5833dfaa24e2dcc5c1ee5
ms.sourcegitcommit: 42d436ebc2a7ee02fc1848c7742bc7d80e13fc2f
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/04/2021
ms.locfileid: "102401772"
---
# <a name="deployment-scenarios-when-migrating-to-aspnet-core"></a><span data-ttu-id="d2e88-103">ASP.NET Core로 마이그레이션하는 경우의 배포 시나리오</span><span class="sxs-lookup"><span data-stu-id="d2e88-103">Deployment scenarios when migrating to ASP.NET Core</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="d2e88-104">기존 ASP.NET MVC 및 Web API apps는 IIS 및 Windows에서 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-104">Existing ASP.NET MVC and Web API apps run on IIS and Windows.</span></span> <span data-ttu-id="d2e88-105">ASP.NET Core로 이식 하는 경우에는 규모가 많은 앱에서 단계별 또는 side-by-side 방법이 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-105">Large apps may require a phased or side-by-side approach when porting to ASP.NET Core.</span></span> <span data-ttu-id="d2e88-106">이전 장에서는 많은 .NET Framework 앱을 단계별로 ASP.NET Core 단계로 마이그레이션하기 위한 다양 한 전략을 배웠습니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-106">In previous chapters, you learned a number of strategies for migrating large .NET Framework apps to ASP.NET Core in phases.</span></span> <span data-ttu-id="d2e88-107">이 장에서는 원래 앱의 일부를 마이그레이션하는 동안 프로덕션에서 원래 앱을 유지 해야 하는 경우 다양 한 배포 시나리오를 구현할 수 있는 방법을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-107">In this chapter, you will see how different deployment scenarios can be achieved when there is a need to maintain the original app in production while migrating portions of it.</span></span>

## <a name="split-a-large-web-app"></a><span data-ttu-id="d2e88-108">대량 웹 앱 분할</span><span class="sxs-lookup"><span data-stu-id="d2e88-108">Split a large web app</span></span>

<span data-ttu-id="d2e88-109">현재 단일 웹 사이트의 IIS에서 호스팅되는 대량 웹 앱의 일반적인 시나리오를 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-109">Consider the common scenario of a large web app that currently is hosted on IIS in a single web site.</span></span> <span data-ttu-id="d2e88-110">규모가 많은 앱 내에서 기능은 다른 경로 및/또는 디렉터리로 분할 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-110">Within the large app, functionality is segmented into different routes and/or directories.</span></span> <span data-ttu-id="d2e88-111">앱은 MVC 뷰와 API 끝점의 조합입니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-111">The app is a mix of MVC views and API endpoints.</span></span> <span data-ttu-id="d2e88-112">MVC 경로에는 기능에 따라 다양 한 경로가 포함 되며, 표준 경로 템플릿을 사용 하 여 앱의 루트에서 시작 합니다 `/{controller}/{action}/{id?}` .</span><span class="sxs-lookup"><span data-stu-id="d2e88-112">The MVC routes include many different paths based on functionality and all start from the root of the app using the standard `/{controller}/{action}/{id?}` route template.</span></span> <span data-ttu-id="d2e88-113">API 끝점은 비슷한 패턴을 따르기는 하지만 모두 루트 아래에 있습니다 `/api` .</span><span class="sxs-lookup"><span data-stu-id="d2e88-113">The API endpoints follow a similar pattern, but are all under an `/api` root.</span></span>

<span data-ttu-id="d2e88-114">응용 프로그램 포팅 작업을 분할 하 여 MVC 기능이 나 API 기능을 먼저 ASP.NET Core로 마이그레이션해야 하는 경우 원본 사이트가 다른 위치에서 실행 중인 새 ASP.NET Core 앱과 원활 하 게 작동 하는 방법</span><span class="sxs-lookup"><span data-stu-id="d2e88-114">Assuming the task of porting the app is split such that either the MVC functionality or the API functionality is migrated to ASP.NET Core first, how would the original site continue to function seamlessly with the new ASP.NET Core app running somewhere else?</span></span> <span data-ttu-id="d2e88-115">시스템 사용자는 변경 해야 하는 경우를 제외 하 고는 마이그레이션 이전에 수행한 것과 동일한 Url을 계속 표시 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-115">Users of the system should continue to see the same URLs they did prior to the migration, unless it's absolutely necessary to change them.</span></span>

<span data-ttu-id="d2e88-116">다행히 IIS는 기능이 풍부한 웹 서버 이며 일정 시간 동안 발생 한 두 가지 기능은 [URL 재작성 모듈 및 응용 프로그램 요청 라우팅](/iis/extensions/url-rewrite-module/reverse-proxy-with-url-rewrite-v2-and-application-request-routing)입니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-116">Fortunately, IIS is a very feature-rich web server, and two features it has had for some time are its [URL Rewrite module and Application Request Routing](/iis/extensions/url-rewrite-module/reverse-proxy-with-url-rewrite-v2-and-application-request-routing).</span></span> <span data-ttu-id="d2e88-117">IIS는 이러한 기능을 사용 하 여 클라이언트 요청을 적절 한 백 엔드 웹 앱으로 라우팅하는 [역방향 프록시](/iis/extensions/url-rewrite-module/reverse-proxy-with-url-rewrite-v2-and-application-request-routing)역할을 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-117">Using these features, IIS can act as a [reverse proxy](/iis/extensions/url-rewrite-module/reverse-proxy-with-url-rewrite-v2-and-application-request-routing), routing client requests to the appropriate back-end web app.</span></span> <span data-ttu-id="d2e88-118">IIS를 역방향 프록시로 구성 하려면 응용 프로그램 요청 라우팅 기능에서 **프록시 사용** 확인란을 선택 하 고 다음과 같이 URL 재작성 규칙을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-118">To configure IIS as a reverse proxy, check the **Enable proxy** checkbox in the Application Request Routing feature, then add a URL Rewrite rule like this one:</span></span>

```xml
<rule name="NetCoreProxy">
  <match url="(.*)> />
  <action type="Rewrite" url="http://servername/{R:1}" />
</rule>
```

<span data-ttu-id="d2e88-119">역방향 프록시를 통해 IIS는 특정 패턴과 일치 하는 트래픽을 라우팅할 수 있으며,이는 다른 서버에서 잠재적으로 앱을 완전히 분리 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-119">As a reverse proxy, IIS can route traffic matching certain patterns to entirely separate apps, potentially on different servers.</span></span>

<span data-ttu-id="d2e88-120">IIS는 URL 재작성 모듈 (호스트 헤더와 함께 사용)만 사용 하 여 여러 웹 사이트를 쉽게 지원할 수 있으며, 각각 다른 버전의 .NET을 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-120">Using just the URL Rewrite module (perhaps combined with host headers), IIS can easily support multiple web sites, each potentially running different versions of .NET.</span></span> <span data-ttu-id="d2e88-121">규모가 많은 웹 앱은 개별 사이트의 컬렉션으로 배포 될 수 있습니다. 각 사이트는 서로 다른 IP 주소 및/또는 호스트 헤더에 응답 하거나 특정 URL 경로 (URL 재작성이 필요 하지 않음)에 응답 하는 하나 이상의 하위 응용 프로그램을 단일 웹 사이트로 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-121">A large web app might be deployed as a collection of individual sites, each responding to different IP addresses and/or host headers, or as a single web site with one or more sub-applications in it responding to certain URL paths (which doesn't even require URL Rewrite).</span></span>

> [!IMPORTANT]
> <span data-ttu-id="d2e88-122">하위 도메인은 일반적으로 상위 두 수준 이전의 도메인 부분을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-122">Subdomains typically refer to the portion of a domain preceding the top two levels.</span></span> <span data-ttu-id="d2e88-123">예를 들어 도메인에서는 도메인의 하위 도메인입니다 `api.contoso.com` `api` `contoso.com` (자체는 `contoso` 도메인 이름과 `.com` 최상위 도메인 또는 TLD로 구성 됨).</span><span class="sxs-lookup"><span data-stu-id="d2e88-123">For example, in the domain `api.contoso.com`, `api` is a subdomain of the `contoso.com` domain (which itself is composed of the `contoso` domain name and the `.com` top-level domain or TLD).</span></span> <span data-ttu-id="d2e88-124">URL 경로는로 시작 하는 도메인 이름 다음에 나오는 URL의 일부를 나타냅니다 `/` .</span><span class="sxs-lookup"><span data-stu-id="d2e88-124">URL paths refer to portion of the URL that follows the domain name, starting with a `/`.</span></span> <span data-ttu-id="d2e88-125">URL `https://contoso.com/api` 의 경로는입니다 `/api` .</span><span class="sxs-lookup"><span data-stu-id="d2e88-125">The URL `https://contoso.com/api` has a path of `/api`.</span></span>

<span data-ttu-id="d2e88-126">동일한 도메인 이나 다른 하위 도메인 (및 도메인)을 사용 하 여 단일 앱을 호스트 하는 것과 같은 장단점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-126">There are pros and cons to using the same or different subdomains (and domains) to host a single app.</span></span> <span data-ttu-id="d2e88-127">[CORS](/aspnet/core/security/cors) 와 같은 메커니즘을 사용 하는 쿠키 및 앱 내 통신의 기능에는 배포 앱에서 제대로 작동 하기 위해 더 많은 구성이 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-127">Features like cookies and intra-app communication using mechanisms like [CORS](/aspnet/core/security/cors) may require more configuration to work properly in distributed apps.</span></span> <span data-ttu-id="d2e88-128">그러나 다른 하위 도메인을 사용 하는 앱은 더 쉽게 DNS를 사용 하 여 요청을 완전히 다른 네트워크 대상으로 라우팅할 수 있으므로 IIS를 역방향 프록시로 사용 하지 않고도 여러 다른 서버 (가상 또는 기타)에 쉽게 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-128">However, apps that use different subdomains can more easily use DNS to route requests to entirely different network destinations, and so can more easily be deployed to many different servers (virtual or otherwise) without the need for IIS to act as a reverse proxy.</span></span>

<span data-ttu-id="d2e88-129">위에서 설명한 예제에서는 API 끝점이 ASP.NET Core로 이식할 앱의 첫 번째 부분으로 지정 되어 있다고 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-129">In the example described above, assume the API endpoints are designated as the first part of the app to be ported to ASP.NET Core.</span></span> <span data-ttu-id="d2e88-130">이 경우 새 ASP.NET Core 앱은 기존 ASP.NET MVC 웹 *사이트* 내에서 별도의 웹 *응용 프로그램* 으로 만들고 IIS에서 호스팅됩니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-130">In this case, a new ASP.NET Core app is created and hosted in IIS as a separate web *application* within the existing ASP.NET MVC web *site*.</span></span> <span data-ttu-id="d2e88-131">이 파일은 원래 웹 사이트의 자식으로 추가 되 고 명명 된 *api* 이므로 기본 경로는 더 이상로 시작 하지 않아야 합니다 `api/` .</span><span class="sxs-lookup"><span data-stu-id="d2e88-131">Since it will be added as a child of the original web site and will be named *api*, its default route should no longer begin with `api/`.</span></span> <span data-ttu-id="d2e88-132">이를 유지 하면 양식의 Url이 일치 하 게 `/api/api/endpoint` 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-132">Keeping this would result in it matching URLs of the form `/api/api/endpoint`.</span></span>

<span data-ttu-id="d2e88-133">그림 5-1에서는 ASP.NET Core 2.1 *api* 앱이 IIS 관리자에서 기존 *DotNetMvcApp* 사이트의 일부로 표시 되는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-133">Figure 5-1 shows how the ASP.NET Core 2.1 *api* app appears in IIS Manager as a part of the existing *DotNetMvcApp* site.</span></span>

![.NET Framework 사이트 내에서 api 앱을 보여 주는 IIS 관리자](./media/Figure5-1.png)

<span data-ttu-id="d2e88-135">**그림 5-1**.</span><span class="sxs-lookup"><span data-stu-id="d2e88-135">**Figure 5-1**.</span></span> <span data-ttu-id="d2e88-136">IIS의 .NET Core 앱을 사용 하 여 사이트를 .NET Framework 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-136">.NET Framework Site with .NET Core app in IIS.</span></span>

<span data-ttu-id="d2e88-137">*DotNetMvcApp* 사이트는 .NET Framework 4.7.2에서 실행 되는 MVC 5 앱으로 호스팅됩니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-137">The *DotNetMvcApp* site is hosted as an MVC 5 app running on .NET Framework 4.7.2.</span></span> <span data-ttu-id="d2e88-138">통합 모드에서 구성 된 자체 IIS 응용 프로그램 풀과 .NET CLR 버전 4.0.30319을 실행 하 고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-138">It has its own IIS app pool configured in integrated mode and running .NET CLR version 4.0.30319.</span></span> <span data-ttu-id="d2e88-139">*Api* 앱은 .NET Framework 4.6.1 ()에서 실행 되는 ASP.NET Core 앱입니다 `net461` .</span><span class="sxs-lookup"><span data-stu-id="d2e88-139">The *api* app is an ASP.NET Core app running on .NET Framework 4.6.1 (`net461`).</span></span> <span data-ttu-id="d2e88-140">새 IIS 앱으로 *DotNetMvcApp* 에 추가 되 고 자체 응용 프로그램 풀을 사용 하도록 구성 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-140">It was added to the *DotNetMvcApp* as a new IIS app and configured to use its own Application Pool.</span></span> <span data-ttu-id="d2e88-141">응용 프로그램 풀이 통합 모드에서 실행 되 고 있지만, [ASP.NET Core 모듈](/aspnet/core/host-and-deploy/aspnet-core-module?preserve-view=true&view=aspnetcore-2.1)을 사용 하 여 실행 되기 때문에 **관리 코드가 없는** .net CLR 버전으로 구성 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-141">Its Application Pool is also running in integrated mode but is configured with a .NET CLR version of **No Managed Code** since it will be executed using the [ASP.NET Core Module](/aspnet/core/host-and-deploy/aspnet-core-module?preserve-view=true&view=aspnetcore-2.1).</span></span> <span data-ttu-id="d2e88-142">ASP.NET Core 앱의 버전은 예제 일 뿐입니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-142">The version of the ASP.NET Core app is just an example.</span></span> <span data-ttu-id="d2e88-143">또한 .NET Core 3.1 또는 .NET 5.0에서 실행 되도록 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-143">It could also be configured to run on .NET Core 3.1 or .NET 5.0.</span></span> <span data-ttu-id="d2e88-144">그러나이 시점에서는 더 이상 .NET Framework 라이브러리를 대상으로 지정할 수 없습니다 ( [올바른 .Net Core 버전 선택](choose-net-core-version.md)참조).</span><span class="sxs-lookup"><span data-stu-id="d2e88-144">Though at that point, it would no longer be able to target .NET Framework libraries (see [Choose the Right .NET Core Version](choose-net-core-version.md))</span></span>

<span data-ttu-id="d2e88-145">이러한 방식으로 구성 된 ASP.NET Core 앱의 Api를 적절히 라우팅하도록 하려면 기본 경로 템플릿을에서로 변경 해야 합니다 `[Route("[api/controller]")]` `[Route("[controller]")]` .</span><span class="sxs-lookup"><span data-stu-id="d2e88-145">Configured in this manner, the only change that must be made in order for the ASP.NET Core app's APIs to be routed properly is to change its default route template from `[Route("[api/controller]")]` to `[Route("[controller]")]`.</span></span>

<span data-ttu-id="d2e88-146">또는 ASP.NET Core 앱은 IIS의 다른 최상위 웹 사이트 일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-146">Alternately the ASP.NET Core app can be another top-level web site in IIS.</span></span> <span data-ttu-id="d2e88-147">이 경우 경로가로 시작 하는 경우 다른 앱으로 리디렉션하는 재작성 규칙 ( [URL 재작성](https://www.iis.net/downloads/microsoft/url-rewrite)포함)을 사용 하도록 원래 사이트를 구성할 수 있습니다 `/api` .</span><span class="sxs-lookup"><span data-stu-id="d2e88-147">In this case, you can configure the original site to use a rewrite rule (with [URL Rewrite](https://www.iis.net/downloads/microsoft/url-rewrite)) that will redirect to the other app if the path starts with `/api`.</span></span> <span data-ttu-id="d2e88-148">ASP.NET Core 앱은 주 앱과 충돌 하지 않지만 루트 기반 경로를 사용 하 여 요청에 응답할 수 있도록 해당 경로에 대해 다른 호스트 헤더를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-148">The ASP.NET Core app can use a different host header for its route so that it doesn't conflict with the main app but can still respond to requests using root-based routes.</span></span>

<span data-ttu-id="d2e88-149">예를 들어, 그림 5-1에 사용 된 것과 동일한 ASP.NET Core 앱을 IIS 웹 사이트로 구성 된 다른 폴더에 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-149">As an example, the same ASP.NET Core app used in Figure 5-1 can be deployed to another folder configured as an IIS web site.</span></span> <span data-ttu-id="d2e88-150">사이트는 **관리 코드 없이** 이전 처럼 구성 된 응용 프로그램 풀을 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-150">The site should use an app pool configured just as before, with **No Managed Code**.</span></span> <span data-ttu-id="d2e88-151">서버에서 고유한 호스트 이름에 응답 하도록 바인딩을 구성 합니다 (예:) `api.contoso.com` .</span><span class="sxs-lookup"><span data-stu-id="d2e88-151">Configure its bindings to respond to a unique host name on the server, such as `api.contoso.com`.</span></span> <span data-ttu-id="d2e88-152">URL 다시 쓰기를 구성 하 여 요청을 다시 작성 하려면 `/api` IIS 서버 (또는 개별 사이트) 수준에서 새 인바운드 규칙을 추가 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-152">To configure URL Rewrite to rewrite requests matching `/api` just add a new inbound rule at the IIS server (or individual site) level.</span></span> <span data-ttu-id="d2e88-153">패턴을 일치 `^/api(.*)` 시키고의 동작 유형과의 `Rewrite` 재작성 URL을 지정 `api.contoso.com/{R:1}` 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-153">Match the pattern `^/api(.*)` and specify an Action type of `Rewrite` and a Rewrite URL of `api.contoso.com/{R:1}`.</span></span> <span data-ttu-id="d2e88-154">`(.*)`일치 패턴 및 재작성 URL에서를 사용 하면 `{R:1}` 나머지 경로가 새 URL에 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-154">The combination of using `(.*)` in the matching pattern and `{R:1}` in the rewrite URL will ensure the rest of the path gets used with the new URL.</span></span> <span data-ttu-id="d2e88-155">이를 위해 동일한 IIS 서버의 개별 사이트는 별도의 .NET 버전을 실행할 수 있지만 하나의 웹 앱으로 인터넷에 표시 되도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-155">With this in place, separate sites on the same IIS server can coexist running separate versions of .NET, but they can be made to appear to the Internet as one web app.</span></span> <span data-ttu-id="d2e88-156">그림 5-2에서는 별도의 웹 사이트를 사용 하 여 IIS에서 구성 된 재작성 규칙을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-156">Figure 5-2 shows the rewrite rule as configured in IIS with the separate web site.</span></span>

![개별 웹 사이트에 하위 폴더 요청을 라우팅하는 URL 다시 쓰기 규칙을 보여 주는 IIS 관리자](./media/Figure5-2.png)

<span data-ttu-id="d2e88-158">**그림 5-2**.</span><span class="sxs-lookup"><span data-stu-id="d2e88-158">**Figure 5-2**.</span></span> <span data-ttu-id="d2e88-159">하위 폴더 요청을 다른 웹 사이트에 다시 작성 하는 규칙을 다시 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-159">Rewrite rule to rewrite subfolder requests to another web site.</span></span>

<span data-ttu-id="d2e88-160">앱에서 IIS 내의 서로 다른 사이트나 앱 간에 Single Sign-On 필요한 경우이 시나리오를 지 원하는 방법에 대 한 자세한 지침은 [ASP.NET apps 간에 인증 쿠키를 공유 하는 방법](/aspnet/core/host-and-deploy/iis/) 에 대 한 설명서를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="d2e88-160">If your app requires single sign-on between different sites or apps within IIS, refer to the documentation on [how to share authentication cookies among ASP.NET apps](/aspnet/core/host-and-deploy/iis/) for detailed instructions on supporting this scenario.</span></span>

## <a name="summary"></a><span data-ttu-id="d2e88-161">요약</span><span class="sxs-lookup"><span data-stu-id="d2e88-161">Summary</span></span>

<span data-ttu-id="d2e88-162">.NET Framework에서 ASP.NET Core로 대량 앱을 이식 하는 일반적인 방법은 앱의 개별 부분을 선택 하 여 하나씩 마이그레이션하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-162">A common approach to porting large apps from .NET Framework to ASP.NET Core is to choose individual portions of the app to migrate one by one.</span></span> <span data-ttu-id="d2e88-163">앱의 각 부분이 이식 될 때 전체 앱은 원래 구성에서 실행 되는 일부와 일부 버전의 .NET Core에서 실행 되는 다른 파트와 함께 실행 중이 고 사용 가능한 상태로 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-163">As each piece of the app is ported, the entire app remains running and usable, with some parts of it running in its original configuration and other parts running on some version of .NET Core.</span></span> <span data-ttu-id="d2e88-164">이 방법에 따라 큰 앱 마이그레이션은 증분 방식으로 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-164">By following this approach, a large app migration can be performed incrementally.</span></span> <span data-ttu-id="d2e88-165">이러한 접근 방식을 통해 보다 신속한 피드백을 제공 하 고 테스트와 관련 된 전체 노출 영역을 줄여 위험을 제한 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-165">This approach results in limiting risk by providing more rapid feedback and reducing total surface area involved in testing.</span></span> <span data-ttu-id="d2e88-166">또한 성능 향상과 같은 .NET Core의 이점에 대 한 보다 신속한 실현을 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-166">It also allows for more rapid realization of benefits of .NET Core, such as performance increases.</span></span> <span data-ttu-id="d2e88-167">ASP.NET Core 앱은 더 이상 IIS에서 호스팅될 필요가 없지만 IIS는 동일한 IIS 인스턴스에서 .NET Framework 및 ASP.NET Core 앱을 모두 포함 하거나 다른 서버에서 호스트 되는 다양 한 호스팅 시나리오를 지원 하도록 구성할 수 있는 매우 유연 하 고 강력한 웹 서버를 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2e88-167">Although ASP.NET Core apps are no longer required to be hosted on IIS, IIS remains a very flexible and powerful web server that can be configured to support a variety of hosting scenarios involving both .NET Framework and ASP.NET Core apps on the same IIS instance or even hosted on different servers.</span></span>

## <a name="references"></a><span data-ttu-id="d2e88-168">참조</span><span class="sxs-lookup"><span data-stu-id="d2e88-168">References</span></span>

- [<span data-ttu-id="d2e88-169">IIS가 있는 Windows에서 ASP.NET Core 호스팅</span><span class="sxs-lookup"><span data-stu-id="d2e88-169">Host ASP.NET Core on Windows with IIS</span></span>](/aspnet/core/host-and-deploy/iis/)
- [<span data-ttu-id="d2e88-170">URL 재작성 모듈 및 응용 프로그램 요청 라우팅</span><span class="sxs-lookup"><span data-stu-id="d2e88-170">URL Rewrite module and Application Request Routing</span></span>](/iis/extensions/url-rewrite-module/reverse-proxy-with-url-rewrite-v2-and-application-request-routing)
- [<span data-ttu-id="d2e88-171">URL 재작성</span><span class="sxs-lookup"><span data-stu-id="d2e88-171">URL Rewrite</span></span>](https://www.iis.net/downloads/microsoft/url-rewrite)
- [<span data-ttu-id="d2e88-172">ASP.NET Core 모듈</span><span class="sxs-lookup"><span data-stu-id="d2e88-172">ASP.NET Core Module</span></span>](/aspnet/core/host-and-deploy/aspnet-core-module?preserve-view=true&view=aspnetcore-2.1)
- [<span data-ttu-id="d2e88-173">ASP.NET apps 간에 인증 쿠키 공유</span><span class="sxs-lookup"><span data-stu-id="d2e88-173">Share authentication cookies among ASP.NET apps</span></span>](/aspnet/core/host-and-deploy/iis/)
- [<span data-ttu-id="d2e88-174">이 섹션에서 사용 되는 샘플</span><span class="sxs-lookup"><span data-stu-id="d2e88-174">Samples used in this section</span></span>](https://github.com/ardalis/MigrateDotNetWithIIS)

>[!div class="step-by-step"]
><span data-ttu-id="d2e88-175">[이전](more-migration-scenarios.md)
>[다음](summary.md)</span><span class="sxs-lookup"><span data-stu-id="d2e88-175">[Previous](more-migration-scenarios.md)
[Next](summary.md)</span></span>
