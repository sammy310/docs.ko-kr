---
title: Dispose 메서드 구현
description: 이 문서에서는 .NET에서 코드에 사용되는 비관리형 리소스를 해제하는 Dispose 메서드를 구현하는 방법을 알아봅니다.
ms.date: 05/27/2020
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Dispose method
- garbage collection, Dispose method
ms.assetid: eb4e1af0-3b48-4fbc-ad4e-fc2f64138bf9
ms.openlocfilehash: c8b4b9a79577776bc049ef77e222d63374178708
ms.sourcegitcommit: b16c00371ea06398859ecd157defc81301c9070f
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 06/05/2020
ms.locfileid: "84447175"
---
# <a name="implement-a-dispose-method"></a><span data-ttu-id="4e603-103">Dispose 메서드 구현</span><span class="sxs-lookup"><span data-stu-id="4e603-103">Implement a Dispose method</span></span>

<span data-ttu-id="4e603-104"><xref:System.IDisposable.Dispose%2A> 메서드 구현은 주로 코드에서 사용하는 관리되지 않는 리소스를 해제하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-104">Implementing the <xref:System.IDisposable.Dispose%2A> method is primarily for releasing unmanaged resources used by your code.</span></span> <span data-ttu-id="4e603-105"><xref:System.IDisposable> 구현인 인스턴스 멤버를 사용하는 경우에는 <xref:System.IDisposable.Dispose%2A> 호출을 계단식 배열하는 것이 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-105">When working with instance members that are <xref:System.IDisposable> implementations, it's common to cascade <xref:System.IDisposable.Dispose%2A> calls.</span></span> <span data-ttu-id="4e603-106"><xref:System.IDisposable.Dispose%2A> 구현에는 이전에 수행한 작업을 실행 취소하는 것과 같은 추가적인 이유가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-106">There are additional reasons for implementing <xref:System.IDisposable.Dispose%2A>, such as undoing something that was previously done.</span></span> <span data-ttu-id="4e603-107">예를 들어 할당된 메모리를 해제하고, 추가된 컬렉션에서 항목을 제거하고, 획득한 잠금의 해제 신호를 보내는 등의 작업이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-107">For example, freeing memory that was allocated, removing an item from a collection that was added, signaling the release of a lock that was acquired, and so on.</span></span>

<span data-ttu-id="4e603-108">[.NET 가비지 수집기](index.md)는 관리되지 않는 메모리를 할당하거나 해제하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-108">The [.NET garbage collector](index.md) does not allocate or release unmanaged memory.</span></span> <span data-ttu-id="4e603-109">Dispose 패턴이라고도 하는 개체 삭제 패턴에서는 개체의 수명에 순서를 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-109">The pattern for disposing an object, referred to as the dispose pattern, imposes order on the lifetime of an object.</span></span> <span data-ttu-id="4e603-110">Dispose 패턴은 <xref:System.IDisposable> 인터페이스를 구현하는 개체에 사용되며, 파일 및 파이프 핸들, 레지스트리 핸들, 대기 핸들 또는 관리되지 않는 메모리 블록에 대한 포인터와 상호 작용하는 경우 일반적으로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-110">The dispose pattern is used for objects that implement the <xref:System.IDisposable> interface, and is common when interacting with file and pipe handles, registry handles, wait handles, or pointers to blocks of unmanaged memory.</span></span> <span data-ttu-id="4e603-111">이는 가비지 수집기가 관리되지 않는 개체를 회수할 수 없기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-111">This is because the garbage collector is unable to reclaim unmanaged objects.</span></span>

<span data-ttu-id="4e603-112">리소스가 항상 적절하게 정리되게 하려면 <xref:System.IDisposable.Dispose%2A> 메서드가 멱등원(idempotent)이어야 합니다(예외를 throw하지 않고 여러 번 호출할 수 있음).</span><span class="sxs-lookup"><span data-stu-id="4e603-112">To help ensure that resources are always cleaned up appropriately, a <xref:System.IDisposable.Dispose%2A> method should be idempotent, such that it is callable multiple times without throwing an exception.</span></span> <span data-ttu-id="4e603-113">또한 <xref:System.IDisposable.Dispose%2A>의 후속 호출은 아무 작업도 수행하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-113">Furthermore, subsequent invocations of <xref:System.IDisposable.Dispose%2A> should do nothing.</span></span>

<span data-ttu-id="4e603-114"><xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> 메서드에 대해 제공된 코드 예에서는 개체 또는 개체의 멤버에 대한 관리되지 않는 참조가 여전히 사용 중인 동안 가비지 수집으로 인해 종료자가 실행되게 할 수 있는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-114">The code example provided for the <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> method shows how garbage collection can cause a finalizer to run, while an unmanaged reference to the object or its members is still in use.</span></span> <span data-ttu-id="4e603-115"><xref:System.GC.KeepAlive%2A?displayProperty=nameWithType>를 활용하여 현재 루틴의 시작부터 이 메서드가 호출되는 시점까지 개체를 가비지 수집에 부적절하도록 만드는 것이 좋을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-115">It may make sense to utilize <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> to make the object ineligible for garbage collection from the start of the current routine to the point where this method is called.</span></span>

## <a name="safe-handles"></a><span data-ttu-id="4e603-116">SafeHandle</span><span class="sxs-lookup"><span data-stu-id="4e603-116">Safe handles</span></span>

<span data-ttu-id="4e603-117">개체 종료자에 대한 코드를 작성하는 작업은 올바르게 수행되지 않을 경우 문제를 일으킬 수 있는 복잡한 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-117">Writing code for an object's finalizer is a complex task that can cause problems if not done correctly.</span></span> <span data-ttu-id="4e603-118">따라서 종료자를 구현하는 대신 <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> 개체를 생성하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-118">Therefore, we recommend that you construct <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> objects instead of implementing a finalizer.</span></span>

<span data-ttu-id="4e603-119"><xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>은 관리되지 않는 리소스를 식별하는 <xref:System.IntPtr?displayProperty=nameWithType>을 래핑하는 관리되는 추상 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-119">A <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> is an abstract managed type that wraps an <xref:System.IntPtr?displayProperty=nameWithType> that identifies an unmanaged resource.</span></span> <span data-ttu-id="4e603-120">Windows에서는 핸들을 식별하며, Unix에서는 파일 설명자를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-120">On Windows it might identify a handle while on Unix, a file descriptor.</span></span> <span data-ttu-id="4e603-121">이 리소스는 `SafeHandle`이 삭제되거나 `SafeHandle`에 대한 모든 참조가 삭제되고 `SafeHandle` 인스턴스가 종료될 때 한 번만 해제되도록 하는 데 필요한 모든 논리를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-121">It provides all of the logic necessary to ensure that this resource is released once and only once, when the `SafeHandle` is disposed of or when all references to the `SafeHandle` have been dropped and the `SafeHandle` instance is finalized.</span></span>

<span data-ttu-id="4e603-122"><xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>은 추상 기본 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-122">The <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> is an abstract base class.</span></span> <span data-ttu-id="4e603-123">파생 클래스는 다양한 종류의 핸들에 대해 특정 인스턴스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-123">Derived classes provide specific instances for different kinds of handle.</span></span> <span data-ttu-id="4e603-124">이러한 파생 클래스는 잘못된 것으로 간주되는 <xref:System.IntPtr?displayProperty=nameWithType> 값과 실제로 핸들을 해제하는 방법의 유효성을 검사합니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-124">These derived classes validate what values for the <xref:System.IntPtr?displayProperty=nameWithType> are considered invalid and how to actually free the handle.</span></span> <span data-ttu-id="4e603-125">예를 들어 <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>은 `SafeHandle`에서 파생되어 열려 있는 파일 핸들/설명자를 식별하는 `IntPtrs`을 래핑하고 <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> 메서드를 재정의하여 닫습니다(Unix의 `close` 함수 또는 Windows의 `CloseHandle` 함수를 통해).</span><span class="sxs-lookup"><span data-stu-id="4e603-125">For example, <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> derives from `SafeHandle` to wrap `IntPtrs` that identify open file handles/descriptors, and overrides its <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> method to close it (via the `close` function on Unix or `CloseHandle` function on Windows).</span></span> <span data-ttu-id="4e603-126">관리되지 않는 리소스를 만드는 대부분의 .NET 라이브러리 API는 원시 포인터를 다시 전달하는 대신 `SafeHandle`에서 이를 래핑하고 필요에 따라 해당 `SafeHandle`을 사용자에게 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-126">Most APIs in .NET libraries that create an unmanaged resource will wrap it in a `SafeHandle` and return that `SafeHandle` to you as needed, rather than handing back the raw pointer.</span></span> <span data-ttu-id="4e603-127">관리되지 않는 구성 요소와 상호 작용하고 관리되지 않는 리소스에 대한 `IntPtr`을 가져오는 경우 고유한 `SafeHandle` 형식을 만들어 래핑할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-127">In situations where you interact with an unmanaged component and get an `IntPtr` for an unmanaged resource, you can create your own `SafeHandle` type to wrap it.</span></span> <span data-ttu-id="4e603-128">따라서 비 `SafeHandle` 형식이 종료자를 구현해야 하는 경우는 거의 없습니다. 대부분의 삭제 가능한 패턴 구현에서는 다른 관리되는 리소스(이 중 일부는 `SafeHandle`이 될 수 있음)를 래핑하는 것으로 끝납니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-128">As a result, few non-`SafeHandle` types need to implement finalizers; most disposable pattern implementations only end up wrapping other managed resources, some of which may be `SafeHandle`s.</span></span>

<span data-ttu-id="4e603-129"><xref:Microsoft.Win32.SafeHandles> 네임스페이스에서 다음과 같은 파생된 클래스가 SafeHandle을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-129">The following derived classes in the <xref:Microsoft.Win32.SafeHandles> namespace provide safe handles:</span></span>

- <span data-ttu-id="4e603-130">파일, 메모리 매핑된 파일 및 파이프에 대한 <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> 및 <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> 클래스</span><span class="sxs-lookup"><span data-stu-id="4e603-130">The <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle>, and <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> class, for files, memory mapped files, and pipes.</span></span>
- <span data-ttu-id="4e603-131">메모리 뷰에 대한 <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> 클래스</span><span class="sxs-lookup"><span data-stu-id="4e603-131">The <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> class, for memory views.</span></span>
- <span data-ttu-id="4e603-132">암호화 구문에 대한 <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle> 및 <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> 클래스</span><span class="sxs-lookup"><span data-stu-id="4e603-132">The <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> classes, for cryptography constructs.</span></span>
- <span data-ttu-id="4e603-133">레지스트리 키에 대한 <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> 클래스</span><span class="sxs-lookup"><span data-stu-id="4e603-133">The <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> class, for registry keys.</span></span>
- <span data-ttu-id="4e603-134">대기 핸들에 대한 <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> 클래스</span><span class="sxs-lookup"><span data-stu-id="4e603-134">The <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> class, for wait handles.</span></span>

## <a name="dispose-and-disposebool"></a><span data-ttu-id="4e603-135">Dispose() 및 Dispose(bool)</span><span class="sxs-lookup"><span data-stu-id="4e603-135">Dispose() and Dispose(bool)</span></span>

<span data-ttu-id="4e603-136"><xref:System.IDisposable> 인터페이스에서는 매개 변수가 없는 단일 메서드인 <xref:System.IDisposable.Dispose%2A>를 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-136">The <xref:System.IDisposable> interface requires the implementation of a single parameterless method, <xref:System.IDisposable.Dispose%2A>.</span></span> <span data-ttu-id="4e603-137">또한 모든 봉인되지 않은 클래스에는 추가 `Dispose(bool)` 오버로드 메서드가 구현되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-137">Also, any non-sealed class should have an additional `Dispose(bool)` overload method to be implemented:</span></span>

- <span data-ttu-id="4e603-138">매개 변수가 없는 `public` 비가상(Visual Basic의 경우 `NonInheritable`) <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> 구현</span><span class="sxs-lookup"><span data-stu-id="4e603-138">A `public` non-virtual (`NonInheritable` in Visual Basic) <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation that has no parameters.</span></span>

- <span data-ttu-id="4e603-139">서명이 다음과 같은 `protected virtual`(Visual Basic의 경우 `Overridable`) `Dispose` 메서드</span><span class="sxs-lookup"><span data-stu-id="4e603-139">A `protected virtual` (`Overridable` in Visual Basic) `Dispose` method whose signature is:</span></span>

  [!code-csharp[Conceptual.Disposable#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#8)]
  [!code-vb[Conceptual.Disposable#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#8)]

  > [!IMPORTANT]
  > <span data-ttu-id="4e603-140">`disposing` 매개 변수가 종료자에서 호출되는 경우 `false`이고 <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> 메서드에서 호출되는 경우 `true`여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-140">The `disposing` parameter should be `false` when called from a finalizer, and `true` when called from the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="4e603-141">즉, 결정적으로 호출되는 경우에는 `true`이고, 비결정적으로 호출되는 경우에는 `false`입니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-141">In other words, it is `true` when deterministically called and `false` when non-deterministically called.</span></span>

### <a name="the-dispose-method"></a><span data-ttu-id="4e603-142">Dispose() 메서드</span><span class="sxs-lookup"><span data-stu-id="4e603-142">The Dispose() method</span></span>

<span data-ttu-id="4e603-143">`public`, 비가상(Visual Basic의 경우 `NonInheritable`), 매개 변수 없는 `Dispose` 메서드는 형식의 소비자에 의해 호출되므로, 관리되지 않는 리소스를 해제하고, 일반 정리를 수행하고, 종료자(있는 경우)를 실행할 필요가 없음을 나타내기 위한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-143">Because the `public`, non-virtual (`NonInheritable` in Visual Basic), parameterless `Dispose` method is called by a consumer of the type, its purpose is to free unmanaged resources, perform general cleanup, and to indicate that the finalizer, if one is present, doesn't have to run.</span></span> <span data-ttu-id="4e603-144">관리되는 개체와 관련된 실제 메모리를 해제하는 것은 항상 [가비지 수집기](index.md)의 영역입니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-144">Freeing the actual memory associated with a managed object is always the domain of the [garbage collector](index.md).</span></span> <span data-ttu-id="4e603-145">이로 인해 다음과 같은 표준 구현이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-145">Because of this, it has a standard implementation:</span></span>

[!code-csharp[Conceptual.Disposable#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#7)]
[!code-vb[Conceptual.Disposable#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#7)]

<span data-ttu-id="4e603-146">`Dispose` 메서드가 모든 개체를 정리하므로, 가비지 수집기가 더 이상 개체의 <xref:System.Object.Finalize%2A?displayProperty=nameWithType> 재정의를 호출할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-146">The `Dispose` method performs all object cleanup, so the garbage collector no longer needs to call the objects' <xref:System.Object.Finalize%2A?displayProperty=nameWithType> override.</span></span> <span data-ttu-id="4e603-147">따라서 <xref:System.GC.SuppressFinalize%2A> 메서드를 호출하면 가비지 수집기가 종료자를 실행하지 않도록 방지됩니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-147">Therefore, the call to the <xref:System.GC.SuppressFinalize%2A> method prevents the garbage collector from running the finalizer.</span></span> <span data-ttu-id="4e603-148">형식에 종료자가 없는 경우 <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>에 대한 호출이 영향을 미치지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-148">If the type has no finalizer, the call to <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> has no effect.</span></span> <span data-ttu-id="4e603-149">실제 정리는 `Dispose(bool)` 메서드 오버로드에 의해 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-149">Note that the actual cleanup is performed by the `Dispose(bool)` method overload.</span></span>

### <a name="the-disposebool-method-overload"></a><span data-ttu-id="4e603-150">Dispose(bool) 메서드 오버로드</span><span class="sxs-lookup"><span data-stu-id="4e603-150">The Dispose(bool) method overload</span></span>

<span data-ttu-id="4e603-151">오버로드에서 `disposing` 매개 변수는 메서드 호출이 <xref:System.IDisposable.Dispose%2A> 메서드(값이 `true`)에서 수행되는지 또는 종료자(값이 `false`)에서 수행되는지를 나타내는 <xref:System.Boolean>입니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-151">In the overload, the `disposing` parameter is a <xref:System.Boolean> that indicates whether the method call comes from a <xref:System.IDisposable.Dispose%2A> method (its value is `true`) or from a finalizer (its value is `false`).</span></span>

<span data-ttu-id="4e603-152">메서드 본문은 다음과 같은 두 가지 코드 블록으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-152">The body of the method consists of two blocks of code:</span></span>

- <span data-ttu-id="4e603-153">관리되지 않는 리소스를 해제하는 블록.</span><span class="sxs-lookup"><span data-stu-id="4e603-153">A block that frees unmanaged resources.</span></span> <span data-ttu-id="4e603-154">이 블록은 `disposing` 매개 변수의 값에 관계없이 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-154">This block executes regardless of the value of the `disposing` parameter.</span></span>
- <span data-ttu-id="4e603-155">관리되는 리소스를 해제하는 조건부 블록.</span><span class="sxs-lookup"><span data-stu-id="4e603-155">A conditional block that frees managed resources.</span></span> <span data-ttu-id="4e603-156">이 블록은 `disposing` 값이 `true`인 경우 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-156">This block executes if the value of `disposing` is `true`.</span></span> <span data-ttu-id="4e603-157">해제되는 관리되는 리소스는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-157">The managed resources that it frees can include:</span></span>

  - <span data-ttu-id="4e603-158">**<xref:System.IDisposable>을 구현하는 관리되는 개체.**</span><span class="sxs-lookup"><span data-stu-id="4e603-158">**Managed objects that implement <xref:System.IDisposable>.**</span></span> <span data-ttu-id="4e603-159">조건부 블록을 사용하여 <xref:System.IDisposable.Dispose%2A> 구현(cascade dispose)을 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-159">The conditional block can be used to call their <xref:System.IDisposable.Dispose%2A> implementation (cascade dispose).</span></span> <span data-ttu-id="4e603-160">관리되지 않는 리소스를 래핑하기 위해 <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>의 파생 클래스를 사용한 경우 여기에서 <xref:System.Runtime.InteropServices.SafeHandle.Dispose?displayProperty=nameWithType> 구현을 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-160">If you have used a derived class of <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> to wrap your unmanaged resource, you should call the <xref:System.Runtime.InteropServices.SafeHandle.Dispose?displayProperty=nameWithType> implementation here.</span></span>

  - <span data-ttu-id="4e603-161">**많은 메모리를 사용하거나 부족한 리소스를 사용하는 관리되는 개체.**</span><span class="sxs-lookup"><span data-stu-id="4e603-161">**Managed objects that consume large amounts of memory or consume scarce resources.**</span></span> <span data-ttu-id="4e603-162">관리되는 큰 개체 참조를 `null`에 할당하여 더 연결할 수 없는 상태로 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-162">Assign large managed object references to `null` to make them more likely to be unreachable.</span></span> <span data-ttu-id="4e603-163">이렇게 하면 비결정적으로 회수된 경우보다 빠르게 해제됩니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-163">This releases them faster than if they were reclaimed non-deterministically.</span></span>

<span data-ttu-id="4e603-164">메서드 호출이 종료자에서 수행된 경우 관리되지 않는 리소스를 해제하는 코드만 실행되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-164">If the method call comes from a finalizer, only the code that frees unmanaged resources should execute.</span></span> <span data-ttu-id="4e603-165">구현자는 false 경로가 회수되었을 수 있는 관리되는 개체와 상호 작용하지 않도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-165">The implementer is responsible for ensuring the the false path doesn't interact with managed objects that may have been reclaimed.</span></span> <span data-ttu-id="4e603-166">이는 종료하는 동안 가비지 수집기가 관리되는 개체를 제거하는 순서가 비결정적이기 때문에 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-166">This is important because the order in which the garbage collector destroys managed objects during finalization is non-deterministic.</span></span>

## <a name="cascade-dispose-calls"></a><span data-ttu-id="4e603-167">Cascade dispose 호출</span><span class="sxs-lookup"><span data-stu-id="4e603-167">Cascade dispose calls</span></span>

<span data-ttu-id="4e603-168">클래스가 필드 또는 속성을 소유하고 해당 형식이 <xref:System.IDisposable>을 구현하는 경우 포함하는 클래스 자체도 <xref:System.IDisposable>을 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-168">If your class owns a field or property, and its type implements <xref:System.IDisposable>, the containing class itself should also implement <xref:System.IDisposable>.</span></span> <span data-ttu-id="4e603-169"><xref:System.IDisposable> 구현을 인스턴스화하고 인스턴스 멤버로 저장하는 클래스도 정리를 담당합니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-169">A class that instantiates an <xref:System.IDisposable> implementation and storing it as an instance member, is also responsible for its cleanup.</span></span> <span data-ttu-id="4e603-170">이는 참조되는 삭제 가능한 형식에 <xref:System.IDisposable.Dispose%2A> 메서드를 통해 결정적으로 정리를 수행할 수 있는 기회를 제공하기 위한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-170">This is to help ensure that the referenced disposable types are given the opportunity to deterministically perform clean up through the <xref:System.IDisposable.Dispose%2A> method.</span></span> <span data-ttu-id="4e603-171">이 예제에서 클래스는 `sealed`입니다(Visual Basic의 경우 `NotInheritable`).</span><span class="sxs-lookup"><span data-stu-id="4e603-171">In this example, the class is `sealed` (or `NotInheritable` in Visual Basic).</span></span>

[!code-csharp[Conceptual.Disposable#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/disposable1.cs#1)]
[!code-vb[Conceptual.Disposable#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/disposable1.vb#1)]

## <a name="implement-the-dispose-pattern"></a><span data-ttu-id="4e603-172">Dispose 패턴 구현</span><span class="sxs-lookup"><span data-stu-id="4e603-172">Implement the dispose pattern</span></span>

<span data-ttu-id="4e603-173">모든 봉인되지 않은 클래스 또는 `NotInheritable`으로 수정되지 않는 Visual Basic 클래스는 상속될 수 있기 때문에 잠재적 기본 클래스로 간주해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-173">All non-sealed classes or (Visual Basic classes not modified as `NotInheritable`) should be considered a potential base class, because they could be inherited.</span></span> <span data-ttu-id="4e603-174">잠재적 기본 클래스에 대한 삭제 패턴을 구현하는 경우 다음을 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-174">If you implement the dispose pattern for any potential base class, you must provide the following:</span></span>

- <span data-ttu-id="4e603-175"><xref:System.IDisposable.Dispose%2A> 메서드를 호출하는 `Dispose(bool)` 구현</span><span class="sxs-lookup"><span data-stu-id="4e603-175">A <xref:System.IDisposable.Dispose%2A> implementation that calls the `Dispose(bool)` method.</span></span>
- <span data-ttu-id="4e603-176">실제 정리를 수행하는 `Dispose(bool)` 메서드</span><span class="sxs-lookup"><span data-stu-id="4e603-176">A `Dispose(bool)` method that performs the actual cleanup.</span></span>
- <span data-ttu-id="4e603-177">관리되지 않는 리소스를 래핑하는 <xref:System.Runtime.InteropServices.SafeHandle>에서 파생된 클래스(권장) 또는 <xref:System.Object.Finalize%2A?displayProperty=nameWithType> 메서드 재정의</span><span class="sxs-lookup"><span data-stu-id="4e603-177">Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="4e603-178"><xref:System.Runtime.InteropServices.SafeHandle> 클래스는 종료자를 제공하므로 직접 작성할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-178">The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer, so you do not have to write one yourself.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="4e603-179">기본 클래스는 관리되는 개체만 참조할 수 있으며 Dispose 패턴을 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-179">It is possible for a base class to only reference managed objects, and implement the dispose pattern.</span></span> <span data-ttu-id="4e603-180">이러한 경우 종료자는 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-180">In these cases, a finalizer is unnecessary.</span></span> <span data-ttu-id="4e603-181">종료자는 관리되지 않는 리소스를 직접 참조하는 경우에만 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-181">A finalizer is only required if you directly reference unmanaged resources.</span></span>

<span data-ttu-id="4e603-182">SafeHandle을 사용하는 기본 클래스에 대한 삭제 패턴을 구현하는 일반적인 패턴은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-182">Here's the general pattern for implementing the dispose pattern for a base class that uses a safe handle.</span></span>

[!code-csharp[System.IDisposable#3](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base1.cs#3)]
[!code-vb[System.IDisposable#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base1.vb#3)]

> [!NOTE]
> <span data-ttu-id="4e603-183">이전 예제에서는 <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> 개체를 사용하여 패턴을 보여 줍니다. <xref:System.Runtime.InteropServices.SafeHandle>에서 파생된 개체를 대신 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-183">The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead.</span></span> <span data-ttu-id="4e603-184">예제에서는 해당 <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> 개체를 제대로 인스턴스화하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-184">Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.</span></span>

<span data-ttu-id="4e603-185"><xref:System.Object.Finalize%2A?displayProperty=nameWithType>를 재정의하는 기본 클래스에 대한 삭제 패턴을 구현하는 일반적인 패턴은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-185">Here's the general pattern for implementing the dispose pattern for a base class that overrides <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span>

[!code-csharp[System.IDisposable#5](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base2.cs#5)]
[!code-vb[System.IDisposable#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base2.vb#5)]

> [!TIP]
> <span data-ttu-id="4e603-186">C#에서는 <xref:System.Object.Finalize%2A?displayProperty=nameWithType>를 재정의하여 [종료자](../../csharp/programming-guide/classes-and-structs/destructors.md)를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-186">In C#, you create a [finalizer](../../csharp/programming-guide/classes-and-structs/destructors.md) by overriding <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4e603-187">Visual Basic에서는 `Protected Overrides Sub Finalize()`를 사용하여 이 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-187">In Visual Basic, this is done with `Protected Overrides Sub Finalize()`.</span></span>

## <a name="implement-the-dispose-pattern-for-a-derived-class"></a><span data-ttu-id="4e603-188">파생 클래스에 대한 Dispose 패턴 구현</span><span class="sxs-lookup"><span data-stu-id="4e603-188">Implement the dispose pattern for a derived class</span></span>

<span data-ttu-id="4e603-189"><xref:System.IDisposable>의 기본 클래스 구현은 파생된 클래스에 의해 상속되므로 <xref:System.IDisposable> 인터페이스를 구현하는 클래스에서 파생된 클래스가 <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>을 구현하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-189">A class derived from a class that implements the <xref:System.IDisposable> interface shouldn't implement <xref:System.IDisposable>, because the base class implementation of <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> is inherited by its derived classes.</span></span> <span data-ttu-id="4e603-190">대신, 파생 클래스를 정리하려면 다음을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-190">Instead, to cleanup a derived class, you provide the following:</span></span>

- <span data-ttu-id="4e603-191">기본 클래스 메서드를 재정의하고 파생 클래스의 실제 정리를 수행하는 `protected override void Dispose(bool)` 메서드.</span><span class="sxs-lookup"><span data-stu-id="4e603-191">A `protected override void Dispose(bool)` method that overrides the base class method and performs the actual cleanup of the derived class.</span></span> <span data-ttu-id="4e603-192">또한 이 메서드는 기본 클래스의 `base.Dispose(bool)`(Visual Basic의 경우 `MyBase.Dispose(bool)`) 메서드를 호출하며 인수에 대해 삭제 중 상태를 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-192">This method must also call the `base.Dispose(bool)` (`MyBase.Dispose(bool)` in Visual Basic) method of the base class and pass its disposing status for the argument.</span></span>
- <span data-ttu-id="4e603-193">관리되지 않는 리소스를 래핑하는 <xref:System.Runtime.InteropServices.SafeHandle>에서 파생된 클래스(권장) 또는 <xref:System.Object.Finalize%2A?displayProperty=nameWithType> 메서드 재정의</span><span class="sxs-lookup"><span data-stu-id="4e603-193">Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="4e603-194"><xref:System.Runtime.InteropServices.SafeHandle> 클래스는 사용자가 코딩할 필요가 없는 종료자를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-194">The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer that frees you from having to code one.</span></span> <span data-ttu-id="4e603-195">종료자를 제공하는 경우 `disposing` 인수가 `false`인 `Dispose(bool)` 오버로드를 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-195">If you do provide a finalizer, it must call the `Dispose(bool)` overload with a `disposing` argument of `false`.</span></span>

<span data-ttu-id="4e603-196">SafeHandle을 사용하는 파생된 클래스에 대한 삭제 패턴을 구현하는 일반적인 패턴은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-196">Here's the general pattern for implementing the dispose pattern for a derived class that uses a safe handle:</span></span>

[!code-csharp[System.IDisposable#4](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived1.cs#4)]
[!code-vb[System.IDisposable#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived1.vb#4)]

> [!NOTE]
> <span data-ttu-id="4e603-197">이전 예제에서는 <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> 개체를 사용하여 패턴을 보여 줍니다. <xref:System.Runtime.InteropServices.SafeHandle>에서 파생된 개체를 대신 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-197">The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead.</span></span> <span data-ttu-id="4e603-198">예제에서는 해당 <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> 개체를 제대로 인스턴스화하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-198">Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.</span></span>

<span data-ttu-id="4e603-199"><xref:System.Object.Finalize%2A?displayProperty=nameWithType>를 재정의하는 파생된 클래스에 대한 삭제 패턴을 구현하는 일반적인 패턴은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-199">Here's the general pattern for implementing the dispose pattern for a derived class that overrides <xref:System.Object.Finalize%2A?displayProperty=nameWithType>:</span></span>

[!code-csharp[System.IDisposable#6](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived2.cs#6)]
[!code-vb[System.IDisposable#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived2.vb#6)]

## <a name="implement-the-dispose-pattern-with-safe-handles"></a><span data-ttu-id="4e603-200">SafeHandle을 사용하여 Dispose 패턴 구현</span><span class="sxs-lookup"><span data-stu-id="4e603-200">Implement the dispose pattern with safe handles</span></span>

<span data-ttu-id="4e603-201">다음 예제는 SafeHandle을 사용하여 관리되지 않는 리소스를 캡슐화하는 기본 클래스에 대한 삭제 패턴인 `DisposableStreamResource`를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-201">The following example illustrates the dispose pattern for a base class, `DisposableStreamResource`, that uses a safe handle to encapsulate unmanaged resources.</span></span> <span data-ttu-id="4e603-202">이는 `DisposableStreamResource`을 사용하여 열려 있는 파일을 나타내는 <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> 개체를 래핑하는 <xref:System.IO.Stream> 클래스를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-202">It defines a `DisposableStreamResource` class that uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> to wrap a <xref:System.IO.Stream> object that represents an open file.</span></span> <span data-ttu-id="4e603-203">또한 이 클래스에는 파일 스트림에서 총 바이트 수를 반환하는 단일 속성인 `Size`도 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-203">The class also includes a single property, `Size`, that returns the total number of bytes in the file stream.</span></span>

[!code-csharp[Conceptual.Disposable#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/base1.cs#9)]
[!code-vb[Conceptual.Disposable#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/base1.vb#9)]

## <a name="implement-the-dispose-pattern-for-a-derived-class-with-safe-handles"></a><span data-ttu-id="4e603-204">SafeHandle을 사용하여 파생 클래스에 대한 Dispose 패턴 구현</span><span class="sxs-lookup"><span data-stu-id="4e603-204">Implement the dispose pattern for a derived class with safe handles</span></span>

<span data-ttu-id="4e603-205">다음 예제는 이전 예제에 제공된 `DisposableStreamResource2` 클래스에서 상속되는 파생된 클래스에 대한 삭제 패턴인 `DisposableStreamResource`를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-205">The following example illustrates the dispose pattern for a derived class, `DisposableStreamResource2`, that inherits from the `DisposableStreamResource` class presented in the previous example.</span></span> <span data-ttu-id="4e603-206">클래스에서 추가 메서드인 `WriteFileInfo`를 추가하고 <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> 개체를 사용하여 쓰기 가능 파일의 핸들을 래핑합니다.</span><span class="sxs-lookup"><span data-stu-id="4e603-206">The class adds an additional method, `WriteFileInfo`, and uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to wrap the handle of the writable file.</span></span>

[!code-csharp[Conceptual.Disposable#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/derived1.cs#10)]
[!code-vb[Conceptual.Disposable#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/derived1.vb#10)]

## <a name="see-also"></a><span data-ttu-id="4e603-207">참조</span><span class="sxs-lookup"><span data-stu-id="4e603-207">See also</span></span>

- <xref:System.GC.SuppressFinalize%2A>
- <xref:System.IDisposable>
- <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>
- <xref:Microsoft.Win32.SafeHandles>
- <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>
- <xref:System.Object.Finalize%2A?displayProperty=nameWithType>
- [<span data-ttu-id="4e603-208">클래스 및 구조체 정의 및 사용(C++/CLI)</span><span class="sxs-lookup"><span data-stu-id="4e603-208">Define and consume classes and structs (C++/CLI)</span></span>](/cpp/dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli)
