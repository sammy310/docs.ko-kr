---
title: 병렬 프로그래밍을 위한 데이터 구조
ms.date: 03/30/2017
helpviewer_keywords:
- data structures, multi-threading
ms.assetid: bdc82f2f-4754-45a1-a81e-fe2e9c30cef9
ms.openlocfilehash: c7f974c5626cf1efc6bf62c423043089d5c32e7c
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/18/2020
ms.locfileid: "94829533"
---
# <a name="data-structures-for-parallel-programming"></a><span data-ttu-id="8658b-102">병렬 프로그래밍을 위한 데이터 구조</span><span class="sxs-lookup"><span data-stu-id="8658b-102">Data Structures for Parallel Programming</span></span>

<span data-ttu-id="8658b-103">.NET에서는 동시 컬렉션 클래스, 간단한 동기화 기본 요소 및 초기화 지연 관련 형식을 포함하여 병렬 프로그래밍에서 유용한 여러 가지 형식을 소개합니다.</span><span class="sxs-lookup"><span data-stu-id="8658b-103">.NET provides several types that are useful in parallel programming, including a set of concurrent collection classes, lightweight synchronization primitives, and types for lazy initialization.</span></span> <span data-ttu-id="8658b-104">이러한 형식을 작업 병렬 라이브러리 및 PLINQ를 포함한 다중 스레드 애플리케이션 코드와 함께 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8658b-104">You can use these types with any multithreaded application code, including the Task Parallel Library and PLINQ.</span></span>  
  
## <a name="concurrent-collection-classes"></a><span data-ttu-id="8658b-105">동시 컬렉션 클래스</span><span class="sxs-lookup"><span data-stu-id="8658b-105">Concurrent Collection Classes</span></span>  
 <span data-ttu-id="8658b-106"><xref:System.Collections.Concurrent?displayProperty=nameWithType> 네임스페이스의 컬렉션 클래스는 가능한 경우 항상 잠금을 방지하고 잠금이 필요한 경우 세분화된 잠금을 사용하는 스레드로부터 안전한 추가 및 제거 작업을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="8658b-106">The collection classes in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace provide thread-safe add and remove operations that avoid locks wherever possible and use fine-grained locking where locks are necessary.</span></span> <span data-ttu-id="8658b-107">동시 컬렉션 클래스는 항목에 액세스할 때 사용자 코드가 잠금을 수행하도록 요구하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8658b-107">A concurrent collection class does not require user code to take any locks when it accesses items.</span></span> <span data-ttu-id="8658b-108">동시 컬렉션 클래스는 여러 스레드가 컬렉션에서 항목을 추가하고 제거하는 시나리오에서 <xref:System.Collections.ArrayList?displayProperty=nameWithType> 및 <xref:System.Collections.Generic.List%601?displayProperty=nameWithType>(사용자가 구현한 잠금 사용)와 같은 형식보다 성능을 크게 개선할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8658b-108">The concurrent collection classes can significantly improve performance over types such as <xref:System.Collections.ArrayList?displayProperty=nameWithType> and <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> (with user-implemented locking) in scenarios where multiple threads add and remove items from a collection.</span></span>  
  
 <span data-ttu-id="8658b-109">다음 표에는 동시 컬렉션 클래스가 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8658b-109">The following table lists the concurrent collection classes:</span></span>  
  
|<span data-ttu-id="8658b-110">형식</span><span class="sxs-lookup"><span data-stu-id="8658b-110">Type</span></span>|<span data-ttu-id="8658b-111">설명</span><span class="sxs-lookup"><span data-stu-id="8658b-111">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType>|<span data-ttu-id="8658b-112"><xref:System.Collections.Concurrent.IProducerConsumerCollection%601?displayProperty=nameWithType>을 구현하는 스레드로부터 안전한 컬렉션에 대한 차단 및 경계 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="8658b-112">Provides blocking and bounding capabilities for thread-safe collections that implement <xref:System.Collections.Concurrent.IProducerConsumerCollection%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8658b-113">슬롯을 사용할 수 없거나 컬렉션이 가득 차면 생산자 스레드가 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="8658b-113">Producer threads block if no slots are available or if the collection is full.</span></span> <span data-ttu-id="8658b-114">컬렉션이 비어 있으면 소비자 스레드가 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="8658b-114">Consumer threads block if the collection is empty.</span></span> <span data-ttu-id="8658b-115">이 형식은 소비자 및 생산자가 비차단 액세스도 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="8658b-115">This type also supports non-blocking access by consumers and producers.</span></span> <span data-ttu-id="8658b-116"><xref:System.Collections.Concurrent.BlockingCollection%601>은 <xref:System.Collections.Generic.IEnumerable%601>을 지원하는 모든 컬렉션 클래스에 대한 차단 및 결합을 제공하기 위한 기본 클래스 또는 백업 저장소로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8658b-116"><xref:System.Collections.Concurrent.BlockingCollection%601> can be used as a base class or backing store to provide blocking and bounding for any collection class that supports <xref:System.Collections.Generic.IEnumerable%601>.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType>|<span data-ttu-id="8658b-117">확장 가능한 추가 및 가져오기 작업을 제공하는 스레드로부터 안전한 모음 구현.</span><span class="sxs-lookup"><span data-stu-id="8658b-117">A thread-safe bag implementation that provides scalable add and get operations.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType>|<span data-ttu-id="8658b-118">동시 및 확장 가능한 사전 형식.</span><span class="sxs-lookup"><span data-stu-id="8658b-118">A concurrent and scalable dictionary type.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType>|<span data-ttu-id="8658b-119">동시 및 확장 가능한 FIFO 큐.</span><span class="sxs-lookup"><span data-stu-id="8658b-119">A concurrent and scalable FIFO queue.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType>|<span data-ttu-id="8658b-120">동시 및 확장 가능한 LIFO 스택.</span><span class="sxs-lookup"><span data-stu-id="8658b-120">A concurrent and scalable LIFO stack.</span></span>|  
  
 <span data-ttu-id="8658b-121">자세한 내용은 [스레드로부터 안전한 컬렉션](../collections/thread-safe/index.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8658b-121">For more information, see [Thread-Safe Collections](../collections/thread-safe/index.md).</span></span>  
  
## <a name="synchronization-primitives"></a><span data-ttu-id="8658b-122">동기화 기본 형식</span><span class="sxs-lookup"><span data-stu-id="8658b-122">Synchronization Primitives</span></span>  
 <span data-ttu-id="8658b-123"><xref:System.Threading?displayProperty=nameWithType> 네임스페이스의 동기화 기본 형식은 레거시 다중 스레딩 코드에 있는 비용이 많이 드는 잠금 메커니즘을 방지하여 세분화된 동시성과 더 빠른 성능을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8658b-123">The synchronization primitives in the <xref:System.Threading?displayProperty=nameWithType> namespace enable fine-grained concurrency and faster performance by avoiding expensive locking mechanisms found in legacy multithreading code.</span></span>
  
 <span data-ttu-id="8658b-124">다음 표에는 동기화 형식이 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8658b-124">The following table lists the synchronization types:</span></span>  
  
|<span data-ttu-id="8658b-125">유형</span><span class="sxs-lookup"><span data-stu-id="8658b-125">Type</span></span>|<span data-ttu-id="8658b-126">Description</span><span class="sxs-lookup"><span data-stu-id="8658b-126">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Threading.Barrier?displayProperty=nameWithType>|<span data-ttu-id="8658b-127">각 작업이 도착에 대한 신호를 보낸 다음, 일부 또는 모든 작업이 도착할 때까지 차단될 수 있는 지점을 제공하여 여러 스레드가 하나의 알고리즘에서 병렬로 작동하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="8658b-127">Enables multiple threads to work on an algorithm in parallel by providing a point at which each task can signal its arrival and then block until some or all tasks have arrived.</span></span> <span data-ttu-id="8658b-128">자세한 내용은 [Barrier](../threading/barrier.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8658b-128">For more information, see [Barrier](../threading/barrier.md).</span></span>|  
|<xref:System.Threading.CountdownEvent?displayProperty=nameWithType>|<span data-ttu-id="8658b-129">쉽게 랑데부 메커니즘을 제공하여 포크 및 조인 시나리오를 간소화합니다.</span><span class="sxs-lookup"><span data-stu-id="8658b-129">Simplifies fork and join scenarios by providing an easy rendezvous mechanism.</span></span> <span data-ttu-id="8658b-130">자세한 내용은 [CountdownEvent](../threading/countdownevent.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8658b-130">For more information, see [CountdownEvent](../threading/countdownevent.md).</span></span>|  
|<xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType>|<span data-ttu-id="8658b-131"><xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>와 유사한 동기화 기본 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="8658b-131">A synchronization primitive similar to <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8658b-132"><xref:System.Threading.ManualResetEventSlim>은 더 간단하지만 프로세스 간 통신에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8658b-132"><xref:System.Threading.ManualResetEventSlim> is lighter-weight but can only be used for intra-process communication.</span></span>|  
|<xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType>|<span data-ttu-id="8658b-133">리소스 또는 리소스 풀에 동시에 액세스할 수 있는 스레드 수를 제한하는 동기화 기본 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="8658b-133">A synchronization primitive that limits the number of threads that can concurrently access a resource or a pool of resources.</span></span> <span data-ttu-id="8658b-134">자세한 내용은 [세마포 및 SemaphoreSlim](../threading/semaphore-and-semaphoreslim.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8658b-134">For more information, see [Semaphore and SemaphoreSlim](../threading/semaphore-and-semaphoreslim.md).</span></span>|  
|<xref:System.Threading.SpinLock?displayProperty=nameWithType>|<span data-ttu-id="8658b-135">퀀텀을 일시 중단하기 전에 일정 시간 동안 잠금을 획득하려고 시도 중인 스레드가 루프 또는 ‘스핀’에서 대기하도록 하는 상호 배제 잠금 기본 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="8658b-135">A mutual exclusion lock primitive that causes the thread that is trying to acquire the lock to wait in a loop, or *spin*, for a period of time before yielding its quantum.</span></span> <span data-ttu-id="8658b-136">잠금 대기가 짧아야 하는 시나리오에서 <xref:System.Threading.SpinLock>은 다른 형태의 잠금보다 향상된 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="8658b-136">In scenarios where the wait for the lock is expected to be short, <xref:System.Threading.SpinLock> offers better performance than other forms of locking.</span></span> <span data-ttu-id="8658b-137">자세한 내용은 [SpinLock](../threading/spinlock.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8658b-137">For more information, see [SpinLock](../threading/spinlock.md).</span></span>|  
|<xref:System.Threading.SpinWait?displayProperty=nameWithType>|<span data-ttu-id="8658b-138">지정된 시간 동안 스핀하고 스핀 수를 초과하는 경우 결국 스레드를 대기 상태로 전환하는 작고 간단한 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="8658b-138">A small, lightweight type that will spin for a specified time and eventually put the thread into a wait state if the spin count is exceeded.</span></span>  <span data-ttu-id="8658b-139">자세한 내용은 [SpinWait](../threading/spinwait.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8658b-139">For more information, see [SpinWait](../threading/spinwait.md).</span></span>|  
  
 <span data-ttu-id="8658b-140">자세한 내용은 다음을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="8658b-140">For more information, see:</span></span>  
  
- [<span data-ttu-id="8658b-141">방법: 낮은 수준의 동기화에 SpinLock 사용</span><span class="sxs-lookup"><span data-stu-id="8658b-141">How to: Use SpinLock for Low-Level Synchronization</span></span>](../threading/how-to-use-spinlock-for-low-level-synchronization.md)  
  
- <span data-ttu-id="8658b-142">[방법: 동시 작업을 배리어와 동기화](../threading/how-to-synchronize-concurrent-operations-with-a-barrier.md).</span><span class="sxs-lookup"><span data-stu-id="8658b-142">[How to: Synchronize Concurrent Operations with a Barrier](../threading/how-to-synchronize-concurrent-operations-with-a-barrier.md).</span></span>  
  
## <a name="lazy-initialization-classes"></a><span data-ttu-id="8658b-143">초기화 지연 클래스</span><span class="sxs-lookup"><span data-stu-id="8658b-143">Lazy Initialization Classes</span></span>  
 <span data-ttu-id="8658b-144">초기화 지연을 사용하면 필요할 때까지 개체용 메모리가 할당되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8658b-144">With lazy initialization, the memory for an object is not allocated until it is needed.</span></span> <span data-ttu-id="8658b-145">초기화 지연을 통해 개체 할당을 프로그램 수명에 균등하게 분산하여 성능을 향상시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8658b-145">Lazy initialization can improve performance by spreading object allocations evenly across the lifetime of a program.</span></span> <span data-ttu-id="8658b-146"><xref:System.Lazy%601> 형식을 래핑하여 모든 사용자 지정 형식에 대한 초기화 지연을 사용하도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8658b-146">You can enable lazy initialization for any custom type by wrapping the type <xref:System.Lazy%601>.</span></span>  
  
 <span data-ttu-id="8658b-147">다음 표에는 초기화 지연 형식이 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8658b-147">The following table lists the lazy initialization types:</span></span>  
  
|<span data-ttu-id="8658b-148">유형</span><span class="sxs-lookup"><span data-stu-id="8658b-148">Type</span></span>|<span data-ttu-id="8658b-149">Description</span><span class="sxs-lookup"><span data-stu-id="8658b-149">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Lazy%601?displayProperty=nameWithType>|<span data-ttu-id="8658b-150">간단하고 스레드로부터 안전한 초기화 지연을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="8658b-150">Provides lightweight, thread-safe lazy-initialization.</span></span>|  
|<xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType>|<span data-ttu-id="8658b-151">각 스레드가 초기화 함수 호출을 지연시켜 스레드별 기준으로 초기화가 지연된 값을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="8658b-151">Provides a lazily-initialized value on a per-thread basis, with each thread lazily-invoking the initialization function.</span></span>|  
|<xref:System.Threading.LazyInitializer?displayProperty=nameWithType>|<span data-ttu-id="8658b-152">전용 초기화 지연 인스턴스를 할당할 필요가 없도록 하는 정적 메서드를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="8658b-152">Provides static methods that avoid the need to allocate a dedicated, lazy-initialization instance.</span></span> <span data-ttu-id="8658b-153">대신 참조를 사용하여 대상이 액세스될 때 초기화되었는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="8658b-153">Instead, they use references to ensure targets have been initialized as they are accessed.</span></span>|  
  
 <span data-ttu-id="8658b-154">자세한 내용은 [초기화 지연](../../framework/performance/lazy-initialization.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8658b-154">For more information, see [Lazy Initialization](../../framework/performance/lazy-initialization.md).</span></span>  
  
## <a name="aggregate-exceptions"></a><span data-ttu-id="8658b-155">집계 예외</span><span class="sxs-lookup"><span data-stu-id="8658b-155">Aggregate Exceptions</span></span>  
 <span data-ttu-id="8658b-156"><xref:System.AggregateException?displayProperty=nameWithType> 형식은 개별 스레드에서 동시에 throw되는 여러 예외를 캡처하고 조인 스레드에 단일 예외로 반환하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8658b-156">The <xref:System.AggregateException?displayProperty=nameWithType> type can be used to capture multiple exceptions that are thrown concurrently on separate threads, and return them to the joining thread as a single exception.</span></span> <span data-ttu-id="8658b-157"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 및 <xref:System.Threading.Tasks.Parallel?displayProperty=nameWithType> 형식과 PLINQ는 이 용도로 <xref:System.AggregateException>을 광범위하게 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="8658b-157">The <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Parallel?displayProperty=nameWithType> types and PLINQ use <xref:System.AggregateException> extensively for this purpose.</span></span> <span data-ttu-id="8658b-158">자세한 내용은 [예외 처리](exception-handling-task-parallel-library.md) 및 [방법: PLINQ 쿼리의 예외 처리](how-to-handle-exceptions-in-a-plinq-query.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8658b-158">For more information, see [Exception Handling](exception-handling-task-parallel-library.md) and [How to: Handle Exceptions in a PLINQ Query](how-to-handle-exceptions-in-a-plinq-query.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="8658b-159">참조</span><span class="sxs-lookup"><span data-stu-id="8658b-159">See also</span></span>

- <xref:System.Collections.Concurrent?displayProperty=nameWithType>
- <xref:System.Threading?displayProperty=nameWithType>
- [<span data-ttu-id="8658b-160">병렬 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="8658b-160">Parallel Programming</span></span>](index.md)
