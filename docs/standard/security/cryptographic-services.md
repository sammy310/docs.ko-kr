---
title: 암호화 서비스
description: .NET에서 지원 되는 암호화 방법 및 방법에 대 한 개요입니다.
ms.date: 07/14/2020
ms.technology: dotnet-standard
helpviewer_keywords:
- cryptography [.NET]
- pattern of derived class inheritance
- digital signatures
- asymmetric cryptographic algorithms
- digital signatures, public-key systems
- public keys
- decryption [.NET]
- private keys
- MAC algorithms
- cryptographic algorithms
- private keys, overview
- encryption [.NET]
- security [.NET], encryption
- cryptographic services
- symmetric cryptographic algorithms
- hash
- message authentication codes
- derived class inheritance
- cryptography [.NET], about
- random number generation
ms.assetid: f96284bc-7b73-44b5-ac59-fac613ad09f8
ms.openlocfilehash: 463ccec5f60ff10331d501d39144a979d95eff95
ms.sourcegitcommit: 74d05613d6c57106f83f82ce8ee71176874ea3f0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/03/2020
ms.locfileid: "93281726"
---
# <a name="cryptographic-services"></a><span data-ttu-id="bff1c-103">암호화 서비스</span><span class="sxs-lookup"><span data-stu-id="bff1c-103">Cryptographic Services</span></span>

<span data-ttu-id="bff1c-104">인터넷과 같은 공용 네트워크에서는 엔터티 간의 보안 통신 수단을 제공하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-104">Public networks such as the Internet do not provide a means of secure communication between entities.</span></span> <span data-ttu-id="bff1c-105">이러한 네트워크를 통한 통신은 권한이 없는 제3자가 읽거나 심지어는 수정하기도 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-105">Communication over such networks is susceptible to being read or even modified by unauthorized third parties.</span></span> <span data-ttu-id="bff1c-106">암호화는 데이터를 볼 수 없도록 보호하며 데이터가 수정되었는지 감지하는 방법을 제공하며 기타 보안상 위험한 채널을 통한 안전한 통신 수단 제공을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-106">Cryptography helps protect data from being viewed, provides ways to detect whether data has been modified, and helps provide a secure means of communication over otherwise nonsecure channels.</span></span> <span data-ttu-id="bff1c-107">예를 들어 데이터를 암호화된 상태로 전송하고 나중에 의도된 당사자가 해독하는 암호화 알고리즘을 사용하여 데이터를 암호화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-107">For example, data can be encrypted by using a cryptographic algorithm, transmitted in an encrypted state, and later decrypted by the intended party.</span></span> <span data-ttu-id="bff1c-108">제3자가 암호화된 데이터를 가로채는 경우 해독하기 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-108">If a third party intercepts the encrypted data, it will be difficult to decipher.</span></span>

<span data-ttu-id="bff1c-109">.NET에서 네임 스페이스의 클래스는 <xref:System.Security.Cryptography> 여러 암호화 세부 정보를 관리 합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-109">In .NET, the classes in the <xref:System.Security.Cryptography> namespace manage many details of cryptography for you.</span></span> <span data-ttu-id="bff1c-110">일부는 운영 체제 구현에 대 한 래퍼입니다. 다른 일부는 순수 하 게 관리 되는 구현입니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-110">Some are wrappers for operating system implementations, while others are purely managed implementations.</span></span> <span data-ttu-id="bff1c-111">이러한 클래스를 사용하기 위해 암호화 전문가가 될 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-111">You do not need to be an expert in cryptography to use these classes.</span></span> <span data-ttu-id="bff1c-112">암호화 알고리즘 클래스 중 하나의 새 인스턴스를 만들 경우 키가 사용 편의를 위해 자동으로 생성되며, 기본 속성은 가능한 한 안전합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-112">When you create a new instance of one of the encryption algorithm classes, keys are autogenerated for ease of use, and default properties are as safe and secure as possible.</span></span>

<span data-ttu-id="bff1c-113">이 개요에서는 ClickOnce 매니페스트를 비롯 하 여 .NET에서 지원 되는 암호화 방법 및 방법의 개요 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-113">This overview provides a synopsis of the encryption methods and practices supported by .NET, including the ClickOnce manifests.</span></span>

## <a name="cryptographic-primitives"></a><span data-ttu-id="bff1c-114">암호화 기본</span><span class="sxs-lookup"><span data-stu-id="bff1c-114">Cryptographic Primitives</span></span>

<span data-ttu-id="bff1c-115">암호화가 사용되는 일반적인 상황에서 두 당사자(Alice와 Bob)는 보안상 위험한 채널을 통해 통신하고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-115">In a typical situation where cryptography is used, two parties (Alice and Bob) communicate over a nonsecure channel.</span></span> <span data-ttu-id="bff1c-116">Alice와 Bob은 통신을 수신할 수도 있는 다른 사용자가 계속해서 둘 간의 통신을 이해할 수 없도록 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-116">Alice and Bob want to ensure that their communication remains incomprehensible by anyone who might be listening.</span></span> <span data-ttu-id="bff1c-117">게다가 Alice와 Bob은 원격 위치에 있으므로 Alice는 Bob으로부터 받은 정보가 전송 중 다른 사용자에 의해 수정되지 않았는지 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-117">Furthermore, because Alice and Bob are in remote locations, Alice must make sure that the information she receives from Bob has not been modified by anyone during transmission.</span></span> <span data-ttu-id="bff1c-118">또한 그녀는 정보가 Bob을 가장하는 사람이 아니라 실제로 Bob에서 온 것임을 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-118">In addition, she must make sure that the information really does originate from Bob and not from someone who is impersonating Bob.</span></span>

<span data-ttu-id="bff1c-119">암호화는 다음과 같은 목표를 달성하기 위해 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-119">Cryptography is used to achieve the following goals:</span></span>

- <span data-ttu-id="bff1c-120">기밀성: 사용자의 ID 또는 데이터를 읽지 못하도록 보호 지원</span><span class="sxs-lookup"><span data-stu-id="bff1c-120">Confidentiality: To help protect a user's identity or data from being read.</span></span>

- <span data-ttu-id="bff1c-121">데이터 무결성: 데이터를 변경하지 못하도록 보호 지원</span><span class="sxs-lookup"><span data-stu-id="bff1c-121">Data integrity: To help protect data from being changed.</span></span>

- <span data-ttu-id="bff1c-122">인증: 데이터가 특정 당사자로부터 온 것임을 보장</span><span class="sxs-lookup"><span data-stu-id="bff1c-122">Authentication: To ensure that data originates from a particular party.</span></span>

- <span data-ttu-id="bff1c-123">부인 방지: 특정 당사자가 메시지 보낸 사실을 부인하지 못하도록 방지</span><span class="sxs-lookup"><span data-stu-id="bff1c-123">Non-repudiation: To prevent a particular party from denying that they sent a message.</span></span>

<span data-ttu-id="bff1c-124">이러한 목표를 달성하기 위해 암호화 기본이라고 알려진 알고리즘과 방법을 결합하여 암호화 체계를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-124">To achieve these goals, you can use a combination of algorithms and practices known as cryptographic primitives to create a cryptographic scheme.</span></span> <span data-ttu-id="bff1c-125">다음 표는 암호화 기본 및 해당 기능 목록을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-125">The following table lists the cryptographic primitives and their uses.</span></span>

|<span data-ttu-id="bff1c-126">암호화 기본</span><span class="sxs-lookup"><span data-stu-id="bff1c-126">Cryptographic primitive</span></span>|<span data-ttu-id="bff1c-127">기능</span><span class="sxs-lookup"><span data-stu-id="bff1c-127">Use</span></span>|
|-----------------------------|---------|
|<span data-ttu-id="bff1c-128">비밀 키 암호화(대칭 암호화)</span><span class="sxs-lookup"><span data-stu-id="bff1c-128">Secret-key encryption (symmetric cryptography)</span></span>|<span data-ttu-id="bff1c-129">데이터에서 변환을 수행하여 제3자가 읽지 못하게 합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-129">Performs a transformation on data to keep it from being read by third parties.</span></span> <span data-ttu-id="bff1c-130">이 유형의 암호화는 공유된 하나의 비밀 키를 사용하여 데이터를 암호화하고 해독합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-130">This type of encryption uses a single shared, secret key to encrypt and decrypt data.</span></span>|
|<span data-ttu-id="bff1c-131">공개 키 암호화(비대칭 암호화)</span><span class="sxs-lookup"><span data-stu-id="bff1c-131">Public-key encryption (asymmetric cryptography)</span></span>|<span data-ttu-id="bff1c-132">데이터에서 변환을 수행하여 제3자가 읽지 못하게 합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-132">Performs a transformation on data to keep it from being read by third parties.</span></span> <span data-ttu-id="bff1c-133">이 유형의 암호화는 퍼블릭/프라이빗 키 쌍을 사용하여 데이터를 암호화하고 해독합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-133">This type of encryption uses a public/private key pair to encrypt and decrypt data.</span></span>|
|<span data-ttu-id="bff1c-134">암호화 서명</span><span class="sxs-lookup"><span data-stu-id="bff1c-134">Cryptographic signing</span></span>|<span data-ttu-id="bff1c-135">특정 당사자에 고유한 디지털 서명을 만들어 데이터가 해당 당사자로부터 온 것임을 확인할 수 있도록 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-135">Helps verify that data originates from a specific party by creating a digital signature that is unique to that party.</span></span> <span data-ttu-id="bff1c-136">또한 이 프로세스는 해시 함수도 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-136">This process also uses hash functions.</span></span>|
|<span data-ttu-id="bff1c-137">암호화 해시</span><span class="sxs-lookup"><span data-stu-id="bff1c-137">Cryptographic hashes</span></span>|<span data-ttu-id="bff1c-138">데이터를 임의 길이에서 고정 길이의 바이트 시퀀스로 매핑합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-138">Maps data from any length to a fixed-length byte sequence.</span></span> <span data-ttu-id="bff1c-139">해시는 통계적으로 고유합니다. 서로 다른 2바이트 시퀀스는 같은 값으로 해시하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-139">Hashes are statistically unique; a different two-byte sequence will not hash to the same value.</span></span>|

## <a name="secret-key-encryption"></a><span data-ttu-id="bff1c-140">비밀 키 암호화</span><span class="sxs-lookup"><span data-stu-id="bff1c-140">Secret-Key Encryption</span></span>

<span data-ttu-id="bff1c-141">비밀 키 암호화 알고리즘은 하나의 비밀 키를 사용하여 데이터를 암호화하고 해독합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-141">Secret-key encryption algorithms use a single secret key to encrypt and decrypt data.</span></span> <span data-ttu-id="bff1c-142">키를 가진 사람은 누구나 키를 사용하여 데이터를 해독하거나 자신의 데이터를 암호화한 다음 출처를 가장할 수 있으므로 권한이 없는 다른 사용자가 키에 액세스할 수 없도록 보호해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-142">You must secure the key from access by unauthorized agents, because any party that has the key can use it to decrypt your data or encrypt their own data, claiming it originated from you.</span></span>

<span data-ttu-id="bff1c-143">또한 비밀 키 암호화는 동일한 키가 암호화 및 해독에 사용되므로 대칭 암호화라고도 합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-143">Secret-key encryption is also referred to as symmetric encryption because the same key is used for encryption and decryption.</span></span> <span data-ttu-id="bff1c-144">비밀 키 암호화 알고리즘은 공개 키 알고리즘과 비교하여 매우 빠르며, 대규모 데이터 스트림에 대해 암호화 변환을 수행하는 데 매우 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-144">Secret-key encryption algorithms are very fast (compared with public-key algorithms) and are well suited for performing cryptographic transformations on large streams of data.</span></span> <span data-ttu-id="bff1c-145">RSA와 같은 비대칭 암호화 알고리즘은 암호화할 수 있는 데이터 양에 있어 수학적으로 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-145">Asymmetric encryption algorithms such as RSA are limited mathematically in how much data they can encrypt.</span></span> <span data-ttu-id="bff1c-146">일반적으로 대칭 암호화 알고리즘에는 이러한 문제가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-146">Symmetric encryption algorithms do not generally have those problems.</span></span>

<span data-ttu-id="bff1c-147">블록 암호라고 하는 비밀 키 알고리즘의 유형은 한 번에 한 데이터 블록을 암호화하는 데 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-147">A type of secret-key algorithm called a block cipher is used to encrypt one block of data at a time.</span></span> <span data-ttu-id="bff1c-148">DES(데이터 암호화 표준), TripleDES 및 AES(Advanced Encryption Standard)와 같은 블록 암호는 *n* 바이트의 입력 블록을 암호화된 바이트의 출력 블록으로 암호화하여 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-148">Block ciphers such as Data Encryption Standard (DES), TripleDES, and Advanced Encryption Standard (AES) cryptographically transform an input block of *n* bytes into an output block of encrypted bytes.</span></span> <span data-ttu-id="bff1c-149">바이트 시퀀스를 암호화하거나 해독하려는 경우 작업을 블록 단위로 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-149">If you want to encrypt or decrypt a sequence of bytes, you have to do it block by block.</span></span> <span data-ttu-id="bff1c-150">*n* 이 작기(DES 및 TripleDES의 경우 8바이트, AES의 경우 16바이트[기본값], 24바이트 또는 32바이트) 때문에 *n* 보다 큰 데이터 값은 한 번에 한 블록씩 암호화되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-150">Because *n* is small (8 bytes for DES and TripleDES; 16 bytes [the default], 24 bytes, or 32 bytes for AES), data values that are larger than *n* have to be encrypted one block at a time.</span></span> <span data-ttu-id="bff1c-151">*n* 보다 작은 데이터 값은 처리하려면 *n* 으로 확장해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-151">Data values that are smaller than *n* have to be expanded to *n* in order to be processed.</span></span>

<span data-ttu-id="bff1c-152">블록 암호의 한 가지 간단한 형태는 ECB(Electronic CodeBook) 모드라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-152">One simple form of block cipher is called the electronic codebook (ECB) mode.</span></span> <span data-ttu-id="bff1c-153">ECB 모드는 첫 번째 일반 텍스트 블록을 초기화하는 데 초기화 벡터를 사용하지 않으므로 안전하지 않은 것으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-153">ECB mode is not considered secure, because it does not use an initialization vector to initialize the first plaintext block.</span></span> <span data-ttu-id="bff1c-154">비밀 키 *k* 가 주어진 경우 초기화 벡터를 사용하지 않는 단순 블록 암호는 일반 텍스트의 동일한 입력 블록을 암호 텍스트의 동일한 출력 블록으로 암호화합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-154">For a given secret key *k* , a simple block cipher that does not use an initialization vector will encrypt the same input block of plaintext into the same output block of ciphertext.</span></span> <span data-ttu-id="bff1c-155">따라서 입력 일반 텍스트 스트림에 중복된 블록이 있는 경우 출력 암호 텍스트 스트림에도 중복된 블록이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-155">Therefore, if you have duplicate blocks in your input plaintext stream, you will have duplicate blocks in your output ciphertext stream.</span></span> <span data-ttu-id="bff1c-156">이러한 중복 출력 블록을 통해 권한이 없는 사용자가 취약한 암호화 알고리즘이 사용되었다는 사실과 가능한 공격 방식을 알게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-156">These duplicate output blocks alert unauthorized users to the weak encryption used the algorithms that might have been employed, and the possible modes of attack.</span></span> <span data-ttu-id="bff1c-157">따라서 ECB 암호화 모드는 분석에 매우 취약하므로 키가 노출될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-157">The ECB cipher mode is therefore quite vulnerable to analysis, and ultimately, key discovery.</span></span>

<span data-ttu-id="bff1c-158">기본 클래스 라이브러리에 제공되는 블록 암호 클래스에서는 CBC(Cipher Block Chaining)라는 기본 체인 모드를 사용하며, 필요에 따라 이 기본 모드를 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-158">The block cipher classes that are provided in the base class library use a default chaining mode called cipher-block chaining (CBC), although you can change this default if you want.</span></span>

<span data-ttu-id="bff1c-159">CBC 암호화에서는 IV(Initialization Vector)를 사용하여 일반 텍스트의 첫 번째 블록을 암호화함으로써 ECB 암호화와 관련된 문제를 해결합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-159">CBC ciphers overcome the problems associated with ECB ciphers by using an initialization vector (IV) to encrypt the first block of plaintext.</span></span> <span data-ttu-id="bff1c-160">일반 텍스트의 각 후속 블록은 암호화되기 전에 이전 암호 텍스트 블록과 배타적 비트 OR(`XOR`) 연산을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-160">Each subsequent block of plaintext undergoes a bitwise exclusive OR (`XOR`) operation with the previous ciphertext block before it is encrypted.</span></span> <span data-ttu-id="bff1c-161">따라서 각 암호 텍스트 블록은 이전 모든 블록에 종속됩니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-161">Each ciphertext block is therefore dependent on all previous blocks.</span></span> <span data-ttu-id="bff1c-162">이 시스템을 사용하는 경우 권한이 없는 사용자에게 알려질 수 있는 일반적인 메시지 헤더를 사용해서는 키를 리버스 엔지니어링할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-162">When this system is used, common message headers that might be known to an unauthorized user cannot be used to reverse-engineer a key.</span></span>

<span data-ttu-id="bff1c-163">CBC 암호화로 암호화된 데이터를 손상시킬 수 있는 한 가지 방법은 가능한 모든 키에 대해 철저한 검색을 수행하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-163">One way to compromise data that is encrypted with a CBC cipher is to perform an exhaustive search of every possible key.</span></span> <span data-ttu-id="bff1c-164">암호화 수행에 사용된 키의 크기에 따라 가장 빠른 컴퓨터를 사용해도 이러한 철저한 검색에는 많은 시간이 걸리므로 이 방법은 실제로 불가능합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-164">Depending on the size of the key that is used to perform encryption, this kind of search is very time-consuming using even the fastest computers and is therefore infeasible.</span></span> <span data-ttu-id="bff1c-165">키 크기가 클수록 해독이 더 어려워집니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-165">Larger key sizes are more difficult to decipher.</span></span> <span data-ttu-id="bff1c-166">이론적으로 암호화를 통해 악의적 사용자가 암호화된 데이터를 검색할 수 없도록 할 수는 있지만, 그러면 비용이 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-166">Although encryption does not make it theoretically impossible for an adversary to retrieve the encrypted data, it does raise the cost of doing this.</span></span> <span data-ttu-id="bff1c-167">며칠 동안만 유용한 데이터를 검색하기 위해 3개월에 걸쳐 철저한 검색을 수행한다면 철저한 검색 방법은 실용적이지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-167">If it takes three months to perform an exhaustive search to retrieve data that is meaningful only for a few days, the exhaustive search method is impractical.</span></span>

<span data-ttu-id="bff1c-168">비밀 키 암호화의 단점은 두 당사자가 키 및 IV에 대해 동의하고 해당 값을 통신했다고 추정하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-168">The disadvantage of secret-key encryption is that it presumes two parties have agreed on a key and IV, and communicated their values.</span></span> <span data-ttu-id="bff1c-169">IV는 비밀로 간주되지 않으며 메시지와 함께 일반 텍스트로 전송할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-169">The IV is not considered a secret and can be transmitted in plaintext with the message.</span></span> <span data-ttu-id="bff1c-170">그러나 키는 권한이 없는 사용자에게 비밀로 유지되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-170">However, the key must be kept secret from unauthorized users.</span></span> <span data-ttu-id="bff1c-171">이러한 문제 때문에 비밀 키 암호화는 키와 IV의 값을 비밀리에 교환하는 공개 키 암호화와 함께 사용되는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-171">Because of these problems, secret-key encryption is often used together with public-key encryption to privately communicate the values of the key and IV.</span></span>

<span data-ttu-id="bff1c-172">두 당사자인 Alice와 Bob이 안전하지 않은 채널을 통해 통신하려는 경우를 가정할 때 그들은 다음과 같은 방법으로 비밀 키 암호화를 사용할 수 있습니다. 즉, Alice와 Bob은 특정 키 및 IV와 함께 하나의 특정 알고리즘(예: AES)을 사용하기로 동의합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-172">Assuming that Alice and Bob are two parties who want to communicate over a nonsecure channel, they might use secret-key encryption as follows: Alice and Bob agree to use one particular algorithm (AES, for example) with a particular key and IV.</span></span> <span data-ttu-id="bff1c-173">Alice는 메시지를 작성 하 고 메시지를 보낼 네트워크 스트림 (아마도 명명 된 파이프 또는 네트워크 메일)을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-173">Alice composes a message and creates a network stream (perhaps a named pipe or network email) on which to send the message.</span></span> <span data-ttu-id="bff1c-174">그런 다음 키와 IV를 사용하여 텍스트를 암호화하고 인트라넷을 통해 Bob에게 암호화된 메시지와 IV를 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-174">Next, she encrypts the text using the key and IV, and sends the encrypted message and IV to Bob over the intranet.</span></span> <span data-ttu-id="bff1c-175">Bob은 암호화된 텍스트를 수신하고 IV와 미리 동의한 키를 사용하여 텍스트를 해독합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-175">Bob receives the encrypted text and decrypts it by using the IV and previously agreed upon key.</span></span> <span data-ttu-id="bff1c-176">전송을 가로채는 경우 인터셉터는 키를 알 수 없으므로 원래 메시지를 복구할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-176">If the transmission is intercepted, the interceptor cannot recover the original message, because they do not know the key.</span></span> <span data-ttu-id="bff1c-177">이 시나리오에서는 키만 비밀로 유지하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-177">In this scenario, only the key must remain secret.</span></span> <span data-ttu-id="bff1c-178">실제 시나리오에서는 Alice 또는 Bob 중 한 사람이 비밀 키를 생성하고 공개 키(비대칭) 암호화를 사용하여 비밀(대칭) 키를 상대방에게 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-178">In a real world scenario, either Alice or Bob generates a secret key and uses public-key (asymmetric) encryption to transfer the secret (symmetric) key to the other party.</span></span> <span data-ttu-id="bff1c-179">공개 키 암호화에 대한 자세한 내용은 다음 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="bff1c-179">For more information about public-key encryption, see the next section.</span></span>

<span data-ttu-id="bff1c-180">.NET에서는 비밀 키 암호화 알고리즘을 구현 하는 다음 클래스를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-180">.NET provides the following classes that implement secret-key encryption algorithms:</span></span>

- <xref:System.Security.Cryptography.Aes>

- <span data-ttu-id="bff1c-181"><xref:System.Security.Cryptography.HMACSHA256>, <xref:System.Security.Cryptography.HMACSHA384> 및 <xref:System.Security.Cryptography.HMACSHA512>입니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-181"><xref:System.Security.Cryptography.HMACSHA256>, <xref:System.Security.Cryptography.HMACSHA384> and <xref:System.Security.Cryptography.HMACSHA512>.</span></span> <span data-ttu-id="bff1c-182">(비밀 키와 결합 된 암호화 해시 함수를 사용 하 여 계산 된 메시지 인증 코드를 나타내므로 기술적으로 비밀 키 알고리즘입니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-182">(These are technically secret-key algorithms because they represent message authentication codes that are calculated by using a cryptographic hash function combined with a secret key.</span></span> <span data-ttu-id="bff1c-183">이 문서의 뒷부분에 있는 [해시 값](#hash-values)을 참조 하세요.)</span><span class="sxs-lookup"><span data-stu-id="bff1c-183">See [Hash Values](#hash-values), later in this article.)</span></span>

## <a name="public-key-encryption"></a><span data-ttu-id="bff1c-184">공개 키 암호화</span><span class="sxs-lookup"><span data-stu-id="bff1c-184">Public-Key Encryption</span></span>

<span data-ttu-id="bff1c-185">퍼블릭 키 암호화에서는 권한이 없는 사용자에게 비밀로 유지되어야 하는 프라이빗 키와 모든 사람에게 퍼블릭될 수 있는 퍼블릭 키를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-185">Public-key encryption uses a private key that must be kept secret from unauthorized users and a public key that can be made public to anyone.</span></span> <span data-ttu-id="bff1c-186">퍼블릭 키와 프라이빗 키는 수학적으로 연결되어 있습니다. 퍼블릭 키로 암호화된 데이터는 해당 프라이빗 키로만 해독할 수 있으며, 프라이빗 키로 서명된 데이터는 해당 퍼블릭 키로만 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-186">The public key and the private key are mathematically linked; data that is encrypted with the public key can be decrypted only with the private key, and data that is signed with the private key can be verified only with the public key.</span></span> <span data-ttu-id="bff1c-187">퍼블릭 키는 모든 사람이 사용할 수 있습니다. 퍼블릭 키는 프라이빗 키의 보유자에게 보낼 데이터를 암호화하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-187">The public key can be made available to anyone; it is used for encrypting data to be sent to the keeper of the private key.</span></span> <span data-ttu-id="bff1c-188">공개 키 암호화 알고리즘은 데이터를 암호화하는 데 필요한 키와 해독하는 데 필요한 키가 서로 다르므로 비대칭 알고리즘이라고도 합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-188">Public-key cryptographic algorithms are also known as asymmetric algorithms because one key is required to encrypt data, and another key is required to decrypt data.</span></span> <span data-ttu-id="bff1c-189">기본적인 암호화 규칙은 키 재사용을 금지하며, 두 키가 모두 각 통신 세션에 고유해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-189">A basic cryptographic rule prohibits key reuse, and both keys should be unique for each communication session.</span></span> <span data-ttu-id="bff1c-190">그러나 실제로는, 일반적으로 비대칭 키가 수명이 깁니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-190">However, in practice, asymmetric keys are generally long-lived.</span></span>

<span data-ttu-id="bff1c-191">두 당사자인 Alice와 Bob은 다음과 같이 퍼블릭 키 암호화를 사용할 수 있습니다. 즉, 먼저 Alice가 퍼블릭/프라이빗 키 쌍을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-191">Two parties (Alice and Bob) might use public-key encryption as follows: First, Alice generates a public/private key pair.</span></span> <span data-ttu-id="bff1c-192">Bob은 Alice에게 암호화된 메시지를 보내려는 경우 Alice의 공개 키를 묻습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-192">If Bob wants to send Alice an encrypted message, he asks her for her public key.</span></span> <span data-ttu-id="bff1c-193">Alice는 안전하지 않은 네트워크를 통해 Bob에게 공개 키를 보내고 Bob은 이 키를 사용하여 메시지를 암호화합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-193">Alice sends Bob her public key over a nonsecure network, and Bob uses this key to encrypt a message.</span></span> <span data-ttu-id="bff1c-194">Bob은 암호화된 메시지를 Alice에게 보내고 Alice는 자신의 프라이빗 키를 사용하여 메시지를 해독합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-194">Bob sends the encrypted message to Alice, and she decrypts it by using her private key.</span></span> <span data-ttu-id="bff1c-195">Bob이 공용 네트워크와 같은 안전하지 않은 채널을 통해 Alice의 키를 받은 경우 Bob은 메시지 가로채기(man-in-the-middle) 공격에 노출될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-195">If Bob received Alice's key over a nonsecure channel, such as a public network, Bob is open to a man-in-the-middle attack.</span></span> <span data-ttu-id="bff1c-196">따라서 Bob은 자신이 공개 키의 정확한 복사본을 가졌는지 Alice에게 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-196">Therefore, Bob must verify with Alice that he has a correct copy of her public key.</span></span>

<span data-ttu-id="bff1c-197">Alice의 공개 키를 전송하는 동안 권한이 없는 제3자가 키를 가로챌 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-197">During the transmission of Alice's public key, an unauthorized agent might intercept the key.</span></span> <span data-ttu-id="bff1c-198">또한 동일한 제3자가 Bob으로부터 암호화된 메시지를 가로챌 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-198">Furthermore, the same agent might intercept the encrypted message from Bob.</span></span> <span data-ttu-id="bff1c-199">그러나 제3자는 공개 키를 사용하여 메시지를 해독할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-199">However, the agent cannot decrypt the message with the public key.</span></span> <span data-ttu-id="bff1c-200">전송되지 않은 Alice의 프라이빗 키를 사용해서만 메시지를 해독할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-200">The message can be decrypted only with Alice's private key, which has not been transmitted.</span></span> <span data-ttu-id="bff1c-201">Alice는 Bob에게 보내는 회신 메시지를 암호화하는 데 자신의 프라이빗 키를 사용하지 않습니다. 퍼블릭 키를 가진 사람이 해당 메시지를 해독할 수 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-201">Alice does not use her private key to encrypt a reply message to Bob, because anyone with the public key could decrypt the message.</span></span> <span data-ttu-id="bff1c-202">Alice가 Bob에게 메시지를 다시 보내려는 경우 Bob에게 그의 공개 키를 묻고 해당 공개 키를 사용하여 메시지를 암호화합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-202">If Alice wants to send a message back to Bob, she asks Bob for his public key and encrypts her message using that public key.</span></span> <span data-ttu-id="bff1c-203">그러면 Bob은 자신의 연결된 프라이빗 키를 사용하여 메시지를 해독합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-203">Bob then decrypts the message using his associated private key.</span></span>

<span data-ttu-id="bff1c-204">이 시나리오에서 Alice와 Bob은 공개 키(비대칭) 암호화를 사용하여 비밀(대칭) 키를 전송하고 나머지 세션에 비밀 키 암호화를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-204">In this scenario, Alice and Bob use public-key (asymmetric) encryption to transfer a secret (symmetric) key and use secret-key encryption for the remainder of their session.</span></span>

<span data-ttu-id="bff1c-205">다음은 공개 키와 비밀 키 암호화 알고리즘을 비교한 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-205">The following list offers comparisons between public-key and secret-key cryptographic algorithms:</span></span>

- <span data-ttu-id="bff1c-206">공개 키 암호화 알고리즘에서는 고정 버퍼 크기를 사용하는 반면 비밀 키 암호화 알고리즘에서는 가변 길이 버퍼를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-206">Public-key cryptographic algorithms use a fixed buffer size, whereas secret-key cryptographic algorithms use a variable-length buffer.</span></span>

- <span data-ttu-id="bff1c-207">공개 키 알고리즘에서는 적은 양의 데이터만 암호화할 수 있으므로 비밀 키 알고리즘과 같이 데이터를 스트림으로 결합하는 데 사용할 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-207">Public-key algorithms cannot be used to chain data together into streams the way secret-key algorithms can, because only small amounts of data can be encrypted.</span></span> <span data-ttu-id="bff1c-208">따라서 비대칭 작업에서는 대칭 작업에서와 동일한 스트리밍 모델을 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-208">Therefore, asymmetric operations do not use the same streaming model as symmetric operations.</span></span>

- <span data-ttu-id="bff1c-209">공개 키 암호화는 비밀 키 암호화보다 키 공간(키에 사용할 수 있는 값의 범위)이 훨씬 큽니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-209">Public-key encryption has a much larger keyspace (range of possible values for the key) than secret-key encryption.</span></span> <span data-ttu-id="bff1c-210">따라서 공개 키 암호화는 가능한 모든 키를 시도하는 철저한 공격에 덜 취약합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-210">Therefore, public-key encryption is less susceptible to exhaustive attacks that try every possible key.</span></span>

- <span data-ttu-id="bff1c-211">보낸 사람의 ID를 확인할 방법이 몇 가지 있다면 공개 키는 보호할 필요가 없으므로 손쉽게 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-211">Public keys are easy to distribute because they do not have to be secured, provided that some way exists to verify the identity of the sender.</span></span>

- <span data-ttu-id="bff1c-212">디지털 서명을 생성하는 데 일부 공개 키 알고리즘(예: RSA 및 DSA 단, Diffie-Hellman 제외)을 사용하면 데이터를 보낸 사람의 ID를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-212">Some public-key algorithms (such as RSA and DSA, but not Diffie-Hellman) can be used to create digital signatures to verify the identity of the sender of data.</span></span>

- <span data-ttu-id="bff1c-213">공개 키 알고리즘은 비밀 키 알고리즘과 비교하면 매우 느리므로 대규모 데이터를 암호화할 때는 적합하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-213">Public-key algorithms are very slow compared with secret-key algorithms, and are not designed to encrypt large amounts of data.</span></span> <span data-ttu-id="bff1c-214">공개 키 알고리즘은 매우 적은 양의 데이터를 전송하는 데만 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-214">Public-key algorithms are useful only for transferring very small amounts of data.</span></span> <span data-ttu-id="bff1c-215">일반적으로 공개 키 암호화는 비밀 키 알고리즘에서 사용하는 키 및 IV를 암호화하는 데 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-215">Typically, public-key encryption is used to encrypt a key and IV to be used by a secret-key algorithm.</span></span> <span data-ttu-id="bff1c-216">키 및 IV가 전송되면 비밀 키 암호화가 나머지 세션에서 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-216">After the key and IV are transferred, secret-key encryption is used for the remainder of the session.</span></span>

<span data-ttu-id="bff1c-217">.NET에서는 공개 키 알고리즘을 구현 하는 다음 클래스를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-217">.NET provides the following classes that implement public-key algorithms:</span></span>

- <xref:System.Security.Cryptography.RSA>

- <xref:System.Security.Cryptography.ECDsa>

- <xref:System.Security.Cryptography.ECDiffieHellman>

- <xref:System.Security.Cryptography.DSA>

<span data-ttu-id="bff1c-218">RSA는 암호화 및 서명을 모두 허용 하지만 서명에만 DSA를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-218">RSA allows both encryption and signing, but DSA can be used only for signing.</span></span> <span data-ttu-id="bff1c-219">DSA는 RSA 만큼 안전 하지 않으며 RSA를 권장 합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-219">DSA is not as secure as RSA, and we recommend RSA.</span></span> <span data-ttu-id="bff1c-220">키 생성에만 Diffie-Hellman을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-220">Diffie-Hellman can be used only for key generation.</span></span> <span data-ttu-id="bff1c-221">일반적으로 퍼블릭 키 알고리즘은 비밀 키 알고리즘보다 용도가 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-221">In general, public-key algorithms are more limited in their uses than private-key algorithms.</span></span>

## <a name="digital-signatures"></a><span data-ttu-id="bff1c-222">디지털 서명</span><span class="sxs-lookup"><span data-stu-id="bff1c-222">Digital Signatures</span></span>

<span data-ttu-id="bff1c-223">공개 키 알고리즘은 디지털 서명을 만드는 데도 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-223">Public-key algorithms can also be used to form digital signatures.</span></span> <span data-ttu-id="bff1c-224">디지털 서명은 보낸 사람의 공개 키를 신뢰하는 경우 보낸 사람의 ID를 인증하고, 데이터 무결성 보호를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-224">Digital signatures authenticate the identity of a sender (if you trust the sender's public key) and help protect the integrity of data.</span></span> <span data-ttu-id="bff1c-225">Alice의 데이터를 받는 사람은 Alice가 생성한 공개 키를 사용하여 해당 디지털 서명을 Alice의 데이터 및 공개 키와 비교함으로써 Alice가 해당 데이터를 보냈는지 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-225">Using a public key generated by Alice, the recipient of Alice's data can verify that Alice sent it by comparing the digital signature to Alice's data and Alice's public key.</span></span>

<span data-ttu-id="bff1c-226">공개 키 암호화를 사용하여 메시지에 디지털 서명을 추가하기 위해 Alice는 먼저 메시지에 해시 알고리즘을 적용하여 메시지 다이제스트를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-226">To use public-key cryptography to digitally sign a message, Alice first applies a hash algorithm to the message to create a message digest.</span></span> <span data-ttu-id="bff1c-227">이 메시지 다이제스트는 데이터의 압축된 고유 표현입니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-227">The message digest is a compact and unique representation of data.</span></span> <span data-ttu-id="bff1c-228">그런 다음 Alice는 자신의 프라이빗 키를 사용하여 메시지 다이제스트를 암호화하고 자신의 개인 서명을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-228">Alice then encrypts the message digest with her private key to create her personal signature.</span></span> <span data-ttu-id="bff1c-229">Bob은 메시지와 서명을 받으면 Alice의 공개 키를 사용하여 서명을 해독하고 메시지 다이제스트를 복구하고 Alice가 사용한 것과 동일한 해시 알고리즘을 사용하여 메시지를 해시합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-229">Upon receiving the message and signature, Bob decrypts the signature using Alice's public key to recover the message digest and hashes the message using the same hash algorithm that Alice used.</span></span> <span data-ttu-id="bff1c-230">Bob이 계산한 메시지 다이제스트가 Alice로부터 받은 메시지 다이제스트와 정확히 일치하면 Bob은 해당 메시지가 프라이빗 키의 소유자로부터 왔으며 데이터가 수정되지 않았음을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-230">If the message digest that Bob computes exactly matches the message digest received from Alice, Bob is assured that the message came from the possessor of the private key and that the data has not been modified.</span></span> <span data-ttu-id="bff1c-231">Bob이 프라이빗 키의 소유자가 Alice임을 신뢰하는 경우 해당 메시지를 Alice가 보냈음을 알게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-231">If Bob trusts that Alice is the possessor of the private key, he knows that the message came from Alice.</span></span>

> [!NOTE]
> <span data-ttu-id="bff1c-232">보낸 사람의 공개 키는 공개된 정보이고 일반적으로 디지털 서명 형식에 포함되므로 누구나 서명을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-232">A signature can be verified by anyone because the sender's public key is common knowledge and is typically included in the digital signature format.</span></span> <span data-ttu-id="bff1c-233">이 방법이 메시지의 기밀성을 유지하지는 않으므로 메시지의 기밀을 위해서는 메시지에 대한 암호화도 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-233">This method does not retain the secrecy of the message; for the message to be secret, it must also be encrypted.</span></span>

<span data-ttu-id="bff1c-234">.NET에서는 디지털 서명 알고리즘을 구현 하는 다음 클래스를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-234">.NET provides the following classes that implement digital signature algorithms:</span></span>

- <xref:System.Security.Cryptography.RSA>

- <xref:System.Security.Cryptography.ECDsa>

- <xref:System.Security.Cryptography.DSA>

## <a name="hash-values"></a><span data-ttu-id="bff1c-235">해시 값</span><span class="sxs-lookup"><span data-stu-id="bff1c-235">Hash Values</span></span>

<span data-ttu-id="bff1c-236">해시 알고리즘은 임의 길이의 이진 값을 해시 값으로 알려진 고정된 길이의 더욱 작은 이진 값에 매핑합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-236">Hash algorithms map binary values of an arbitrary length to smaller binary values of a fixed length, known as hash values.</span></span> <span data-ttu-id="bff1c-237">해시 값은 데이터 부분을 숫자로 나타낸 값입니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-237">A hash value is a numerical representation of a piece of data.</span></span> <span data-ttu-id="bff1c-238">일반 텍스트 단락을 해시하고 단락의 한 문자만 변경해도 그다음 해시는 다른 값을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-238">If you hash a paragraph of plaintext and change even one letter of the paragraph, a subsequent hash will produce a different value.</span></span> <span data-ttu-id="bff1c-239">해시가 강력하게 암호화되면 해당 값이 크게 변경됩니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-239">If the hash is cryptographically strong, its value will change significantly.</span></span> <span data-ttu-id="bff1c-240">예를 들어 메시지 중 1비트만 변경되어도 강력한 해시 함수는 50%까지 다른 출력을 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-240">For example, if a single bit of a message is changed, a strong hash function may produce an output that differs by 50 percent.</span></span> <span data-ttu-id="bff1c-241">여러 입력 값이 동일한 출력 값으로 해시될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-241">Many input values may hash to the same output value.</span></span> <span data-ttu-id="bff1c-242">그러나 동일한 값으로 해시되는 두 개의 고유한 입력을 찾는 것은 계산상 불가능합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-242">However, it is computationally infeasible to find two distinct inputs that hash to the same value.</span></span>

<span data-ttu-id="bff1c-243">두 당사자, Alice와 Bob은 해시 함수를 사용하여 메시지 무결성을 보장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-243">Two parties (Alice and Bob) could use a hash function to ensure message integrity.</span></span> <span data-ttu-id="bff1c-244">이를 위해 메시지에 서명할 해시 알고리즘을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-244">They would select a hash algorithm to sign their messages.</span></span> <span data-ttu-id="bff1c-245">Alice는 메시지를 작성한 후 선택한 알고리즘을 사용하여 해당 메시지의 해시를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-245">Alice would write a message, and then create a hash of that message by using the selected algorithm.</span></span> <span data-ttu-id="bff1c-246">그런 다음 아래 방법 중 하나를 따릅니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-246">They would then follow one of the following methods:</span></span>

- <span data-ttu-id="bff1c-247">Alice는 일반 텍스트 메시지와 해시된 메시지(디지털 서명)를 Bob에게 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-247">Alice sends the plaintext message and the hashed message (digital signature) to Bob.</span></span> <span data-ttu-id="bff1c-248">Bob은 메시지를 받아 해시하고 자신의 해시 값과 Alice로부터 받은 해시 값을 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-248">Bob receives and hashes the message and compares his hash value to the hash value that he received from Alice.</span></span> <span data-ttu-id="bff1c-249">해시 값이 동일하면 메시지가 변경되지 않은 것입니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-249">If the hash values are identical, the message was not altered.</span></span> <span data-ttu-id="bff1c-250">값이 동일하지 않으면 Alice가 메시지를 작성한 후 해당 메시지가 변경된 것입니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-250">If the values are not identical, the message was altered after Alice wrote it.</span></span>

  <span data-ttu-id="bff1c-251">하지만 이 방법이 보낸 사람의 신뢰성을 보장하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-251">Unfortunately, this method does not establish the authenticity of the sender.</span></span> <span data-ttu-id="bff1c-252">다른 사람이 Alice를 가장하여 Bob에게 메시지를 보낼 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-252">Anyone can impersonate Alice and send a message to Bob.</span></span> <span data-ttu-id="bff1c-253">Alice와 Bob이 동일한 해시 알고리즘을 사용하여 메시지에 서명할 수 있는데 이때 Bob은 메시지와 해당 서명이 일치한다는 사실만 확인하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-253">They can use the same hash algorithm to sign their message, and all Bob can determine is that the message matches its signature.</span></span> <span data-ttu-id="bff1c-254">이는 메시지 가로채기(man-in-the-middle) 공격의 한 가지 형태입니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-254">This is one form of a man-in-the-middle attack.</span></span> <span data-ttu-id="bff1c-255">자세한 내용은 [CNG (Cryptography Next generation) 보안 통신 예제](/previous-versions/cc488018(v=vs.100))를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="bff1c-255">For more information, see [Cryptography Next Generation (CNG) Secure Communication Example](/previous-versions/cc488018(v=vs.100)).</span></span>

- <span data-ttu-id="bff1c-256">Alice가 비보안 공용 채널을 통해 Bob에게 일반 텍스트 메시지를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-256">Alice sends the plaintext message to Bob over a nonsecure public channel.</span></span> <span data-ttu-id="bff1c-257">그리고 보안 개인 채널을 통해 Bob에게 해시된 메시지를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-257">She sends the hashed message to Bob over a secure private channel.</span></span> <span data-ttu-id="bff1c-258">Bob은 일반 텍스트 메시지를 받아 해시하고, 이 해시를 개인 채널로 교환된 해시와 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-258">Bob receives the plaintext message, hashes it, and compares the hash to the privately exchanged hash.</span></span> <span data-ttu-id="bff1c-259">해시가 일치하면 Bob은 다음 두 가지 사실을 알게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-259">If the hashes match, Bob knows two things:</span></span>

  - <span data-ttu-id="bff1c-260">메시지가 변경되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-260">The message was not altered.</span></span>

  - <span data-ttu-id="bff1c-261">메시지를 보낸 사람(Alice)이 인증되었습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-261">The sender of the message (Alice) is authentic.</span></span>

  <span data-ttu-id="bff1c-262">이 시스템이 작동되려면 Alice가 Bob을 제외한 모든 사람에게 원본 해시 값을 숨겨야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-262">For this system to work, Alice must hide her original hash value from all parties except Bob.</span></span>

- <span data-ttu-id="bff1c-263">Alice가 비보안 공용 채널을 통해 Bob에게 일반 텍스트 메시지를 보내고 공개적으로 볼 수 있는 자신의 웹 사이트에 해시된 메시지를 게시합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-263">Alice sends the plaintext message to Bob over a nonsecure public channel and places the hashed message on her publicly viewable Web site.</span></span>

  <span data-ttu-id="bff1c-264">이 방법을 사용하면 아무도 해시 값을 수정할 수 없으므로 메시지 변조를 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-264">This method prevents message tampering by preventing anyone from modifying the hash value.</span></span> <span data-ttu-id="bff1c-265">메시지와 해당 해시를 아무나 읽을 수 있지만, 해시 값은 Alice만 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-265">Although the message and its hash can be read by anyone, the hash value can be changed only by Alice.</span></span> <span data-ttu-id="bff1c-266">Alice를 가장하려는 공격자는 Alice의 웹 사이트에 액세스할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-266">An attacker who wants to impersonate Alice would require access to Alice's Web site.</span></span>

<span data-ttu-id="bff1c-267">이러한 방법 중 어떠한 방법을 사용해도 일반 텍스트로 전송되는 Alice의 메시지를 다른 사람이 읽지 못하게 할 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-267">None of the previous methods will prevent someone from reading Alice's messages, because they are transmitted in plaintext.</span></span> <span data-ttu-id="bff1c-268">일반적으로 완벽한 보안을 구현하려면 디지털 서명(메시지 서명)과 암호화가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-268">Full security typically requires digital signatures (message signing) and encryption.</span></span>

<span data-ttu-id="bff1c-269">.NET에서는 해시 알고리즘을 구현 하는 다음 클래스를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-269">.NET provides the following classes that implement hashing algorithms:</span></span>

- <span data-ttu-id="bff1c-270"><xref:System.Security.Cryptography.SHA256>.</span><span class="sxs-lookup"><span data-stu-id="bff1c-270"><xref:System.Security.Cryptography.SHA256>.</span></span>

- <span data-ttu-id="bff1c-271"><xref:System.Security.Cryptography.SHA384>.</span><span class="sxs-lookup"><span data-stu-id="bff1c-271"><xref:System.Security.Cryptography.SHA384>.</span></span>

- <span data-ttu-id="bff1c-272"><xref:System.Security.Cryptography.SHA512>.</span><span class="sxs-lookup"><span data-stu-id="bff1c-272"><xref:System.Security.Cryptography.SHA512>.</span></span>

<span data-ttu-id="bff1c-273">.NET에서는 및도 제공 <xref:System.Security.Cryptography.MD5> <xref:System.Security.Cryptography.SHA1> 합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-273">.NET also provides <xref:System.Security.Cryptography.MD5> and <xref:System.Security.Cryptography.SHA1>.</span></span> <span data-ttu-id="bff1c-274">그러나 MD5 및 SHA-1 알고리즘은 안전 하지 않은 것으로 확인 되었으므로 이제는 s h a-2를 대신 권장 합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-274">But the MD5 and SHA-1 algorithms have been found to be insecure, and SHA-2 is now recommended instead.</span></span> <span data-ttu-id="bff1c-275">S h a-2에는 SHA256, SHA384 및 SHA512가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-275">SHA-2 includes SHA256, SHA384, and SHA512.</span></span>

## <a name="random-number-generation"></a><span data-ttu-id="bff1c-276">난수 생성</span><span class="sxs-lookup"><span data-stu-id="bff1c-276">Random Number Generation</span></span>

<span data-ttu-id="bff1c-277">난수 생성은 여러 암호화 작업에 필수적입니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-277">Random number generation is integral to many cryptographic operations.</span></span> <span data-ttu-id="bff1c-278">예를 들어 암호화 키는 재현이 불가능하도록 가능한 한 무작위적이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-278">For example, cryptographic keys need to be as random as possible so that it is infeasible to reproduce them.</span></span> <span data-ttu-id="bff1c-279">암호화 난수 생성기는 계산상 1/2 이상의 확률로 예측할 수 없는 출력을 생성해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-279">Cryptographic random number generators must generate output that is computationally infeasible to predict with a probability that is better than one half.</span></span> <span data-ttu-id="bff1c-280">따라서 어떠한 다음 출력 비트 예측 방법도 임의 추측보다 더 잘 예측할 수 없어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-280">Therefore, any method of predicting the next output bit must not perform better than random guessing.</span></span> <span data-ttu-id="bff1c-281">.NET의 클래스는 난수 생성기를 사용 하 여 암호화 키를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-281">The classes in .NET use random number generators to generate cryptographic keys.</span></span>

<span data-ttu-id="bff1c-282"><xref:System.Security.Cryptography.RandomNumberGenerator> 클래스는 난수 생성기 알고리즘을 구현한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-282">The <xref:System.Security.Cryptography.RandomNumberGenerator> class is an implementation of a random number generator algorithm.</span></span>

## <a name="clickonce-manifests"></a><span data-ttu-id="bff1c-283">ClickOnce 매니페스트</span><span class="sxs-lookup"><span data-stu-id="bff1c-283">ClickOnce Manifests</span></span>

<span data-ttu-id="bff1c-284">다음 암호화 클래스를 사용 하 여 [ClickOnce 기술을](/visualstudio/deployment/clickonce-security-and-deployment)사용 하 여 배포 된 응용 프로그램의 매니페스트 서명에 대 한 정보를 가져오고 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-284">The following cryptography classes let you obtain and verify information about manifest signatures for applications that are deployed using [ClickOnce technology](/visualstudio/deployment/clickonce-security-and-deployment):</span></span>

- <span data-ttu-id="bff1c-285"><xref:System.Security.Cryptography.ManifestSignatureInformation> 클래스의 <xref:System.Security.Cryptography.ManifestSignatureInformation.VerifySignature%2A> 메서드 오버로드를 사용할 경우 매니페스트 서명에 대한 정보를 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-285">The <xref:System.Security.Cryptography.ManifestSignatureInformation> class obtains information about a manifest signature when you use its <xref:System.Security.Cryptography.ManifestSignatureInformation.VerifySignature%2A> method overloads.</span></span>

- <span data-ttu-id="bff1c-286"><xref:System.Security.ManifestKinds> 열거형을 사용하여 확인할 매니페스트를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-286">You can use the <xref:System.Security.ManifestKinds> enumeration to specify which manifests to verify.</span></span> <span data-ttu-id="bff1c-287">확인 결과는 <xref:System.Security.Cryptography.SignatureVerificationResult> 열거형 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-287">The result of the verification is one of the <xref:System.Security.Cryptography.SignatureVerificationResult> enumeration values.</span></span>

- <span data-ttu-id="bff1c-288"><xref:System.Security.Cryptography.ManifestSignatureInformationCollection> 클래스는 확인된 서명의 읽기 전용 <xref:System.Security.Cryptography.ManifestSignatureInformation> 개체 컬렉션을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-288">The <xref:System.Security.Cryptography.ManifestSignatureInformationCollection> class provides a read-only collection of <xref:System.Security.Cryptography.ManifestSignatureInformation> objects of the verified signatures.</span></span>

<span data-ttu-id="bff1c-289">또한 다음 클래스는 특정 서명 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-289">In addition, the following classes provide specific signature information:</span></span>

- <span data-ttu-id="bff1c-290"><xref:System.Security.Cryptography.StrongNameSignatureInformation> 은 매니페스트의 강력한 이름 서명 정보를 보유합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-290"><xref:System.Security.Cryptography.StrongNameSignatureInformation> holds the strong name signature information for a manifest.</span></span>

- <span data-ttu-id="bff1c-291"><xref:System.Security.Cryptography.X509Certificates.AuthenticodeSignatureInformation> 은 매니페스트의 Authenticode 서명 정보를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-291"><xref:System.Security.Cryptography.X509Certificates.AuthenticodeSignatureInformation> represents the Authenticode signature information for a manifest.</span></span>

- <span data-ttu-id="bff1c-292"><xref:System.Security.Cryptography.X509Certificates.TimestampInformation> 에는 Authenticode 서명의 타임스탬프에 대한 정보가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-292"><xref:System.Security.Cryptography.X509Certificates.TimestampInformation> contains information about the time stamp on an Authenticode signature.</span></span>

- <span data-ttu-id="bff1c-293"><xref:System.Security.Cryptography.X509Certificates.TrustStatus> 는 Authenticode 서명을 신뢰할 수 있는지 확인할 수 있는 간단한 방법을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-293"><xref:System.Security.Cryptography.X509Certificates.TrustStatus> provides a simple way to check whether an Authenticode signature is trusted.</span></span>

## <a name="cryptography-next-generation-cng-classes"></a><span data-ttu-id="bff1c-294">CNG(Cryptography Next Generation) 클래스</span><span class="sxs-lookup"><span data-stu-id="bff1c-294">Cryptography Next Generation (CNG) Classes</span></span>

<span data-ttu-id="bff1c-295">CNG(Cryptography Next Generation) 클래스는 네이티브 CNG 함수 관련 관리 래퍼를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-295">The Cryptography Next Generation (CNG) classes provide a managed wrapper around the native CNG functions.</span></span> <span data-ttu-id="bff1c-296">(CNG는 CryptoAPI를 대체 합니다.) 이러한 클래스는 이름의 일부로 "Cng"를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-296">(CNG is the replacement for CryptoAPI.) These classes have "Cng" as part of their names.</span></span> <span data-ttu-id="bff1c-297">CNG 래퍼 클래스의 핵심은 CNG 키의 스토리지 및 사용을 추상화하는 <xref:System.Security.Cryptography.CngKey> 키 컨테이너 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-297">Central to the CNG wrapper classes is the <xref:System.Security.Cryptography.CngKey> key container class, which abstracts the storage and use of CNG keys.</span></span> <span data-ttu-id="bff1c-298">이 클래스를 통해 키 쌍 또는 공개 키를 안전하게 저장하고 간단한 문자열 이름을 사용하여 참조할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-298">This class lets you store a key pair or a public key securely and refer to it by using a simple string name.</span></span> <span data-ttu-id="bff1c-299">타원 곡선 기반 <xref:System.Security.Cryptography.ECDsaCng> 서명 클래스 및 <xref:System.Security.Cryptography.ECDiffieHellmanCng> 암호화 클래스는 <xref:System.Security.Cryptography.CngKey> 개체를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-299">The elliptic curve-based <xref:System.Security.Cryptography.ECDsaCng> signature class and the <xref:System.Security.Cryptography.ECDiffieHellmanCng> encryption class can use <xref:System.Security.Cryptography.CngKey> objects.</span></span>

<span data-ttu-id="bff1c-300"><xref:System.Security.Cryptography.CngKey> 클래스는 키 열기, 생성, 삭제, 내보내기 등의 다양한 추가 작업에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-300">The <xref:System.Security.Cryptography.CngKey> class is used for a variety of additional operations, including opening, creating, deleting, and exporting keys.</span></span> <span data-ttu-id="bff1c-301">또한 네이티브 함수를 직접 호출할 때 사용할 기본 키 핸들에 대한 액세스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-301">It also provides access to the underlying key handle to use when calling native functions directly.</span></span>

<span data-ttu-id="bff1c-302">.NET에는 다음과 같은 다양 한 지원 CNG 클래스도 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-302">.NET also includes a variety of supporting CNG classes, such as the following:</span></span>

- <span data-ttu-id="bff1c-303"><xref:System.Security.Cryptography.CngProvider>는 키 스토리지 공급자를 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-303"><xref:System.Security.Cryptography.CngProvider> maintains a key storage provider.</span></span>

- <span data-ttu-id="bff1c-304"><xref:System.Security.Cryptography.CngAlgorithm> 은 CNG 알고리즘을 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-304"><xref:System.Security.Cryptography.CngAlgorithm> maintains a CNG algorithm.</span></span>

- <span data-ttu-id="bff1c-305"><xref:System.Security.Cryptography.CngProperty> 는 자주 사용되는 키 속성을 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-305"><xref:System.Security.Cryptography.CngProperty> maintains frequently used key properties.</span></span>

## <a name="see-also"></a><span data-ttu-id="bff1c-306">참고 항목</span><span class="sxs-lookup"><span data-stu-id="bff1c-306">See also</span></span>

- <span data-ttu-id="bff1c-307">[암호화 모델](cryptography-model.md) -기본 클래스 라이브러리에서 암호화가 구현 되는 방법에 대해 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="bff1c-307">[Cryptography Model](cryptography-model.md) - Describes how cryptography is implemented in the base class library.</span></span>
- [<span data-ttu-id="bff1c-308">플랫폼 간 암호화</span><span class="sxs-lookup"><span data-stu-id="bff1c-308">Cross-Platform Cryptography</span></span>](cross-platform-cryptography.md)
- [<span data-ttu-id="bff1c-309">패딩을 사용하는 CBC 모드 대칭 암호 해독의 타이밍 취약성</span><span class="sxs-lookup"><span data-stu-id="bff1c-309">Timing vulnerabilities with CBC-mode symmetric decryption using padding</span></span>](vulnerabilities-cbc-mode.md)
- [<span data-ttu-id="bff1c-310">ASP.NET Core 데이터 보호</span><span class="sxs-lookup"><span data-stu-id="bff1c-310">ASP.NET Core Data Protection</span></span>](/aspnet/core/security/data-protection/introduction)
