---
title: 주요 보안 개념
ms.date: 07/15/2020
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
- cpp
helpviewer_keywords:
- unauthorized access
- permissions [.NET]
- security [.NET], about security
ms.assetid: 3cfced4f-ea02-4e66-ae98-d69286363e98
ms.openlocfilehash: 259723b903377f7e79731e1ff79b3d512581102f
ms.sourcegitcommit: b7a8b09828bab4e90f66af8d495ecd7024c45042
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87555269"
---
# <a name="key-security-concepts"></a><span data-ttu-id="b25f8-102">주요 보안 개념</span><span class="sxs-lookup"><span data-stu-id="b25f8-102">Key Security Concepts</span></span>

> [!NOTE]
> <span data-ttu-id="b25f8-103">이 문서는 Windows에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b25f8-103">This article applies to Windows.</span></span>
>
> <span data-ttu-id="b25f8-104">ASP.NET Core에 대 한 자세한 내용은 [ASP.NET Core 보안 개요](https://docs.microsoft.com/aspnet/core/security/)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="b25f8-104">For information about ASP.NET Core, see [Overview of ASP.NET Core Security](https://docs.microsoft.com/aspnet/core/security/).</span></span>

<span data-ttu-id="b25f8-105">.NET에서는 역할 기반 보안 기능을 제공 하 여 모바일 코드에 대 한 보안 문제를 해결 하 고, 구성 요소에서 사용자가 수행할 수 있는 작업을 결정할 수 있는 지원을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="b25f8-105">.NET offers role-based security to help address security concerns about mobile code and to provide support that enables components to determine what users are authorized to do.</span></span>  
  
## <a name="type-safety-and-security"></a><span data-ttu-id="b25f8-106">형식 안전성 및 보안</span><span class="sxs-lookup"><span data-stu-id="b25f8-106">Type safety and security</span></span>  

<span data-ttu-id="b25f8-107">형식 안전 코드는 액세스 권한이 부여된 메모리 위치에만 액세스합니다.</span><span class="sxs-lookup"><span data-stu-id="b25f8-107">Type-safe code accesses only the memory locations it is authorized to access.</span></span> <span data-ttu-id="b25f8-108">이 설명에서 형식 안전성은 특히 메모리 형식 안전성을 가리키며 보다 광범위 한 형식 안전과 혼동 해서는 안 됩니다. 예를 들어 형식 안전 코드는 다른 개체의 전용 필드에서 값을 읽을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b25f8-108">(For this discussion, type safety specifically refers to memory type safety and should not be confused with type safety in a broader respect.) For example, type-safe code cannot read values from another object's private fields.</span></span> <span data-ttu-id="b25f8-109">잘 정의된 허용되는 방식으로만 형식에 액세스합니다.</span><span class="sxs-lookup"><span data-stu-id="b25f8-109">It accesses types only in well-defined, allowable ways.</span></span>  
  
<span data-ttu-id="b25f8-110">JIT(Just-In-Time) 컴파일 중에 선택적 검증 프로세스는 네이티브 기계어 코드로 JIT 컴파일될 메서드의 메타데이터 및 MSIL(Microsoft Intermediate Language)을 검사하여 형식이 안전한지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="b25f8-110">During just-in-time (JIT) compilation, an optional verification process examines the metadata and Microsoft intermediate language (MSIL) of a method to be JIT-compiled into native machine code to verify that they are type safe.</span></span> <span data-ttu-id="b25f8-111">코드에 검증을 건너뛸 수 있는 권한이 있으면 이 프로세스를 건너뜁니다.</span><span class="sxs-lookup"><span data-stu-id="b25f8-111">This process is skipped if the code has permission to bypass verification.</span></span> <span data-ttu-id="b25f8-112">검증에 대한 자세한 내용은 [관리되는 실행 프로세스](../managed-execution-process.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b25f8-112">For more information about verification, see [Managed Execution Process](../managed-execution-process.md).</span></span>  
  
<span data-ttu-id="b25f8-113">형식 안전성 검증은 관리 코드를 실행하기 위한 필수 사항이 아니지만 형식 안전성은 어셈블리 격리 및 보안 적용에서 중요한 역할을 합니다.</span><span class="sxs-lookup"><span data-stu-id="b25f8-113">Although verification of type safety is not mandatory to run managed code, type safety plays a crucial role in assembly isolation and security enforcement.</span></span> <span data-ttu-id="b25f8-114">코드 형식이 안전한 경우 공용 언어 런타임에서 어셈블리를 서로 완전히 격리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b25f8-114">When code is type safe, the common language runtime can completely isolate assemblies from each other.</span></span> <span data-ttu-id="b25f8-115">이 격리는 어셈블리가 서로 부정적인 영향을 줄 수 없도록 하며 애플리케이션 안정성을 향상시킵니다.</span><span class="sxs-lookup"><span data-stu-id="b25f8-115">This isolation helps ensure that assemblies cannot adversely affect each other and it increases application reliability.</span></span> <span data-ttu-id="b25f8-116">형식이 안전한 구성 요소는 서로 다른 수준에서 신뢰된 경우에도 동일한 프로세스에서 안전하게 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b25f8-116">Type-safe components can execute safely in the same process even if they are trusted at different levels.</span></span> <span data-ttu-id="b25f8-117">코드 형식이 안전하지 않은 경우 원치 않는 부작용이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b25f8-117">When code is not type safe, unwanted side effects can occur.</span></span> <span data-ttu-id="b25f8-118">예를 들면, 관리 코드가 네이티브(비관리) 코드로 호출되어 부정적인 작업을 수행하는 것을 런타임에서 방지할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b25f8-118">For example, the runtime cannot prevent managed code from calling into native (unmanaged) code and performing malicious operations.</span></span> <span data-ttu-id="b25f8-119">코드 형식이 안전하면 런타임의 보안 적용 메커니즘에서 권한이 없을 경우 네이티브 코드에 액세스하지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="b25f8-119">When code is type safe, the runtime's security enforcement mechanism ensures that it does not access native code unless it has permission to do so.</span></span> <span data-ttu-id="b25f8-120">형식이 안전하지 않은 모든 코드를 실행하려면 전달된 열거형 멤버 <xref:System.Security.Permissions.SecurityPermissionAttribute.SkipVerification%2A>과 함께 <xref:System.Security.Permissions.SecurityPermission>이 부여되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b25f8-120">All code that is not type safe must have been granted <xref:System.Security.Permissions.SecurityPermission> with the passed enum member <xref:System.Security.Permissions.SecurityPermissionAttribute.SkipVerification%2A> to run.</span></span>  
  
<span data-ttu-id="b25f8-121">자세한 내용은 [Code Access Security Basics](../../framework/misc/code-access-security-basics.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b25f8-121">For more information, see [Code Access Security Basics](../../framework/misc/code-access-security-basics.md).</span></span>  
  
## <a name="principal"></a><span data-ttu-id="b25f8-122">주 서버</span><span class="sxs-lookup"><span data-stu-id="b25f8-122">Principal</span></span>  

<span data-ttu-id="b25f8-123">보안 주체는 사용자의 ID 및 역할을 나타내고 사용자 대신 역할을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="b25f8-123">A principal represents the identity and role of a user and acts on the user's behalf.</span></span> <span data-ttu-id="b25f8-124">.NET의 역할 기반 보안은 다음 세 종류의 보안 주체를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="b25f8-124">Role-based security in .NET supports three kinds of principals:</span></span>  
  
- <span data-ttu-id="b25f8-125">일반 보안 주체는 Windows 사용자 및 역할과 독립적으로  존재하는 사용자와 역할을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="b25f8-125">Generic principals represent users and roles that exist independent of Windows users and roles.</span></span>  
  
- <span data-ttu-id="b25f8-126">Windows 보안 주체는 Windows 사용자와 해당 역할(또는 해당 Windows 그룹)을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="b25f8-126">Windows principals represent Windows users and their roles (or their Windows groups).</span></span> <span data-ttu-id="b25f8-127">Windows 보안 주체는 다른 사용자를 가장할 수 있습니다. 이는 해당 사용자에게 속하는 ID를 제공하는 동안 보안 주체가 사용자 대신 리소스에 액세스할 수 있음을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="b25f8-127">A Windows principal can impersonate another user, which means that the principal can access a resource on a user's behalf while presenting the identity that belongs to that user.</span></span>  
  
- <span data-ttu-id="b25f8-128">해당 특정 애플리케이션에 필요한 방식으로 애플리케이션에서 사용자 지정 보안 주체를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b25f8-128">Custom principals can be defined by an application in any way that is needed for that particular application.</span></span> <span data-ttu-id="b25f8-129">보안 주체의 ID 및 역할의 기본 개념을 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b25f8-129">They can extend the basic notion of the principal's identity and roles.</span></span>  
  
<span data-ttu-id="b25f8-130">자세한 내용은 [Principal 개체 및 Identity 개체](principal-and-identity-objects.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b25f8-130">For more information, see [Principal and Identity Objects](principal-and-identity-objects.md).</span></span>  
  
## <a name="authentication"></a><span data-ttu-id="b25f8-131">인증</span><span class="sxs-lookup"><span data-stu-id="b25f8-131">Authentication</span></span>  
<span data-ttu-id="b25f8-132">인증은 사용자 자격 증명을 검사하고 일부 권한에 대해 해당 자격 증명의 유효성을 검사하여 보안 주체의 ID를 찾고 확인하는 프로세스입니다.</span><span class="sxs-lookup"><span data-stu-id="b25f8-132">Authentication is the process of discovering and verifying the identity of a principal by examining the user's credentials and validating those credentials against some authority.</span></span> <span data-ttu-id="b25f8-133">인증 중에 얻은 정보를 코드에서 직접 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b25f8-133">The information obtained during authentication is directly usable by your code.</span></span> <span data-ttu-id="b25f8-134">.NET 역할 기반 보안을 사용 하 여 현재 사용자를 인증 하 고 해당 보안 주체가 코드에 액세스 하도록 허용할지 여부를 결정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b25f8-134">You can also use .NET role-based security to authenticate the current user and to determine whether to allow that principal to access your code.</span></span> <span data-ttu-id="b25f8-135">특정 역할에 대해 보안 주체를 인증하는 방법의 예는 <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A?displayProperty=nameWithType> 메서드 오버로드를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b25f8-135">See the overloads of the <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A?displayProperty=nameWithType> method for examples of how to authenticate the principal for specific roles.</span></span> <span data-ttu-id="b25f8-136">예를 들어 <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.String%29?displayProperty=nameWithType> 오버로드를 사용하여 현재 사용자가 Administrators 그룹의 멤버인지 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b25f8-136">For example, you can use the <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.String%29?displayProperty=nameWithType> overload to determine if the current user is a member of the Administrators group.</span></span>  
  
<span data-ttu-id="b25f8-137">현재 다양 한 인증 메커니즘이 사용 되며, 대부분은 .NET 역할 기반 보안과 함께 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b25f8-137">A variety of authentication mechanisms are used today, many of which can be used with .NET role-based security.</span></span> <span data-ttu-id="b25f8-138">가장 일반적으로 사용되는 메커니즘 중 일부는 기본, 다이제스트, Passport, 운영 체제(예: NTLM 또는 Kerberos) 또는 애플리케이션 정의 메커니즘입니다.</span><span class="sxs-lookup"><span data-stu-id="b25f8-138">Some of the most commonly used mechanisms are basic, digest, Passport, operating system (such as NTLM or Kerberos), or application-defined mechanisms.</span></span>  
  
### <a name="example"></a><span data-ttu-id="b25f8-139">예제</span><span class="sxs-lookup"><span data-stu-id="b25f8-139">Example</span></span>  

<span data-ttu-id="b25f8-140">다음 예제에서는 활성 보안 주체가 관리자여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b25f8-140">The following example requires that the active principal be an administrator.</span></span> <span data-ttu-id="b25f8-141">`name` 매개 변수는 `null`이므로 관리자인 모든 사용자가 요구를 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b25f8-141">The `name` parameter is `null`, which allows any user who is an administrator to pass the demand.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="b25f8-142">Windows Vista에서는 UAC(사용자 계정 컨트롤)가 사용자 권한을 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="b25f8-142">In Windows Vista, User Account Control (UAC) determines the privileges of a user.</span></span> <span data-ttu-id="b25f8-143">기본 제공 Administrators 그룹의 멤버인 경우 두 개의 런타임 액세스 토큰(표준 사용자 액세스 토큰 및 관리자 액세스 토큰)이 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="b25f8-143">If you are a member of the Built-in Administrators group, you are assigned two run-time access tokens: a standard user access token and an administrator access token.</span></span> <span data-ttu-id="b25f8-144">기본적으로 표준 사용자 역할이 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="b25f8-144">By default, you are in the standard user role.</span></span> <span data-ttu-id="b25f8-145">관리자 권한이 필요한 코드를 실행하려면 먼저 표준 사용자에서 관리자로 권한을 높여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b25f8-145">To execute the code that requires you to be an administrator, you must first elevate your privileges from standard user to administrator.</span></span> <span data-ttu-id="b25f8-146">애플리케이션 아이콘을 마우스 오른쪽 단추로 클릭하고 관리자로 실행하도록 지정하여 애플리케이션을 시작하면 이 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b25f8-146">You can do this when you start an application by right-clicking the application icon and indicating that you want to run as an administrator.</span></span>  
  
 [!code-cpp[Classic PrincipalPermission Example#1](../../../samples/snippets/cpp/VS_Snippets_CLR_Classic/classic PrincipalPermission Example/CPP/source.cpp#1)]
 [!code-csharp[Classic PrincipalPermission Example#1](../../../samples/snippets/csharp/VS_Snippets_CLR_Classic/classic PrincipalPermission Example/CS/source.cs#1)]
 [!code-vb[Classic PrincipalPermission Example#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic PrincipalPermission Example/VB/source.vb#1)]  
  
 <span data-ttu-id="b25f8-147">다음 예제에서는 보안 주체 및 보안 주체가 사용할 수 있는 역할의 ID를 확인하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="b25f8-147">The following example demonstrates how to determine the identity of the principal and the roles available to the principal.</span></span> <span data-ttu-id="b25f8-148">이 예제의 애플리케이션은 현재 사용자가 애플리케이션을 사용하도록 허용하는 역할에 있는지 확인하기 위한 것일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b25f8-148">An application of this example might be to confirm that the current user is in a role you allow for using your application.</span></span>  
  
 [!code-cpp[System.Security.Principal.WindowsBuiltInRole Example#1](../../../samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CPP/source.cpp#1)]
 [!code-csharp[System.Security.Principal.WindowsBuiltInRole Example#1](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CS/source.cs#1)]
 [!code-vb[System.Security.Principal.WindowsBuiltInRole Example#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/VB/source.vb#1)]  
  
## <a name="authorization"></a><span data-ttu-id="b25f8-149">권한 부여</span><span class="sxs-lookup"><span data-stu-id="b25f8-149">Authorization</span></span>  

<span data-ttu-id="b25f8-150">권한 부여는 보안 주체가 요청된 작업을 수행할 수 있는지 여부를 확인하는 프로세스입니다.</span><span class="sxs-lookup"><span data-stu-id="b25f8-150">Authorization is the process of determining whether a principal is allowed to perform a requested action.</span></span> <span data-ttu-id="b25f8-151">권한 부여는 인증 후 발생하며 보안 주체의 ID 및 역할에 대한 정보를 사용하여 보안 주체가 액세스할 수 있는 리소스를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="b25f8-151">Authorization occurs after authentication and uses information about the principal's identity and roles to determine what resources the principal can access.</span></span> <span data-ttu-id="b25f8-152">.NET 역할 기반 보안을 사용 하 여 권한 부여를 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b25f8-152">You can use .NET role-based security to implement authorization.</span></span>

## <a name="see-also"></a><span data-ttu-id="b25f8-153">참고 항목</span><span class="sxs-lookup"><span data-stu-id="b25f8-153">See also</span></span>

- [<span data-ttu-id="b25f8-154">ASP.NET Core 보안</span><span class="sxs-lookup"><span data-stu-id="b25f8-154">ASP.NET Core Security</span></span>](/aspnet/core/security/)
