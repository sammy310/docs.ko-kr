---
title: P/Invoke(플랫폼 호출)
description: .NET에서 P/Invoke를 통해 네이티브 함수를 호출하는 방법을 알아봅니다.
ms.date: 01/18/2019
ms.openlocfilehash: fa8b43edfba50fbc620f257c4e7caf1673f83235
ms.sourcegitcommit: 5f236cd78cf09593c8945a7d753e0850e96a0b80
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 01/07/2020
ms.locfileid: "75706307"
---
# <a name="platform-invoke-pinvoke"></a><span data-ttu-id="368c0-103">P/Invoke(플랫폼 호출)</span><span class="sxs-lookup"><span data-stu-id="368c0-103">Platform Invoke (P/Invoke)</span></span>

<span data-ttu-id="368c0-104">P/Invoke는 관리 코드에서 비관리형 라이브러리의 구조체, 콜백 및 함수에 액세스할 수 있는 기술입니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-104">P/Invoke is a technology that allows you to access structs, callbacks, and functions in unmanaged libraries from your managed code.</span></span> <span data-ttu-id="368c0-105">P/Invoke API는 대부분 `System` 및 `System.Runtime.InteropServices`라는 두 네임스페이스에 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-105">Most of the P/Invoke API is contained in two namespaces: `System` and `System.Runtime.InteropServices`.</span></span> <span data-ttu-id="368c0-106">이러한 두 네임스페이스를 사용하면 기본 구성 요소와 통신하는 방법을 설명하는 도구가 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-106">Using these two namespaces give you the tools to describe how you want to communicate with the native component.</span></span>

<span data-ttu-id="368c0-107">관리 코드에서 관리되지 않는 함수를 호출하는 가장 일반적인 예제에서 시작하겠습니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-107">Let’s start from the most common example, and that is calling unmanaged functions in your managed code.</span></span> <span data-ttu-id="368c0-108">명령줄 애플리케이션에서 메시지 상자를 표시하겠습니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-108">Let’s show a message box from a command-line application:</span></span>

[!code-csharp[MessageBox](~/samples/snippets/standard/interop/pinvoke/messagebox.cs)]

<span data-ttu-id="368c0-109">앞의 예제는 간단하지만 관리 코드에서 관리되지 않는 함수를 호출하는 데 필요한 사항을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-109">The previous example is simple, but it does show off what's needed to invoke unmanaged functions from managed code.</span></span> <span data-ttu-id="368c0-110">예제를 단계별로 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-110">Let’s step through the example:</span></span>

- <span data-ttu-id="368c0-111">줄 #1에서는 필요한 항목이 모두 포함되어 있는 `System.Runtime.InteropServices` 네임스페이스에 대한 using 문을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-111">Line #1 shows the using statement for the `System.Runtime.InteropServices` namespace that holds all the items needed.</span></span>
- <span data-ttu-id="368c0-112">줄 #7에서는 `DllImport` 특성을 도입합니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-112">Line #7 introduces the `DllImport` attribute.</span></span> <span data-ttu-id="368c0-113">이 특성은 관리되지 않는 DLL을 로드하도록 런타임에 지정하므로 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-113">This attribute is crucial, as it tells the runtime that it should load the unmanaged DLL.</span></span> <span data-ttu-id="368c0-114">전달된 문자열은 대상 함수가 있는 DLL입니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-114">The string passed in is the DLL our target function is in.</span></span> <span data-ttu-id="368c0-115">또한 문자열을 마샬링하는 데 사용할 [문자 집합](./charset.md)을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-115">Additionally, it specifies which [character set](./charset.md) to use for marshalling the strings.</span></span> <span data-ttu-id="368c0-116">마지막으로 이 함수가 [SetLastError](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror)를 호출하고 사용자가 <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error?displayProperty=nameWithType>을 통해 검색할 수 있게 런타임이 이 오류 코드를 캡처하도록 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-116">Finally, it specifies that this function calls [SetLastError](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror) and that the runtime should capture that error code so the user can retrieve it via <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="368c0-117">줄 #8은 P/Invoke 작업의 핵심입니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-117">Line #8 is the crux of the P/Invoke work.</span></span> <span data-ttu-id="368c0-118">관리되지 않는 메서드와 **동일한 시그니처**가 있는 관리되는 메서드를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-118">It defines a managed method that has the **exact same signature** as the unmanaged one.</span></span> <span data-ttu-id="368c0-119">선언에서 확인할 수 있는 새 키워드 `extern`은 이 메서드가 외부 메서드이며 호출 시 런타임이 `DllImport` 특성에 지정된 DLL에서 찾도록 런타임에 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-119">The declaration has a new keyword that you can notice, `extern`, which tells the runtime this is an external method, and that when you invoke it, the runtime should find it in the DLL specified in `DllImport` attribute.</span></span>

<span data-ttu-id="368c0-120">예제의 나머지 부분에서는 단순히 다른 관리되는 메서드와 마찬가지로 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-120">The rest of the example is just invoking the method as you would any other managed method.</span></span>

<span data-ttu-id="368c0-121">macOS에 대한 샘플도 이와 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-121">The sample is similar for macOS.</span></span> <span data-ttu-id="368c0-122">macOS에서는 다른 동적 라이브러리 명명 체계를 사용하므로 `DllImport` 특성의 라이브러리 이름을 변경해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-122">The name of the library in the `DllImport` attribute needs to change since macOS has a different scheme of naming dynamic libraries.</span></span> <span data-ttu-id="368c0-123">다음 샘플에서는 `getpid(2)` 함수를 사용하여 애플리케이션의 프로세스 ID를 가져오고 콘솔에 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-123">The following sample uses the `getpid(2)` function to get the process ID of the application and print it out to the console:</span></span>

[!code-csharp[getpid macOS](~/samples/snippets/standard/interop/pinvoke/getpid-macos.cs)]

<span data-ttu-id="368c0-124">Linux에서도 이와 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-124">It is also similar on Linux.</span></span> <span data-ttu-id="368c0-125">`getpid(2)`는 표준 [POSIX](https://en.wikipedia.org/wiki/POSIX) 시스템 호출이기 때문에 함수 이름이 같습니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-125">The function name is the same, since `getpid(2)` is a standard [POSIX](https://en.wikipedia.org/wiki/POSIX) system call.</span></span>

[!code-csharp[getpid Linux](~/samples/snippets/standard/interop/pinvoke/getpid-linux.cs)]

## <a name="invoking-managed-code-from-unmanaged-code"></a><span data-ttu-id="368c0-126">비관리 코드에서 관리 코드 호출</span><span class="sxs-lookup"><span data-stu-id="368c0-126">Invoking managed code from unmanaged code</span></span>

<span data-ttu-id="368c0-127">런타임에서 양방향 통신을 허용하므로 함수 포인터를 사용하여 네이티브 함수에서 관리 코드로 콜백할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-127">The runtime allows communication to flow in both directions, enabling you to call back into managed code from native functions by using function pointers.</span></span> <span data-ttu-id="368c0-128">관리 코드에서 함수 포인터와 가장 가까운 것은 **대리자**이므로, 대리자를 사용하여 네이티브 코드에서 관리 코드로의 콜백을 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-128">The closest thing to a function pointer in managed code is a **delegate**, so this is what is used to allow callbacks from native code into managed code.</span></span>

<span data-ttu-id="368c0-129">이 기능을 사용하는 방법은 앞에서 설명한 관리 코드에서 네이티브 코드로의 프로세스와 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-129">The way to use this feature is similar to the managed to native process previously described.</span></span> <span data-ttu-id="368c0-130">지정된 콜백에 대해 시그니처와 일치하는 대리자를 정의하고 외부 메서드에 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-130">For a given callback, you define a delegate that matches the signature and pass that into the external method.</span></span> <span data-ttu-id="368c0-131">다른 모든 작업은 런타임에서 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-131">The runtime will take care of everything else.</span></span>

[!code-csharp[EnumWindows](~/samples/snippets/standard/interop/pinvoke/enumwindows.cs)]

<span data-ttu-id="368c0-132">예제를 살펴보기 전에 작업해야 하는 관리되지 않는 함수의 시그니처를 검토하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-132">Before walking through the example, it's good to review the signatures of the unmanaged functions you need to work with.</span></span> <span data-ttu-id="368c0-133">모든 창을 열거하기 위해 호출할 함수에는 다음과 같은 시그니처가 있습니다. `BOOL EnumWindows (WNDENUMPROC lpEnumFunc, LPARAM lParam);`</span><span class="sxs-lookup"><span data-stu-id="368c0-133">The function to be called to enumerate all of the windows has the following signature: `BOOL EnumWindows (WNDENUMPROC lpEnumFunc, LPARAM lParam);`</span></span>

<span data-ttu-id="368c0-134">첫 번째 매개 변수는 콜백입니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-134">The first parameter is a callback.</span></span> <span data-ttu-id="368c0-135">이 콜백에는 다음과 같은 시그니처가 있습니다. `BOOL CALLBACK EnumWindowsProc (HWND hwnd, LPARAM lParam);`</span><span class="sxs-lookup"><span data-stu-id="368c0-135">The said callback has the following signature: `BOOL CALLBACK EnumWindowsProc (HWND hwnd, LPARAM lParam);`</span></span>

<span data-ttu-id="368c0-136">이제 예제를 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-136">Now, let’s walk through the example:</span></span>

- <span data-ttu-id="368c0-137">예제의 줄 #9에서는 비관리 코드의 콜백 시그니처와 일치하는 대리자를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-137">Line #9 in the example defines a delegate that matches the signature of the callback from unmanaged code.</span></span> <span data-ttu-id="368c0-138">관리 코드에서 `IntPtr`을 사용하여 LPARAM 및 HWND 형식을 나타내는 방법을 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-138">Notice how the LPARAM and HWND types are represented using `IntPtr` in the managed code.</span></span>
- <span data-ttu-id="368c0-139">줄 #13 및 #14에서는 user32.dll 라이브러리의 `EnumWindows` 함수를 도입합니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-139">Lines #13 and #14 introduce the `EnumWindows` function from the user32.dll library.</span></span>
- <span data-ttu-id="368c0-140">줄 #17-20에서는 대리자를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-140">Lines #17 - 20 implement the delegate.</span></span> <span data-ttu-id="368c0-141">이 간단한 예제에서는 단순히 핸들을 콘솔에 출력하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-141">For this simple example, we just want to output the handle to the console.</span></span>
- <span data-ttu-id="368c0-142">마지막으로, 줄 #24에서는 외부 메서드를 호출하고 대리자에 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-142">Finally, in line #24, the external method is called and passed in the delegate.</span></span>

<span data-ttu-id="368c0-143">Linux 및 macOS 예제는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-143">The Linux and macOS examples are shown below.</span></span> <span data-ttu-id="368c0-144">해당 예제에서는 C 라이브러리 `libc`에 있는 `ftw` 함수를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-144">For them, we use the `ftw` function that can be found in `libc`, the C library.</span></span> <span data-ttu-id="368c0-145">이 함수는 디렉터리 계층 구조를 트래버스하는 데 사용되며, 함수에 대한 포인터를 해당 매개 변수 중 하나로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-145">This function is used to traverse directory hierarchies and it takes a pointer to a function as one of its parameters.</span></span> <span data-ttu-id="368c0-146">이 함수에는 다음과 같은 시그니처가 있습니다. `int (*fn) (const char *fpath, const struct stat *sb, int typeflag)`.</span><span class="sxs-lookup"><span data-stu-id="368c0-146">The said function has the following signature: `int (*fn) (const char *fpath, const struct stat *sb, int typeflag)`.</span></span>

[!code-csharp[ftw Linux](~/samples/snippets/standard/interop/pinvoke/ftw-linux.cs)]

<span data-ttu-id="368c0-147">macOS 예제에서는 동일한 함수를 사용하며, macOS에서 `libc`가 다른 위치에 유지되므로 `DllImport` 특성에 대한 인수만 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-147">macOS example uses the same function, and the only difference is the argument to the `DllImport` attribute, as macOS keeps `libc` in a different place.</span></span>

[!code-csharp[ftw macOS](~/samples/snippets/standard/interop/pinvoke/ftw-macos.cs)]

<span data-ttu-id="368c0-148">앞의 두 예제에서는 매개 변수를 사용하며, 두 경우 모두 매개 변수가 관리형 형식으로 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-148">Both of the previous examples depend on parameters, and in both cases, the parameters are given as managed types.</span></span> <span data-ttu-id="368c0-149">런타임에서 “올바른 작업”을 수행하고 다른 쪽의 해당 항목으로 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-149">Runtime does the "right thing" and processes these into its equivalents on the other side.</span></span> <span data-ttu-id="368c0-150">[형식 마샬링](type-marshaling.md) 페이지에서 형식이 네이티브 코드로 마샬링되는 방법을 알아봅니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-150">Learn about how types are marshaled to native code in our page on [Type marshaling](type-marshaling.md).</span></span>

## <a name="more-resources"></a><span data-ttu-id="368c0-151">추가 리소스</span><span class="sxs-lookup"><span data-stu-id="368c0-151">More resources</span></span>

- <span data-ttu-id="368c0-152">[PInvoke.net wiki](https://www.pinvoke.net/)는 일반적인 Windows API 및 호출 방법에 대한 정보가 포함된 우수한 Wiki입니다.</span><span class="sxs-lookup"><span data-stu-id="368c0-152">[PInvoke.net wiki](https://www.pinvoke.net/) an excellent Wiki with information on common Windows APIs and how to call them.</span></span>
- [<span data-ttu-id="368c0-153">C++/CLI의 P/Invoke</span><span class="sxs-lookup"><span data-stu-id="368c0-153">P/Invoke in C++/CLI</span></span>](/cpp/dotnet/native-and-dotnet-interoperability)
- [<span data-ttu-id="368c0-154">P/Invoke에 대한 Mono 설명서</span><span class="sxs-lookup"><span data-stu-id="368c0-154">Mono documentation on P/Invoke</span></span>](https://www.mono-project.com/docs/advanced/pinvoke/)
