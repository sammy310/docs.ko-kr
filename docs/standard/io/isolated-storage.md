---
title: 격리된 스토리지
description: 코드와 저장된 데이터를 연결하는 표준화된 방법을 정의하여 격리와 안전을 제공하는 데이터 스토리지 메커니즘인 격리된 스토리지를 살펴봅니다.
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- data storage using isolated storage
- stores
- storing data using isolated storage
- isolated storage
- location of isolated storage in file system
- standardizing storage systems
- storing data using isolated storage, when not to use
- code, isolated storage
- isolated storage, options
- data storage using isolated storage, when not to use
- storing data using isolated storage, options
- isolated storage, when not to use
- data storage using isolated storage, options
- isolation
ms.assetid: aff939d7-9e49-46f2-a8cd-938d3020e94e
ms.openlocfilehash: 3699edda6cce24adb8e932d6e8b8a0a5bb977142
ms.sourcegitcommit: 74d05613d6c57106f83f82ce8ee71176874ea3f0
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/03/2020
ms.locfileid: "93282026"
---
# <a name="isolated-storage"></a><span data-ttu-id="802cb-103">격리된 스토리지</span><span class="sxs-lookup"><span data-stu-id="802cb-103">Isolated storage</span></span>

<span data-ttu-id="802cb-104">데스크톱 앱에서 격리된 스토리지는 코드와 저장된 데이터를 연결하는 표준화된 방법을 정의하여 격리와 안전을 제공하는 데이터 스토리지 메커니즘입니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-104">For desktop apps, isolated storage is a data storage mechanism that provides isolation and safety by defining standardized ways of associating code with saved data.</span></span> <span data-ttu-id="802cb-105">표준화를 통해 다음과 같은 여러 가지 이점도 활용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-105">Standardization provides other benefits as well.</span></span> <span data-ttu-id="802cb-106">관리자는 파일 스토리지 구성, 보안 정책 설정, 사용하지 않은 데이터 삭제를 위해 격리된 스토리지를 조작하는 도구를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-106">Administrators can use tools designed to manipulate isolated storage to configure file storage space, set security policies, and delete unused data.</span></span> <span data-ttu-id="802cb-107">격리된 스토리지를 사용하면 더 이상 파일 시스템에서 안전한 위치를 지정하기 위해 코드에 고유 경로를 포함할 필요가 없으며 격리된 스토리지에만 액세스할 수 있는 다른 애플리케이션으로부터 데이터가 보호됩니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-107">With isolated storage, your code no longer needs unique paths to specify safe locations in the file system, and data is protected from other applications that only have isolated storage access.</span></span> <span data-ttu-id="802cb-108">애플리케이션의 스토리지 영역 위치를 나타내는 하드 코드된 정보는 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-108">Hard-coded information that indicates where an application's storage area is located is unnecessary.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="802cb-109">Windows 8.x 스토어 앱에는 격리된 스토리지를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-109">Isolated storage is not available for Windows 8.x Store apps.</span></span> <span data-ttu-id="802cb-110">대신에 Windows Runtime API에 포함된 `Windows.Storage` 네임스페이스의 애플리케이션 데이터 클래스를 사용하여 로컬 데이터 및 파일을 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-110">Instead, use the application data classes in the `Windows.Storage` namespaces included in the Windows Runtime API to store local data and files.</span></span> <span data-ttu-id="802cb-111">자세한 내용은 Windows 개발자 센터에서 [애플리케이션 데이터](/previous-versions/windows/apps/hh464917(v=win.10)) 를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="802cb-111">For more information, see [Application data](/previous-versions/windows/apps/hh464917(v=win.10)) in the Windows Dev Center.</span></span>

<a name="data_compartments_and_stores"></a>

## <a name="data-compartments-and-stores"></a><span data-ttu-id="802cb-112">데이터 구획 및 저장소</span><span class="sxs-lookup"><span data-stu-id="802cb-112">Data Compartments and Stores</span></span>

<span data-ttu-id="802cb-113">애플리케이션이 데이터를 파일에 저장할 때 스토리지 위치가 다른 애플리케이션에 알려져 손상될 가능성을 최소화할 수 있도록 파일 이름과 스토리지 위치를 신중하게 선택해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-113">When an application stores data in a file, the file name and storage location must be carefully chosen to minimize the possibility that the storage location will be known to another application and, therefore, vulnerable to corruption.</span></span> <span data-ttu-id="802cb-114">이러한 문제를 관리할 적절한 표준 시스템 없이 스토리지 충돌을 최소화하는 기법을 즉흥적으로 만드는 것은 복잡할 수 있으며 결과를 신뢰할 수도 없습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-114">Without a standard system in place to manage these problems, improvising techniques that minimize storage conflicts can be complex, and the results can be unreliable.</span></span>

<span data-ttu-id="802cb-115">격리된 스토리지를 사용하면 데이터는 항상 사용자와 어셈블리별로 격리됩니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-115">With isolated storage, data is always isolated by user and by assembly.</span></span> <span data-ttu-id="802cb-116">어셈블리의 원본 또는 강력한 이름과 같은 자격 증명은 어셈블리 ID를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-116">Credentials such as the origin or the strong name of the assembly determine assembly identity.</span></span> <span data-ttu-id="802cb-117">또한 유사한 자격 증명을 사용하여 데이터가 애플리케이션 도메인별로 격리될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-117">Data can also be isolated by application domain, using similar credentials.</span></span>

<span data-ttu-id="802cb-118">격리된 스토리지를 사용하는 경우, 애플리케이션은 게시자 또는 서명 등과 같은 코드 ID의 몇 가지 측면과 관련된 고유 데이터 구획에 데이터를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-118">When you use isolated storage, your application saves data to a unique data compartment that is associated with some aspect of the code's identity, such as its publisher or signature.</span></span> <span data-ttu-id="802cb-119">데이터 컴파트먼트는 특정 스토리지 위치가 아니라 추상적인 개념이며 스토리지라고 하는 하나 이상의 격리된 스토리지 파일로 구성됩니다. 이 스토리지는 데이터가 저장되는 실제 디렉터리 위치를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-119">The data compartment is an abstraction, not a specific storage location; it consists of one or more isolated storage files, called stores, which contain the actual directory locations where data is stored.</span></span> <span data-ttu-id="802cb-120">예를 들어, 애플리케이션은 관련된 데이터 구획을 가질 수 있고 파일 시스템의 디렉터리는 이 애플리케이션의 데이터를 실제로 유지하는 저장소를 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-120">For example, an application might have a data compartment associated with it, and a directory in the file system would implement the store that actually preserves the data for that application.</span></span> <span data-ttu-id="802cb-121">저장소에 저장된 데이터는 사용자 기본 설정 정보에서 애플리케이션 상태에 이르기까지 모든 종류의 데이터가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-121">The data saved in the store can be any kind of data, from user preference information to application state.</span></span> <span data-ttu-id="802cb-122">개발자의 경우, 데이터 구획의 위치는 투명합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-122">For the developer, the location of the data compartment is transparent.</span></span> <span data-ttu-id="802cb-123">저장소는 보통 클라이언트에 있지만, 서버 애플리케이션은 사용자를 대신하여 관련 기능을 수행하면서 그 사용자를 가장하여 정보를 저장하는 격리된 저장소를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-123">Stores usually reside on the client, but a server application could use isolated stores to store information by impersonating the user on whose behalf it is functioning.</span></span> <span data-ttu-id="802cb-124">또한 격리된 스토리지는 로밍 사용자와 함께 정보가 이동되도록 사용자의 로밍 프로필과 함께 서버의 정보를 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-124">Isolated storage can also store information on a server with a user's roaming profile so that the information will travel with the roaming user.</span></span>

<a name="quotas"></a>

## <a name="quotas-for-isolated-storage"></a><span data-ttu-id="802cb-125">격리된 스토리지의 할당량</span><span class="sxs-lookup"><span data-stu-id="802cb-125">Quotas for Isolated Storage</span></span>

<span data-ttu-id="802cb-126">할당 한도는 사용 가능한 격리된 스토리지 크기의 제한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-126">A quota is a limit on the amount of isolated storage that can be used.</span></span> <span data-ttu-id="802cb-127">디렉터리 및 저장소의 다른 정보와 관련된 오버헤드는 물론 파일 공간(바이트)을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-127">The quota includes bytes of file space as well as the overhead associated with the directory and other information in the store.</span></span> <span data-ttu-id="802cb-128">격리된 스토리지는 <xref:System.Security.Permissions.IsolatedStoragePermission> 개체를 사용하여 설정된 스토리지의 제한에 해당하는 사용 권한 할당을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-128">Isolated storage uses permission quotas, which are storage limits that are set by using <xref:System.Security.Permissions.IsolatedStoragePermission> objects.</span></span> <span data-ttu-id="802cb-129">할당량을 초과하는 데이터를 쓰려고 하면 <xref:System.IO.IsolatedStorage.IsolatedStorageException> 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-129">If you try to write data that exceeds the quota, an <xref:System.IO.IsolatedStorage.IsolatedStorageException> exception is thrown.</span></span>  <span data-ttu-id="802cb-130">.NET Framework 구성 도구(Mscorcfg.msc)를 사용하여 수정할 수 있는 보안 정책에 따라 코드에 부여될 권한이 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-130">Security policy, which can be modified using the .NET Framework Configuration Tool (Mscorcfg.msc), determines which permissions are granted to code.</span></span> <span data-ttu-id="802cb-131"><xref:System.Security.Permissions.IsolatedStoragePermission> 권한이 부여된 코드는 <xref:System.Security.Permissions.IsolatedStoragePermission.UserQuota%2A> 속성이 허용하는 수준의 스토리지만 사용하도록 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-131">Code that has been granted <xref:System.Security.Permissions.IsolatedStoragePermission> is restricted to using no more storage than the <xref:System.Security.Permissions.IsolatedStoragePermission.UserQuota%2A> property allows.</span></span> <span data-ttu-id="802cb-132">그러나 코드에서 다른 사용자 ID를 제공하여 사용 권한 할당 한도를 무시할 수 있으므로 사용 권한 할당 한도는 코드 동작에 대해 고정된 제한이 아니라 코드 동작 방식에 대한 지침으로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-132">However, because code can bypass permission quotas by presenting different user identities, permission quotas serve as guidelines for how code should behave rather than as a firm limit on code behavior.</span></span>

<span data-ttu-id="802cb-133">로밍 저장소에는 할당 한도가 적용되지 않기 때문에</span><span class="sxs-lookup"><span data-stu-id="802cb-133">Quotas are not enforced on roaming stores.</span></span> <span data-ttu-id="802cb-134">코드에 약간 높은 수준의 사용 권한이 있어야 이를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-134">Because of this, a slightly higher level of permission is required for code to use them.</span></span> <span data-ttu-id="802cb-135">열거형 값 <xref:System.Security.Permissions.IsolatedStorageContainment.AssemblyIsolationByRoamingUser> 및 <xref:System.Security.Permissions.IsolatedStorageContainment.DomainIsolationByRoamingUser>는 로밍 사용자를 위한 격리된 스토리지를 사용하여 권한을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-135">The enumeration values <xref:System.Security.Permissions.IsolatedStorageContainment.AssemblyIsolationByRoamingUser> and <xref:System.Security.Permissions.IsolatedStorageContainment.DomainIsolationByRoamingUser> specify a permission to use isolated storage for a roaming user.</span></span>

<a name="secure_access"></a>

## <a name="secure-access"></a><span data-ttu-id="802cb-136">액세스 보안</span><span class="sxs-lookup"><span data-stu-id="802cb-136">Secure Access</span></span>

<span data-ttu-id="802cb-137">격리된 스토리지를 사용하면 부분적으로 신뢰할 수 있는 애플리케이션은 컴퓨터의 보안 정책에 의해 제어되는 방식으로 데이터를 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-137">Using isolated storage enables partially trusted applications to store data in a manner that is controlled by the computer's security policy.</span></span> <span data-ttu-id="802cb-138">이 방법은 특히 사용자가 주의하여 실행해야 하는 다운로드된 구성 요소에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-138">This is especially useful for downloaded components that a user might want to run cautiously.</span></span> <span data-ttu-id="802cb-139">표준 I/O 메커니즘을 사용하여 파일 시스템에 액세스하는 경우, 사용 권한을 이 유형의 코드에 부여하는 경우는 거의 없습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-139">Security policy rarely grants this kind of code permission when you access the file system by using standard I/O mechanisms.</span></span> <span data-ttu-id="802cb-140">그러나 격리된 스토리지를 사용할 권한은 로컬 컴퓨터, 로컬 네트워크 또는 인터넷에서 실행되는 코드에 기본적으로 부여됩니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-140">However, by default, code running from the local computer, a local network, or the Internet is granted the right to use isolated storage.</span></span>

<span data-ttu-id="802cb-141">관리자는 해당 신뢰 수준에 따라 애플리케이션 또는 사용자가 가질 수 있는 격리된 스토리지 양을 제한할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-141">Administrators can limit how much isolated storage an application or a user has available, based on an appropriate trust level.</span></span> <span data-ttu-id="802cb-142">또한 사용자의 지속된 데이터를 모두 제거할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-142">In addition, administrators can remove a user's persisted data completely.</span></span> <span data-ttu-id="802cb-143">격리된 스토리지를 만들거나 액세스하려면 코드에 적절한 <xref:System.Security.Permissions.IsolatedStorageFilePermission> 권한이 부여되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-143">To create or access isolated storage, code must be granted the appropriate <xref:System.Security.Permissions.IsolatedStorageFilePermission> permission.</span></span>

<span data-ttu-id="802cb-144">격리된 스토리지에 액세스하려면 필요한 네이티브 플랫폼 운영 체제 권한이 모두 코드에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-144">To access isolated storage, code must have all necessary native platform operating system rights.</span></span> <span data-ttu-id="802cb-145">파일 시스템을 사용할 수 있는 권한을 가진 사용자를 제어하는 ACL(액세스 제어 목록)이 충족되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-145">The access control lists (ACLs) that control which users have the rights to use the file system must be satisfied.</span></span> <span data-ttu-id="802cb-146">.NET 애플리케이션은 특정 플랫폼 관련 가장을 수행하는 경우를 제외하고는 격리된 스토리지에 액세스할 수 있는 운영 체제 권한을 이미 가지고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-146">.NET applications already have operating system rights to access isolated storage unless they perform (platform-specific) impersonation.</span></span> <span data-ttu-id="802cb-147">이런 경우 애플리케이션은 가장된 사용자 ID가 격리된 스토리지에 액세스할 수 있는 적절한 운영 체제 권한을 가지고 있는지 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-147">In this case, the application is responsible for ensuring that the impersonated user identity has the proper operating system rights to access isolated storage.</span></span> <span data-ttu-id="802cb-148">이 액세스 권한은 웹에서 실행되거나 다운로드된 코드에 특정 사용자와 관련된 스토리지 영역에서 읽고 쓸 수 있는 편리한 방법을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-148">This access provides a convenient way for code that is run or downloaded from the web to read and write to a storage area related to a particular user.</span></span>

<span data-ttu-id="802cb-149">격리된 스토리지에 대한 액세스를 제어하기 위해 공용 언어 런타임은 <xref:System.Security.Permissions.IsolatedStorageFilePermission> 개체를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-149">To control access to isolated storage, the common language runtime uses <xref:System.Security.Permissions.IsolatedStorageFilePermission> objects.</span></span> <span data-ttu-id="802cb-150">각 개체에는 다음과 같은 값을 지정하는 속성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-150">Each object has properties that specify the following values:</span></span>

- <span data-ttu-id="802cb-151">허용 수준 - 허용된 액세스 형식을 나타내며</span><span class="sxs-lookup"><span data-stu-id="802cb-151">Allowed usage, which indicates the type of access that is allowed.</span></span> <span data-ttu-id="802cb-152">값은 <xref:System.Security.Permissions.IsolatedStorageContainment> 열거형의 멤버입니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-152">The values are members of the <xref:System.Security.Permissions.IsolatedStorageContainment> enumeration.</span></span> <span data-ttu-id="802cb-153">이러한 값에 대한 자세한 내용은 다음 섹션의 표를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="802cb-153">For more information about these values, see the table in the next section.</span></span>

- <span data-ttu-id="802cb-154">이전 섹션에서 설명한 스토리지 할당량입니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-154">Storage quota, as discussed in the preceding section.</span></span>

<span data-ttu-id="802cb-155">런타임은 코드에서 처음으로 저장소를 열려고 할 때 이 <xref:System.Security.Permissions.IsolatedStorageFilePermission> 권한을 요청합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-155">The runtime demands <xref:System.Security.Permissions.IsolatedStorageFilePermission> permission when code first attempts to open a store.</span></span> <span data-ttu-id="802cb-156">코드의 신뢰 정도에 따라 이 권한을 부여할지 여부를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-156">It decides whether to grant this permission, based on how much the code is trusted.</span></span> <span data-ttu-id="802cb-157">이 사용 권한이 부여되면 보안 정책 및 코드의 <xref:System.Security.Permissions.IsolatedStorageFilePermission> 요청에 의해 허용되는 사용법과 스토리지 할당량 값이 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-157">If the permission is granted, the allowed usage and storage quota values are determined by security policy and by the code's request for <xref:System.Security.Permissions.IsolatedStorageFilePermission>.</span></span> <span data-ttu-id="802cb-158">보안 정책은 .NET Framework 구성 도구(Mscorcfg.msc)를 사용하여 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-158">Security policy is set by using the .NET Framework Configuration Tool (Mscorcfg.msc).</span></span> <span data-ttu-id="802cb-159">호출 스택의 모든 호출자를 검사하여 각 호출자가 적절한 최소 허용 수준 값을 가지고 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-159">All callers in the call stack are checked to ensure that each caller has at least the appropriate allowed usage.</span></span> <span data-ttu-id="802cb-160">또한 런타임은 파일을 저장할 저장소를 열거나 만든 코드에 부과된 할당 한도도 검사합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-160">The runtime also checks the quota imposed on the code that opened or created the store in which the file is to be saved.</span></span> <span data-ttu-id="802cb-161">이러한 조건을 충족하면 사용 권한이 부여됩니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-161">If these conditions are satisfied, permission is granted.</span></span> <span data-ttu-id="802cb-162">할당 한도는 파일을 저장소에 쓸 때마다 다시 검사됩니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-162">The quota is checked again every time a file is written to the store.</span></span>

<span data-ttu-id="802cb-163">공용 언어 런타임은 보안 정책을 기반으로 적절한 모든 <xref:System.Security.Permissions.IsolatedStorageFilePermission> 을 부여하므로 권한을 요청하는 데 애플리케이션 코드가 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-163">Application code is not required to request permission because the common language runtime will grant whatever <xref:System.Security.Permissions.IsolatedStorageFilePermission> is appropriate based on security policy.</span></span> <span data-ttu-id="802cb-164">그러나 <xref:System.Security.Permissions.IsolatedStorageFilePermission>을 포함하여 애플리케이션에서 필요로 하는 특정 사용 권한을 요청해야 하는 경우가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-164">However, there are good reasons to request specific permissions that your application needs, including <xref:System.Security.Permissions.IsolatedStorageFilePermission>.</span></span>

<a name="allowed_usage"></a>

## <a name="allowed-usage-and-security-risks"></a><span data-ttu-id="802cb-165">허용 수준과 보안 위험</span><span class="sxs-lookup"><span data-stu-id="802cb-165">Allowed Usage and Security Risks</span></span>

<span data-ttu-id="802cb-166"><xref:System.Security.Permissions.IsolatedStorageFilePermission>에 의해 지정되는 허용 사용법에 따라 코드에서 격리된 스토리지를 만들고 사용할 수 있는 정도가 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-166">The allowed usage specified by <xref:System.Security.Permissions.IsolatedStorageFilePermission> determines the degree to which code will be allowed to create and use isolated storage.</span></span> <span data-ttu-id="802cb-167">다음 표에서는 사용 권한에 지정된 허용 수준이 어떤 방식으로 격리 유형에 부합하는지를 보여 주고 각 허용 수준과 관련된 보안 위험을 요약하여 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-167">The following table shows how the allowed usage specified in the permission corresponds to types of isolation and summarizes the security risks associated with each allowed usage.</span></span>

|<span data-ttu-id="802cb-168">허용 수준</span><span class="sxs-lookup"><span data-stu-id="802cb-168">Allowed usage</span></span>|<span data-ttu-id="802cb-169">격리 유형</span><span class="sxs-lookup"><span data-stu-id="802cb-169">Isolation types</span></span>|<span data-ttu-id="802cb-170">보안 효과</span><span class="sxs-lookup"><span data-stu-id="802cb-170">Security impact</span></span>|
|-------------------|---------------------|---------------------|
|<xref:System.Security.Permissions.IsolatedStorageContainment.None>|<span data-ttu-id="802cb-171">격리된 스토리지를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-171">No isolated storage use is allowed.</span></span>|<span data-ttu-id="802cb-172">보안 효과가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-172">There is no security impact.</span></span>|
|<xref:System.Security.Permissions.IsolatedStorageContainment.DomainIsolationByUser>|<span data-ttu-id="802cb-173">사용자, 도메인 및 어셈블리별 격리.</span><span class="sxs-lookup"><span data-stu-id="802cb-173">Isolation by user, domain, and assembly.</span></span> <span data-ttu-id="802cb-174">각 어셈블리는 도메인 내에 별도의 하위 저장소를 가지고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-174">Each assembly has a separate substore within the domain.</span></span> <span data-ttu-id="802cb-175">이 권한을 사용하는 저장소는 암시적으로 컴퓨터와 별로도 격리됩니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-175">Stores that use this permission are also implicitly isolated by computer.</span></span>|<span data-ttu-id="802cb-176">이 권한을 사용하면 비록 할당 한도가 적용되어 어느 정도까지는 허가되지 않은 수준의 리소스 남용을 방지하지만 그래도 이러한 리소스 남용이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-176">This permission level leaves resources open to unauthorized overuse, although enforced quotas make it more difficult.</span></span> <span data-ttu-id="802cb-177">이를 서비스 거부 공격이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-177">This is called a denial of service attack.</span></span>|
|<xref:System.Security.Permissions.IsolatedStorageContainment.DomainIsolationByRoamingUser>|<span data-ttu-id="802cb-178">`DomainIsolationByUser`와 동일하지만, 로밍 사용자 프로필을 사용할 수 있고 할당량이 적용되지 않은 경우 로밍되는 위치에 저장소가 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-178">Same as `DomainIsolationByUser`, but store is saved to a location that will roam if roaming user profiles are enabled and quotas are not enforced.</span></span>|<span data-ttu-id="802cb-179">할당 한도를 사용할 수 없으므로 스토리지 리소스가 서비스 거부 공격에 노출되기 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-179">Because quotas must be disabled, storage resources are more vulnerable to a denial of service attack.</span></span>|
|<xref:System.Security.Permissions.IsolatedStorageContainment.AssemblyIsolationByUser>|<span data-ttu-id="802cb-180">사용자 및 어셈블리별 격리.</span><span class="sxs-lookup"><span data-stu-id="802cb-180">Isolation by user and assembly.</span></span> <span data-ttu-id="802cb-181">이 권한을 사용하는 저장소는 암시적으로 컴퓨터와 별로도 격리됩니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-181">Stores that use this permission are also implicitly isolated by computer.</span></span>|<span data-ttu-id="802cb-182">서비스 거부 공격 문제를 방지하기 위해 이 수준에서 할당 한도가 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-182">Quotas are enforced at this level to help prevent a denial of service attack.</span></span> <span data-ttu-id="802cb-183">다른 도메인의 동일한 어셈블리가 이 저장소에 액세스할 수 있으므로 애플리케이션 간에 정보가 누출될 가능성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-183">The same assembly in another domain can access this store, opening the possibility that information could be leaked between applications.</span></span>|
|<xref:System.Security.Permissions.IsolatedStorageContainment.AssemblyIsolationByRoamingUser>|<span data-ttu-id="802cb-184">`AssemblyIsolationByUser`와 동일하지만, 로밍 사용자 프로필을 사용할 수 있고 할당량이 적용되지 않은 경우 로밍되는 위치에 저장소가 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-184">Same as `AssemblyIsolationByUser`, but store is saved to a location that will roam if roaming user profiles are enabled and quotas are not enforced.</span></span>|<span data-ttu-id="802cb-185">`AssemblyIsolationByUser`의 경우와 동일하지만, 할당량이 없으므로 서비스 거부 공격 위험이 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-185">Same as in `AssemblyIsolationByUser`, but without quotas, the risk of a denial of service attack increases.</span></span>|
|<xref:System.Security.Permissions.IsolatedStorageContainment.AdministerIsolatedStorageByUser>|<span data-ttu-id="802cb-186">사용자별 격리.</span><span class="sxs-lookup"><span data-stu-id="802cb-186">Isolation by user.</span></span> <span data-ttu-id="802cb-187">일반적으로 관리 또는 디버깅 도구에서 이 권한 수준을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-187">Typically, only administrative or debugging tools use this level of permission.</span></span>|<span data-ttu-id="802cb-188">이 권한으로 액세스하면 코드가 어셈블리 격리와 관계없이 사용자의 격리된 스토리지 파일 또는 디렉터리를 보거나 삭제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-188">Access with this permission allows code to view or delete any of a user's isolated storage files or directories (regardless of assembly isolation).</span></span> <span data-ttu-id="802cb-189">정보 누출 및 데이터 손실 등의 위험이 있지만 이에 제한되지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-189">Risks include, but are not limited to, leaking information and data loss.</span></span>|
|<xref:System.Security.Permissions.IsolatedStorageContainment.UnrestrictedIsolatedStorage>|<span data-ttu-id="802cb-190">모든 사용자, 도메인 및 어셈블리별 격리.</span><span class="sxs-lookup"><span data-stu-id="802cb-190">Isolation by all users, domains, and assemblies.</span></span> <span data-ttu-id="802cb-191">일반적으로 관리 또는 디버깅 도구에서 이 권한 수준을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-191">Typically, only administrative or debugging tools use this level of permission.</span></span>|<span data-ttu-id="802cb-192">이 권한을 사용하면 모든 사용자에 대한 모든 격리된 저장소 전체가 손상될 가능성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-192">This permission creates the potential for a total compromise of all isolated stores for all users.</span></span>|

## <a name="safety-of-isolated-storage-components-with-regard-to-untrusted-data"></a><span data-ttu-id="802cb-193">신뢰할 수 없는 데이터와 관련하여 격리된 스토리지 구성 요소의 안전</span><span class="sxs-lookup"><span data-stu-id="802cb-193">Safety of isolated storage components with regard to untrusted data</span></span>

<span data-ttu-id="802cb-194">__이 섹션은 다음과 같은 프레임워크에 적용됩니다.__</span><span class="sxs-lookup"><span data-stu-id="802cb-194">__This section applies to the following frameworks:__</span></span>

- <span data-ttu-id="802cb-195">.NET Framework(모든 버전)</span><span class="sxs-lookup"><span data-stu-id="802cb-195">.NET Framework (all versions)</span></span>
- <span data-ttu-id="802cb-196">.NET Core 2.1 이상</span><span class="sxs-lookup"><span data-stu-id="802cb-196">.NET Core 2.1+</span></span>
- <span data-ttu-id="802cb-197">.NET 5.0 이상</span><span class="sxs-lookup"><span data-stu-id="802cb-197">.NET 5.0+</span></span>

<span data-ttu-id="802cb-198">.NET Framework 및 .NET Core는 사용자, 애플리케이션 또는 구성 요소의 데이터를 유지하는 메커니즘으로 격리된 스토리지를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-198">.NET Framework and .NET Core offer isolated storage as a mechanism to persist data for a user, an application, or a component.</span></span> <span data-ttu-id="802cb-199">기본적으로 이 레거시 구성 요소는 지금은 사용되지 않는 코드 액세스 보안 시나리오를 위해 설계되었습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-199">This is a legacy component primarily designed for now-deprecated Code Access Security scenarios.</span></span>

<span data-ttu-id="802cb-200">다양한 격리된 스토리지 API 및 도구를 사용하여 신뢰 경계 전반에서 데이터를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-200">Various isolated storage APIs and tools can be used to read data across trust boundaries.</span></span> <span data-ttu-id="802cb-201">예를 들어 머신 전체 범위에서 데이터를 읽으면 머신에서 신뢰할 수 없는 다른 사용자 계정의 데이터를 집계할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-201">For example, reading data from a machine-wide scope can aggregate data from other, possibly less-trusted user accounts on the machine.</span></span> <span data-ttu-id="802cb-202">머신 전체의 격리된 스토리지 범위에서 읽는 구성 요소 또는 애플리케이션은 이 데이터를 읽을 때의 결과를 알고 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-202">Components or applications that read from machine-wide isolated storage scopes should be aware of the consequences of reading this data.</span></span>

### <a name="security-sensitive-apis-that-can-read-from-the-machine-wide-scope"></a><span data-ttu-id="802cb-203">머신 전체 범위에서 읽을 수 있는 보안 관련 API</span><span class="sxs-lookup"><span data-stu-id="802cb-203">Security-sensitive APIs that can read from the machine-wide scope</span></span>

<span data-ttu-id="802cb-204">다음 API를 호출하는 구성 요소 또는 애플리케이션은 머신 전체 범위에서 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-204">Components or applications that call any of the following APIs read from the machine-wide scope:</span></span>

* <span data-ttu-id="802cb-205">[IsolatedStorageFile.GetEnumerator](/dotnet/api/system.io.isolatedstorage.isolatedstoragefile.getenumerator) - IsolatedStorageScope.Machine 플래그를 포함하는 범위를 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-205">[IsolatedStorageFile.GetEnumerator](/dotnet/api/system.io.isolatedstorage.isolatedstoragefile.getenumerator), passing a scope that includes the IsolatedStorageScope.Machine flag</span></span>
* [<span data-ttu-id="802cb-206">IsolatedStorageFile.GetMachineStoreForApplication</span><span class="sxs-lookup"><span data-stu-id="802cb-206">IsolatedStorageFile.GetMachineStoreForApplication</span></span>](/dotnet/api/system.io.isolatedstorage.isolatedstoragefile.getmachinestoreforapplication)
* [<span data-ttu-id="802cb-207">IsolatedStorageFile.GetMachineStoreForAssembly</span><span class="sxs-lookup"><span data-stu-id="802cb-207">IsolatedStorageFile.GetMachineStoreForAssembly</span></span>](/dotnet/api/system.io.isolatedstorage.isolatedstoragefile.getmachinestoreforassembly)
* [<span data-ttu-id="802cb-208">IsolatedStorageFile.GetMachineStoreForDomain</span><span class="sxs-lookup"><span data-stu-id="802cb-208">IsolatedStorageFile.GetMachineStoreForDomain</span></span>](/dotnet/api/system.io.isolatedstorage.isolatedstoragefile.getmachinestorefordomain)
* <span data-ttu-id="802cb-209">[IsolatedStorageFile.GetStore](/dotnet/api/system.io.isolatedstorage.isolatedstoragefile.getstore) - IsolatedStorageScope.Machine 플래그를 포함하는 범위를 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-209">[IsolatedStorageFile.GetStore](/dotnet/api/system.io.isolatedstorage.isolatedstoragefile.getstore), passing a scope that includes the IsolatedStorageScope.Machine flag</span></span>
* <span data-ttu-id="802cb-210">[IsolatedStorageFile.Remove](/dotnet/api/system.io.isolatedstorage.isolatedstoragefile.remove) - `IsolatedStorageScope.Machine` 플래그를 포함하는 범위를 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-210">[IsolatedStorageFile.Remove](/dotnet/api/system.io.isolatedstorage.isolatedstoragefile.remove), passing a scope that includes the `IsolatedStorageScope.Machine` flag</span></span>

<span data-ttu-id="802cb-211">[격리된 스토리지 도구](../../framework/tools/storeadm-exe-isolated-storage-tool.md) `storeadm.exe`는 다음 코드에서처럼 `/machine` 스위치를 사용하여 호출되는 경우 영향을 받습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-211">The [isolated storage tool](../../framework/tools/storeadm-exe-isolated-storage-tool.md) `storeadm.exe` is impacted if called with the `/machine` switch, as shown in the following code:</span></span>

```txt
storeadm.exe /machine [any-other-switches]
```

<span data-ttu-id="802cb-212">격리된 스토리지 도구는 Visual Studio 및 .NET Framework SDK의 일부로 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-212">The isolated storage tool is provided as part of Visual Studio and the .NET Framework SDK.</span></span>

<span data-ttu-id="802cb-213">애플리케이션에서 위의 API를 호출하지 않거나 워크플로에서 이러한 방식으로 `storeadm.exe`를 호출하지 않는 경우에는 이 문서의 내용이 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-213">If the application doesn't involve calls to the preceding APIs, or if the workflow doesn't involve calling `storeadm.exe` in this manner, this document doesn't apply.</span></span>

### <a name="impact-in-multi-user-environments"></a><span data-ttu-id="802cb-214">다중 사용자 환경에 미치는 영향</span><span class="sxs-lookup"><span data-stu-id="802cb-214">Impact in multi-user environments</span></span>

<span data-ttu-id="802cb-215">앞에서 언급했듯이 이러한 API가 보안에 미치는 영향은 한 신뢰 환경에서 기록된 데이터를 다른 신뢰 환경에서 읽기 때문에 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-215">As mentioned previously, the security impact from these APIs results from data written from one trust environment is read from a different trust environment.</span></span> <span data-ttu-id="802cb-216">격리된 스토리지는 일반적으로 다음 세 위치 중 하나를 사용하여 데이터를 읽고 씁니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-216">Isolated storage generally uses one of three locations to read and write data:</span></span>

1. <span data-ttu-id="802cb-217">`%LOCALAPPDATA%\IsolatedStorage\`: 예를 들어 `User` 범위의 경우 `C:\Users\<username>\AppData\Local\IsolatedStorage\`입니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-217">`%LOCALAPPDATA%\IsolatedStorage\`: For example, `C:\Users\<username>\AppData\Local\IsolatedStorage\`, for `User` scope.</span></span>
2. <span data-ttu-id="802cb-218">`%APPDATA%\IsolatedStorage\`: 예를 들어 `User|Roaming` 범위의 경우 `C:\Users\<username>\AppData\Roaming\IsolatedStorage\`입니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-218">`%APPDATA%\IsolatedStorage\`: For example, `C:\Users\<username>\AppData\Roaming\IsolatedStorage\`, for `User|Roaming` scope.</span></span>
3. <span data-ttu-id="802cb-219">`%PROGRAMDATA%\IsolatedStorage\`: 예를 들어 `Machine` 범위의 경우 `C:\ProgramData\IsolatedStorage\`입니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-219">`%PROGRAMDATA%\IsolatedStorage\`: For example, `C:\ProgramData\IsolatedStorage\`, for `Machine` scope.</span></span>

<span data-ttu-id="802cb-220">처음 두 위치는 사용자별로 격리됩니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-220">The first two locations are isolated per-user.</span></span> <span data-ttu-id="802cb-221">Windows에서는 같은 머신의 여러 사용자 계정이 서로의 사용자 프로필 폴더에 액세스할 수 없도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-221">Windows ensures that different user accounts on the same machine cannot access each other's user profile folders.</span></span> <span data-ttu-id="802cb-222">`User` 또는 `User|Roaming` 저장소를 사용하는 서로 다른 두 사용자 계정은 서로의 데이터를 볼 수 없고 조작할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-222">Two different user accounts who use the `User` or `User|Roaming` stores will not see each other's data and cannot interfere with each other's data.</span></span>

<span data-ttu-id="802cb-223">세 번째 위치는 머신의 모든 사용자 계정 간에 공유됩니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-223">The third location is shared across all user accounts on the machine.</span></span> <span data-ttu-id="802cb-224">다른 계정이 이 위치에서 읽고 위치에 쓸 수 있으며 서로의 데이터를 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-224">Different accounts can read from and write to this location, and they're able to see each other's data.</span></span>

<span data-ttu-id="802cb-225">앞의 경로는 사용 중인 Windows 버전에 따라 다를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-225">The preceding paths may differ based on the version of Windows in use.</span></span>

<span data-ttu-id="802cb-226">이제 두 명의 등록된 사용자 _Mallory_ 및 _Bob_ 이 있는 다중 사용자 시스템을 살펴봅니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-226">Now consider a multi-user system with two registered users _Mallory_ and _Bob_.</span></span> <span data-ttu-id="802cb-227">Mallory는 자신의 사용자 프로필 디렉터리 `C:\Users\Mallory\`에 액세스할 수 있고 공유 머신 전체 스토리지 위치 `C:\ProgramData\IsolatedStorage\`에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-227">Mallory has the ability to access her user profile directory `C:\Users\Mallory\`, and she can access the shared machine-wide storage location `C:\ProgramData\IsolatedStorage\`.</span></span> <span data-ttu-id="802cb-228">Bob의 사용자 프로필 디렉터리 `C:\Users\Bob\`에는 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-228">She cannot access Bob's user profile directory `C:\Users\Bob\`.</span></span>

<span data-ttu-id="802cb-229">Mallory가 Bob을 공격하려는 경우 머신 전체 스토리지 위치에 데이터를 쓴 다음 Bob이 머신 전체 저장소에서 읽도록 영향을 주려고 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-229">If Mallory wishes to attack Bob, she might write data to the machine-wide storage location, then attempt to influence Bob into reading from the machine-wide store.</span></span> <span data-ttu-id="802cb-230">Bob이 이 저장소에서 읽는 앱을 실행하면 해당 앱은 Mallory가 여기에 저장한 데이터를 사용하지만 Bob의 사용자 계정 컨텍스트 내에서 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-230">When Bob runs an app that reads from this store, that app will operate on the data Mallory placed there, but from within the context of Bob's user account.</span></span> <span data-ttu-id="802cb-231">이 문서의 나머지 부분에서는 다양한 공격 벡터와 이러한 공격의 위험을 최소화하기 위해 앱에서 수행할 수 있는 단계를 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-231">The remainder of this document contemplates various attack vectors and what steps apps can do to minimize their risk to these attacks.</span></span>

> [!NOTE]
> <span data-ttu-id="802cb-232">이러한 공격을 수행하기 위해 Mallory는 다음이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-232">In order for such an attack to take place, Mallory requires:</span></span>
>
> * <span data-ttu-id="802cb-233">머신의 사용자 계정</span><span class="sxs-lookup"><span data-stu-id="802cb-233">A user account on the machine.</span></span>
> * <span data-ttu-id="802cb-234">파일 시스템의 알려진 위치에 파일을 저장할 수 있는 기능</span><span class="sxs-lookup"><span data-stu-id="802cb-234">The ability to place a file into a known location on the file system.</span></span>
> * <span data-ttu-id="802cb-235">Bob이 어느 시점에 이 데이터를 읽으려고 시도하는 앱을 실행할 것이라는 정보</span><span class="sxs-lookup"><span data-stu-id="802cb-235">Knowledge that Bob will at some point run an app that attempts to read this data.</span></span>
>
> <span data-ttu-id="802cb-236">이러한 위협 벡터는 가정용 PC 또는 직원이 한 명인 기업 워크스테이션과 같은 표준 단일 사용자 데스크톱 환경에는 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-236">These are not threat vectors that apply to standard single-user desktop environments like home PCs or single-employee enterprise workstations.</span></span>

#### <a name="elevation-of-privilege"></a><span data-ttu-id="802cb-237">권한 상승</span><span class="sxs-lookup"><span data-stu-id="802cb-237">Elevation of privilege</span></span>

<span data-ttu-id="802cb-238">__권한 상승__ 공격은 Bob의 앱이 Mallory의 파일을 읽고 자동으로 해당 페이로드의 콘텐츠를 기반으로 작업을 수행하려고 할 때 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-238">An __elevation of privilege__ attack occurs when Bob's app reads Mallory's file and automatically tries to take some action based on the contents of that payload.</span></span> <span data-ttu-id="802cb-239">머신 전체 저장소에서 시작 스크립트의 콘텐츠를 읽고 해당 콘텐츠를 `Process.Start`에 전달하는 앱이 있다고 가정해 보세요.</span><span class="sxs-lookup"><span data-stu-id="802cb-239">Consider an app that reads the contents of a startup script from the machine-wide store and passes those contents to `Process.Start`.</span></span> <span data-ttu-id="802cb-240">Mallory가 머신 전체 저장소 내에 악성 스크립트를 저장할 수 있는 경우 Bob이 앱을 시작하면 다음이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-240">If Mallory can place a malicious script inside the machine-wide store, when Bob launches his app:</span></span>

* <span data-ttu-id="802cb-241">앱이 ‘Bob의 사용자 프로필 컨텍스트에서’ Mallory의 악성 스크립트를 구문 분석하고 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-241">His app parses and launches Mallory's malicious script _under the context of Bob's user profile_.</span></span>
* <span data-ttu-id="802cb-242">Mallory가 로컬 머신에서 Bob의 계정에 액세스합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-242">Mallory gains access to Bob's account on the local machine.</span></span>

#### <a name="denial-of-service"></a><span data-ttu-id="802cb-243">서비스 거부</span><span class="sxs-lookup"><span data-stu-id="802cb-243">Denial of service</span></span>

<span data-ttu-id="802cb-244">__서비스 거부__ 공격은 Bob의 앱이 Mallory의 파일을 읽고 크래시되거나 제대로 작동하지 않을 때 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-244">A __denial of service__ attack occurs when Bob's app reads Mallory's file and crashes or otherwise stops functioning correctly.</span></span> <span data-ttu-id="802cb-245">앞에서 언급한 앱이 머신 전체 저장소에서 시작 스크립트를 구문 분석하려고 시도한다고 가정해 보세요.</span><span class="sxs-lookup"><span data-stu-id="802cb-245">Consider again the app mentioned previously, which attempts to parse a startup script from the machine-wide store.</span></span> <span data-ttu-id="802cb-246">Mallory가 머신 전체 저장소 내에서 잘 구성되지 않은 콘텐츠가 포함된 파일을 저장할 수 있는 경우 다음을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-246">If Mallory can place a file with malformed contents inside the machine-wide store, she might:</span></span>

* <span data-ttu-id="802cb-247">Bob의 앱이 시작 경로의 초기에 예외를 throw하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-247">Cause Bob's app to throw an exception early in the startup path.</span></span>
* <span data-ttu-id="802cb-248">앱이 예외 때문에 제대로 시작되지 않게 합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-248">Prevent the app from launching successfully because of the exception.</span></span>

<span data-ttu-id="802cb-249">그런 다음 자신의 사용자 계정에서 Bob이 앱을 시작할 수 있는 기능을 거부했습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-249">She has then denied Bob the ability to launch the app under his own user account.</span></span>

#### <a name="information-disclosure"></a><span data-ttu-id="802cb-250">정보 공개</span><span class="sxs-lookup"><span data-stu-id="802cb-250">Information disclosure</span></span>

<span data-ttu-id="802cb-251">__정보 공개__ 공격은 Mallory가 Bob을 속여 정상적으로는 액세스할 수 없는 파일의 콘텐츠를 공개하도록 할 수 있는 경우 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-251">An __information disclosure__ attack occurs when Mallory can trick Bob into disclosing the contents of a file that Mallory does not normally have access to.</span></span> <span data-ttu-id="802cb-252">Bob의 비밀 파일 *C:\Users\Bob\secret.txt* 를 Mallory가 읽고 싶어한다고 가정해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-252">Consider that Bob has a secret file *C:\Users\Bob\secret.txt* that Mallory wants to read.</span></span> <span data-ttu-id="802cb-253">Mallory는 파일의 경로는 알지만 Windows에서 Bob의 사용자 프로필 디렉터리에 액세스하지 못하게 하므로 파일을 읽을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-253">She knows the path to this file, but she cannot read it because Windows forbids her from gaining access to Bob's user profile directory.</span></span>

<span data-ttu-id="802cb-254">대신, Mallory는 하드 링크를 머신 전체 저장소에 배치합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-254">Instead, Mallory places a hard link into the machine-wide store.</span></span> <span data-ttu-id="802cb-255">이 특수한 종류의 파일은 자체에 콘텐츠를 포함하지는 않고 디스크의 다른 파일을 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-255">This is a special kind of file that itself does not contain any contents, rather, it points to another file on disk.</span></span> <span data-ttu-id="802cb-256">하드 링크 파일을 읽으려고 하면 대신 링크의 대상으로 지정된 파일의 콘텐츠를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-256">Attempting to read the hard link file will instead read the contents of the file targeted by the link.</span></span> <span data-ttu-id="802cb-257">하드 링크를 만든 후에도 Mallory는 링크의 대상(`C:\Users\Bob\secret.txt`)에 액세스할 수 없으므로 파일 콘텐츠를 읽을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-257">After creating the hard link, Mallory still cannot read the file contents because she does not have access to the target (`C:\Users\Bob\secret.txt`) of the link.</span></span> <span data-ttu-id="802cb-258">그러나 Bob은 이 파일에 액세스할 수 ‘있습니다’.</span><span class="sxs-lookup"><span data-stu-id="802cb-258">However, Bob _does_ have access to this file.</span></span>

<span data-ttu-id="802cb-259">Bob의 앱이 머신 전체 저장소에서 읽을 때 이제 `secret.txt` 파일 자체가 머신 전체 저장소에 있었던 것처럼 파일 콘텐츠를 실수로 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-259">When Bob's app reads from the machine-wide store, it now inadvertently reads the contents of his `secret.txt` file, just as if the file itself had been present in the machine-wide store.</span></span> <span data-ttu-id="802cb-260">Bob의 앱이 종료될 때 파일을 머신 전체 저장소에 다시 저장하려고 하는 경우 파일의 실제 복사본을 \*C:\ProgramData\IsolatedStorage\* 디렉터리에 저장하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-260">When Bob's app exits, if it attempts to resave the file to the machine-wide store, it will end up placing an actual copy of the file in the \*C:\ProgramData\IsolatedStorage\* directory.</span></span> <span data-ttu-id="802cb-261">이 디렉터리는 머신의 모든 사용자가 읽을 수 있으므로 이제 Mallory는 파일의 콘텐츠를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-261">Since this directory is readable by any user on the machine, Mallory can now read the contents of the file.</span></span>

### <a name="best-practices-to-defend-against-these-attacks"></a><span data-ttu-id="802cb-262">이러한 공격으로부터 방어하기 위한 모범 사례</span><span class="sxs-lookup"><span data-stu-id="802cb-262">Best practices to defend against these attacks</span></span>

<span data-ttu-id="802cb-263">__중요:__ 환경에 상호 신뢰할 수 없는 사용자가 여러 명 있는 경우 API `IsolatedStorageFile.GetEnumerator(IsolatedStorageScope.Machine)`를 호출하거나 `storeadm.exe /machine /list` 도구를 호출하지 __마세요__.</span><span class="sxs-lookup"><span data-stu-id="802cb-263">__Important:__ If your environment has multiple mutually untrusted users, __do not__ call the API `IsolatedStorageFile.GetEnumerator(IsolatedStorageScope.Machine)` or invoke the tool `storeadm.exe /machine /list`.</span></span> <span data-ttu-id="802cb-264">둘은 모두 신뢰할 수 있는 데이터에서 작동하고 있다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-264">Both of these assume that they're operating on trusted data.</span></span> <span data-ttu-id="802cb-265">공격자가 머신 전체 저장소에 악성 페이로드를 시드할 수 있는 경우 해당 페이로드로 인해 이러한 명령을 실행하는 사용자의 컨텍스트에서 권한 상승 공격이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-265">If an attacker can seed a malicious payload in the machine-wide store, that payload can lead to an elevation of privilege attack under the context of the user who runs these commands.</span></span>

<span data-ttu-id="802cb-266">다중 사용자 환경에서 운영하는 경우 머신 범위를 대상으로 하는 격리된 스토리지 기능을 사용하는 것을 다시 고려하세요.</span><span class="sxs-lookup"><span data-stu-id="802cb-266">If operating in a multi-user environment, reconsider use of isolated storage features that target the _Machine_ scope.</span></span> <span data-ttu-id="802cb-267">앱이 머신 전체 위치에서 데이터를 읽어야 하는 경우 관리자 계정만 쓸 수 있는 위치에서 데이터를 읽는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-267">If an app must read data from a machine-wide location, prefer to read the data from a location that's writable only by admin accounts.</span></span> <span data-ttu-id="802cb-268">`%PROGRAMFILES%` 디렉터리 및 `HKLM` 레지스트리 하이브는 관리자만 쓸 수 있고 모든 사용자가 읽을 수 있는 위치의 예입니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-268">The `%PROGRAMFILES%` directory and the `HKLM` registry hive are examples of locations that are writable by only administrators and readable by everyone.</span></span> <span data-ttu-id="802cb-269">따라서 해당 위치에서 읽은 데이터는 신뢰할 수 있다고 간주합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-269">Data read from those locations is therefore considered trustworthy.</span></span>

<span data-ttu-id="802cb-270">앱이 다중 사용자 환경에서 ‘머신’ 범위를 사용해야 하는 경우에는 머신 전체 저장소에서 읽은 모든 파일의 콘텐츠를 유효성 검사하세요.</span><span class="sxs-lookup"><span data-stu-id="802cb-270">If an app must use the _Machine_ scope in a multi-user environment, validate the contents of any file that you read from the machine-wide store.</span></span> <span data-ttu-id="802cb-271">앱이 이러한 파일에서 개체 그래프를 역직렬화하는 경우 `BinaryFormatter` 또는 `NetDataContractSerializer`와 같이 위험한 직렬 변환기 대신 `XmlSerializer`와 같은 더 안전한 직렬 변환기를 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="802cb-271">If the app deserializing object graphs from these files, consider using safer serializers like `XmlSerializer` instead of dangerous serializers like `BinaryFormatter` or `NetDataContractSerializer`.</span></span> <span data-ttu-id="802cb-272">파일 콘텐츠에 따라 리소스 할당을 수행하는 개체 그래프나 많이 중첩된 개체 그래프는 주의해서 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="802cb-272">Use caution with deeply nested object graphs or object graphs that perform resource allocation based on the file contents.</span></span>

<a name="isolated_storage_locations"></a>

## <a name="isolated-storage-locations"></a><span data-ttu-id="802cb-273">격리된 스토리지 위치</span><span class="sxs-lookup"><span data-stu-id="802cb-273">Isolated Storage Locations</span></span>

<span data-ttu-id="802cb-274">때때로 운영 체제의 파일 시스템을 사용하여 격리된 스토리지에 대한 변경 내용을 확인하면 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-274">Sometimes it is helpful to verify a change to isolated storage by using the file system of the operating system.</span></span> <span data-ttu-id="802cb-275">또한 개발자는 격리된 스토리지 파일의 위치를 알고 싶을 때가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-275">You might also want to know the location of isolated storage files.</span></span> <span data-ttu-id="802cb-276">이 위치는 운영 체제에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-276">This location is different depending on the operating system.</span></span> <span data-ttu-id="802cb-277">다음 표에서는 일반적으로 사용되는 몇 가지 운영 체제에서 격리된 스토리지가 만들어지는 루트 위치를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-277">The following table shows the root locations where isolated storage is created on a few common operating systems.</span></span> <span data-ttu-id="802cb-278">이 루트 위치 아래에 있는 Microsoft\IsolatedStorage 디렉터리를 찾으세요.</span><span class="sxs-lookup"><span data-stu-id="802cb-278">Look for Microsoft\IsolatedStorage directories under this root location.</span></span> <span data-ttu-id="802cb-279">파일 시스템에서 격리된 스토리지를 보려면 숨김 파일과 폴더를 표시하도록 폴더 설정을 변경해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-279">You must change folder settings to show hidden files and folders in order to see isolated storage in the file system.</span></span>

|<span data-ttu-id="802cb-280">운영 체제</span><span class="sxs-lookup"><span data-stu-id="802cb-280">Operating system</span></span>|<span data-ttu-id="802cb-281">파일 시스템에서의 위치</span><span class="sxs-lookup"><span data-stu-id="802cb-281">Location in file system</span></span>|
|----------------------|-----------------------------|
|<span data-ttu-id="802cb-282">Windows 2000, Windows XP, Windows Server 2003(Windows NT 4.0에서 업그레이드)</span><span class="sxs-lookup"><span data-stu-id="802cb-282">Windows 2000, Windows XP, Windows Server 2003  (upgrade from Windows NT 4.0)</span></span>|<span data-ttu-id="802cb-283">로밍 가능 저장소 =</span><span class="sxs-lookup"><span data-stu-id="802cb-283">Roaming-enabled stores =</span></span><br /><br /> <span data-ttu-id="802cb-284">\<SYSTEMROOT>\Profiles\\<user\>\Application Data</span><span class="sxs-lookup"><span data-stu-id="802cb-284">\<SYSTEMROOT>\Profiles\\<user\>\Application Data</span></span><br /><br /> <span data-ttu-id="802cb-285">비로밍 저장소 =</span><span class="sxs-lookup"><span data-stu-id="802cb-285">Nonroaming stores =</span></span><br /><br /> <span data-ttu-id="802cb-286">\<SYSTEMROOT>\Profiles\\<user\>\Local Settings\Application Data</span><span class="sxs-lookup"><span data-stu-id="802cb-286">\<SYSTEMROOT>\Profiles\\<user\>\Local Settings\Application Data</span></span>|
|<span data-ttu-id="802cb-287">Windows 2000  - 새로 설치 및 Windows 98, Windows NT 3.51에서 업그레이드</span><span class="sxs-lookup"><span data-stu-id="802cb-287">Windows 2000  - clean installation (and upgrades from Windows 98 and Windows NT 3.51)</span></span>|<span data-ttu-id="802cb-288">로밍 가능 저장소 =</span><span class="sxs-lookup"><span data-stu-id="802cb-288">Roaming-enabled stores =</span></span><br /><br /> <span data-ttu-id="802cb-289">\<SYSTEMDRIVE>\Documents and Settings\\<user\>\Application Data</span><span class="sxs-lookup"><span data-stu-id="802cb-289">\<SYSTEMDRIVE>\Documents and Settings\\<user\>\Application Data</span></span><br /><br /> <span data-ttu-id="802cb-290">비로밍 저장소 =</span><span class="sxs-lookup"><span data-stu-id="802cb-290">Nonroaming stores =</span></span><br /><br /> <span data-ttu-id="802cb-291">\<SYSTEMDRIVE>\Documents and Settings\\<user\>\Local Settings\Application Data</span><span class="sxs-lookup"><span data-stu-id="802cb-291">\<SYSTEMDRIVE>\Documents and Settings\\<user\>\Local Settings\Application Data</span></span>|
|<span data-ttu-id="802cb-292">Windows XP, Windows Server 2003 - 새로 설치 및 Windows 2000, Windows 98에서 업그레이드</span><span class="sxs-lookup"><span data-stu-id="802cb-292">Windows XP, Windows Server 2003 - clean installation (and upgrades from Windows 2000 and Windows 98)</span></span>|<span data-ttu-id="802cb-293">로밍 가능 저장소 =</span><span class="sxs-lookup"><span data-stu-id="802cb-293">Roaming-enabled stores =</span></span><br /><br /> <span data-ttu-id="802cb-294">\<SYSTEMDRIVE>\Documents and Settings\\<user\>\Application Data</span><span class="sxs-lookup"><span data-stu-id="802cb-294">\<SYSTEMDRIVE>\Documents and Settings\\<user\>\Application Data</span></span><br /><br /> <span data-ttu-id="802cb-295">비로밍 저장소 =</span><span class="sxs-lookup"><span data-stu-id="802cb-295">Nonroaming stores =</span></span><br /><br /> <span data-ttu-id="802cb-296">\<SYSTEMDRIVE>\Documents and Settings\\<user\>\Local Settings\Application Data</span><span class="sxs-lookup"><span data-stu-id="802cb-296">\<SYSTEMDRIVE>\Documents and Settings\\<user\>\Local Settings\Application Data</span></span>|
|<span data-ttu-id="802cb-297">Windows 8, Windows 7, Windows Server 2008, Windows Vista</span><span class="sxs-lookup"><span data-stu-id="802cb-297">Windows 8, Windows 7, Windows Server 2008, Windows Vista</span></span>|<span data-ttu-id="802cb-298">로밍 가능 저장소 =</span><span class="sxs-lookup"><span data-stu-id="802cb-298">Roaming-enabled stores =</span></span><br /><br /> <span data-ttu-id="802cb-299">\<SYSTEMDRIVE>\Users\\<user\>\AppData\Roaming</span><span class="sxs-lookup"><span data-stu-id="802cb-299">\<SYSTEMDRIVE>\Users\\<user\>\AppData\Roaming</span></span><br /><br /> <span data-ttu-id="802cb-300">비로밍 저장소 =</span><span class="sxs-lookup"><span data-stu-id="802cb-300">Nonroaming stores =</span></span><br /><br /> <span data-ttu-id="802cb-301">\<SYSTEMDRIVE>\Users\\<user\>\AppData\Local</span><span class="sxs-lookup"><span data-stu-id="802cb-301">\<SYSTEMDRIVE>\Users\\<user\>\AppData\Local</span></span>|

<a name="isolated_storage_tasks"></a>

## <a name="creating-enumerating-and-deleting-isolated-storage"></a><span data-ttu-id="802cb-302">격리된 스토리지 만들기, 열거 및 삭제</span><span class="sxs-lookup"><span data-stu-id="802cb-302">Creating, Enumerating, and Deleting Isolated Storage</span></span>

<span data-ttu-id="802cb-303">.NET에서는 <xref:System.IO.IsolatedStorage> 네임스페이스의 세 가지 클래스를 제공해 격리된 스토리지와 관련된 작업을 수행할 수 있도록 해줍니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-303">.NET provides three classes in the <xref:System.IO.IsolatedStorage> namespace to help you perform tasks that involve isolated storage:</span></span>

- <span data-ttu-id="802cb-304"><xref:System.IO.IsolatedStorage.IsolatedStorageFile>에서 파생되는 <xref:System.IO.IsolatedStorage.IsolatedStorage?displayProperty=nameWithType> 은 저장된 어셈블리 및 애플리케이션 파일의 기본 관리를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-304"><xref:System.IO.IsolatedStorage.IsolatedStorageFile>, derives from <xref:System.IO.IsolatedStorage.IsolatedStorage?displayProperty=nameWithType> and provides basic management of stored assembly and application files.</span></span> <span data-ttu-id="802cb-305"><xref:System.IO.IsolatedStorage.IsolatedStorageFile> 클래스 인스턴스는 파일 시스템에 있는 단일 저장소를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-305">An instance of the <xref:System.IO.IsolatedStorage.IsolatedStorageFile> class represents a single store located in the file system.</span></span>

- <span data-ttu-id="802cb-306"><xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> 에서 파생되는 <xref:System.IO.FileStream?displayProperty=nameWithType> 은 저장소에 있는 파일에 대한 액세스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-306"><xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> derives from <xref:System.IO.FileStream?displayProperty=nameWithType> and provides access to the files in a store.</span></span>

- <span data-ttu-id="802cb-307"><xref:System.IO.IsolatedStorage.IsolatedStorageScope> 은 적절한 격리 유형을 사용하여 저장소를 만들고 선택할 수 있도록 하는 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-307"><xref:System.IO.IsolatedStorage.IsolatedStorageScope> is an enumeration that enables you to create and select a store with the appropriate isolation type.</span></span>

<span data-ttu-id="802cb-308">격리된 스토리지 클래스를 사용하여 격리된 스토리지를 만들고 열거하고 삭제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-308">The isolated storage classes enable you to create, enumerate, and delete isolated storage.</span></span> <span data-ttu-id="802cb-309">이러한 작업을 수행하는 데 필요한 메서드는 <xref:System.IO.IsolatedStorage.IsolatedStorageFile> 개체를 통해 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-309">The methods for performing these tasks are available through the <xref:System.IO.IsolatedStorage.IsolatedStorageFile> object.</span></span> <span data-ttu-id="802cb-310">일부 작업을 수행하려면 격리된 스토리지를 관리할 수 있는 권한을 나타내는 <xref:System.Security.Permissions.IsolatedStorageFilePermission> 권한을 가져야 하며 파일이나 디렉터리에 액세스할 수 있는 운영 체제 권한도 가지고 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-310">Some operations require you to have the <xref:System.Security.Permissions.IsolatedStorageFilePermission> permission that represents the right to administer isolated storage; you might also need to have operating system rights to access the file or directory.</span></span>

<span data-ttu-id="802cb-311">일반적인 격리된 스토리지 작업을 보여 주는 일련의 예제는 [관련 항목](#related_topics)에 나열되어 있는 방법 항목을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="802cb-311">For a series of examples that demonstrate common isolated storage tasks, see the how-to topics listed in [Related Topics](#related_topics).</span></span>

<a name="scenarios_for_isolated_storage"></a>

## <a name="scenarios-for-isolated-storage"></a><span data-ttu-id="802cb-312">격리된 스토리지 시나리오</span><span class="sxs-lookup"><span data-stu-id="802cb-312">Scenarios for Isolated Storage</span></span>

<span data-ttu-id="802cb-313">격리된 스토리지는 다음 네 가지 시나리오를 비롯하여 다양한 상황에서 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-313">Isolated storage is useful in many situations, including these four scenarios:</span></span>

- <span data-ttu-id="802cb-314">다운로드된 컨트롤.</span><span class="sxs-lookup"><span data-stu-id="802cb-314">Downloaded controls.</span></span> <span data-ttu-id="802cb-315">인터넷에서 다운로드된 관리 코드 컨트롤은 일반 I/O 클래스를 통해 하드 드라이브에 쓸 수 없지만 격리된 스토리지를 사용하여 사용자 설정 및 애플리케이션 상태를 유지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-315">Managed code controls downloaded from the Internet are not allowed to write to the hard drive through normal I/O classes, but they can use isolated storage to persist users' settings and application states.</span></span>

- <span data-ttu-id="802cb-316">공유 구성 요소 스토리지.</span><span class="sxs-lookup"><span data-stu-id="802cb-316">Shared component storage.</span></span> <span data-ttu-id="802cb-317">애플리케이션 간에 공유되는 구성 요소는 격리된 스토리지를 사용하여 데이터 스토리지에 대한 제어된 액세스를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-317">Components that are shared between applications can use isolated storage to provide controlled access to data stores.</span></span>

- <span data-ttu-id="802cb-318">서버 스토리지.</span><span class="sxs-lookup"><span data-stu-id="802cb-318">Server storage.</span></span> <span data-ttu-id="802cb-319">서버 애플리케이션은 격리된 스토리지를 사용하여 애플리케이션을 요청하는 다수의 사용자에게 개별 스토리지를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-319">Server applications can use isolated storage to provide individual stores for a large number of users making requests to the application.</span></span> <span data-ttu-id="802cb-320">격리된 스토리지는 항상 사용자별로 분리되어 있으므로 서버는 요청하는 사용자를 가장해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-320">Because isolated storage is always segregated by user, the server must impersonate the user making the request.</span></span> <span data-ttu-id="802cb-321">이런 경우 데이터는 사용자를 구분하기 위해 애플리케이션에서 사용하는 동일한 ID인 보안 주체 ID를 기반으로 격리됩니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-321">In this case, data is isolated based on the identity of the principal, which is the same identity the application uses to distinguish between its users.</span></span>

- <span data-ttu-id="802cb-322">로밍.</span><span class="sxs-lookup"><span data-stu-id="802cb-322">Roaming.</span></span> <span data-ttu-id="802cb-323">또한 애플리케이션에서는 격리된 스토리지를 사용하여 로밍 사용자 프로필을 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-323">Applications can also use isolated storage with roaming user profiles.</span></span> <span data-ttu-id="802cb-324">따라서 사용자의 격리된 저장소는 프로필을 로밍하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-324">This allows a user's isolated stores to roam with the profile.</span></span>

<span data-ttu-id="802cb-325">다음과 같은 경우 격리된 스토리지를 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="802cb-325">Do not use isolated storage in the following situations:</span></span>

- <span data-ttu-id="802cb-326">격리된 스토리지는 충분히 신뢰할 수 있는 코드, 비관리 코드 또는 컴퓨터에서 신뢰할 수 있는 사용자로부터 보호되지 않으므로 암호화되지 않은 키 또는 암호 등의 상위 값 비밀을 저장하는 데 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="802cb-326">To store high-value secrets, such as unencrypted keys or passwords, because isolated storage is not protected from highly trusted code, from unmanaged code, or from trusted users of the computer.</span></span>

- <span data-ttu-id="802cb-327">코드를 저장하는 데 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="802cb-327">To store code.</span></span>

- <span data-ttu-id="802cb-328">관리자가 컨트롤하는 구성 및 배포 설정을 저장하는 데 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="802cb-328">To store configuration and deployment settings, which administrators control.</span></span> <span data-ttu-id="802cb-329">사용자 기본 설정은 관리자가 제어하지 않으므로 구성 설정으로 간주되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-329">(User preferences are not considered to be configuration settings because administrators do not control them.)</span></span>

<span data-ttu-id="802cb-330">대부분의 애플리케이션은 데이터베이스를 사용하여 데이터를 저장하고 격리합니다. 이때 데이터베이스에 있는 하나 이상의 행은 특정 사용자에 대한 스토리지를 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-330">Many applications use a database to store and isolate data, in which case one or more rows in a database might represent storage for a specific user.</span></span> <span data-ttu-id="802cb-331">사용자 수가 적은 경우, 데이터베이스 사용에 따른 오버헤드가 의미가 있는 경우 또는 데이터베이스 기능이 없는 경우 데이터베이스 대신 격리된 스토리지를 사용하도록 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-331">You might choose to use isolated storage instead of a database when the number of users is small, when the overhead of using a database is significant, or when no database facility exists.</span></span> <span data-ttu-id="802cb-332">또한 데이터베이스에서 제공하는 행보다 더 융통성 있고 복잡한 스토리지가 애플리케이션에 필요한 경우에도 격리된 스토리지를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-332">Also, when the application requires storage that is more flexible and complex than what a row in a database provides, isolated storage can provide a viable alternative.</span></span>

<a name="related_topics"></a>

## <a name="related-articles"></a><span data-ttu-id="802cb-333">관련 문서</span><span class="sxs-lookup"><span data-stu-id="802cb-333">Related articles</span></span>

|<span data-ttu-id="802cb-334">제목</span><span class="sxs-lookup"><span data-stu-id="802cb-334">Title</span></span>|<span data-ttu-id="802cb-335">설명</span><span class="sxs-lookup"><span data-stu-id="802cb-335">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="802cb-336">격리 유형</span><span class="sxs-lookup"><span data-stu-id="802cb-336">Types of Isolation</span></span>](types-of-isolation.md)|<span data-ttu-id="802cb-337">다양한 유형의 격리에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-337">Describes the different types of isolation.</span></span>|
|[<span data-ttu-id="802cb-338">방법: 격리된 스토리지의 저장소 가져오기</span><span class="sxs-lookup"><span data-stu-id="802cb-338">How to: Obtain Stores for Isolated Storage</span></span>](how-to-obtain-stores-for-isolated-storage.md)|<span data-ttu-id="802cb-339"><xref:System.IO.IsolatedStorage.IsolatedStorageFile> 클래스를 사용하여 사용자 및 어셈블리별로 격리된 저장소를 가져오는 예제를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-339">Provides an example of using the <xref:System.IO.IsolatedStorage.IsolatedStorageFile> class to obtain a store isolated by user and assembly.</span></span>|
|[<span data-ttu-id="802cb-340">방법: 격리된 스토리지의 저장소 열거</span><span class="sxs-lookup"><span data-stu-id="802cb-340">How to: Enumerate Stores for Isolated Storage</span></span>](how-to-enumerate-stores-for-isolated-storage.md)|<span data-ttu-id="802cb-341"><xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetEnumerator%2A?displayProperty=nameWithType> 메서드를 사용하여 사용자에 대한 모든 격리된 스토리지 크기를 계산하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-341">Shows how to use the <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetEnumerator%2A?displayProperty=nameWithType> method to calculate the size of all isolated storage for the user.</span></span>|
|[<span data-ttu-id="802cb-342">방법: 격리된 스토리지에서 저장소 삭제</span><span class="sxs-lookup"><span data-stu-id="802cb-342">How to: Delete Stores in Isolated Storage</span></span>](how-to-delete-stores-in-isolated-storage.md)|<span data-ttu-id="802cb-343"><xref:System.IO.IsolatedStorage.IsolatedStorageFile.Remove%2A?displayProperty=nameWithType> 메서드를 두 가지 방법으로 사용하여 격리된 저장소를 삭제하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-343">Shows how to use the <xref:System.IO.IsolatedStorage.IsolatedStorageFile.Remove%2A?displayProperty=nameWithType> method in two different ways to delete isolated stores.</span></span>|
|[<span data-ttu-id="802cb-344">방법: 격리된 스토리지의 공간 부족 상태 예상</span><span class="sxs-lookup"><span data-stu-id="802cb-344">How to: Anticipate Out-of-Space Conditions with Isolated Storage</span></span>](how-to-anticipate-out-of-space-conditions-with-isolated-storage.md)|<span data-ttu-id="802cb-345">격리된 저장소에서 남은 공간을 측정하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-345">Shows how to measure the remaining space in an isolated store.</span></span>|
|[<span data-ttu-id="802cb-346">방법: 격리된 스토리지의 파일 및 디렉터리 만들기</span><span class="sxs-lookup"><span data-stu-id="802cb-346">How to: Create Files and Directories in Isolated Storage</span></span>](how-to-create-files-and-directories-in-isolated-storage.md)|<span data-ttu-id="802cb-347">격리된 저장소에서 파일 및 디렉터리를 만드는 몇 가지 예제를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-347">Provides some examples of creating files and directories in an isolated store.</span></span>|
|[<span data-ttu-id="802cb-348">방법: 격리된 스토리지의 기존 파일 및 디렉터리 찾기</span><span class="sxs-lookup"><span data-stu-id="802cb-348">How to: Find Existing Files and Directories in Isolated Storage</span></span>](how-to-find-existing-files-and-directories-in-isolated-storage.md)|<span data-ttu-id="802cb-349">격리된 스토리지에서 디렉터리 구조 및 파일을 읽는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-349">Demonstrates how to read the directory structure and files in isolated storage.</span></span>|
|[<span data-ttu-id="802cb-350">방법: 격리된 스토리지의 파일 읽기 및 쓰기</span><span class="sxs-lookup"><span data-stu-id="802cb-350">How to: Read and Write to Files in Isolated Storage</span></span>](how-to-read-and-write-to-files-in-isolated-storage.md)|<span data-ttu-id="802cb-351">격리된 스토리지 파일에 문자열을 쓰고 다시 문자열을 읽는 예제를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-351">Provides an example of writing a string to an isolated storage file and reading it back.</span></span>|
|[<span data-ttu-id="802cb-352">방법: 격리된 스토리지의 파일 및 디렉터리 삭제</span><span class="sxs-lookup"><span data-stu-id="802cb-352">How to: Delete Files and Directories in Isolated Storage</span></span>](how-to-delete-files-and-directories-in-isolated-storage.md)|<span data-ttu-id="802cb-353">격리된 스토리지 파일 및 디렉터리를 삭제하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-353">Demonstrates how to delete isolated storage files and directories.</span></span>|
|[<span data-ttu-id="802cb-354">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="802cb-354">File and Stream I/O</span></span>](index.md)|<span data-ttu-id="802cb-355">동기 및 비동기 파일과 데이터 스트림 액세스를 수행할 수 있는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="802cb-355">Explains how you can perform synchronous and asynchronous file and data stream access.</span></span>|

<a name="reference"></a>

## <a name="reference"></a><span data-ttu-id="802cb-356">참고</span><span class="sxs-lookup"><span data-stu-id="802cb-356">Reference</span></span>

- <xref:System.IO.IsolatedStorage.IsolatedStorage?displayProperty=nameWithType>

- <xref:System.IO.IsolatedStorage.IsolatedStorageFile?displayProperty=nameWithType>

- <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream?displayProperty=nameWithType>

- <xref:System.IO.IsolatedStorage.IsolatedStorageScope?displayProperty=nameWithType>
