---
title: .NET 어셈블리
description: 어셈블리는 .NET 기반 애플리케이션에 대한 배포, 버전 제어, 재사용, 활성화 범위 및 보안 권한의 기본 단위입니다.
ms.date: 08/15/2019
ms.assetid: 149f5ca5-5b34-4746-9542-1ae43b2d0256
helpviewer_keywords:
- dynamic assemblies
- security [.NET Framework], boundaries
- boundaries of assemblies
- assemblies [.NET Framework], about
- assemblies [.NET Framework], boundaries
- reference scope boundaries
- assemblies [.NET Framework]
- version boundaries
- type boundaries
ms.openlocfilehash: f5703377782977bb69815255d04cf1ee5a274c18
ms.sourcegitcommit: 0bb8074d524e0dcf165430b744bb143461f17026
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/15/2021
ms.locfileid: "103477228"
---
# <a name="assemblies-in-net"></a><span data-ttu-id="ebcb4-103">.NET 어셈블리</span><span class="sxs-lookup"><span data-stu-id="ebcb4-103">Assemblies in .NET</span></span>

<span data-ttu-id="ebcb4-104">어셈블리는 .NET 기반 애플리케이션에 대한 배포, 버전 제어, 재사용, 활성화 범위 및 보안 권한의 기본 단위를 형성합니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-104">Assemblies form the fundamental units of deployment, version control, reuse, activation scoping, and security permissions for .NET-based applications.</span></span> <span data-ttu-id="ebcb4-105">어셈블리는 서로 함께 사용되어 논리적 기능 단위를 형성하도록 빌드되는 형식 및 리소스의 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-105">An assembly is a collection of types and resources that are built to work together and form a logical unit of functionality.</span></span> <span data-ttu-id="ebcb4-106">어셈블리는 실행 파일( *.exe*) 또는 동적 연결 라이브러리( *.dll*) 파일의 형태를 가지며 .NET 애플리케이션의 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-106">Assemblies take the form of executable (*.exe*) or dynamic link library (*.dll*) files, and are the building blocks of .NET applications.</span></span> <span data-ttu-id="ebcb4-107">어셈블리는 형식 구현을 인식하는 데 필요한 정보와 함께 공용 언어 런타임을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-107">They provide the common language runtime with the information it needs to be aware of type implementations.</span></span>

<span data-ttu-id="ebcb4-108">.NET Core 및 .NET Framework에서, 소스 코드 파일 1개 이상에서 어셈블리를 빌드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-108">In .NET Core and .NET Framework, you can build an assembly from one or more source code files.</span></span> <span data-ttu-id="ebcb4-109">.NET Framework에서, 어셈블리 모듈을 하나 이상 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-109">In .NET Framework, assemblies can contain one or more modules.</span></span> <span data-ttu-id="ebcb4-110">따라서 대규모 프로젝트를 계획하여 여러 개발자가 작업하는 별도의 소스 코드 파일이나 모듈을 결합하여 단일 어셈블리를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-110">This allows larger projects to be planned so that several developers can work on separate source code files or modules, which are combined to create a single assembly.</span></span> <span data-ttu-id="ebcb4-111">모듈에 대한 자세한 내용은 [ 방법: 다중 파일 어셈블리 빌드](../../framework/app-domains/build-multifile-assembly.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-111">For more information about modules, see [How to: Build a multifile assembly](../../framework/app-domains/build-multifile-assembly.md).</span></span>

<span data-ttu-id="ebcb4-112">어셈블리에는 다음과 같은 속성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-112">Assemblies have the following properties:</span></span>

- <span data-ttu-id="ebcb4-113">어셈블리는 *.exe* 또는 *.dll* 파일로 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-113">Assemblies are implemented as *.exe* or *.dll* files.</span></span>

- <span data-ttu-id="ebcb4-114">.NET Framework를 대상으로 하는 라이브러리의 경우 [전역 어셈블리 캐시(GAC)](../../framework/app-domains/gac.md)에 어셈블리를 넣으면 애플리케이션 간에 어셈블리를 공유할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-114">For libraries that target the .NET Framework, you can share assemblies between applications by putting them in the [global assembly cache (GAC)](../../framework/app-domains/gac.md).</span></span> <span data-ttu-id="ebcb4-115">GAC에 어셈블리를 포함하려면 먼저 강력한 이름의 어셈블리를 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-115">You must strong-name assemblies before you can include them in the GAC.</span></span> <span data-ttu-id="ebcb4-116">자세한 내용은 [강력한 이름의 어셈블리](strong-named.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-116">For more information, see [Strong-named assemblies](strong-named.md).</span></span>

- <span data-ttu-id="ebcb4-117">어셈블리는 필요한 경우에만 메모리에 로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-117">Assemblies are only loaded into memory if they are required.</span></span> <span data-ttu-id="ebcb4-118">사용되지 않는 경우에는 로드되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-118">If they aren't used, they aren't loaded.</span></span> <span data-ttu-id="ebcb4-119">즉, 어셈블리는 대규모 프로젝트에서 리소스를 관리하는 효율적인 방법일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-119">This means that assemblies can be an efficient way to manage resources in larger projects.</span></span>

- <span data-ttu-id="ebcb4-120">리플렉션을 사용하여 프로그래밍 방식으로 어셈블리에 대한 정보를 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-120">You can programmatically obtain information about an assembly by using reflection.</span></span> <span data-ttu-id="ebcb4-121">자세한 내용은 [리플렉션(C#)](../../csharp/programming-guide/concepts/reflection.md) 또는 [Reflection(Visual Basic)](../../visual-basic/programming-guide/concepts/reflection.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-121">For more information, see [Reflection (C#)](../../csharp/programming-guide/concepts/reflection.md) or [Reflection (Visual Basic)](../../visual-basic/programming-guide/concepts/reflection.md).</span></span>

- <span data-ttu-id="ebcb4-122">.NET Core에서 <xref:System.Reflection.MetadataLoadContext> 클래스를 사용하거나 .NET Core 및 .NET Framework에서 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> 또는 <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A?displayProperty=nameWithType> 메서드를 사용하여 검사만을 위해 어셈블리를 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-122">You can load an assembly just to inspect it by using the <xref:System.Reflection.MetadataLoadContext> class in .NET Core and the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A?displayProperty=nameWithType> methods in .NET Core and .NET Framework.</span></span>

## <a name="assemblies-in-the-common-language-runtime"></a><span data-ttu-id="ebcb4-123">공용 언어 런타임의 어셈블리</span><span class="sxs-lookup"><span data-stu-id="ebcb4-123">Assemblies in the common language runtime</span></span>

<span data-ttu-id="ebcb4-124">어셈블리는 공용 언어 런타임에게 형식 구현에 필요한 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-124">Assemblies provide the common language runtime with the information it needs to be aware of type implementations.</span></span> <span data-ttu-id="ebcb4-125">런타임에 형식은 어셈블리 컨텍스트 외부에 존재하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-125">To the runtime, a type does not exist outside the context of an assembly.</span></span>

<span data-ttu-id="ebcb4-126">어셈블리는 다음 정보를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-126">An assembly defines the following information:</span></span>

- <span data-ttu-id="ebcb4-127">공용 언어 런타임이 실행하는 코드.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-127">Code that the common language runtime executes.</span></span> <span data-ttu-id="ebcb4-128">각 어셈블리는 진입점을 하나만 가질 수 있습니다(`DllMain`, `WinMain` 또는 `Main`).</span><span class="sxs-lookup"><span data-stu-id="ebcb4-128">Note that each assembly can have only one entry point: `DllMain`, `WinMain`, or `Main`.</span></span>

- <span data-ttu-id="ebcb4-129">보안 경계.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-129">Security boundary.</span></span> <span data-ttu-id="ebcb4-130">어셈블리는 권한이 요청되고 허용되는 단위입니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-130">An assembly is the unit at which permissions are requested and granted.</span></span> <span data-ttu-id="ebcb4-131">어셈블리의 보안 경계에 대한 자세한 내용은 [어셈블리 보안 고려 사항](security-considerations.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-131">For more information about security boundaries in assemblies, see [Assembly security considerations](security-considerations.md).</span></span>

- <span data-ttu-id="ebcb4-132">형식 경계.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-132">Type boundary.</span></span> <span data-ttu-id="ebcb4-133">각 형식의 ID에는 해당 형식이 존재하는 어셈블리의 이름이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-133">Every type's identity includes the name of the assembly in which it resides.</span></span> <span data-ttu-id="ebcb4-134">한 어셈블리의 범위에서 로드된 `MyType`이라는 형식은 다른 어셈블리의 범위에서 로드된 `MyType`이라는 형식과 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-134">A type called `MyType` that is loaded in the scope of one assembly is not the same as a type called `MyType` that is loaded in the scope of another assembly.</span></span>

- <span data-ttu-id="ebcb4-135">참조 범위 경계.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-135">Reference scope boundary.</span></span> <span data-ttu-id="ebcb4-136">[어셈블리 매니페스트](#assembly-manifest)에는 형식을 확인하고 리소스 요청을 충족하는 데 사용되는 메타데이터가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-136">The [assembly manifest](#assembly-manifest) has metadata that is used for resolving types and satisfying resource requests.</span></span> <span data-ttu-id="ebcb4-137">매니페스트는 어셈블리 외부에 노출할 형식과 리소스를 지정하고, 해당 어셈블리가 종속된 다른 어셈블리를 열거합니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-137">The manifest specifies the types and resources to expose outside the assembly, and enumerates other assemblies on which it depends.</span></span> <span data-ttu-id="ebcb4-138">이식 가능(PE) 파일의 Microsoft Intermediate Language(MSIL) 코드는 연결된 [어셈블리 매니페스트](#assembly-manifest)가 없으면 실행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-138">Microsoft intermediate language (MSIL) code in a portable executable (PE) file won't be executed unless it has an associated [assembly manifest](#assembly-manifest).</span></span>

- <span data-ttu-id="ebcb4-139">버전 경계.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-139">Version boundary.</span></span> <span data-ttu-id="ebcb4-140">어셈블리는 공용 언어 런타임에서 가장 작은 버전 지정 가능 단위입니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-140">The assembly is the smallest versionable unit in the common language runtime.</span></span> <span data-ttu-id="ebcb4-141">동일한 어셈블리의 모든 형식과 리소스는 하나의 단위로 버전이 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-141">All types and resources in the same assembly are versioned as a unit.</span></span> <span data-ttu-id="ebcb4-142">[어셈블리 매니페스트](#assembly-manifest)는 종속 어셈블리에 지정한 버전 종속성을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-142">The [assembly manifest](#assembly-manifest) describes the version dependencies you specify for any dependent assemblies.</span></span> <span data-ttu-id="ebcb4-143">버전 관리에 대한 자세한 내용은 [어셈블리 버전 관리](versioning.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-143">For more information about versioning, see [Assembly versioning](versioning.md).</span></span>

- <span data-ttu-id="ebcb4-144">배포 단위.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-144">Deployment unit.</span></span> <span data-ttu-id="ebcb4-145">애플리케이션이 시작될 때 애플리케이션이 처음으로 호출하는 어셈블리만 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-145">When an application starts, only the assemblies that the application initially calls must be present.</span></span> <span data-ttu-id="ebcb4-146">지역화 리소스 또는 유틸리티 클래스가 포함된 어셈블리 등의 다른 어셈블리는 요청 시 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-146">Other assemblies, such as assemblies containing localization resources or utility classes, can be retrieved on demand.</span></span> <span data-ttu-id="ebcb4-147">이렇게 하면 처음 다운로드될 때 앱이 단순해집니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-147">This allows apps to be simple and thin when first downloaded.</span></span> <span data-ttu-id="ebcb4-148">어셈블리 배포에 대한 자세한 내용은 [애플리케이션 배포](../../framework/deployment/index.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-148">For more information about deploying assemblies, see [Deploy applications](../../framework/deployment/index.md).</span></span>

- <span data-ttu-id="ebcb4-149">Side-by-Side 실행 단위.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-149">Side-by-side execution unit.</span></span> <span data-ttu-id="ebcb4-150">여러 버전의 어셈블리 실행에 대한 자세한 내용은 [어셈블리 및 Side-by-Side 실행](side-by-side-execution.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-150">For more information about running multiple versions of an assembly, see [Assemblies and side-by-side execution](side-by-side-execution.md).</span></span>

## <a name="create-an-assembly"></a><span data-ttu-id="ebcb4-151">어셈블리 만들기</span><span class="sxs-lookup"><span data-stu-id="ebcb4-151">Create an assembly</span></span>

<span data-ttu-id="ebcb4-152">어셈블리는 정적 또는 동적이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-152">Assemblies can be static or dynamic.</span></span> <span data-ttu-id="ebcb4-153">정적 어셈블리는 PE(이식 가능한 실행) 파일로 디스크에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-153">Static assemblies are stored on disk in portable executable (PE) files.</span></span> <span data-ttu-id="ebcb4-154">정적 어셈블리에는 인터페이스와 클래스뿐 아니라 비트맵, JPEG 파일, 기타 리소스 파일 같은 리소스가 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-154">Static assemblies can include interfaces, classes, and resources like bitmaps, JPEG files, and other resource files.</span></span> <span data-ttu-id="ebcb4-155">메모리에서 직접 실행되며 실행 전에 디스크에 저장되지 않는 동적 어셈블리를 만들 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-155">You can also create dynamic assemblies, which are run directly from memory and aren't saved to disk before execution.</span></span> <span data-ttu-id="ebcb4-156">동적 어셈블리는 실행된 후에 디스크에 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-156">You can save dynamic assemblies to disk after they have executed.</span></span>

<span data-ttu-id="ebcb4-157">여러 가지 방법으로 어셈블리를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-157">There are several ways to create assemblies.</span></span> <span data-ttu-id="ebcb4-158">Visual Studio와 같이 *.dll* 또는 *.exe* 파일을 만들 수 있는 개발 도구를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-158">You can use development tools, such as Visual Studio, that can create *.dll* or *.exe* files.</span></span> <span data-ttu-id="ebcb4-159">Windows SDK의 도구를 사용하여 다른 개발 환경의 모듈이 포함된 어셈블리를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-159">You can use tools in the Windows SDK to create assemblies with modules from other development environments.</span></span> <span data-ttu-id="ebcb4-160">또한 <xref:System.Reflection.Emit?displayProperty=nameWithType> 등의 공용 언어 런타임 API를 사용하여 동적 어셈블리를 만들 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-160">You can also use common language runtime APIs, such as <xref:System.Reflection.Emit?displayProperty=nameWithType>, to create dynamic assemblies.</span></span>

<span data-ttu-id="ebcb4-161">Visual Studio에서 또는 .NET Core 명령줄 인터페이스 도구를 사용하여 어셈블리를 빌드하거나 명령줄 컴파일러를 사용하여 .NET Framework 어셈블리를 빌드하여 어셈블리를 컴파일합니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-161">Compile assemblies by building them in Visual Studio, building them with .NET Core command-line interface tools, or building .NET Framework assemblies with a command-line compiler.</span></span> <span data-ttu-id="ebcb4-162">.NET Core CLI를 사용하여 어셈블리를 빌드하는 방법에 대한 자세한 내용은 [.NET Core CLI 개요](../../core/tools/index.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-162">For more information about building assemblies using .NET Core CLI, see [.NET Core CLI overview](../../core/tools/index.md).</span></span>

> [!NOTE]
> <span data-ttu-id="ebcb4-163">Visual Studio에서 어셈블리를 빌드하려면 **빌드** 메뉴에서 **빌드** 를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-163">To build an assembly in Visual Studio, on the **Build** menu, select **Build**.</span></span>

## <a name="assembly-manifest"></a><span data-ttu-id="ebcb4-164">어셈블리 매니페스트</span><span class="sxs-lookup"><span data-stu-id="ebcb4-164">Assembly manifest</span></span>

<span data-ttu-id="ebcb4-165">모든 어셈블리에는 *어셈블리 매니페스트* 파일이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-165">Every assembly has an *assembly manifest* file.</span></span> <span data-ttu-id="ebcb4-166">목차와 유사하게 어셈블리 매니페스트에는 다음이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-166">Similar to a table of contents, the assembly manifest contains:</span></span>

- <span data-ttu-id="ebcb4-167">어셈블리의 ID(해당 이름 및 버전).</span><span class="sxs-lookup"><span data-stu-id="ebcb4-167">The assembly's identity (its name and version).</span></span>

- <span data-ttu-id="ebcb4-168">어셈블리를 구성하는 다른 모든 파일을 설명하는 파일 테이블(예: 사용자의 *.exe* 또는 *.dll* 파일이 의존하는 사용자가 만든 다른 모든 어셈블리 또는 비트맵 파일 또는 추가 정보 파일).</span><span class="sxs-lookup"><span data-stu-id="ebcb4-168">A file table describing all the other files that make up the assembly, such as other assemblies you created that your *.exe* or *.dll* file relies on, bitmap files, or Readme files.</span></span>

- <span data-ttu-id="ebcb4-169">*.dll* 또는 기타 파일 같은 모든 외부 종속성의 목록인 *어셈블리 참조 목록*.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-169">An *assembly reference list*, which is a list of all external dependencies, such as *.dll* s or other files.</span></span> <span data-ttu-id="ebcb4-170">어셈블리 참조는 global 및 private 개체에 대한 참조를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-170">Assembly references contain references to both global and private objects.</span></span> <span data-ttu-id="ebcb4-171">전역 개체는 다른 모든 애플리케이션에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-171">Global objects are available to all other applications.</span></span> <span data-ttu-id="ebcb4-172">.NET Core에서 전역 개체는 특정 .NET Core 런타임과 결합됩니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-172">In .NET Core, global objects are coupled with a particular .NET Core runtime.</span></span> <span data-ttu-id="ebcb4-173">.NET Framework에서 전역 개체는 전역 어셈블리 캐시(GAC)에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-173">In .NET Framework, global objects reside in the global assembly cache (GAC).</span></span> <span data-ttu-id="ebcb4-174">*System.IO.dll* 은 GAC에 있는 어셈블리의 예입니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-174">*System.IO.dll* is an example of an assembly in the GAC.</span></span> <span data-ttu-id="ebcb4-175">private 개체는 앱이 설치된 디렉터리와 같거나 낮은 디렉터리 수준에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-175">Private objects must be in a directory level at or below the directory in which your app is installed.</span></span>

<span data-ttu-id="ebcb4-176">어셈블리는 콘텐츠, 버전 관리 및 종속성에 대한 정보를 포함하므로 이를 사용하는 애플리케이션은 제대로 작동하기 위해 Windows 시스템의 레지스트리 같은 외부 소스를 사용할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-176">Because assemblies contain information about content, versioning, and dependencies, the applications that use them needn't rely on external sources, such as the registry on Windows systems, to function properly.</span></span> <span data-ttu-id="ebcb4-177">어셈블리는 *.dll* 충돌을 줄이고 더 안정적이고 배포하기 쉬운 애플리케이션을 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-177">Assemblies reduce *.dll* conflicts and make your applications more reliable and easier to deploy.</span></span> <span data-ttu-id="ebcb4-178">많은 경우에 해당 파일을 대상 컴퓨터에 복사하는 것만으로 .NET 기반 애플리케이션을 설치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-178">In many cases, you can install a .NET-based application simply by copying its files to the target computer.</span></span> <span data-ttu-id="ebcb4-179">자세한 내용은 [어셈블리 매니페스트](manifest.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-179">For more information, see [Assembly manifest](manifest.md).</span></span>

## <a name="add-a-reference-to-an-assembly"></a><span data-ttu-id="ebcb4-180">어셈블리에 대한 참조 추가</span><span class="sxs-lookup"><span data-stu-id="ebcb4-180">Add a reference to an assembly</span></span>

<span data-ttu-id="ebcb4-181">애플리케이션에서 어셈블리를 사용하려면 어셈블리에 대한 참조를 추가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-181">To use an assembly in an application, you must add a reference to it.</span></span> <span data-ttu-id="ebcb4-182">어셈블리가 참조되면 해당 코드가 소스 파일에 속해 있는 것처럼 해당 네임스페이스의 액세스 가능한 모든 유형, 속성, 메서드 및 기타 멤버를 애플리케이션에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-182">Once an assembly is referenced, all the accessible types, properties, methods, and other members of its namespaces are available to your application as if their code were part of your source file.</span></span>

> [!NOTE]
> <span data-ttu-id="ebcb4-183">.NET 클래스 라이브러리의 대부분의 어셈블리는 자동으로 참조됩니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-183">Most assemblies from the .NET Class Library are referenced automatically.</span></span> <span data-ttu-id="ebcb4-184">시스템 어셈블리가 자동으로 참조되지 않으면 .NET Core의 경우 어셈블리를 포함하는 NuGet 패키지에 대한 참조를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-184">If a system assembly isn't automatically referenced, for .NET Core, you can add a reference to the NuGet package that contains the assembly.</span></span> <span data-ttu-id="ebcb4-185">Visual Studio에서 NuGet 패키지 관리자를 사용하거나 어셈블리의 [\<PackageReference>](../../core/tools/dependencies.md#the-packagereference-element) 요소를 *.csproj* 또는 *.vbproj* 프로젝트에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-185">Either use the NuGet Package Manager in Visual Studio, or add a [\<PackageReference>](../../core/tools/dependencies.md#the-packagereference-element) element for the assembly to the *.csproj* or *.vbproj* project.</span></span> <span data-ttu-id="ebcb4-186">.NET framework에서 Visual Studio의 **참조 추가** 대화 상자를 사용하거나 [C#](../../csharp/language-reference/compiler-options/inputs.md#references)의 `-reference` 명령줄 옵션 또는 [Visual Basic](../../visual-basic/reference/command-line-compiler/reference.md) 컴파일러를 사용하여 어셈블리에 대한 참조를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-186">In .NET Framework, you can add a reference to the assembly by using the **Add Reference** dialog in Visual Studio, or by using the `-reference` command line option for the [C#](../../csharp/language-reference/compiler-options/inputs.md#references) or [Visual Basic](../../visual-basic/reference/command-line-compiler/reference.md) compilers.</span></span>

<span data-ttu-id="ebcb4-187">C#에서는 단일 애플리케이션에서 동일한 어셈블리의 두 버전을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-187">In C#, you can use two versions of the same assembly in a single application.</span></span> <span data-ttu-id="ebcb4-188">자세한 내용은 [extern alias](../../csharp/language-reference/keywords/extern-alias.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-188">For more information, see [extern alias](../../csharp/language-reference/keywords/extern-alias.md).</span></span>

## <a name="related-content"></a><span data-ttu-id="ebcb4-189">관련 콘텐츠</span><span class="sxs-lookup"><span data-stu-id="ebcb4-189">Related content</span></span>

|<span data-ttu-id="ebcb4-190">제목</span><span class="sxs-lookup"><span data-stu-id="ebcb4-190">Title</span></span>|<span data-ttu-id="ebcb4-191">설명</span><span class="sxs-lookup"><span data-stu-id="ebcb4-191">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="ebcb4-192">어셈블리 콘텐츠</span><span class="sxs-lookup"><span data-stu-id="ebcb4-192">Assembly contents</span></span>](contents.md)|<span data-ttu-id="ebcb4-193">어셈블리를 구성하는 요소.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-193">Elements that make up an assembly.</span></span>|
|[<span data-ttu-id="ebcb4-194">어셈블리 매니페스트</span><span class="sxs-lookup"><span data-stu-id="ebcb4-194">Assembly manifest</span></span>](manifest.md)|<span data-ttu-id="ebcb4-195">어셈블리 매니페스트의 데이터와 이 데이터가 어셈블리에 저장되는 방법.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-195">Data in the assembly manifest, and how it is stored in assemblies.</span></span>|
|[<span data-ttu-id="ebcb4-196">전역 어셈블리 캐시</span><span class="sxs-lookup"><span data-stu-id="ebcb4-196">Global assembly cache</span></span>](../../framework/app-domains/gac.md)|<span data-ttu-id="ebcb4-197">GAC에서 어셈블리를 저장하고 사용하는 방법.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-197">How the GAC stores and uses assemblies.</span></span>|
|[<span data-ttu-id="ebcb4-198">강력한 이름의 어셈블리</span><span class="sxs-lookup"><span data-stu-id="ebcb4-198">Strong-named assemblies</span></span>](strong-named.md)|<span data-ttu-id="ebcb4-199">강력한 이름의 어셈블리의 특징.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-199">Characteristics of strong-named assemblies.</span></span>|
|[<span data-ttu-id="ebcb4-200">어셈블리 보안 고려 사항</span><span class="sxs-lookup"><span data-stu-id="ebcb4-200">Assembly security considerations</span></span>](security-considerations.md)|<span data-ttu-id="ebcb4-201">어셈블리에 보안이 사용되는 방법.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-201">How security works with assemblies.</span></span>|
|[<span data-ttu-id="ebcb4-202">어셈블리 버전 관리</span><span class="sxs-lookup"><span data-stu-id="ebcb4-202">Assembly versioning</span></span>](versioning.md)|<span data-ttu-id="ebcb4-203">.NET Framework 버전 관리 정책의 개요.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-203">Overview of the .NET Framework versioning policy.</span></span>|
|[<span data-ttu-id="ebcb4-204">어셈블리 배치</span><span class="sxs-lookup"><span data-stu-id="ebcb4-204">Assembly placement</span></span>](../../framework/app-domains/assembly-placement.md)|<span data-ttu-id="ebcb4-205">어셈블리가 배치되는 위치.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-205">Where to locate assemblies.</span></span>|
|[<span data-ttu-id="ebcb4-206">어셈블리 및 Side-by-Side 실행</span><span class="sxs-lookup"><span data-stu-id="ebcb4-206">Assemblies and side-by-side execution</span></span>](side-by-side-execution.md)|<span data-ttu-id="ebcb4-207">여러 버전의 런타임 또는 어셈블리를 동시에 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-207">Use multiple versions of the runtime or an assembly simultaneously.</span></span>|
|[<span data-ttu-id="ebcb4-208">동적 메서드 및 어셈블리 내보내기</span><span class="sxs-lookup"><span data-stu-id="ebcb4-208">Emit dynamic methods and assemblies</span></span>](../../framework/reflection-and-codedom/emitting-dynamic-methods-and-assemblies.md)|<span data-ttu-id="ebcb4-209">동적 어셈블리를 만드는 방법.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-209">How to create dynamic assemblies.</span></span>|
|[<span data-ttu-id="ebcb4-210">런타임에서 어셈블리를 찾는 방법</span><span class="sxs-lookup"><span data-stu-id="ebcb4-210">How the runtime locates assemblies</span></span>](../../framework/deployment/how-the-runtime-locates-assemblies.md)|<span data-ttu-id="ebcb4-211">.NET Framework가 런타임에서 어셈블리 참조를 확인하는 방법.</span><span class="sxs-lookup"><span data-stu-id="ebcb4-211">How the .NET Framework resolves assembly references at run time.</span></span>|

## <a name="reference"></a><span data-ttu-id="ebcb4-212">참고</span><span class="sxs-lookup"><span data-stu-id="ebcb4-212">Reference</span></span>

<xref:System.Reflection.Assembly?displayProperty=nameWithType>

## <a name="see-also"></a><span data-ttu-id="ebcb4-213">참조</span><span class="sxs-lookup"><span data-stu-id="ebcb4-213">See also</span></span>

- [<span data-ttu-id="ebcb4-214">.NET 어셈블리 파일 형식</span><span class="sxs-lookup"><span data-stu-id="ebcb4-214">.NET assembly file format</span></span>](file-format.md)
- [<span data-ttu-id="ebcb4-215">friend 어셈블리</span><span class="sxs-lookup"><span data-stu-id="ebcb4-215">Friend assemblies</span></span>](friend.md)
- [<span data-ttu-id="ebcb4-216">참조 어셈블리</span><span class="sxs-lookup"><span data-stu-id="ebcb4-216">Reference assemblies</span></span>](reference-assemblies.md)
- [<span data-ttu-id="ebcb4-217">방법: 어셈블리 로드 및 언로드</span><span class="sxs-lookup"><span data-stu-id="ebcb4-217">How to: Load and unload assemblies</span></span>](load-unload.md)
- [<span data-ttu-id="ebcb4-218">방법: .NET Core에서 어셈블리 언로드 기능 사용 및 디버그</span><span class="sxs-lookup"><span data-stu-id="ebcb4-218">How to: Use and debug assembly unloadability in .NET Core</span></span>](unloadability.md)
- [<span data-ttu-id="ebcb4-219">방법: 파일이 어셈블리인지 확인</span><span class="sxs-lookup"><span data-stu-id="ebcb4-219">How to: Determine if a file is an assembly</span></span>](identify.md)
- [<span data-ttu-id="ebcb4-220">방법: MetadataLoadContext를 사용하여 어셈블리 콘텐츠 검사</span><span class="sxs-lookup"><span data-stu-id="ebcb4-220">How to: Inspect assembly contents using MetadataLoadContext</span></span>](inspect-contents-using-metadataloadcontext.md)
