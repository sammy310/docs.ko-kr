---
title: 관리되는 스레드의 취소
description: 관리형 스레드의 취소에 대해 이해합니다. 비동기 작업 또는 장기 실행 동기 작업에 대한 협조적 취소의 취소 토큰에 대해 알아봅니다.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- cancellation in .NET, overview
ms.assetid: eea11fe5-d8b0-4314-bb5d-8a58166fb1c3
ms.openlocfilehash: 578db725458ad5c4a90256a06744a58a6d1918da
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/18/2020
ms.locfileid: "94819957"
---
# <a name="cancellation-in-managed-threads"></a><span data-ttu-id="30557-104">관리되는 스레드의 취소</span><span class="sxs-lookup"><span data-stu-id="30557-104">Cancellation in Managed Threads</span></span>

<span data-ttu-id="30557-105">.NET Framework 4부터 .NET에서는 비동기 또는 장기 실행 비동기 작업의 협조적 취소를 위한 통합 모델을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="30557-105">Starting with .NET Framework 4, .NET uses a unified model for cooperative cancellation of asynchronous or long-running synchronous operations.</span></span> <span data-ttu-id="30557-106">이 모델은 취소 토큰이라는 경량 개체에 기반을 둡니다.</span><span class="sxs-lookup"><span data-stu-id="30557-106">This model is based on a lightweight object called a cancellation token.</span></span> <span data-ttu-id="30557-107">취소할 수 있는 작업 하나 이상을 호출하는 개체가 새 스레드나 작업 등을 만드는 방식으로 토큰을 각 작업에 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="30557-107">The object that invokes one or more cancelable operations, for example by creating new threads or tasks, passes the token to each operation.</span></span> <span data-ttu-id="30557-108">개별 작업이 토큰 복사본을 다시 다른 작업에 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30557-108">Individual operations can in turn pass copies of the token to other operations.</span></span> <span data-ttu-id="30557-109">나중에 토큰을 만든 개체가 해당 토큰을 사용하여 관련 작업이 수행 중인 작업을 중지하도록 요청할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30557-109">At some later time, the object that created the token can use it to request that the operations stop what they are doing.</span></span> <span data-ttu-id="30557-110">요청 개체만 취소 요청을 실행할 수 있고 각 수신기는 적절한 시간에 적절한 방식으로 요청을 알리고 요청에 응답해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="30557-110">Only the requesting object can issue the cancellation request, and each listener is responsible for noticing the request and responding to it in an appropriate and timely manner.</span></span>  
  
<span data-ttu-id="30557-111">협조적 취소 모델을 구현하는 일반적인 패턴은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="30557-111">The general pattern for implementing the cooperative cancellation model is:</span></span>  
  
- <span data-ttu-id="30557-112">개별 취소 토큰을 관리하고 토큰에 취소 알림을 보내는 <xref:System.Threading.CancellationTokenSource> 개체를 인스턴스화합니다.</span><span class="sxs-lookup"><span data-stu-id="30557-112">Instantiate a <xref:System.Threading.CancellationTokenSource> object, which manages and sends cancellation notification to the individual cancellation tokens.</span></span>  
  
- <span data-ttu-id="30557-113"><xref:System.Threading.CancellationTokenSource.Token%2A?displayProperty=nameWithType> 속성에서 반환된 토큰을 취소를 수신 대기하는 각 작업이나 스레드에 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="30557-113">Pass the token returned by the <xref:System.Threading.CancellationTokenSource.Token%2A?displayProperty=nameWithType> property to each task or thread that listens for cancellation.</span></span>  
  
- <span data-ttu-id="30557-114">각 작업이나 스레드가 취소에 응답하는 메커니즘을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="30557-114">Provide a mechanism for each task or thread to respond to cancellation.</span></span>  
  
- <span data-ttu-id="30557-115"><xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> 메서드를 호출하여 취소 알림을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="30557-115">Call the <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> method to provide notification of cancellation.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="30557-116"><xref:System.Threading.CancellationTokenSource> 클래스가 <xref:System.IDisposable> 인터페이스를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="30557-116">The <xref:System.Threading.CancellationTokenSource> class implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="30557-117">취소 토큰 소스 사용을 마치면 <xref:System.Threading.CancellationTokenSource.Dispose%2A?displayProperty=nameWithType> 메서드를 호출하여 토큰에 포함된 관리되지 않는 리소스를 해제해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="30557-117">You should be sure to call the <xref:System.Threading.CancellationTokenSource.Dispose%2A?displayProperty=nameWithType> method when you have finished using the cancellation token source to free any unmanaged resources it holds.</span></span>  
  
 <span data-ttu-id="30557-118">다음 그림에서는 토큰 소스와 모든 토큰 복사본의 관계를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="30557-118">The following illustration shows the relationship between a token source and all the copies of its token.</span></span>  
  
 <span data-ttu-id="30557-119">![CancellationTokenSource 및 cancellation 토큰](media/vs-cancellationtoken.png "VS_CancellationToken")</span><span class="sxs-lookup"><span data-stu-id="30557-119">![CancellationTokenSource and cancellation tokens](media/vs-cancellationtoken.png "VS_CancellationToken")</span></span>  
  
 <span data-ttu-id="30557-120">협조적 취소 모델을 통해 취소 인식 애플리케이션 및 라이브러리를 더 쉽게 만들 수 있고 이 모델은 다음 기능을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="30557-120">The cooperative cancellation model makes it easier to create cancellation-aware applications and libraries, and it supports the following features:</span></span>  
  
- <span data-ttu-id="30557-121">취소는 협조적이고 수신기에 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="30557-121">Cancellation is cooperative and is not forced on the listener.</span></span> <span data-ttu-id="30557-122">수신기는 취소 요청에 대한 응답으로 정상적으로 종료하는 방법을 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="30557-122">The listener determines how to gracefully terminate in response to a cancellation request.</span></span>  
  
- <span data-ttu-id="30557-123">요청은 수신 대기와 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="30557-123">Requesting is distinct from listening.</span></span> <span data-ttu-id="30557-124">취소할 수 있는 작업을 호출하는 개체는 취소가 있더라도 취소가 요청되는 시점을 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30557-124">An object that invokes a cancelable operation can control when (if ever) cancellation is requested.</span></span>  
  
- <span data-ttu-id="30557-125">요청 개체는 단 하나의 메서드 호출을 통해 모든 토큰 복사본에 대해 취소 요청을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="30557-125">The requesting object issues the cancellation request to all copies of the token by using just one method call.</span></span>  
  
- <span data-ttu-id="30557-126">수신기는 여러 토큰을 하나의 *연결된 토큰* 으로 결합하여 동시에 수신 대기할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30557-126">A listener can listen to multiple tokens simultaneously by joining them into one *linked token*.</span></span>  
  
- <span data-ttu-id="30557-127">사용자 코드는 라이브러리 코드에서 취소 요청을 인식하고 이 요청에 응답할 수 있고, 라이브러리 코드는 사용자 코드에서 취소 요청을 인식하고 이 요청에 응답할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30557-127">User code can notice and respond to cancellation requests from library code, and library code can notice and respond to cancellation requests from user code.</span></span>  
  
- <span data-ttu-id="30557-128">수신기는 대기 핸들에 대한 폴링, 콜백 등록 또는 대기를 통해 취소 요청에 대한 알림을 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30557-128">Listeners can be notified of cancellation requests by polling, callback registration, or waiting on wait handles.</span></span>  
  
## <a name="cancellation-types"></a><span data-ttu-id="30557-129">취소 형식</span><span class="sxs-lookup"><span data-stu-id="30557-129">Cancellation Types</span></span>  
 <span data-ttu-id="30557-130">취소 프레임워크는 다음 표에 나열된 관련 형식 집합으로 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="30557-130">The cancellation framework is implemented as a set of related types, which are listed in the following table.</span></span>  
  
|<span data-ttu-id="30557-131">형식 이름</span><span class="sxs-lookup"><span data-stu-id="30557-131">Type name</span></span>|<span data-ttu-id="30557-132">설명</span><span class="sxs-lookup"><span data-stu-id="30557-132">Description</span></span>|  
|---------------|-----------------|  
|<xref:System.Threading.CancellationTokenSource>|<span data-ttu-id="30557-133">취소 토큰을 만들고 해당 토큰의 모든 복사본에 대한 취소 요청을 실행하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="30557-133">Object that creates a cancellation token, and also issues the cancellation request for all copies of that token.</span></span>|  
|<xref:System.Threading.CancellationToken>|<span data-ttu-id="30557-134">일반적으로 메서드 매개 변수로 수신기 하나 이상에 전달되는 경량 값 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="30557-134">Lightweight value type passed to one or more listeners, typically as a method parameter.</span></span> <span data-ttu-id="30557-135">수신기는 핸들을 폴링, 콜백 또는 대기하여 토큰의 `IsCancellationRequested` 속성 값을 모니터링합니다.</span><span class="sxs-lookup"><span data-stu-id="30557-135">Listeners monitor the value of the `IsCancellationRequested` property of the token by polling, callback, or wait handle.</span></span>|  
|<xref:System.OperationCanceledException>|<span data-ttu-id="30557-136">이 예외 생성자의 오버로드는 <xref:System.Threading.CancellationToken>을 매개 변수로 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="30557-136">Overloads of this exception's constructor accept a <xref:System.Threading.CancellationToken> as a parameter.</span></span> <span data-ttu-id="30557-137">수신기는 선택적으로 이 예외를 throw하여 취소의 출처를 확인하고 취소 요청에 응답했다는 것을 다른 수신기에 알립니다.</span><span class="sxs-lookup"><span data-stu-id="30557-137">Listeners can optionally throw this exception to verify the source of the cancellation and notify others that it has responded to a cancellation request.</span></span>|  
  
 <span data-ttu-id="30557-138">취소 모델은 여러 가지 형식으로 .NET에 통합되었습니다.</span><span class="sxs-lookup"><span data-stu-id="30557-138">The cancellation model is integrated into .NET in several types.</span></span> <span data-ttu-id="30557-139">가장 중요한 형식은 <xref:System.Threading.Tasks.Parallel?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Task?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> 및 <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType>입니다.</span><span class="sxs-lookup"><span data-stu-id="30557-139">The most important ones are <xref:System.Threading.Tasks.Parallel?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Task?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> and <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType>.</span></span> <span data-ttu-id="30557-140">모든 새 라이브러리 및 애플리케이션 코드에 대해 이 협조적 취소 모델을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="30557-140">We recommend that you use this cooperative cancellation model for all new library and application code.</span></span>  
  
## <a name="code-example"></a><span data-ttu-id="30557-141">코드 예제</span><span class="sxs-lookup"><span data-stu-id="30557-141">Code Example</span></span>  
 <span data-ttu-id="30557-142">다음 예제에서는 요청 개체가 <xref:System.Threading.CancellationTokenSource> 개체를 만들고 <xref:System.Threading.CancellationTokenSource.Token%2A> 속성을 취소 가능한 작업에 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="30557-142">In the following example, the requesting object creates a <xref:System.Threading.CancellationTokenSource> object, and then passes its <xref:System.Threading.CancellationTokenSource.Token%2A> property to the cancelable operation.</span></span> <span data-ttu-id="30557-143">요청을 수신하는 작업에서는 폴링을 통해 토큰의 <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> 속성 값을 모니터링합니다.</span><span class="sxs-lookup"><span data-stu-id="30557-143">The operation that receives the request monitors the value of the <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property of the token by polling.</span></span> <span data-ttu-id="30557-144">값이 `true`가 되면 수신기가 적절한 방식이더라도 종료될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30557-144">When the value becomes `true`, the listener can terminate in whatever manner is appropriate.</span></span> <span data-ttu-id="30557-145">이 예제에서는 대부분 경우에 모두 필요한 메서드가 종료됩니다.</span><span class="sxs-lookup"><span data-stu-id="30557-145">In this example, the method just exits, which is all that is required in many cases.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="30557-146">예제에서는 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> 메서드를 사용하여 협조적 취소 프레임워크가 레거시 API와 호환된다는 것을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="30557-146">The example uses the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method to demonstrate that the cooperative cancellation framework is compatible with legacy APIs.</span></span> <span data-ttu-id="30557-147">권장 <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 형식을 사용하는 예제에 관해서는 [방법: 작업 및 해당 자식 취소](../parallel-programming/how-to-cancel-a-task-and-its-children.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="30557-147">For an example that uses the preferred <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> type, see [How to: Cancel a Task and Its Children](../parallel-programming/how-to-cancel-a-task-and-its-children.md).</span></span>  
  
 [!code-csharp[Cancellation#1](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/cancellationex1.cs#1)]
 [!code-vb[Cancellation#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/cancellationex1.vb#1)]  
  
## <a name="operation-cancellation-versus-object-cancellation"></a><span data-ttu-id="30557-148">작업 취소 대 개체 취소</span><span class="sxs-lookup"><span data-stu-id="30557-148">Operation Cancellation Versus Object Cancellation</span></span>  
 <span data-ttu-id="30557-149">협조적 취소 프레임워크에서 취소는 개체가 아니라 작업을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="30557-149">In the cooperative cancellation framework, cancellation refers to operations, not objects.</span></span> <span data-ttu-id="30557-150">취소 요청은 필요한 정리가 수행되고 나서 가능하면 즉시 작업이 중지되어야 함을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="30557-150">The cancellation request means that the operation should stop as soon as possible after any required cleanup is performed.</span></span> <span data-ttu-id="30557-151">취소 토큰 하나가 “취소할 수 있는 작업" 하나를 나타내야 하지만 해당 작업은 프로그램에서 구현될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30557-151">One cancellation token should refer to one "cancelable operation," however that operation may be implemented in your program.</span></span> <span data-ttu-id="30557-152">토큰의 <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> 속성이 `true`로 설정되고 나면 `false`로 재설정될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="30557-152">After the <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property of the token has been set to `true`, it cannot be reset to `false`.</span></span> <span data-ttu-id="30557-153">따라서 취소 토큰이 취소된 후에는 해당 토큰을 다시 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="30557-153">Therefore, cancellation tokens cannot be reused after they have been canceled.</span></span>  
  
 <span data-ttu-id="30557-154">개체 취소 메커니즘이 필요하면 다음 예제와 같이 <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType> 메서드를 호출하여 작업 취소 메커니즘을 기반으로 개체 취소 메커니즘을 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30557-154">If you require an object cancellation mechanism, you can base it on the operation cancellation mechanism by calling the <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType> method, as shown in the following example.</span></span>  
  
 [!code-csharp[Cancellation#2](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/objectcancellation1.cs#2)]
 [!code-vb[Cancellation#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/objectcancellation1.vb#2)]  
  
 <span data-ttu-id="30557-155">개체가 동시 취소 가능 작업을 두 개 이상 지원하면 개별 토큰을 개별 취소 가능한 작업에 입력으로 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="30557-155">If an object supports more than one concurrent cancelable operation, pass a separate token as input to each distinct cancelable operation.</span></span> <span data-ttu-id="30557-156">이런 방식으로 다른 작업에 영향을 미치지 않고 작업을 취소할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30557-156">That way, one operation can be cancelled without affecting the others.</span></span>  
  
## <a name="listening-and-responding-to-cancellation-requests"></a><span data-ttu-id="30557-157">취소 요청 수신 대기 및 응답</span><span class="sxs-lookup"><span data-stu-id="30557-157">Listening and Responding to Cancellation Requests</span></span>  
 <span data-ttu-id="30557-158">사용자 대리자에서 취소 가능한 작업의 구현자는 취소 요청에 대한 응답으로 작업을 종료하는 방법을 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="30557-158">In the user delegate, the implementer of a cancelable operation determines how to terminate the operation in response to a cancellation request.</span></span> <span data-ttu-id="30557-159">대부분 경우에 사용자 대리자는 필요한 정리를 수행하고 즉시 반환될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30557-159">In many cases, the user delegate can just perform any required cleanup and then return immediately.</span></span>  
  
 <span data-ttu-id="30557-160">그러나 더 복잡한 경우에 사용자 대리자가 취소가 발생했다는 정보를 라이브러리 코드에 알려야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30557-160">However, in more complex cases, it might be necessary for the user delegate to notify library code that cancellation has occurred.</span></span> <span data-ttu-id="30557-161">이 경우 작업을 종료하는 올바른 방법은 <xref:System.OperationCanceledException>을 throw하는 <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A> 메서드를 대리자가 호출하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="30557-161">In such cases, the correct way to terminate the operation is for the delegate to call the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A>, method, which will cause an <xref:System.OperationCanceledException> to be thrown.</span></span> <span data-ttu-id="30557-162">라이브러리 코드는 사용자 대리자 스레드에서 이 예외를 catch하고 예외의 토큰을 검사하여 예외가 협조적 취소를 나타내는지, 아니면 다른 예외적인 상황인지를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="30557-162">Library code can catch this exception on the user delegate thread and examine the exception's token to determine whether the exception indicates cooperative cancellation or some other exceptional situation.</span></span>  
  
 <span data-ttu-id="30557-163"><xref:System.Threading.Tasks.Task> 클래스는 이 방식으로 <xref:System.OperationCanceledException>을 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="30557-163">The <xref:System.Threading.Tasks.Task> class handles <xref:System.OperationCanceledException> in this way.</span></span> <span data-ttu-id="30557-164">자세한 내용은 [작업 취소](../parallel-programming/task-cancellation.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="30557-164">For more information, see [Task Cancellation](../parallel-programming/task-cancellation.md).</span></span>  
  
### <a name="listening-by-polling"></a><span data-ttu-id="30557-165">폴링으로 수신 대기</span><span class="sxs-lookup"><span data-stu-id="30557-165">Listening by Polling</span></span>  
 <span data-ttu-id="30557-166">루핑되거나 재귀적으로 사용되는 장기 실행 계산의 경우 <xref:System.Threading.CancellationToken.IsCancellationRequested%2A?displayProperty=nameWithType> 속성 값을 주기적으로 폴링하여 취소 요청을 수신 대기할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30557-166">For long-running computations that loop or recurse, you can listen for a cancellation request by periodically polling the value of the <xref:System.Threading.CancellationToken.IsCancellationRequested%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="30557-167">값이 `true`이면 메서드가 가능한 한 빠르게 정리 및 종료되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="30557-167">If its value is `true`, the method should clean up and terminate as quickly as possible.</span></span> <span data-ttu-id="30557-168">최적 폴링 빈도는 애플리케이션 형식에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="30557-168">The optimal frequency of polling depends on the type of application.</span></span> <span data-ttu-id="30557-169">특정 프로그램에 대한 최적 폴링 빈도는 개발자가 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30557-169">It is up to the developer to determine the best polling frequency for any given program.</span></span> <span data-ttu-id="30557-170">폴링 자체는 성능에 큰 영향을 미치지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="30557-170">Polling itself does not significantly impact performance.</span></span> <span data-ttu-id="30557-171">다음 예제에서는 한 가지 가능한 폴링 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="30557-171">The following example shows one possible way to poll.</span></span>  
  
 [!code-csharp[Cancellation#3](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/cancellationex11.cs#3)]
 [!code-vb[Cancellation#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/cancellationex11.vb#3)]  
  
 <span data-ttu-id="30557-172">자세한 예제는 [방법: 폴링을 통해 취소 요청 수신 대기](how-to-listen-for-cancellation-requests-by-polling.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="30557-172">For a more complete example, see [How to: Listen for Cancellation Requests by Polling](how-to-listen-for-cancellation-requests-by-polling.md).</span></span>  
  
### <a name="listening-by-registering-a-callback"></a><span data-ttu-id="30557-173">콜백을 등록하여 수신 대기</span><span class="sxs-lookup"><span data-stu-id="30557-173">Listening by Registering a Callback</span></span>  
 <span data-ttu-id="30557-174">일부 작업은 적절한 시기에 취소 토큰의 값을 확인할 수 없는 방식으로 차단될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30557-174">Some operations can become blocked in such a way that they cannot check the value of the cancellation token in a timely manner.</span></span> <span data-ttu-id="30557-175">이러한 경우에는 취소 요청이 수신될 때 메서드를 차단 해제하는 콜백 메서드를 등록할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30557-175">For these cases, you can register a callback method that unblocks the method when a cancellation request is received.</span></span>  
  
 <span data-ttu-id="30557-176"><xref:System.Threading.CancellationToken.Register%2A> 메서드는 특히 이 목적으로 사용되는 <xref:System.Threading.CancellationTokenRegistration> 개체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="30557-176">The <xref:System.Threading.CancellationToken.Register%2A> method returns a <xref:System.Threading.CancellationTokenRegistration> object that is used specifically for this purpose.</span></span> <span data-ttu-id="30557-177">다음 예제에서는 <xref:System.Threading.CancellationToken.Register%2A> 메서드를 사용하여 비동기 웹 요청을 취소하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="30557-177">The following example shows how to use the <xref:System.Threading.CancellationToken.Register%2A> method to cancel an asynchronous Web request.</span></span>  
  
 [!code-csharp[Cancellation#4](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/cancellationex4.cs#4)]
 [!code-vb[Cancellation#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/cancellationex4.vb#4)]  
  
 <span data-ttu-id="30557-178"><xref:System.Threading.CancellationTokenRegistration> 개체는 스레드 동기화를 관리하고 콜백이 정확한 시점에 실행을 중지하는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="30557-178">The <xref:System.Threading.CancellationTokenRegistration> object manages thread synchronization and ensures that the callback will stop executing at a precise point in time.</span></span>  
  
 <span data-ttu-id="30557-179">시스템 응답성을 확인하고 교착 상태를 방지하려면 콜백을 등록할 때 다음 지침을 따라야 합니다.</span><span class="sxs-lookup"><span data-stu-id="30557-179">In order to ensure system responsiveness and to avoid deadlocks, the following guidelines must be followed when registering callbacks:</span></span>  
  
- <span data-ttu-id="30557-180">콜백 메서드는 동기적으로 호출되어 콜백이 반환될 때까지 <xref:System.Threading.CancellationTokenSource.Cancel%2A>에 대한 호출이 반환되지 않으므로 콜백 메서드는 빨라야 합니다.</span><span class="sxs-lookup"><span data-stu-id="30557-180">The callback method should be fast because it is called synchronously and therefore the call to <xref:System.Threading.CancellationTokenSource.Cancel%2A> does not return until the callback returns.</span></span>  
  
- <span data-ttu-id="30557-181">콜백이 실행되는 동안 <xref:System.Threading.CancellationTokenRegistration.Dispose%2A>를 호출하고 콜백이 대기하도록 잠금을 유지하면 프로그램에서 교착 상태가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30557-181">If you call <xref:System.Threading.CancellationTokenRegistration.Dispose%2A> while the callback is running, and you hold a lock that the callback is waiting on, your program can deadlock.</span></span> <span data-ttu-id="30557-182">`Dispose`가 반환되고 나서 콜백에 필요한 리소스를 해제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30557-182">After `Dispose` returns, you can free any resources required by the callback.</span></span>  
  
- <span data-ttu-id="30557-183">콜백은 한 콜백에서 수동 스레드 또는 <xref:System.Threading.SynchronizationContext> 사용을 수행하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="30557-183">Callbacks should not perform any manual thread or <xref:System.Threading.SynchronizationContext> usage in a callback.</span></span> <span data-ttu-id="30557-184">콜백이 특정 스레드에서 실행되어야 하면 대상 syncContext가 활성 <xref:System.Threading.SynchronizationContext.Current%2A?displayProperty=nameWithType>가 되도록 지정할 수 있는 <xref:System.Threading.CancellationTokenRegistration?displayProperty=nameWithType> 생성자를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="30557-184">If a callback must run on a particular thread, use the <xref:System.Threading.CancellationTokenRegistration?displayProperty=nameWithType> constructor that enables you to specify that the target syncContext is the active <xref:System.Threading.SynchronizationContext.Current%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="30557-185">콜백에서 수동 스레딩을 수행하면 교착 상태가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30557-185">Performing manual threading in a callback can cause deadlock.</span></span>  
  
 <span data-ttu-id="30557-186">자세한 예제는 [방법: 취소 요청에 대한 콜백 등록](how-to-register-callbacks-for-cancellation-requests.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="30557-186">For a more complete example, see [How to: Register Callbacks for Cancellation Requests](how-to-register-callbacks-for-cancellation-requests.md).</span></span>  
  
### <a name="listening-by-using-a-wait-handle"></a><span data-ttu-id="30557-187">대기 핸들을 사용하여 수신 대기</span><span class="sxs-lookup"><span data-stu-id="30557-187">Listening by Using a Wait Handle</span></span>  
 <span data-ttu-id="30557-188">취소할 수 있는 작업이 <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType> 또는 <xref:System.Threading.Semaphore?displayProperty=nameWithType>와 같은 동기화 기본 형식에서 대기하는 동안 차단되면 <xref:System.Threading.CancellationToken.WaitHandle%2A?displayProperty=nameWithType> 속성을 사용하여 작업이 이벤트 및 취소 요청에서 대기하도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30557-188">When a cancelable operation can block while it waits on a synchronization primitive such as a <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType> or <xref:System.Threading.Semaphore?displayProperty=nameWithType>, you can use the <xref:System.Threading.CancellationToken.WaitHandle%2A?displayProperty=nameWithType> property to enable the operation to wait on both the event and the cancellation request.</span></span> <span data-ttu-id="30557-189">취소 토큰의 대기 핸들은 취소 요청에 대한 응답으로 신호가 전송되고 메서드는 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드의 반환 값을 사용하여 신호를 전송한 취소 토큰이었는지를 판별할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30557-189">The wait handle of the cancellation token will become signaled in response to a cancellation request, and the method can use the return value of the <xref:System.Threading.WaitHandle.WaitAny%2A> method to determine whether it was the cancellation token that signaled.</span></span> <span data-ttu-id="30557-190">그리고 나서 작업은 적절하게 종료되거나 <xref:System.OperationCanceledException>을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="30557-190">The operation can then just exit, or throw a <xref:System.OperationCanceledException>, as appropriate.</span></span>  
  
 [!code-csharp[Cancellation#5](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/cancellationex9.cs#5)]
 [!code-vb[Cancellation#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/cancellationex9.vb#5)]  
  
<span data-ttu-id="30557-191"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> 및 <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType>은 `Wait` 메서드에서 취소 프레임워크를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="30557-191"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> and <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> both support the cancellation framework in their `Wait` methods.</span></span> <span data-ttu-id="30557-192"><xref:System.Threading.CancellationToken>을 메서드에 전달하고 취소가 요청될 대 이벤트가 활성화되어 <xref:System.OperationCanceledException>을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="30557-192">You can pass the <xref:System.Threading.CancellationToken> to the method, and when the cancellation is requested, the event wakes up and throws an <xref:System.OperationCanceledException>.</span></span>  
  
 [!code-csharp[Cancellation#6](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/cancellationex10.cs#6)]
 [!code-vb[Cancellation#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/cancellationex10.vb#6)]  
  
 <span data-ttu-id="30557-193">자세한 예제는 [방법: 대기 핸들이 있는 취소 요청 수신 대기](how-to-listen-for-cancellation-requests-that-have-wait-handles.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="30557-193">For a more complete example, see [How to: Listen for Cancellation Requests That Have Wait Handles](how-to-listen-for-cancellation-requests-that-have-wait-handles.md).</span></span>  
  
### <a name="listening-to-multiple-tokens-simultaneously"></a><span data-ttu-id="30557-194">동시에 여러 토큰 수신 대기</span><span class="sxs-lookup"><span data-stu-id="30557-194">Listening to Multiple Tokens Simultaneously</span></span>  
 <span data-ttu-id="30557-195">경우에 따라 수신기는 여러 취소 토큰을 동시에 수신 대기해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30557-195">In some cases, a listener may have to listen to multiple cancellation tokens simultaneously.</span></span> <span data-ttu-id="30557-196">예를 들어 취소 가능한 작업은 외부에서 메서드 매개 변수에 인수로 전달되는 토큰 이외에 내부 취소 토큰을 모니터링해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30557-196">For example, a cancelable operation may have to monitor an internal cancellation token in addition to a token passed in externally as an argument to a method parameter.</span></span> <span data-ttu-id="30557-197">이 작업을 하려면 다음 예제와 같이 토큰 두 개 이상을 토큰 하나로 결합할 수 있는 연결된 토큰 소스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="30557-197">To accomplish this, create a linked token source that can join two or more tokens into one token, as shown in the following example.</span></span>  
  
 [!code-csharp[Cancellation#7](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/cancellationex13.cs#7)]
 [!code-vb[Cancellation#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/cancellationex13.vb#7)]  
  
 <span data-ttu-id="30557-198">작업을 완료했을 때 연결된 토큰 소스에서 `Dispose`를 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="30557-198">Notice that you must call `Dispose` on the linked token source when you are done with it.</span></span> <span data-ttu-id="30557-199">자세한 예제는 [방법: 여러 개의 취소 요청 수신 대기](how-to-listen-for-multiple-cancellation-requests.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="30557-199">For a more complete example, see [How to: Listen for Multiple Cancellation Requests](how-to-listen-for-multiple-cancellation-requests.md).</span></span>  
  
## <a name="cooperation-between-library-code-and-user-code"></a><span data-ttu-id="30557-200">라이브러리 코드와 사용자 코드 간 협력</span><span class="sxs-lookup"><span data-stu-id="30557-200">Cooperation Between Library Code and User Code</span></span>  
 <span data-ttu-id="30557-201">통합 취소 프레임워크를 사용하면 라이브러리 코드에서 사용자 코드를 취소하고 사용자 코드에서 협조적 방식으로 라이브러리 코드를 취소할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30557-201">The unified cancellation framework makes it possible for library code to cancel user code, and for user code to cancel library code in a cooperative manner.</span></span> <span data-ttu-id="30557-202">원활한 협력은 다음 지침에 따라 양측에 의존합니다.</span><span class="sxs-lookup"><span data-stu-id="30557-202">Smooth cooperation depends on each side following these guidelines:</span></span>  
  
- <span data-ttu-id="30557-203">취소 가능한 작업을 제공하는 라이브러리 코드는 사용자 코드가 취소를 요청할 수 있도록 외부 취소 토큰을 허용하는 공용 메서드도 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="30557-203">If library code provides cancelable operations, it should also provide public methods that accept an external cancellation token so that user code can request cancellation.</span></span>  
  
- <span data-ttu-id="30557-204">라이브러리 코드가 사용자 코드를 호출하면 라이브러리 코드는 OperationCanceledException(externalToken)을 *협조적 취소* 로 해석하고 오류 예외로 해석할 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="30557-204">If library code calls into user code, the library code should interpret an OperationCanceledException(externalToken) as *cooperative cancellation*, and not necessarily as a failure exception.</span></span>  
  
- <span data-ttu-id="30557-205">사용자 대리자는 적절한 시간에 라이브러리 코드의 취소 요청에 응답해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="30557-205">User-delegates should attempt to respond to cancellation requests from library code in a timely manner.</span></span>  
  
 <span data-ttu-id="30557-206"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 및 <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType>은 이들 지침을 따르는 클래스의 예입니다.</span><span class="sxs-lookup"><span data-stu-id="30557-206"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType> are examples of classes that follow these guidelines.</span></span> <span data-ttu-id="30557-207">자세한 내용은 [작업 취소](../parallel-programming/task-cancellation.md) 및 [방법: PLINQ 쿼리 취소](../parallel-programming/how-to-cancel-a-plinq-query.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="30557-207">For more information, see [Task Cancellation](../parallel-programming/task-cancellation.md) and [How to: Cancel a PLINQ Query](../parallel-programming/how-to-cancel-a-plinq-query.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="30557-208">참조</span><span class="sxs-lookup"><span data-stu-id="30557-208">See also</span></span>

- [<span data-ttu-id="30557-209">관리되는 스레딩 기본 사항</span><span class="sxs-lookup"><span data-stu-id="30557-209">Managed Threading Basics</span></span>](managed-threading-basics.md)
