---
title: AssemblyLoadContext 이해 - .NET Core
description: .NET Core에서 AssemblyLoadContext의 용도와 동작을 이해하기 위한 핵심 개념입니다.
ms.date: 08/09/2019
author: sdmaclea
ms.author: stmaclea
ms.openlocfilehash: 8a73a432bf8cc72cced77cf6c62a785b72032913
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/14/2020
ms.locfileid: "72303709"
---
# <a name="understanding-systemruntimeloaderassemblyloadcontext"></a><span data-ttu-id="ced5a-103">System.Runtime.Loader.AssemblyLoadContext 이해</span><span class="sxs-lookup"><span data-stu-id="ced5a-103">Understanding System.Runtime.Loader.AssemblyLoadContext</span></span>

<span data-ttu-id="ced5a-104"><xref:System.Runtime.Loader.AssemblyLoadContext> 클래스는 .NET Core에만 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-104">The <xref:System.Runtime.Loader.AssemblyLoadContext> class is unique to .NET Core.</span></span> <span data-ttu-id="ced5a-105">이 문서는 <xref:System.Runtime.Loader.AssemblyLoadContext> API 설명서를 개념 정보로 보완하기 위한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-105">This article attempts to supplement the <xref:System.Runtime.Loader.AssemblyLoadContext> API documentation with conceptual information.</span></span>

<span data-ttu-id="ced5a-106">이 문서는 동적 로딩을 구현하는 개발자, 특히 동적 로딩 프레임워크 개발자와 관련이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-106">This article is relevant to developers implementing dynamic loading, especially dynamic loading framework developers.</span></span>

## <a name="what-is-the-assemblyloadcontext"></a><span data-ttu-id="ced5a-107">AssemblyLoadContext란?</span><span class="sxs-lookup"><span data-stu-id="ced5a-107">What is the AssemblyLoadContext?</span></span>

<span data-ttu-id="ced5a-108">모든 .NET Core 애플리케이션은 <xref:System.Runtime.Loader.AssemblyLoadContext>를 암시적으로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-108">Every .NET Core application implicitly uses the <xref:System.Runtime.Loader.AssemblyLoadContext>.</span></span>
<span data-ttu-id="ced5a-109">종속성을 찾고 로드하는 런타임 공급자입니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-109">It's the runtime's provider for locating and loading dependencies.</span></span> <span data-ttu-id="ced5a-110">종속성이 로드될 때마다 <xref:System.Runtime.Loader.AssemblyLoadContext> 인스턴스가 호출되어 해당 종속성을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-110">Whenever a dependency is loaded, an <xref:System.Runtime.Loader.AssemblyLoadContext> instance is invoked to locate it.</span></span>

- <span data-ttu-id="ced5a-111">관리형 어셈블리 및 기타 종속성을 검색, 로드 및 캐시하는 서비스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-111">It provides a service of locating, loading, and caching managed assemblies and other dependencies.</span></span>

- <span data-ttu-id="ced5a-112">동적 코드 로드 및 언로드를 지원하기 위해 자체 <xref:System.Runtime.Loader.AssemblyLoadContext> 인스턴스에 코드와 해당 종속성을 로드하기 위한 격리된 컨텍스트를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-112">To support dynamic code loading and unloading, it creates an isolated context for loading code and its dependencies in their own <xref:System.Runtime.Loader.AssemblyLoadContext> instance.</span></span>

## <a name="when-do-you-need-multiple-assemblyloadcontext-instances"></a><span data-ttu-id="ced5a-113">여러 AssemblyLoadContext 인스턴스가 필요한 경우는 언제인가요?</span><span class="sxs-lookup"><span data-stu-id="ced5a-113">When do you need multiple AssemblyLoadContext instances?</span></span>

<span data-ttu-id="ced5a-114">단일 <xref:System.Runtime.Loader.AssemblyLoadContext> 인스턴스는 단순 어셈블리 이름(<xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType>)당 정확히 하나의 <xref:System.Reflection.Assembly> 버전을 로드하는 것으로 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-114">A single <xref:System.Runtime.Loader.AssemblyLoadContext> instance is limited to loading exactly one version of an <xref:System.Reflection.Assembly> per simple assembly name, <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="ced5a-115">이 제한은 코드 모듈을 동적으로 로드할 때 문제가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-115">This restriction can become a problem when loading code modules dynamically.</span></span> <span data-ttu-id="ced5a-116">각 모듈은 독립적으로 컴파일되며 <xref:System.Reflection.Assembly>의 다른 버전에 따라 달라질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-116">Each module is independently compiled and may depend on different versions of an <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="ced5a-117">이 문제는 일반적으로 여러 모듈이 일반적으로 사용되는 라이브러리의 서로 다른 버전에 따라 달라지는 경우에 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-117">This problem commonly occurs when different modules depend on different versions of a commonly used library.</span></span>

<span data-ttu-id="ced5a-118">동적으로 코드를 로드하도록 지원하기 위해 <xref:System.Runtime.Loader.AssemblyLoadContext> API는 동일한 애플리케이션에서 충돌하는 버전의 <xref:System.Reflection.Assembly>를 로드하는 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-118">To support dynamically loading code, the <xref:System.Runtime.Loader.AssemblyLoadContext> API provides for loading conflicting versions of an <xref:System.Reflection.Assembly> in the same application.</span></span> <span data-ttu-id="ced5a-119">각 <xref:System.Runtime.Loader.AssemblyLoadContext> 인스턴스는 각 <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType>을 특정 <xref:System.Reflection.Assembly> 인스턴스에 매핑하는 고유한 사전을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-119">Each <xref:System.Runtime.Loader.AssemblyLoadContext> instance provides a unique dictionary mapping each <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType> to a specific <xref:System.Reflection.Assembly> instance.</span></span>

<span data-ttu-id="ced5a-120">또한 나중에 언로드하기 위해 코드 모듈과 관련된 종속성을 그룹화하는 편리한 메커니즘도 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-120">It also provides a convenient mechanism for grouping dependencies related to a code module for later unload.</span></span>

## <a name="what-is-special-about-the-assemblyloadcontextdefault-instance"></a><span data-ttu-id="ced5a-121">AssemblyLoadContext.Default 인스턴스에 대한 특별한 사항은 무엇인가요?</span><span class="sxs-lookup"><span data-stu-id="ced5a-121">What is special about the AssemblyLoadContext.Default instance?</span></span>

<span data-ttu-id="ced5a-122"><xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> 인스턴스는 시작 시 런타임에서 자동으로 채웁니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-122">The <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> instance is automatically populated by the runtime at startup.</span></span>  <span data-ttu-id="ced5a-123">[기본 프로빙](default-probing.md)을 사용하여 모든 정적 종속성을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-123">It uses [default probing](default-probing.md) to locate and find all static dependencies.</span></span>

<span data-ttu-id="ced5a-124">가장 일반적인 종속성 로드 시나리오를 해결합니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-124">It solves the most common dependency loading scenarios.</span></span>

## <a name="how-does-assemblyloadcontext-support-dynamic-dependencies"></a><span data-ttu-id="ced5a-125">AssemblyLoadContext에서 동적 종속성을 어떻게 지원하나요?</span><span class="sxs-lookup"><span data-stu-id="ced5a-125">How does AssemblyLoadContext support dynamic dependencies?</span></span>

<span data-ttu-id="ced5a-126"><xref:System.Runtime.Loader.AssemblyLoadContext>에는 재정의할 수 있는 다양한 이벤트와 가상 함수가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-126"><xref:System.Runtime.Loader.AssemblyLoadContext> has various events and virtual functions that can be overridden.</span></span>

<span data-ttu-id="ced5a-127"><xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> 인스턴스는 이벤트 재정의만 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-127">The <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> instance only supports overriding the events.</span></span>

<span data-ttu-id="ced5a-128">[관리형 어셈블리 로드 알고리즘](loading-managed.md), [위성 어셈블리 로드 알고리즘](loading-resources.md) 및 [비관리형(네이티브) 라이브러리 로드 알고리즘](loading-unmanaged.md) 문서에서는 사용 가능한 모든 이벤트와 가상 함수를 참조합니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-128">The articles [Managed assembly loading algorithm](loading-managed.md), [Satellite assembly loading algorithm](loading-resources.md), and [Unmanaged (native) library loading algorithm](loading-unmanaged.md) refer to all the available events and virtual functions.</span></span>  <span data-ttu-id="ced5a-129">이 문서에는 로드 알고리즘에서 각 이벤트와 함수의 상대적 위치가 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-129">The articles show each event and function's relative position in the loading algorithms.</span></span> <span data-ttu-id="ced5a-130">여기서는 해당 정보를 재현하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-130">This article doesn't reproduce that information.</span></span>

<span data-ttu-id="ced5a-131">이 섹션에서는 관련 이벤트 및 함수에 대한 일반 원칙에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-131">This section covers the general principles for the relevant events and functions.</span></span>

- <span data-ttu-id="ced5a-132">**반복할 수 있습니다**.</span><span class="sxs-lookup"><span data-stu-id="ced5a-132">**Be repeatable**.</span></span> <span data-ttu-id="ced5a-133">특정 종속성에 대한 쿼리는 항상 동일한 응답을 생성해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-133">A query for a specific dependency must always result in the same response.</span></span> <span data-ttu-id="ced5a-134">로드된 동일한 종속성 인스턴스를 반환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-134">The same loaded dependency instance must be returned.</span></span> <span data-ttu-id="ced5a-135">이 요구 사항은 캐시 일관성을 위한 기본 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-135">This requirement is fundamental  for cache consistency.</span></span> <span data-ttu-id="ced5a-136">특히 관리형 어셈블리의 경우 <xref:System.Reflection.Assembly> 캐시를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-136">For managed assemblies in particular, we're creating a <xref:System.Reflection.Assembly> cache.</span></span> <span data-ttu-id="ced5a-137">캐시 키는 단순 어셈블리 이름(<xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType>)입니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-137">The cache key is a simple assembly name, <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="ced5a-138">**일반적으로 throw하지 않습니다**.</span><span class="sxs-lookup"><span data-stu-id="ced5a-138">**Typically don't throw**.</span></span>  <span data-ttu-id="ced5a-139">요청된 종속성을 찾을 수 없는 경우 이러한 함수는 덤프 대신 `null`을 반환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-139">It's expected that these functions return `null` rather than throw when unable to find the requested dependency.</span></span> <span data-ttu-id="ced5a-140">throw하면 검색을 조기에 종료하고 예외를 호출자에 전파합니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-140">Throwing will prematurely end the search and be propagate an exception to the caller.</span></span> <span data-ttu-id="ced5a-141">throw는 손상된 어셈블리 또는 메모리 부족 상태와 같은 예기치 않은 오류로 제한해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-141">Throwing should be restricted to unexpected errors like a corrupted assembly or an out of memory condition.</span></span>
- <span data-ttu-id="ced5a-142">**재귀를 사용하지 않습니다**.</span><span class="sxs-lookup"><span data-stu-id="ced5a-142">**Avoid recursion**.</span></span> <span data-ttu-id="ced5a-143">이러한 함수와 처리기는 종속성을 찾기 위한 로드 규칙을 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-143">Be aware that these functions and handlers implement the loading rules for locating dependencies.</span></span> <span data-ttu-id="ced5a-144">구현에서 재귀를 트리거하는 API를 호출하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-144">Your implementation shouldn't call APIs that trigger recursion.</span></span> <span data-ttu-id="ced5a-145">코드는 일반적으로 특정 경로 또는 메모리 참조 인수가 필요한 **AssemblyLoadContext** 로드 함수를 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-145">Your code should typically call **AssemblyLoadContext** load functions that require a specific path or memory reference argument.</span></span>
- <span data-ttu-id="ced5a-146">**올바른 AssemblyLoadContext에 로드합니다**.</span><span class="sxs-lookup"><span data-stu-id="ced5a-146">**Load into the correct AssemblyLoadContext**.</span></span> <span data-ttu-id="ced5a-147">로드 종속성을 로드할 위치를 선택하는 것은 애플리케이션마다 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-147">The choice of where to load dependencies is application-specific.</span></span>  <span data-ttu-id="ced5a-148">선택은 이러한 이벤트와 함수를 통해 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-148">The choice is implemented by these events and functions.</span></span> <span data-ttu-id="ced5a-149">코드에서 **AssemblyLoadContext** load-by-path(경로별 로드) 함수를 호출하면 코드를 로드하려는 인스턴스에서 이 함수를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-149">When your code calls **AssemblyLoadContext** load-by-path functions call them on the instance where you want the code loaded.</span></span> <span data-ttu-id="ced5a-150">때로는 `null`을 반환하고 <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>에서 로드를 처리할 수 있도록 하는 것이 가장 간단한 옵션일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-150">Sometime returning `null` and letting the <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> handle the load may be the simplest option.</span></span>
- <span data-ttu-id="ced5a-151">**스레드 경합에 주의합니다**.</span><span class="sxs-lookup"><span data-stu-id="ced5a-151">**Be aware of thread races**.</span></span> <span data-ttu-id="ced5a-152">로딩은 여러 스레드에서 트리거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-152">Loading can be triggered by multiple threads.</span></span> <span data-ttu-id="ced5a-153">AssemblyLoadContext는 어셈블리를 원자 단위로 캐시에 추가하여 스레드 경합을 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-153">The AssemblyLoadContext handles thread races by atomically adding assemblies to its cache.</span></span> <span data-ttu-id="ced5a-154">경합 실패자의 인스턴스가 삭제됩니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-154">The race loser's instance is discarded.</span></span> <span data-ttu-id="ced5a-155">구현 논리에서는 여러 스레드를 올바르게 처리하지 않는 추가 논리를 추가하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-155">In your implementation logic, don't add extra logic that doesn't handle multiple threads properly.</span></span>

## <a name="how-are-dynamic-dependencies-isolated"></a><span data-ttu-id="ced5a-156">동적 종속성은 어떻게 격리되나요?</span><span class="sxs-lookup"><span data-stu-id="ced5a-156">How are dynamic dependencies isolated?</span></span>

<span data-ttu-id="ced5a-157">각 <xref:System.Runtime.Loader.AssemblyLoadContext> 인스턴스는 <xref:System.Reflection.Assembly> 인스턴스와 <xref:System.Type> 정의의 고유 범위를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-157">Each <xref:System.Runtime.Loader.AssemblyLoadContext> instance represents a unique scope for <xref:System.Reflection.Assembly> instances and <xref:System.Type> definitions.</span></span>

<span data-ttu-id="ced5a-158">이러한 종속성 간에는 이진 격리가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-158">There's no binary isolation between these dependencies.</span></span> <span data-ttu-id="ced5a-159">이름으로 서로를 찾지 못하여 격리될 뿐입니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-159">They're only isolated by not finding each other by name.</span></span>

<span data-ttu-id="ced5a-160">각각의 <xref:System.Runtime.Loader.AssemblyLoadContext>에서 다음을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-160">In each <xref:System.Runtime.Loader.AssemblyLoadContext>:</span></span>

- <span data-ttu-id="ced5a-161"><xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType>은 다른 <xref:System.Reflection.Assembly> 인스턴스를 참조할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-161"><xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType> may refer to a different <xref:System.Reflection.Assembly> instance.</span></span>
- <span data-ttu-id="ced5a-162"><xref:System.Type.GetType%2A?displayProperty=nameWithType>은 동일한 `name` 형식에 대해 다른 형식 인스턴스를 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-162"><xref:System.Type.GetType%2A?displayProperty=nameWithType> may return a different type instance for the same type `name`.</span></span>

## <a name="how-are-dependencies-shared"></a><span data-ttu-id="ced5a-163">종속성은 어떻게 공유되나요?</span><span class="sxs-lookup"><span data-stu-id="ced5a-163">How are dependencies shared?</span></span>

<span data-ttu-id="ced5a-164">종속성은 <xref:System.Runtime.Loader.AssemblyLoadContext> 인스턴스 간에 쉽게 공유할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-164">Dependencies can easily be shared between <xref:System.Runtime.Loader.AssemblyLoadContext> instances.</span></span> <span data-ttu-id="ced5a-165">일반 모델은 하나의 <xref:System.Runtime.Loader.AssemblyLoadContext>에서 종속성을 로드하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-165">The general model is for one <xref:System.Runtime.Loader.AssemblyLoadContext> to load a dependency.</span></span>  <span data-ttu-id="ced5a-166">다른 하나는 로드된 어셈블리에 대한 참조를 사용하여 종속성을 공유합니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-166">The other shares the dependency by using a reference to the loaded assembly.</span></span>

<span data-ttu-id="ced5a-167">이 공유는 런타임 어셈블리에 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-167">This sharing is required of the runtime assemblies.</span></span> <span data-ttu-id="ced5a-168">이러한 어셈블리는 <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>에만 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-168">These assemblies can only be loaded into the <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ced5a-169">`ASP.NET`, `WPF` 또는 `WinForms`와 같은 프레임워크에도 동일하게 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-169">The same is required for frameworks like `ASP.NET`, `WPF`, or `WinForms`.</span></span>

<span data-ttu-id="ced5a-170">공유 종속성을 <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>에 로드하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-170">It's recommended that shared dependencies should be loaded into <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ced5a-171">이 공유는 일반적인 디자인 패턴입니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-171">This sharing is the common design pattern.</span></span>

<span data-ttu-id="ced5a-172">공유는 사용자 지정 <xref:System.Runtime.Loader.AssemblyLoadContext> 인스턴스의 코딩에서 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-172">Sharing is implemented in the coding of the custom <xref:System.Runtime.Loader.AssemblyLoadContext> instance.</span></span> <span data-ttu-id="ced5a-173"><xref:System.Runtime.Loader.AssemblyLoadContext>에는 재정의할 수 있는 다양한 이벤트와 가상 함수가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-173"><xref:System.Runtime.Loader.AssemblyLoadContext> has various events and virtual functions that can be overridden.</span></span> <span data-ttu-id="ced5a-174">이러한 함수 중 하나에서 다른 <xref:System.Runtime.Loader.AssemblyLoadContext> 인스턴스에 로드된 <xref:System.Reflection.Assembly> 인스턴스에 대한 참조를 반환하면 <xref:System.Reflection.Assembly> 인스턴스가 공유됩니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-174">When any of these functions return a reference to an <xref:System.Reflection.Assembly> instance that was loaded in another <xref:System.Runtime.Loader.AssemblyLoadContext> instance, the <xref:System.Reflection.Assembly> instance is shared.</span></span> <span data-ttu-id="ced5a-175">표준 로드 알고리즘은 일반 공유 패턴을 간소화하기 위해 <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>의 로드를 지연시킵니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-175">The standard load algorithm defers to <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> for loading to simplify the common sharing pattern.</span></span>  <span data-ttu-id="ced5a-176">[관리형 어셈블리 로드 알고리즘](loading-managed.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ced5a-176">See [Managed assembly loading algorithm](loading-managed.md).</span></span>

## <a name="complications"></a><span data-ttu-id="ced5a-177">컴플리케이션</span><span class="sxs-lookup"><span data-stu-id="ced5a-177">Complications</span></span>

### <a name="type-conversion-issues"></a><span data-ttu-id="ced5a-178">형식 변환 문제</span><span class="sxs-lookup"><span data-stu-id="ced5a-178">Type conversion issues</span></span>

<span data-ttu-id="ced5a-179">두 <xref:System.Runtime.Loader.AssemblyLoadContext> 인스턴스에 동일한 `name`의 형식 정의가 포함되는 경우 동일한 형식이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-179">When two <xref:System.Runtime.Loader.AssemblyLoadContext> instances contain type definitions with the same `name`, they're not the same type.</span></span> <span data-ttu-id="ced5a-180">이러한 형식은 동일한 <xref:System.Reflection.Assembly> 인스턴스에서 온 경우에만 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-180">They're the same type if and only if they come from the same <xref:System.Reflection.Assembly> instance.</span></span>

<span data-ttu-id="ced5a-181">복잡한 문제에서 이러한 일치하지 않는 형식에 대한 예외 메시지는 혼동될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-181">To complicate matters, exception messages about these mismatched types can be confusing.</span></span> <span data-ttu-id="ced5a-182">형식은 예외 메시지에서 단순 형식 이름으로 참조됩니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-182">The types are referred to in the exception messages by their simple type names.</span></span> <span data-ttu-id="ced5a-183">이 경우 일반적인 예외 메시지는 다음과 같은 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-183">The common exception message in this case would be of the form:</span></span>

> <span data-ttu-id="ced5a-184">'IsolatedType' 형식의 개체를 'IsolatedType' 형식으로 변환할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-184">Object of type 'IsolatedType' cannot be converted to type 'IsolatedType'.</span></span>

### <a name="debugging-type-conversion-issues"></a><span data-ttu-id="ced5a-185">형식 변환 문제 디버깅</span><span class="sxs-lookup"><span data-stu-id="ced5a-185">Debugging type conversion issues</span></span>

<span data-ttu-id="ced5a-186">일치하지 않는 형식 쌍을 지정하는 경우 다음 사항도 알고 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-186">Given a pair of mismatched types it's important to also know:</span></span>

- <span data-ttu-id="ced5a-187">각 형식의 <xref:System.Type.Assembly?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="ced5a-187">Each type's <xref:System.Type.Assembly?displayProperty=nameWithType></span></span>
- <span data-ttu-id="ced5a-188">각 형식의 <xref:System.Runtime.Loader.AssemblyLoadContext> - <xref:System.Runtime.Loader.AssemblyLoadContext.GetLoadContext(System.Reflection.Assembly)?displayProperty=nameWithType> 함수를 통해 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-188">Each type's <xref:System.Runtime.Loader.AssemblyLoadContext>, which can be obtained via the <xref:System.Runtime.Loader.AssemblyLoadContext.GetLoadContext(System.Reflection.Assembly)?displayProperty=nameWithType> function.</span></span>

<span data-ttu-id="ced5a-189">`a` 및 `b`의 두 개체를 지정하는 경우 디버거에서 다음을 평가하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-189">Given two objects `a` and `b`, evaluating the following in the debugger will be helpful:</span></span>

```csharp
// In debugger look at each assembly's instance, Location, and FullName
a.GetType().Assembly
b.GetType().Assembly
// In debugger look at each AssemblyLoadContext's instance and name
System.Runtime.AssemblyLoadContext.GetLoadContext(a.GetType().Assembly)
System.Runtime.AssemblyLoadContext.GetLoadContext(b.GetType().Assembly)
```

### <a name="resolving-type-conversion-issues"></a><span data-ttu-id="ced5a-190">형식 변환 문제 해결</span><span class="sxs-lookup"><span data-stu-id="ced5a-190">Resolving type conversion issues</span></span>

<span data-ttu-id="ced5a-191">이러한 형식 변환 문제를 해결하기 위한 두 가지 디자인 패턴이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-191">There are two design patterns for solving these type conversion issues.</span></span>

1. <span data-ttu-id="ced5a-192">공용 공유 형식을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-192">Use common shared types.</span></span> <span data-ttu-id="ced5a-193">이 공유 형식은 기본 런타임 형식이거나 새 공유 형식을 공유 어셈블리에 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-193">This shared type can either be a primitive runtime type, or it can involve creating a new shared type in a shared assembly.</span></span>  <span data-ttu-id="ced5a-194">공유 형식은 애플리케이션 어셈블리에 정의된 [인터페이스](../../csharp/language-reference/keywords/interface.md)인 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-194">Often the shared type is an [interface](../../csharp/language-reference/keywords/interface.md) defined in an application assembly.</span></span> <span data-ttu-id="ced5a-195">참고 항목: [종속성은 어떻게 공유되나요?](#how-are-dependencies-shared)</span><span class="sxs-lookup"><span data-stu-id="ced5a-195">See also: [How are dependencies shared?](#how-are-dependencies-shared).</span></span>

2. <span data-ttu-id="ced5a-196">마샬링 기술을 사용하여 한 형식에서 다른 형식으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="ced5a-196">Use marshaling techniques to convert from one type to another.</span></span>
