---
title: 프로파일링 환경 설정
ms.date: 03/30/2017
helpviewer_keywords:
- environment variables, profiling API
- profiling API [.NET Framework], setting up environment
- COR_PROFILER environment variable
- Windows Service applications, profiling
- profiling API [.NET Framework], Windows Service applications
- COR_ENABLE_PROFILING environment variable
- profiling API [.NET Framework], enabling
ms.assetid: fefca07f-7555-4e77-be86-3c542e928312
ms.openlocfilehash: 04b9abd8ffe04a24c08ad89ff48b037c9b003359
ms.sourcegitcommit: b11efd71c3d5ce3d9449c8d4345481b9f21392c6
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 01/29/2020
ms.locfileid: "76860981"
---
# <a name="setting-up-a-profiling-environment"></a><span data-ttu-id="a2c3c-102">프로파일링 환경 설정</span><span class="sxs-lookup"><span data-stu-id="a2c3c-102">Setting Up a Profiling Environment</span></span>
> [!NOTE]
> <span data-ttu-id="a2c3c-103">.NET Framework 4에서 프로 파일링에 대 한 상당한 변경 내용이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-103">There have been substantial changes to profiling in the .NET Framework 4.</span></span>  
  
 <span data-ttu-id="a2c3c-104">관리되는 프로세스(애플리케이션 또는 서비스)가 시작되면 CLR(공용 언어 런타임)을 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-104">When a managed process (application or service) starts, it loads the common language runtime (CLR).</span></span> <span data-ttu-id="a2c3c-105">CLR이 초기화되면 다음 두 가지 환경 변수를 평가하여 프로세스를 프로파일러에 연결해야 할지를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-105">When the CLR is initialized, it evaluates the following two environmental variables to decide whether the process should connect to a profiler:</span></span>  
  
- <span data-ttu-id="a2c3c-106">COR_ENABLE_PROFILING: 이 환경 변수가 있고 1로 설정될 경우에만 CLR이 프로파일러에 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-106">COR_ENABLE_PROFILING: The CLR connects to a profiler only if this environment variable exists and is set to 1.</span></span>  
  
- <span data-ttu-id="a2c3c-107">COR_PROFILER: COR_ENABLE_PROFILING 확인에 통과하면 이전에 레지스트리에 저장되었어야 하는 이 CLSID 또는 ProgID를 포함하는 프로파일러에 CLR이 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-107">COR_PROFILER: If the COR_ENABLE_PROFILING check passes, the CLR connects to the profiler that has this CLSID or ProgID, which must have been stored previously in the registry.</span></span> <span data-ttu-id="a2c3c-108">COR_PROFILER 환경 변수는 다음 두 가지 예제와 같이 문자열로 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-108">The COR_PROFILER environment variable is defined as a string, as shown in the following two examples.</span></span>  
  
    ```cpp  
    set COR_PROFILER={32E2F4DA-1BEA-47ea-88F9-C5DAF691C94A}  
    set COR_PROFILER="MyProfiler"  
    ```  
  
 <span data-ttu-id="a2c3c-109">CLR 애플리케이션을 프로파일링하려면 애플리케이션을 실행하기 전에 COR_ENABLE_PROFILING 및 COR_PROFILER 환경 변수를 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-109">To profile a CLR application, you must set the COR_ENABLE_PROFILING and COR_PROFILER environment variables before you run the application.</span></span> <span data-ttu-id="a2c3c-110">또한 프로파일러 DLL이 등록되었는지 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-110">You must also make sure that the profiler DLL is registered.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="a2c3c-111">.NET Framework 4 부터는 프로파일러를 등록할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-111">Starting with the .NET Framework 4, profilers do not have to be registered.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="a2c3c-112">.NET Framework 4 이상 버전에서 .NET Framework 버전 2.0, 3.0 및 3.5 프로파일러를 사용 하려면 COMPLUS_ProfAPI_ProfilerCompatibilitySetting 환경 변수를 설정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-112">To use .NET Framework versions 2.0, 3.0, and 3.5 profilers in the .NET Framework 4 and later versions, you must set the COMPLUS_ProfAPI_ProfilerCompatibilitySetting environment variable.</span></span>  
  
## <a name="environment-variable-scope"></a><span data-ttu-id="a2c3c-113">환경 변수 범위</span><span class="sxs-lookup"><span data-stu-id="a2c3c-113">Environment Variable Scope</span></span>  
 <span data-ttu-id="a2c3c-114">COR_ENABLE_PROFILING 및 COR_PROFILER 환경 변수를 설정하는 방법에 따라 영향을 미치는 범위가 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-114">How you set the COR_ENABLE_PROFILING and COR_PROFILER environment variables will determine their scope of influence.</span></span> <span data-ttu-id="a2c3c-115">다음 방법의 하나로 이들 변수를 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-115">You can set these variables in one of the following ways:</span></span>  
  
- <span data-ttu-id="a2c3c-116">[ICorDebug:: CreateProcess](../../../../docs/framework/unmanaged-api/debugging/icordebug-createprocess-method.md) 호출에서 변수를 설정 하는 경우 해당 변수는 현재 실행 중인 응용 프로그램에만 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-116">If you set the variables in an [ICorDebug::CreateProcess](../../../../docs/framework/unmanaged-api/debugging/icordebug-createprocess-method.md) call, they will apply only to the application that you are running at the time.</span></span> <span data-ttu-id="a2c3c-117">변수는 환경을 상속하는 해당 애플리케이션에 의해 시작된 기타 애플리케이션에도 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-117">(They will also apply to other applications started by that application that inherit the environment.)</span></span>  
  
- <span data-ttu-id="a2c3c-118">명령 프롬프트 창에서 변수를 설정하면 해당 창에서 시작된 모든 애플리케이션에 변수가 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-118">If you set the variables in a Command Prompt window, they will apply to all applications that are started from that window.</span></span>  
  
- <span data-ttu-id="a2c3c-119">사용자 수준에서 변수를 설정하는 경우 파일 탐색기로 시작하는 모든 애플리케이션에 해당 변수가 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-119">If you set the variables at the user level, they will apply to all applications that you start with File Explorer.</span></span> <span data-ttu-id="a2c3c-120">변수를 설정하고 나서 연 명령 프롬프트 창에는 이 환경 설정이 포함되고 해당 창에서 시작하는 모든 애플리케이션도 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-120">A Command Prompt window that you open after you set the variables will have these environment settings, and so will any application that you start from that window.</span></span> <span data-ttu-id="a2c3c-121">사용자 수준에서 환경 변수를 설정 하려면 **내 컴퓨터**을 마우스 오른쪽 단추로 클릭 하 고 **속성**, **고급** 탭, **환경 변수**를 차례로 클릭 한 다음 **사용자 변수** 목록에 변수를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-121">To set environment variables at the user level, right-click **My Computer**, click **Properties**, click the **Advanced** tab, click **Environment Variables**, and add the variables to the **User variables** list.</span></span>  
  
- <span data-ttu-id="a2c3c-122">컴퓨터 수준에서 변수를 설정하는 경우 해당 컴퓨터에서 시작되는 모든 애플리케이션에 해당 변수가 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-122">If you set the variables at the computer level, they will apply to all applications that are started on that computer.</span></span> <span data-ttu-id="a2c3c-123">해당 컴퓨터에서 연 명령 프롬프트 창에는 이 환경 설정이 포함되고 해당 창에서 시작하는 모든 애플리케이션도 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-123">A Command Prompt window that you open on that computer will have these environment settings, and so will any application that you start from that window.</span></span> <span data-ttu-id="a2c3c-124">즉, 해당 컴퓨터의 모든 관리되는 프로세스가 프로파일러를 사용하여 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-124">This means that every managed process on that computer will start with your profiler.</span></span> <span data-ttu-id="a2c3c-125">컴퓨터 수준에서 환경 변수를 설정 하려면 **내 컴퓨터**을 마우스 오른쪽 단추로 클릭 하 고 **속성**, **고급** 탭, **환경 변수**를 차례로 클릭 한 다음 **시스템 변수** 목록에 변수를 추가 하 고 컴퓨터를 다시 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-125">To set environment variables at the computer level, right-click **My Computer**, click **Properties**, click the **Advanced** tab, click **Environment Variables**, add the variables to the **System variables** list, and then restart your computer.</span></span> <span data-ttu-id="a2c3c-126">다시 시작하고 나면 변수를 시스템 수준에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-126">After restarting, the variables will be available system-wide.</span></span>  
  
 <span data-ttu-id="a2c3c-127">Windows 서비스를 프로파일링할 경우 환경 변수를 설정하고 프로파일러 DLL을 등록하고 나서 컴퓨터를 다시 시작해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-127">If you are profiling a Windows Service, you must restart your computer after you set the environment variables and register the profiler DLL.</span></span> <span data-ttu-id="a2c3c-128">이러한 고려 사항에 대 한 자세한 내용은 [Windows 서비스 프로 파일링](#windows_service)섹션을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-128">For more information about these considerations, see the section [Profiling a Windows Service](#windows_service).</span></span>  
  
## <a name="additional-considerations"></a><span data-ttu-id="a2c3c-129">추가 고려 사항</span><span class="sxs-lookup"><span data-stu-id="a2c3c-129">Additional Considerations</span></span>  
  
- <span data-ttu-id="a2c3c-130">Profiler 클래스는 [ICorProfilerCallback](icorprofilercallback-interface.md) 및 [ICorProfilerCallback2](icorprofilercallback2-interface.md) 인터페이스를 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-130">The profiler class implements the [ICorProfilerCallback](icorprofilercallback-interface.md) and [ICorProfilerCallback2](icorprofilercallback2-interface.md) interfaces.</span></span> <span data-ttu-id="a2c3c-131">.NET Framework 버전 2.0에서 프로파일러는 `ICorProfilerCallback2`를 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-131">In the .NET Framework version 2.0, a profiler must implement `ICorProfilerCallback2`.</span></span> <span data-ttu-id="a2c3c-132">구현하지 않으면 `ICorProfilerCallback2`가 로드되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-132">If it does not, `ICorProfilerCallback2` will not be loaded.</span></span>  
  
- <span data-ttu-id="a2c3c-133">특정 환경에서 한 번에 한 프로파일러에서만 프로세스를 프로파일링할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-133">Only one profiler can profile a process at one time in a given environment.</span></span> <span data-ttu-id="a2c3c-134">두 가지 프로파일러를 서로 다른 환경에서 등록할 수 있지만 각 프로파일러는 개별 프로세스를 프로파일링해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-134">You can register two different profilers in different environments, but each must profile separate processes.</span></span> <span data-ttu-id="a2c3c-135">프로파일러는 프로파일링되고 있는 프로세스와 같은 주소 공간으로 매핑되는 in-process COM 서버 DLL로 구현되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-135">The profiler must be implemented as an in-process COM server DLL, which is mapped into the same address space as the process that is being profiled.</span></span> <span data-ttu-id="a2c3c-136">이는 프로파일러가 in-process로 실행됨을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-136">This means that the profiler runs in-process.</span></span> <span data-ttu-id="a2c3c-137">.NET Framework는 다른 형식의 COM 서버를 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-137">The .NET Framework does not support any other type of COM server.</span></span> <span data-ttu-id="a2c3c-138">예를 들어 프로파일러가 원격 컴퓨터에서 애플리케이션을 모니터링하려고 하면 프로파일러가 각 컴퓨터에서 수집기 에이전트를 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-138">For example, if a profiler wants to monitor applications from a remote computer, it must implement collector agents on each computer.</span></span> <span data-ttu-id="a2c3c-139">이들 에이전트를 결과를 일괄 처리하고 중앙 데이터 수집 컴퓨터에 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-139">These agents will batch results and communicate them to the central data collection computer.</span></span>  
  
- <span data-ttu-id="a2c3c-140">프로파일러는 in-process로 인스턴스화되는 COM 개체이므로 각 프로파일링된 애플리케이션에는 자체 프로파일러 복사본이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-140">Because the profiler is a COM object that is instantiated in-process, each profiled application will have its own copy of the profiler.</span></span> <span data-ttu-id="a2c3c-141">따라서 단일 프로파일러 인스턴스는 여러 애플리케이션에서 데이터를 처리할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-141">Therefore, a single profiler instance does not have to handle data from multiple applications.</span></span> <span data-ttu-id="a2c3c-142">그러나 다른 프로파일링된 애플리케이션에서 로그 파일을 덮어쓰지 않도록 방지하려면 프로파일러의 로깅 코드에 논리를 추가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-142">However, you will have to add logic to the profiler's logging code to prevent log file overwrites from other profiled applications.</span></span>  
  
## <a name="initializing-the-profiler"></a><span data-ttu-id="a2c3c-143">프로파일러 초기화</span><span class="sxs-lookup"><span data-stu-id="a2c3c-143">Initializing the Profiler</span></span>  
 <span data-ttu-id="a2c3c-144">두 가지 환경 변수 확인을 모두 통과하면 CLR에서는 COM `CoCreateInstance` 함수와 비슷한 방식으로 프로파일러의 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-144">When both environment variable checks pass, the CLR creates an instance of the profiler in a similar manner to the COM `CoCreateInstance` function.</span></span> <span data-ttu-id="a2c3c-145">프로파일러는 직접 호출을 통해 `CoCreateInstance`에 로드되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-145">The profiler is not loaded through a direct call to `CoCreateInstance`.</span></span> <span data-ttu-id="a2c3c-146">따라서 스레딩 모델을 설정해야 하는 `CoInitialize`가 호출되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-146">Therefore, a call to `CoInitialize`, which requires setting the threading model, is avoided.</span></span> <span data-ttu-id="a2c3c-147">그런 다음 CLR은 프로파일러에서 [ICorProfilerCallback:: Initialize](icorprofilercallback-initialize-method.md) 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-147">The CLR then calls the [ICorProfilerCallback::Initialize](icorprofilercallback-initialize-method.md) method in the profiler.</span></span> <span data-ttu-id="a2c3c-148">이 메서드의 서명은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-148">The signature of this method is as follows.</span></span>  
  
```cpp  
HRESULT Initialize(IUnknown *pICorProfilerInfoUnk)  
```  
  
 <span data-ttu-id="a2c3c-149">프로파일러는 [ICorProfilerInfo](icorprofilerinfo-interface.md) 또는 [ICorProfilerInfo2](icorprofilerinfo2-interface.md) 인터페이스 포인터에 대 한 `pICorProfilerInfoUnk`를 쿼리하고 나중에 프로 파일링 하는 동안 추가 정보를 요청할 수 있도록 저장 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-149">The profiler must query `pICorProfilerInfoUnk` for an [ICorProfilerInfo](icorprofilerinfo-interface.md) or [ICorProfilerInfo2](icorprofilerinfo2-interface.md) interface pointer and save it so that it can request more information later during profiling.</span></span>  
  
## <a name="setting-event-notifications"></a><span data-ttu-id="a2c3c-150">이벤트 알림 설정</span><span class="sxs-lookup"><span data-stu-id="a2c3c-150">Setting Event Notifications</span></span>  
 <span data-ttu-id="a2c3c-151">그런 다음 프로파일러는 [ICorProfilerInfo:: SetEventMask](icorprofilerinfo-seteventmask-method.md) 메서드를 호출 하 여 관심 있는 알림 범주를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-151">The profiler then calls the [ICorProfilerInfo::SetEventMask](icorprofilerinfo-seteventmask-method.md) method to specify which categories of notifications it is interested in.</span></span> <span data-ttu-id="a2c3c-152">예를 들어 프로파일러가 함수 시작 및 종료 알림과 가비지 수집 알림에만 관심이 있으면 다음을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-152">For example, if the profiler is interested only in function enter and leave notifications and garbage collection notifications, it specifies the following.</span></span>  
  
```cpp  
ICorProfilerInfo* pInfo;  
pICorProfilerInfoUnk->QueryInterface(IID_ICorProfilerInfo, (void**)&pInfo);  
pInfo->SetEventMask(COR_PRF_MONITOR_ENTERLEAVE | COR_PRF_MONITOR_GC)  
```  
  
 <span data-ttu-id="a2c3c-153">이 방식으로 알림 마스크를 설정하면 프로파일러는 수신하는 알림을 제한할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-153">By setting the notifications mask in this manner, the profiler can limit which notifications it receives.</span></span> <span data-ttu-id="a2c3c-154">이 접근 방식을 통해 사용자가 단순 또는 특수 목적용 프로파일러를 빌드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-154">This approach helps the user build a simple or special-purpose profiler.</span></span> <span data-ttu-id="a2c3c-155">이를 통해 프로파일러가 무시하는 알림을 보내는 데 사용되는 CPU 시간이 감소합니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-155">It also reduces CPU time that would be wasted sending notifications that the profiler would just ignore.</span></span>  
  
 <span data-ttu-id="a2c3c-156">특정 프로파일러 이벤트는 변경할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-156">Certain profiler events are immutable.</span></span> <span data-ttu-id="a2c3c-157">즉, 이들 이벤트는 `ICorProfilerCallback::Initialize` 콜백에서 설정되고 난 직후에 해제할 수 없고 새 이벤트를 설정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-157">This means that as soon as these events are set in the `ICorProfilerCallback::Initialize` callback, they cannot be turned off and new events cannot be turned on.</span></span> <span data-ttu-id="a2c3c-158">변경할 수 없는 이벤트를 변경하려고 하면 `ICorProfilerInfo::SetEventMask`에서 실패한 HRESULT가 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-158">Attempts to change an immutable event will result in `ICorProfilerInfo::SetEventMask` returning a failed HRESULT.</span></span>  
  
<a name="windows_service"></a>   
## <a name="profiling-a-windows-service"></a><span data-ttu-id="a2c3c-159">Windows 서비스 프로파일링</span><span class="sxs-lookup"><span data-stu-id="a2c3c-159">Profiling a Windows Service</span></span>  
 <span data-ttu-id="a2c3c-160">Windows 서비스 프로파일링은 공용 언어 런타임 애플리케이션 프로파일링과 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-160">Profiling a Windows Service is like profiling a common language runtime application.</span></span> <span data-ttu-id="a2c3c-161">두 가지 프로파일링 작업은 모두 환경 변수를 통해 사용하도록 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-161">Both profiling operations are enabled through environment variables.</span></span> <span data-ttu-id="a2c3c-162">운영 체제가 시작될 때 Windows 서비스가 시작되므로 이 항목의 앞에서 설명한 환경 변수가 이미 있고 시스템이 시작되기 전에 필요한 값으로 설정되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-162">Because a Windows Service is started when the operating system starts, the environment variables discussed previously in this topic must already be present and set to the required values before the system starts.</span></span> <span data-ttu-id="a2c3c-163">또한 프로파일링 DLL이 시스템에 등록되어 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-163">In addition, the profiling DLL must already be registered on the system.</span></span>  
  
 <span data-ttu-id="a2c3c-164">the COR_ENABLE_PROFILING 및 COR_PROFILER 환경 변수를 설정하고 프로파일러 DLL을 등록하고 나서 Windows 서비스가 해당 변경 내용을 감지할 수 있도록 대상 컴퓨터를 다시 시작해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-164">After you set the COR_ENABLE_PROFILING and COR_PROFILER environment variables and register the profiler DLL, you should restart the target computer so that the Windows Service can detect those changes.</span></span>  
  
 <span data-ttu-id="a2c3c-165">이 변경을 통해 프로파일링이 시스템 전반에서 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-165">Note that these changes will enable profiling on a system-wide basis.</span></span> <span data-ttu-id="a2c3c-166">나중에 실행되는 모든 관리되는 애플리케이션이 프로파일링되지 않게 하려면 대상 컴퓨터를 다시 사직하고 나서 시스템 환경 변수를 삭제해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-166">To prevent every managed application that subsequently runs from being profiled, you should delete the system environment variables after you restart the target computer.</span></span>  
  
 <span data-ttu-id="a2c3c-167">이 방법을 사용하면 모든 CLR 프로세스도 프로파일링됩니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-167">This technique also leads to every CLR process getting profiled.</span></span> <span data-ttu-id="a2c3c-168">프로파일러는 [ICorProfilerCallback:: Initialize](icorprofilercallback-initialize-method.md) 콜백에 논리를 추가 하 여 현재 프로세스의 관심 여부를 감지 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-168">The profiler should add logic to its [ICorProfilerCallback::Initialize](icorprofilercallback-initialize-method.md) callback to detect whether the current process is of interest.</span></span> <span data-ttu-id="a2c3c-169">관심이 없으면 프로파일러는 초기화를 수행하지 않고 콜백을 오류로 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a2c3c-169">If it is not, the profiler can fail the callback without performing the initialization.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a2c3c-170">참조</span><span class="sxs-lookup"><span data-stu-id="a2c3c-170">See also</span></span>

- [<span data-ttu-id="a2c3c-171">프로파일링 개요</span><span class="sxs-lookup"><span data-stu-id="a2c3c-171">Profiling Overview</span></span>](profiling-overview.md)
