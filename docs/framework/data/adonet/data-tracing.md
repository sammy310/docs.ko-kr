---
title: ADO.NET의 데이터 추적
ms.date: 03/30/2017
ms.assetid: a6a752a5-d2a9-4335-a382-b58690ccb79f
ms.openlocfilehash: e27f1f30ab8626b21421d6d4a7808f8ffef5c26f
ms.sourcegitcommit: 7f8eeef060ddeb2cabfa52843776faf652c5a1f5
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/14/2019
ms.locfileid: "74088769"
---
# <a name="data-tracing-in-adonet"></a><span data-ttu-id="abaa6-102">ADO.NET의 데이터 추적</span><span class="sxs-lookup"><span data-stu-id="abaa6-102">Data Tracing in ADO.NET</span></span>

<span data-ttu-id="abaa6-103">ADO.NET는 SQL Server, Oracle, OLE DB 및 ODBC 용 .NET 데이터 공급자 뿐만 아니라 ADO.NET <xref:System.Data.DataSet>및 SQL Server 네트워크 프로토콜에 대해 지원 되는 기본 제공 데이터 추적 기능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="abaa6-103">ADO.NET features built-in data tracing functionality that is supported by the .NET data providers for SQL Server, Oracle, OLE DB and ODBC, as well as the ADO.NET <xref:System.Data.DataSet>, and the SQL Server network protocols.</span></span>

<span data-ttu-id="abaa6-104">데이터 액세스 API 호출을 추적하면 다음과 같은 문제를 진단할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="abaa6-104">Tracing data access API calls can help diagnose the following problems:</span></span>

- <span data-ttu-id="abaa6-105">클라이언트 프로그램과 데이터베이스 간의 스키마 불일치</span><span class="sxs-lookup"><span data-stu-id="abaa6-105">Schema mismatch between client program and the database.</span></span>

- <span data-ttu-id="abaa6-106">데이터베이스 비가용성 또는 네트워크 라이브러리 문제</span><span class="sxs-lookup"><span data-stu-id="abaa6-106">Database unavailability or network library problems.</span></span>

- <span data-ttu-id="abaa6-107">하드 코딩되거나 애플리케이션에서 생성된 잘못된 SQL</span><span class="sxs-lookup"><span data-stu-id="abaa6-107">Incorrect SQL whether hard coded or generated by an application.</span></span>

- <span data-ttu-id="abaa6-108">잘못된 프로그래밍 논리</span><span class="sxs-lookup"><span data-stu-id="abaa6-108">Incorrect programming logic.</span></span>

- <span data-ttu-id="abaa6-109">여러 ADO.NET 구성 요소 간의 상호 작용 및 ADO.NET과 사용자 구성 요소 간의 상호 작용으로 인한 문제</span><span class="sxs-lookup"><span data-stu-id="abaa6-109">Issues resulting from the interaction between multiple ADO.NET components or between ADO.NET and your own components.</span></span>

<span data-ttu-id="abaa6-110">다양한 추적 기술을 지원하기 위해 추적을 확장할 수 있으므로 개발자는 애플리케이션 스택의 모든 수준에서 문제를 추적할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="abaa6-110">To support different trace technologies, tracing is extensible, so a developer can trace a problem at any level of the application stack.</span></span> <span data-ttu-id="abaa6-111">추적이 ADO.NET에만 있는 기능은 아니지만 Microsoft 공급자에서는 일반화된 추적 및 계측 API를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="abaa6-111">Although tracing is not an ADO.NET-only feature, Microsoft providers take advantage of generalized tracing and instrumentation APIs.</span></span>

<span data-ttu-id="abaa6-112">ADO.NET에서 관리 되는 추적을 설정 하 고 구성 하는 방법에 대 한 자세한 내용은 [데이터 액세스 추적](https://docs.microsoft.com/previous-versions/sql/sql-server-2012/hh880086(v=msdn.10))을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="abaa6-112">For more information about setting and configuring managed tracing in ADO.NET, see [Tracing Data Access](https://docs.microsoft.com/previous-versions/sql/sql-server-2012/hh880086(v=msdn.10)).</span></span>

## <a name="accessing-diagnostic-information-in-the-extended-events-log"></a><span data-ttu-id="abaa6-113">확장 이벤트 로그에서 진단 정보에 액세스</span><span class="sxs-lookup"><span data-stu-id="abaa6-113">Accessing Diagnostic Information in the Extended Events Log</span></span>

<span data-ttu-id="abaa6-114">SQL Server에 대 한 .NET Framework Data Provider에서 데이터 액세스 추적 ([데이터 액세스 추적](https://docs.microsoft.com/previous-versions/sql/sql-server-2012/hh880086(v=msdn.10)))은 서버 연결 링 버퍼 및 확장 이벤트 로그의 응용 프로그램 성능 정보에서 클라이언트 이벤트와 진단 정보 (예: 연결 오류)를 더 쉽게 상호 연결할 수 있도록 업데이트 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="abaa6-114">In the .NET Framework Data Provider for SQL Server, data access tracing ([Data Access Tracing](https://docs.microsoft.com/previous-versions/sql/sql-server-2012/hh880086(v=msdn.10))) has been updated to make it easier to correlate client events with diagnostic information, such as connection failures, from the server's connectivity ring buffer and application performance information in the extended events log.</span></span> <span data-ttu-id="abaa6-115">확장 이벤트 로그를 읽는 방법에 대 한 자세한 내용은 [이벤트 세션 데이터 보기](https://docs.microsoft.com/previous-versions/sql/sql-server-2012/hh710068(v=sql.110))를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="abaa6-115">For information about reading the extended events log, see [View Event Session Data](https://docs.microsoft.com/previous-versions/sql/sql-server-2012/hh710068(v=sql.110)).</span></span>

<span data-ttu-id="abaa6-116">연결 동작의 경우 ADO.NET은 클라이언트 연결 ID를 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="abaa6-116">For connection operations, ADO.NET will send a client connection ID.</span></span> <span data-ttu-id="abaa6-117">연결에 실패 하면 연결 링 버퍼 (연결[링 버퍼를 사용 하 여 SQL Server 2008의 연결 문제 해결](https://go.microsoft.com/fwlink/?LinkId=207752))에 액세스 하 고 `ClientConnectionID` 필드를 찾아서 연결 실패에 대 한 진단 정보를 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="abaa6-117">If the connection fails, you can access the connectivity ring buffer ([Connectivity troubleshooting in SQL Server 2008 with the Connectivity Ring Buffer](https://go.microsoft.com/fwlink/?LinkId=207752)) and find the `ClientConnectionID` field and get diagnostic information about the connection failure.</span></span> <span data-ttu-id="abaa6-118">클라이언트 연결 ID는 오류가 발생한 경우에만 링 버퍼에 로그인됩니다.</span><span class="sxs-lookup"><span data-stu-id="abaa6-118">Client connection IDs are logged in the ring buffer only if an error occurs.</span></span> <span data-ttu-id="abaa6-119">사전 로그인 패킷을 전송 하기 전에 연결이 실패 하는 경우 클라이언트 연결 ID는 생성 되지 않습니다. 클라이언트 연결 ID는 16 바이트 GUID입니다.</span><span class="sxs-lookup"><span data-stu-id="abaa6-119">(If a connection fails before sending the prelogin packet, a client connection ID will not be generated.) The client connection ID is a 16-byte GUID.</span></span> <span data-ttu-id="abaa6-120">`client_connection_id` 동작이 확장 이벤트 세션에서 이벤트에 추가된 경우 확장 이벤트 대상 출력에서 클라이언트 연결 ID를 찾을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="abaa6-120">You can also find the client connection ID in the extended events target output, if the `client_connection_id` action is added to events in an extended events session.</span></span> <span data-ttu-id="abaa6-121">추가 클라이언트 드라이버 진단이 필요한 경우 데이터 액세스 추적을 활성화하고 연결 명령을 다시 실행하여 데이터 액세스 추적에서 `ClientConnectionID` 필드를 관찰할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="abaa6-121">You can enable data access tracing and rerun the connection command and observe the `ClientConnectionID` field in the data access trace, if you need further client driver diagnostic assistance.</span></span>

<span data-ttu-id="abaa6-122">`SqlConnection.ClientConnectionID` 속성을 사용하여 클라이언트 연결 ID를 프로그래밍 방식으로 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="abaa6-122">You can get the client connection ID programmatically by using the `SqlConnection.ClientConnectionID` property.</span></span>

<span data-ttu-id="abaa6-123">`ClientConnectionID`는 연결을 성공적으로 설정하는 <xref:System.Data.SqlClient.SqlConnection> 개체에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="abaa6-123">The `ClientConnectionID` is available for a <xref:System.Data.SqlClient.SqlConnection> object that successfully establishes  a connection.</span></span> <span data-ttu-id="abaa6-124">연결 시도에 실패한 경우에는 `ClientConnectionID`을 통해 `SqlException.ToString`를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="abaa6-124">If a connection attempt fails, `ClientConnectionID` may be available via `SqlException.ToString`.</span></span>

<span data-ttu-id="abaa6-125">또한 ADO.NET은 스레드별 동작 ID를 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="abaa6-125">ADO.NET also sends a thread-specific activity ID.</span></span> <span data-ttu-id="abaa6-126">활동 ID는 세션이 TRACK_CAUSALITY 옵션을 사용 하도록 설정 된 상태에서 시작 되는 경우 확장 이벤트 세션에서 캡처됩니다.</span><span class="sxs-lookup"><span data-stu-id="abaa6-126">The activity ID is captured in the extended events sessions if the sessions are started with the TRACK_CAUSALITY option enabled.</span></span> <span data-ttu-id="abaa6-127">활성 연결과 관련한 성능 문제의 경우 클라이언트의 데이터 액세스 추적에서 동작 ID(`ActivityID` 필드)를 가져온 다음 확장 이벤트 출력에서 동작 ID를 찾아볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="abaa6-127">For performance issues with an active connection, you can get the activity ID from the client's data access trace (`ActivityID` field) and then locate the activity ID in the extended events output.</span></span> <span data-ttu-id="abaa6-128">확장 이벤트의 동작 ID는16바이트 GUID(클라이언트 연결 ID의 GUID와는 다름)에 4바이트 시퀀스 번호를 추가한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="abaa6-128">The activity ID in extended events is a 16-byte GUID (not the same as the GUID for the client connection ID) appended with a four-byte sequence number.</span></span> <span data-ttu-id="abaa6-129">시퀀스 번호는 스레드 내의 요청 순서를 나타내며 스레드에서 일괄 처리 및 RPC 문의 상대적인 순서를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="abaa6-129">The sequence number represents the order of a request within a thread and indicates the relative ordering of batch and RPC statements for the thread.</span></span> <span data-ttu-id="abaa6-130">`ActivityID`는 현재 데이터 액세스 추적이 활성화된 상태이고 데이터 액세스 추적 구성 단어의 18번째 비트가 ON 상태인 경우 SQL 일괄 처리 문과 RPC 요청에 대해 선택적으로 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="abaa6-130">The `ActivityID` is currently optionally sent for SQL batch statements and RPC requests when data access tracing is enabled on and the 18th bit in the data access tracing configuration word is turned ON.</span></span>

<span data-ttu-id="abaa6-131">다음은 Transact-sql을 사용 하 여 링 버퍼에 저장 되 고 RPC 및 일괄 처리 작업 시 클라이언트에서 전송 된 활동 ID를 기록 하는 확장 이벤트 세션을 시작 하는 샘플입니다.</span><span class="sxs-lookup"><span data-stu-id="abaa6-131">The following is a sample that uses Transact-SQL to start an extended events session that will be stored in a ring buffer and will record the activity ID sent from a client on RPC and batch operations.</span></span>

```sql
create event session MySession on server
add event connectivity_ring_buffer_recorded,
add event sql_statement_starting (action (client_connection_id)),
add event sql_statement_completed (action (client_connection_id)),
add event rpc_starting (action (client_connection_id)),
add event rpc_completed (action (client_connection_id))
add target ring_buffer with (track_causality=on)
```

## <a name="see-also"></a><span data-ttu-id="abaa6-132">참조</span><span class="sxs-lookup"><span data-stu-id="abaa6-132">See also</span></span>

- [<span data-ttu-id="abaa6-133">.NET Framework의 네트워크 추적</span><span class="sxs-lookup"><span data-stu-id="abaa6-133">Network Tracing in the .NET Framework</span></span>](../../network-programming/network-tracing.md)
- [<span data-ttu-id="abaa6-134">애플리케이션 추적 및 조율</span><span class="sxs-lookup"><span data-stu-id="abaa6-134">Tracing and Instrumenting Applications</span></span>](../../debug-trace-profile/tracing-and-instrumenting-applications.md)
- [<span data-ttu-id="abaa6-135">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="abaa6-135">ADO.NET Overview</span></span>](ado-net-overview.md)
