---
description: '자세한 정보: 사용자 지정 인코더'
title: 사용자 지정 인코더
ms.date: 03/30/2017
ms.assetid: fa0e1d7f-af36-4bf4-aac9-cd4eab95bc4f
ms.openlocfilehash: 12c706daf025b6ab63bd5c4e2cbb426a2ea83af1
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/06/2021
ms.locfileid: "99735298"
---
# <a name="custom-encoders"></a><span data-ttu-id="096c6-103">사용자 지정 인코더</span><span class="sxs-lookup"><span data-stu-id="096c6-103">Custom Encoders</span></span>

<span data-ttu-id="096c6-104">이 항목에서는 사용자 지정 인코더를 만드는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-104">This topic discusses how to create custom encoders.</span></span>  
  
 <span data-ttu-id="096c6-105">WCF (Windows Communication Foundation)에서 *바인딩을* 사용 하 여 네트워크를 통해 끝점 간에 데이터를 전송 하는 방법을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-105">In Windows Communication Foundation (WCF), you use a *binding* to specify how to transfer data across a network between endpoints.</span></span> <span data-ttu-id="096c6-106">바인딩은 *바인딩 요소* 시퀀스로 구성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-106">A binding is made up of a sequence of *binding elements*.</span></span> <span data-ttu-id="096c6-107">바인딩에는 보안, 필수 *메시지 인코더* 바인딩 요소 및 필수 전송 바인딩 요소와 같은 선택적 프로토콜 바인딩 요소가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-107">A binding includes optional protocol binding elements such as security, a required *Message Encoder* binding element, and a required transport binding element.</span></span> <span data-ttu-id="096c6-108">메시지 인코더는 메시지 인코딩 바인딩 요소로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-108">A message encoder is represented by a message encoding binding element.</span></span> <span data-ttu-id="096c6-109">WCF에는 이진, MTOM (메시지 전송 최적화 메커니즘) 및 텍스트의 세 가지 메시지 인코더가 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-109">Three message encoders are included in WCF: Binary, Message Transmission Optimization Mechanism (MTOM), and Text.</span></span>  
  
 <span data-ttu-id="096c6-110">메시지 인코딩 바인딩 요소는 보내는 <xref:System.ServiceModel.Channels.Message>를 serialize한 다음 전송으로 전달하거나, 전송에서 serialize된 메시지 형식을 받은 다음 프로토콜 계층이 있으면 프로토콜 계층에 전달하고 없으면 애플리케이션에 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-110">A message encoding binding element serializes an outgoing <xref:System.ServiceModel.Channels.Message> and passes it to the transport, or receives the serialized form of a message from the transport and passes it to the protocol layer if present, or to the application, if not present.</span></span>  
  
 <span data-ttu-id="096c6-111">메시지 인코더는 <xref:System.ServiceModel.Channels.Message> 인스턴스를 연결 표시로 또는 그 반대로 변형합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-111">Message encoders transform <xref:System.ServiceModel.Channels.Message> instances to and from a wire representation.</span></span> <span data-ttu-id="096c6-112">인코더가 채널 스택에서 전송 계층 위에 있는 것으로 설명될지라도 전송 계층 내부에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-112">Although encoders are described as sitting above the transport layer in the channel stack, they reside inside the transport layer.</span></span> <span data-ttu-id="096c6-113">전송(예: HTTP)은 전송 표준 요구 사항에 따라 메시지의 형식을 지정하며</span><span class="sxs-lookup"><span data-stu-id="096c6-113">Transports (for example HTTP) format the message according to the requirements of the transport standard.</span></span> <span data-ttu-id="096c6-114">인코더(예: Text Xml)는 단지 메시지를 인코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-114">Encoders (for example Text Xml) just encode the message.</span></span>  
  
 <span data-ttu-id="096c6-115">기존 클라이언트 또는 서버에 연결할 경우에는 특정 메시지 인코딩을 사용하지 못할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-115">When connecting to a preexisting client or server, you may not have a choice about using a particular message encoding.</span></span> <span data-ttu-id="096c6-116">그러나 WCF 서비스는 서로 다른 메시지 인코더를 사용 하 여 여러 끝점을 통해 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-116">However, WCF services can be made accessible through multiple endpoints, each with a different message encoder.</span></span> <span data-ttu-id="096c6-117">단일 인코더가 서비스의 전체 대상을 수용하지 못하는 경우 여러 엔드포인트를 통해 서비스를 공개해 보세요.</span><span class="sxs-lookup"><span data-stu-id="096c6-117">When a single encoder does not cover the entire audience for your service, consider exposing your service over multiple endpoints.</span></span> <span data-ttu-id="096c6-118">그러면 클라이언트 애플리케이션에서 가장 적합한 엔드포인트를 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-118">Client applications can then choose the endpoint that is best for them.</span></span> <span data-ttu-id="096c6-119">여러 엔드포인트를 사용하면 여러 메시지 인코더의 이점을 다른 바인딩 요소와 결합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-119">Using multiple endpoints allows you to combine the advantages of different message encoders with other binding elements.</span></span>  
  
## <a name="system-provided-encoders"></a><span data-ttu-id="096c6-120">시스템 제공 인코더</span><span class="sxs-lookup"><span data-stu-id="096c6-120">System-Provided Encoders</span></span>  

 <span data-ttu-id="096c6-121">WCF는 가장 일반적인 응용 프로그램 시나리오를 처리 하도록 설계 된 여러 시스템 제공 바인딩을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-121">WCF provides several system-provided bindings that are designed to cover the most common application scenarios.</span></span> <span data-ttu-id="096c6-122">이러한 각 바인딩은 전송, 메시지 인코더 및 기타 옵션(예: 보안)을 결합합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-122">Each of these bindings combine a transport, message encoder, and other options (security, for example).</span></span> <span data-ttu-id="096c6-123">이 항목에서는 `Text` `Binary` `MTOM` WCF에 포함 된, 및 메시지 인코더를 확장 하거나 사용자 지정 인코더를 만드는 방법에 대해 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-123">This topic describes how to extend the `Text`, `Binary`, and `MTOM` message encoders that are included in WCF, or create your own custom encoder.</span></span> <span data-ttu-id="096c6-124">텍스트 메시지 인코더는 일반 XML 인코딩뿐 아니라 SOAP 인코딩을 모두 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-124">The text message encoder supports both a plain XML encoding as well as SOAP encodings.</span></span> <span data-ttu-id="096c6-125">텍스트 메시지 인코더의 일반 XML 인코딩 모드는 텍스트 기반 SOAP 인코딩과 구별하기 위해 POX("Plain Old Xml") 인코더라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-125">The plain XML encoding mode of the text message encoder is called the POX ("Plain Old XML") encoder to distinguish it from the text-based SOAP encoding.</span></span>  
  
 <span data-ttu-id="096c6-126">시스템에서 제공 하는 바인딩에 의해 제공 되는 바인딩 요소 조합에 대 한 자세한 내용은 [전송 선택](../feature-details/choosing-a-transport.md)에서 해당 섹션을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="096c6-126">For more information about the combinations of binding elements provided by the system-provided bindings, see the corresponding section in [Choosing a Transport](../feature-details/choosing-a-transport.md).</span></span>  
  
## <a name="how-to-work-with-system-provided-encoders"></a><span data-ttu-id="096c6-127">시스템 제공 인코더 작업 방법</span><span class="sxs-lookup"><span data-stu-id="096c6-127">How to Work with System-Provided Encoders</span></span>  

 <span data-ttu-id="096c6-128">인코딩은 <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>에서 파생된 클래스를 사용하여 바인딩에 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-128">An encoding is added to a binding using a class derived from <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>.</span></span>  
  
 <span data-ttu-id="096c6-129">WCF는 <xref:System.ServiceModel.Channels.MessageEncodingBindingElement> 텍스트, 이진 및 MTOM (메시지 전송 최적화 메커니즘) 인코딩에 제공할 수 있는 클래스에서 파생 된 다음 형식의 바인딩 요소를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-129">WCF provides the following types of binding elements derived from the <xref:System.ServiceModel.Channels.MessageEncodingBindingElement> class that can provide for text, binary and Message Transmission Optimization Mechanism (MTOM) encoding:</span></span>  
  
- <span data-ttu-id="096c6-130"><xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>: 상호 운용성이 가장 뛰어나지만 XML 메시지에 대해서는 효율성이 가장 낮은 인코더입니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-130"><xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>: The most interoperable, but the least efficient encoder for XML messages.</span></span> <span data-ttu-id="096c6-131">웹 서비스 또는 웹 서비스 클라이언트는 일반적으로 텍스트 XML을 이해할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-131">A Web service or Web service client can generally understand textual XML.</span></span> <span data-ttu-id="096c6-132">그러나 이진 데이터의 긴 블록을 텍스트로 전송 하는 것은 효율적이 지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-132">However, transmitting large blocks of binary data as text is not efficient.</span></span>  
  
- <span data-ttu-id="096c6-133"><xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>: 이진 기반 XML 메시지에 사용되는 문자 인코딩 및 메시지 버전 관리를 지정하는 바인딩 요소를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-133"><xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>: Represents the binding element that specifies the character encoding and message versioning used for binary-based XML messages.</span></span> <span data-ttu-id="096c6-134">이는 인코딩 옵션을 가장 효율적으로 사용할 수 있지만, WCF 끝점 에서만 지원 되기 때문에 상호 운용성이 가장 높습니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-134">This is most efficient of the encoding options, but the least interoperable, because it is only supported by WCF endpoints.</span></span>  
  
- <span data-ttu-id="096c6-135"><xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement>: MTOM(Message Transmission Optimization Mechanism) 인코딩을 사용하여 메시지에 사용되는 문자 인코딩 및 메시지 버전 관리를 지정하는 바인딩 요소를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-135"><xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement>: Represents the binding element that specifies the character encoding and message versioning used for a message using a Message Transmission Optimization Mechanism (MTOM) encoding.</span></span> <span data-ttu-id="096c6-136">MTOM은 WCF 메시지의 이진 데이터를 전송하기 위한 효율적인 기술입니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-136">MTOM is an efficient technology for transmitting binary data in WCF messages.</span></span> <span data-ttu-id="096c6-137">MTOM 인코더는 효율성과 호환성 간의 균형을 유지하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-137">The MTOM encoder attempts to balance between efficiency and interoperability.</span></span> <span data-ttu-id="096c6-138">MTOM 인코딩은 대부분의 XML을 텍스트 형식으로 전송하지만, 큰 이진 데이터 블록의 경우에는 텍스트로 변환하지 않고 있는 그대로 전송하여 최적화합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-138">The MTOM encoding transmits most XML in textual form, but optimizes large blocks of binary data by transmitting them as-is, without conversion to text.</span></span>  
  
 <span data-ttu-id="096c6-139">바인딩 요소는 이진, MTOM 또는 텍스트 <xref:System.ServiceModel.Channels.MessageEncoderFactory>를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-139">The binding element creates a binary, MTOM, or text <xref:System.ServiceModel.Channels.MessageEncoderFactory>.</span></span> <span data-ttu-id="096c6-140">팩터리는 이진, MTOM 또는 텍스트 <xref:System.ServiceModel.Channels.MessageEncoderFactory> 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-140">The factory creates a binary, MTOM, or text <xref:System.ServiceModel.Channels.MessageEncoderFactory> instance.</span></span> <span data-ttu-id="096c6-141">일반적으로 인스턴스는 하나만 있습니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-141">Typically, there is only a single instance.</span></span> <span data-ttu-id="096c6-142">그러나 세션을 사용하는 경우에는 세션마다 다른 인코더가 제공될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-142">However if sessions are used, a different encoder may be provided to each session.</span></span> <span data-ttu-id="096c6-143">이진 인코더는 이를 사용하여 동적 사전을 조정합니다(XML 인프라 참조).</span><span class="sxs-lookup"><span data-stu-id="096c6-143">The Binary encoder makes use of this to coordinate dynamic dictionaries (see XML Infrastructure).</span></span>  
  
 <span data-ttu-id="096c6-144"><xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%2A> 및 <xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%2A> 메서드는 인코더의 핵심입니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-144">The <xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%2A> and <xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%2A> methods are the core of the encoders.</span></span> <span data-ttu-id="096c6-145">이러한 메서드를 사용하면 스트림 또는 <xref:System.Byte> 배열에서 메시지를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-145">The methods provide for reading a message from a stream or from a <xref:System.Byte> array.</span></span> <span data-ttu-id="096c6-146">전송이 버퍼링 모드에서 작동할 때는 바이트 배열이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-146">Byte arrays are used when the transport is operating in buffered mode.</span></span> <span data-ttu-id="096c6-147">메시지는 항상 스트림에 기록됩니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-147">Messages are always written to streams.</span></span> <span data-ttu-id="096c6-148">메시지를 버퍼링해야 하는 경우 전송은 버퍼링을 수행하는 스트림을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-148">If the transport must buffer the message, it provides a stream that does the buffering.</span></span>  
  
 <span data-ttu-id="096c6-149">나머지 멤버는 지원 콘텐츠, 미디어 유형 및 <xref:System.ServiceModel.Channels.MessageEncoder.MessageVersion%2A>과 함께 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-149">The rest of the members work with support content, media types, and <xref:System.ServiceModel.Channels.MessageEncoder.MessageVersion%2A>.</span></span> <span data-ttu-id="096c6-150">전송에서는 이러한 인코더 메서드를 호출하여 들어오는 메시지를 디코딩할 수 있는지 여부를 테스트하거나 보내는 메시지가 이 인코더에 유효한지를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-150">The transport calls these encoder methods to test whether the incoming message can be decoded by it, or to determine if the outgoing message is valid for this encoder.</span></span>  
  
 <span data-ttu-id="096c6-151">세 가지 각 인코더 구현은 특정 인코딩과 관련된 속성을 추가하며 완전히 구성 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-151">Each of the three encoder implementations adds properties that are relevant to the specific encodings and is fully configurable.</span></span> <span data-ttu-id="096c6-152">인코더는 또한 보안 기본값을 갖는 판독기 할당량을 공개합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-152">The encoders also expose reader quotas that have secure defaults.</span></span> <span data-ttu-id="096c6-153">할당량에 대한 자세한 내용은 XML 인프라를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="096c6-153">See XML Infrastructure for a discussion of the quotas.</span></span>  
  
## <a name="features-of-system-provided-encoders"></a><span data-ttu-id="096c6-154">시스템 제공 인코더의 기능</span><span class="sxs-lookup"><span data-stu-id="096c6-154">Features of System-Provided Encoders</span></span>  

 <span data-ttu-id="096c6-155">시스템 제공 인코더는 다양한 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-155">There are a number of features provided by the system-provided encoders.</span></span>  
  
### <a name="pooling"></a><span data-ttu-id="096c6-156">Pooling</span><span class="sxs-lookup"><span data-stu-id="096c6-156">Pooling</span></span>  

 <span data-ttu-id="096c6-157">각 인코더 구현에서는 가능한 한 많이 풀링하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-157">Each of the encoder implementations tries to pool as much as possible.</span></span> <span data-ttu-id="096c6-158">관리 코드의 성능을 향상시키기 위한 주요 방법은 할당을 줄이는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-158">Reducing allocations is a key way to improve the performance of managed code.</span></span> <span data-ttu-id="096c6-159">이 풀링을 수행하기 위해 구현에서는 `SynchronizedPool` 클래스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-159">To accomplish this pooling, the implementations use the `SynchronizedPool` class.</span></span> <span data-ttu-id="096c6-160">C# 파일에는 이 클래스에서 사용하는 추가 최적화에 대한 설명이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-160">The C# file contains a description of the additional optimizations used by this class.</span></span>  
  
 <span data-ttu-id="096c6-161"><xref:System.Xml.XmlDictionaryReader> 및 <xref:System.Xml.XmlDictionaryWriter> 인스턴스를 풀링하고 다시 초기화하여 각 메시지의 새 인스턴스가 할당되지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-161"><xref:System.Xml.XmlDictionaryReader> and <xref:System.Xml.XmlDictionaryWriter> instances are pooled and reinitialized to prevent allocating new ones for each message.</span></span> <span data-ttu-id="096c6-162">판독기의 경우 `OnClose`가 호출될 때 `Close()` 콜백이 판독기를 회수합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-162">For the readers, an `OnClose` callback reclaims the reader when `Close()` is called.</span></span> <span data-ttu-id="096c6-163">인코더는 또한 메시지를 구성할 때 사용된 일부 메시지 상태 개체를 재활용합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-163">The encoder also recycles some message state objects used when constructing messages.</span></span> <span data-ttu-id="096c6-164">이러한 풀의 크기는 `MaxReadPoolSize`에서 파생된 세 가지 각 클래스에 대한 `MaxWritePoolSize` 및 <xref:System.ServiceModel.Channels.MessageEncodingBindingElement> 속성으로 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-164">The sizes of these pools are configurable by the `MaxReadPoolSize` and `MaxWritePoolSize` properties on each of the three classes derived from <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>.</span></span>  
  
### <a name="binary-encoding"></a><span data-ttu-id="096c6-165">이진 인코딩</span><span class="sxs-lookup"><span data-stu-id="096c6-165">Binary Encoding</span></span>  

 <span data-ttu-id="096c6-166">이진 인코딩에서 세션을 사용하는 경우 동적 사전 문자열을 메시지 수신자에게 전달해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-166">When binary encoding uses sessions, the dynamic dictionary string must be communicated to the receiver of the message.</span></span> <span data-ttu-id="096c6-167">이 작업은 동적 사전 문자열을 메시지의 접두사로 지정하여 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-167">This is done by prefixing the message with the dynamic dictionary strings.</span></span> <span data-ttu-id="096c6-168">수신자는 문자열을 제거하여 세션에 추가한 다음 메시지를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-168">The receiver strips off the strings, adds them to the session, and processes the message.</span></span> <span data-ttu-id="096c6-169">사전 문자열을 올바르게 전달하려면 전송을 버퍼링해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-169">Correctly passing dictionary strings requires that the transport be buffered.</span></span>  
  
 <span data-ttu-id="096c6-170">문자열은 내부 `AddSessionInformationToMessage` 메서드에 의해 메시지에 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-170">The strings are appended to the message by an internal `AddSessionInformationToMessage` method.</span></span> <span data-ttu-id="096c6-171">이 메서드는 해당 문자열의 길이로 접두사가 지정된 메시지 앞에 문자열을 UTF-8로 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-171">It adds the strings as UTF-8 to the front of the message prefixed with their length.</span></span> <span data-ttu-id="096c6-172">그런 다음 이 데이터의 길이를 전체 사전 헤더의 접두사로 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-172">The entire dictionary header is then prefixed with the length of its data.</span></span> <span data-ttu-id="096c6-173">이 반대 작업은 내부 `ExtractSessionInformationFromMessage` 메서드에 의해 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-173">The reverse operation is performed by an internal `ExtractSessionInformationFromMessage` method.</span></span>  
  
 <span data-ttu-id="096c6-174">동적 사전 키를 처리하는 이외에도 성공적으로 버퍼링된 메시지를 고유한 방식으로 수신합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-174">In addition to processing dynamic dictionary keys, buffered sessionful messages are received in a unique way.</span></span> <span data-ttu-id="096c6-175">이진 인코더는 문서에 대한 판독기를 만들어 문서를 처리하는 대신 내부 `MessagePatterns` 클래스를 사용하여 이진 스트림을 해체합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-175">Instead of creating a reader over the document and processing it, the binary encoder uses the internal `MessagePatterns` class to deconstruct the binary stream.</span></span> <span data-ttu-id="096c6-176">대부분의 메시지에는 WCF에서 생성 될 때 특정 순서로 표시 되는 특정 헤더 집합이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-176">The idea is that most messages have a certain set of headers that show up in a certain order when generated by WCF.</span></span> <span data-ttu-id="096c6-177">패턴 시스템은 필요에 따라 메시지를 분리합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-177">The pattern system breaks the message apart based on what it expects.</span></span> <span data-ttu-id="096c6-178">성공하면 XML을 구문 분석하지 않고 <xref:System.ServiceModel.Channels.MessageHeaders> 개체를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-178">If it is successful, it initializes a <xref:System.ServiceModel.Channels.MessageHeaders> object without parsing the XML.</span></span> <span data-ttu-id="096c6-179">실패하면 표준 메서드로 변경됩니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-179">If not, it falls back to the standard method.</span></span>  
  
### <a name="mtom-encoding"></a><span data-ttu-id="096c6-180">MTOM 인코딩</span><span class="sxs-lookup"><span data-stu-id="096c6-180">MTOM Encoding</span></span>  

 <span data-ttu-id="096c6-181"><xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> 클래스에는 <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement.MaxBufferSize%2A>라는 추가 구성 속성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-181">The <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> class has an additional configuration property called <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement.MaxBufferSize%2A>.</span></span> <span data-ttu-id="096c6-182">이 속성은 메시지를 읽는 동안 버퍼링할 수 있는 데이터의 크기에 대한 상한을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-182">This places an upper bound on how much data it is allowed to buffer during the process of reading a message.</span></span> <span data-ttu-id="096c6-183">모든 MIME 부분을 단일 메시지로 다시 어셈블하려면 XML Infoset(정보 집합) 또는 다른 MIME 부분을 버퍼링해야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-183">The XML Information Set (Infoset), or other MIME parts, may need to be buffered to reassemble all the MIME parts into a single message.</span></span>  
  
 <span data-ttu-id="096c6-184">HTTP에서 올바로 작동하기 위해 내부 MTOM 메시지 인코더 클래스는 내부 `GetContentType` 및 public이며 재정의 가능한 `WriteMessage`에 대한 몇 가지 내부 API를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-184">To work correctly with HTTP, the internal MTOM message encoder class provides some internal APIs for `GetContentType` (which is also internal) and `WriteMessage`, which is public and can be overridden.</span></span> <span data-ttu-id="096c6-185">HTTP 헤더의 값과 MIME 헤더의 값이 일치하려면 더 많은 통신이 수행되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-185">More communication must occur to ensure values in the HTTP headers agree with values in the MIME headers.</span></span>  
  
 <span data-ttu-id="096c6-186">내부적으로 MTOM 메시지 인코더는 WCF의 텍스트 판독기를 사용 하며 텍스트 인코더와 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-186">Internally, the MTOM message encoder uses WCF's text readers, and is similar to the Text encoder.</span></span> <span data-ttu-id="096c6-187">주된 차이점은 MTOM 메시지 인코더는 대량의 이진, 즉 "BLOB"(Binary Large Object)를 메시지 바이트에 포함하기 전에 Base-64 인코딩으로 변환하지 않음으로써 최적화한다는 데 있습니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-187">The main difference is that it optimizes large chunks of binary, or "Binary Large Objects" (BLOBs), by not converting them to Base-64 encoding prior to being embedded into the message bytes.</span></span> <span data-ttu-id="096c6-188">대신 이러한 BLOB는 추출되어 MIME 첨부 파일로 참조됩니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-188">Instead, these BLOBs are kept extracted, and referenced as the MIME attachments.</span></span>  
  
## <a name="writing-your-own-encoder"></a><span data-ttu-id="096c6-189">사용자 고유의 인코더 작성</span><span class="sxs-lookup"><span data-stu-id="096c6-189">Writing your own Encoder</span></span>  

 <span data-ttu-id="096c6-190">사용자 고유의 사용자 지정 메시지 인코더를 구현 하려면 다음 추상 기본 클래스의 사용자 지정 구현을 제공 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-190">To implement your own custom message encoder, you must provide custom implementations of the following abstract base classes:</span></span>  
  
- <xref:System.ServiceModel.Channels.MessageEncoder>  
  
- <xref:System.ServiceModel.Channels.MessageEncoderFactory>  
  
- <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>  
  
 <span data-ttu-id="096c6-191">메시지의 메모리 내 표현을 스트림에 기록할 수 있는 표현으로 변환하여 <xref:System.ServiceModel.Channels.MessageEncoder> 클래스 내에 캡슐화합니다. 이 클래스는 특정 유형의 XML 인코딩을 지원하는 XML 판독기 및 XML 작성기의 팩터리 역할을 합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-191">Converting from the in-memory representation of a message to a representation that can be written to a stream is encapsulated within the <xref:System.ServiceModel.Channels.MessageEncoder> class, which serves as a factory for XML readers and XML writers that support specific types of XML encodings.</span></span>  
  
- <span data-ttu-id="096c6-192">재정의해야 하는 이 클래스의 주요 메서드는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-192">The key methods of this class that you must override are:</span></span>  
  
- <span data-ttu-id="096c6-193"><xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%2A> - <xref:System.ServiceModel.Channels.MessageEncodingBindingElement> 개체를 가져와서 <xref:System.IO.Stream> 개체에 씁니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-193"><xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%2A> which takes a <xref:System.ServiceModel.Channels.MessageEncodingBindingElement> object and writes it into a <xref:System.IO.Stream> object.</span></span>  
  
- <span data-ttu-id="096c6-194"><xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%2A> - <xref:System.IO.Stream> 개체와 최대 헤더 크기를 가져오고 <xref:System.ServiceModel.Channels.Message> 개체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-194"><xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%2A> which takes a <xref:System.IO.Stream> object and a maximum header size and returns a <xref:System.ServiceModel.Channels.Message> object.</span></span>  
  
 <span data-ttu-id="096c6-195">이러한 메서드에 작성하는 코드로, 표준 전송 프로토콜과 사용자 지정 인코딩 간의 변환을 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-195">It is the code you write in these methods that handles conversion between the standard transport protocol, and your customized encoding.</span></span>  
  
 <span data-ttu-id="096c6-196">다음으로는 사용자 지정 인코더를 만드는 팩터리 클래스를 코딩해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-196">Next you need to code a factory class that creates your custom encoder.</span></span> <span data-ttu-id="096c6-197"><xref:System.ServiceModel.Channels.MessageEncoderFactory.Encoder%2A>사용자 지정의 인스턴스를 반환 하려면를 재정의 합니다 <xref:System.ServiceModel.Channels.MessageEncoder> .</span><span class="sxs-lookup"><span data-stu-id="096c6-197">Override the <xref:System.ServiceModel.Channels.MessageEncoderFactory.Encoder%2A> to return an instance of your custom <xref:System.ServiceModel.Channels.MessageEncoder>.</span></span>  
  
 <span data-ttu-id="096c6-198">그런 다음 이 팩터리의 인스턴스를 반환하도록 <xref:System.ServiceModel.Channels.MessageEncoderFactory> 메서드를 재정의하여 서비스 또는 클라이언트를 구성하는 데 사용되는 바인딩 요소 스택에 사용자 지정 <xref:System.ServiceModel.Channels.MessageEncodingBindingElement.CreateMessageEncoderFactory%2A>를 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-198">Then connect your custom <xref:System.ServiceModel.Channels.MessageEncoderFactory> to the binding element stack used to configure the service or client by overriding the <xref:System.ServiceModel.Channels.MessageEncodingBindingElement.CreateMessageEncoderFactory%2A> method to return an instance of this factory.</span></span>  
  
 <span data-ttu-id="096c6-199">WCF에는 [사용자 지정 메시지 인코더](../samples/custom-message-encoder-custom-text-encoder.md) : 사용자 지정 텍스트 인코더 및 [사용자 지정 메시지 인코더: 압축 인코더](../samples/custom-message-encoder-compression-encoder.md)와 같은 샘플 코드를 사용 하 여이 프로세스를 설명 하는 두 개의 샘플이 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="096c6-199">There are two samples provided with WCF that illustrate this process with sample code: [Custom Message Encoder: Custom Text Encoder](../samples/custom-message-encoder-custom-text-encoder.md) and [Custom Message Encoder: Compression Encoder](../samples/custom-message-encoder-compression-encoder.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="096c6-200">참고 항목</span><span class="sxs-lookup"><span data-stu-id="096c6-200">See also</span></span>

- <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>
- <xref:System.ServiceModel.Channels.MessageEncoderFactory>
- <xref:System.ServiceModel.Channels.MessageEncoder>
- [<span data-ttu-id="096c6-201">데이터 전송 아키텍처 개요</span><span class="sxs-lookup"><span data-stu-id="096c6-201">Data Transfer Architectural Overview</span></span>](../feature-details/data-transfer-architectural-overview.md)
- [<span data-ttu-id="096c6-202">메시지 인코더 선택</span><span class="sxs-lookup"><span data-stu-id="096c6-202">Choosing a Message Encoder</span></span>](../feature-details/choosing-a-message-encoder.md)
- [<span data-ttu-id="096c6-203">전송 선택</span><span class="sxs-lookup"><span data-stu-id="096c6-203">Choosing a Transport</span></span>](../feature-details/choosing-a-transport.md)
