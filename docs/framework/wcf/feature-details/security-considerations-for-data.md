---
title: 데이터에 대한 보안 고려 사항
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: a7eb98da-4a93-4692-8b59-9d670c79ffb2
ms.openlocfilehash: 530bb54936f97f1d7460d63cfa316c760cbd449d
ms.sourcegitcommit: 2543a78be6e246aa010a01decf58889de53d1636
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/17/2020
ms.locfileid: "86441819"
---
# <a name="security-considerations-for-data"></a><span data-ttu-id="b3d6e-102">데이터에 대한 보안 고려 사항</span><span class="sxs-lookup"><span data-stu-id="b3d6e-102">Security Considerations for Data</span></span>

<span data-ttu-id="b3d6e-103">WCF (Windows Communication Foundation)에서 데이터를 처리할 때는 여러 가지 위협 범주를 고려해 야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-103">When dealing with data in Windows Communication Foundation (WCF), you must consider a number of threat categories.</span></span> <span data-ttu-id="b3d6e-104">다음 표에는 데이터 처리와 관련하여 가장 중요한 위협 클래스가 나열되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-104">The following table lists the most important threat classes that relate to data processing.</span></span> <span data-ttu-id="b3d6e-105">WCF는 이러한 위협을 완화 하는 도구를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-105">WCF provides tools to mitigate these threats.</span></span>

<span data-ttu-id="b3d6e-106">서비스 거부 신뢰할 수 없는 데이터를 받을 때 데이터가 수신 측에서 메모리, 스레드, 사용 가능한 연결, 프로세서 주기 등 많은 양의 다양 한 리소스에 액세스 하 여 시간이 오래 걸리는 계산을 발생 시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-106">Denial of service When receiving untrusted data, the data may cause the receiving side to access a disproportionate amount of various resources, such as memory, threads, available connections, or processor cycles by causing lengthy computations.</span></span> <span data-ttu-id="b3d6e-107">서버에 대한 서비스 거부 공격이 발생하면 서버의 작동이 중단되고 서버가 다른 올바른 클라이언트에서 보낸 메시지를 처리하지 못할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-107">A denial-of-service attack against a server may cause it to crash and be unable to process messages from other, legitimate clients.</span></span>

<span data-ttu-id="b3d6e-108">악의적인 코드 실행 신뢰할 수 없는 데이터는 받는 쪽에서 의도 하지 않은 코드를 실행 하 게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-108">Malicious code execution Incoming untrusted data causes the receiving side to run code it did not intend to.</span></span>

<span data-ttu-id="b3d6e-109">정보 노출 원격 공격자는 받는 사람이 의도 하는 것 보다 많은 정보를 공개 하는 방식으로 요청에 응답 하도록 강제 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-109">Information disclosure The remote attacker forces the receiving party to respond to its requests in such a way as to disclose more information than it intends to.</span></span>

## <a name="user-provided-code-and-code-access-security"></a><span data-ttu-id="b3d6e-110">사용자 제공 코드 및 코드 액세스 보안</span><span class="sxs-lookup"><span data-stu-id="b3d6e-110">User-Provided Code and Code Access Security</span></span>

<span data-ttu-id="b3d6e-111">WCF (Windows Communication Foundation) 인프라의 여러 위치는 사용자가 제공 하는 코드를 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-111">A number of places in the Windows Communication Foundation (WCF) infrastructure run code that is provided by the user.</span></span> <span data-ttu-id="b3d6e-112">예를 들어, <xref:System.Runtime.Serialization.DataContractSerializer> serialization 엔진은 사용자 제공 속성 `set` 접근자 및 `get` 접근자를 호출할 수 있으며,</span><span class="sxs-lookup"><span data-stu-id="b3d6e-112">For example, the <xref:System.Runtime.Serialization.DataContractSerializer> serialization engine may call user-provided property `set` accessors and `get` accessors.</span></span> <span data-ttu-id="b3d6e-113">WCF 채널 인프라는 클래스의 사용자 제공 파생 클래스를 호출할 수도 있습니다 <xref:System.ServiceModel.Channels.Message> .</span><span class="sxs-lookup"><span data-stu-id="b3d6e-113">The WCF channel infrastructure may also call into user-provided derived classes of the <xref:System.ServiceModel.Channels.Message> class.</span></span>

<span data-ttu-id="b3d6e-114">코드를 작성할 때는 보안상 취약한 부분이 없도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-114">It is the responsibility of the code author to ensure that no security vulnerabilities exist.</span></span> <span data-ttu-id="b3d6e-115">예를 들어, 데이터 멤버 속성이 정수 형식인 데이터 계약 형식을 만들고 `set` 접근자 구현에서 속성 값을 기반으로 배열을 할당하는 경우 악의적인 메시지에 이 데이터 멤버에 대한 매우 큰 값이 포함되어 있으면 서비스 거부 공격을 받을 가능성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-115">For example, if you create a data contract type with a data member property of type integer, and in the `set` accessor implementation allocate an array based on the property value, you expose the possibility of a denial-of-service attack if a malicious message contains an extremely large value for this data member.</span></span> <span data-ttu-id="b3d6e-116">일반적으로 들어오는 데이터를 기반으로 할당을 수행하거나 사용자 제공 코드에서 시간이 오래 걸리는 처리를 수행하는 것은 피해야 합니다(특히 들어오는 데이터의 양이 적어도 처리 시간이 오래 걸릴 수 있는 경우).</span><span class="sxs-lookup"><span data-stu-id="b3d6e-116">In general, avoid any allocations based on incoming data or lengthy processing in user-provided code (especially if lengthy processing can be caused by a small amount of incoming data).</span></span> <span data-ttu-id="b3d6e-117">사용자 제공 코드의 보안 분석을 수행할 때는 모든 실패의 경우(즉, 예외가 throw되는 모든 코드 분기)도 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-117">When performing security analysis of user-provided code, make sure to also consider all failure cases (that is, all code branches where exceptions are thrown).</span></span>

<span data-ttu-id="b3d6e-118">사용자 제공 코드의 한 예로 각 작업에 대한 서비스 구현 내에 있는 코드를 들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-118">The ultimate example of user-provided code is the code inside your service implementation for each operation.</span></span> <span data-ttu-id="b3d6e-119">이 경우 서비스 구현의 보안에 대해서도 신경을 써야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-119">The security of your service implementation is your responsibility.</span></span> <span data-ttu-id="b3d6e-120">작업을 구현할 때 실수로 보안을 설정하지 않아서 서비스 거부 공격에 노출되는 경우도 많습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-120">It is easy to inadvertently create insecure operation implementations that may result in denial-of-service vulnerabilities.</span></span> <span data-ttu-id="b3d6e-121">문자열을 받아서 데이터베이스에서 이름이 해당 문자열로 시작하는 고객의 목록을 반환하는 작업을 예로 들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-121">For example, an operation that takes a string and returns the list of customers from a database whose name starts with that string.</span></span> <span data-ttu-id="b3d6e-122">용량이 큰 데이터베이스로 작업하는 경우 전달되는 문자열이 단지 한 글자인 경우 사용자 코드가 사용 가능한 메모리 전체 크기보다 큰 메시지를 만들려고 해서 전체 서비스가 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-122">If you are working with a large database and the string being passed is just a single letter, your code may attempt to create a message larger than all available memory, causing the entire service to fail.</span></span> <span data-ttu-id="b3d6e-123">는 <xref:System.OutOfMemoryException> .NET Framework에서 복구할 수 없으며 항상 응용 프로그램의 종료를 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-123">(An <xref:System.OutOfMemoryException> is not recoverable in the .NET Framework and always results in the termination of your application.)</span></span>

<span data-ttu-id="b3d6e-124">다양한 확장 지점에 악의적인 코드가 들어가지 않도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-124">You should ensure that no malicious code is plugged in to the various extensibility points.</span></span> <span data-ttu-id="b3d6e-125">부분 신뢰에서 실행하거나, 부분적으로 신뢰할 수 있는 어셈블리의 형식을 처리하거나, 부분적으로 신뢰할 수 있는 코드에서 사용할 수 있는 구성 요소를 만드는 경우 특히 그렇습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-125">This is especially relevant when running under partial trust, dealing with types from partially-trusted assemblies, or creating components usable by partially-trusted code.</span></span> <span data-ttu-id="b3d6e-126">자세한 내용은 뒷부분의 "부분 신뢰 위협"을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-126">For more information, see "Partial Trust Threats" in a later section.</span></span>

<span data-ttu-id="b3d6e-127">부분 신뢰에서 실행하는 경우 데이터 계약 serialization 인프라에서는 데이터 계약 프로그래밍 모델의 제한된 하위 집합만 지원합니다. 예를 들어 <xref:System.SerializableAttribute> 특성을 사용한 전용 데이터 멤버 또는 형식은 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-127">Note that when running in partial trust, the data contract serialization infrastructure supports only a limited subset of the data contract programming model - for example, private data members or types using the <xref:System.SerializableAttribute> attribute are not supported.</span></span> <span data-ttu-id="b3d6e-128">자세한 내용은 [부분 신뢰](partial-trust.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-128">For more information, see [Partial Trust](partial-trust.md).</span></span>

## <a name="avoiding-unintentional-information-disclosure"></a><span data-ttu-id="b3d6e-129">의도하지 않은 정보 공개 방지</span><span class="sxs-lookup"><span data-stu-id="b3d6e-129">Avoiding Unintentional Information Disclosure</span></span>

<span data-ttu-id="b3d6e-130">보안을 염두에 두고 serialize 가능 형식을 디자인하는 경우 정보 공개는 고려해야 할 중요한 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-130">When designing serializable types with security in mind, information disclosure is a possible concern.</span></span>

<span data-ttu-id="b3d6e-131">다음 사항을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-131">Consider the following points:</span></span>

- <span data-ttu-id="b3d6e-132"><xref:System.Runtime.Serialization.DataContractSerializer> 프로그래밍 모델에서는 serialization 동안 형식 또는 어셈블리 외부의 개인 및 내부 데이터가 노출될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-132">The <xref:System.Runtime.Serialization.DataContractSerializer> programming model allows the exposure of private and internal data outside of the type or assembly during serialization.</span></span> <span data-ttu-id="b3d6e-133">또한 스키마를 내보내는 동안 형식의 셰이프가 노출될 수 있으므로</span><span class="sxs-lookup"><span data-stu-id="b3d6e-133">Additionally, the shape of a type can be exposed during schema export.</span></span> <span data-ttu-id="b3d6e-134">형식의 serialization 프로젝션을 이해해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-134">Be sure to understand your type's serialization projection.</span></span> <span data-ttu-id="b3d6e-135">노출되지 않도록 하려면 serialize하지 않도록 설정해야 합니다. 예를 들어, 데이터 계약의 경우 <xref:System.Runtime.Serialization.DataMemberAttribute> 특성을 적용하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-135">If you do not want anything exposed, disable serializing it (for example, by not applying the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute in the case of a data contract).</span></span>

- <span data-ttu-id="b3d6e-136">사용하는 serializer에 따라 같은 형식에 여러 개의 serialization 프로젝션이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-136">Be aware that the same type may have multiple serialization projections, depending on the serializer in use.</span></span> <span data-ttu-id="b3d6e-137">같은 형식이 <xref:System.Runtime.Serialization.DataContractSerializer> 에 사용한 경우와 <xref:System.Xml.Serialization.XmlSerializer>에 사용한 경우에 노출하는 데이터 집합이 다를 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-137">The same type may expose one set of data when used with the <xref:System.Runtime.Serialization.DataContractSerializer> and another set of data when used with the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="b3d6e-138">실수로 잘못된 serializer를 사용하면 정보가 공개될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-138">Accidentally using the wrong serializer may lead to information disclosure.</span></span>

- <span data-ttu-id="b3d6e-139">레거시 RPC(원격 프로시저 호출)/인코딩 모드에서 <xref:System.Xml.Serialization.XmlSerializer> 를 사용하면 보내는 쪽의 개체 그래프의 셰이프가 받는 쪽에 실수로 노출될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-139">Using the <xref:System.Xml.Serialization.XmlSerializer> in legacy remote procedure call (RPC)/encoded mode may unintentionally expose the shape of the object graph on the sending side to the receiving side.</span></span>

## <a name="preventing-denial-of-service-attacks"></a><span data-ttu-id="b3d6e-140">서비스 거부 공격 방지</span><span class="sxs-lookup"><span data-stu-id="b3d6e-140">Preventing Denial-of-Service Attacks</span></span>

### <a name="quotas"></a><span data-ttu-id="b3d6e-141">할당량</span><span class="sxs-lookup"><span data-stu-id="b3d6e-141">Quotas</span></span>

<span data-ttu-id="b3d6e-142">받는 쪽에서 많은 양의 메모리를 할당하도록 하면 서비스 거부 공격이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-142">Causing the receiving side to allocate a significant amount of memory is a potential denial-of-service attack.</span></span> <span data-ttu-id="b3d6e-143">이 단원에서는 용량이 큰 메시지로 인해 발생하는 메모리 소비 문제를 주로 설명하지만 다른 공격이 발생할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-143">While this section concentrates on memory consumption issues arising from large messages, other attacks may occur.</span></span> <span data-ttu-id="b3d6e-144">예를 들어, 메시지의 처리 시간이 과도하게 오래 걸릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-144">For example, messages may use a disproportionate amount of processing time.</span></span>

<span data-ttu-id="b3d6e-145">서비스 거부 공격은 주로 할당량을 사용하여 완화시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-145">Denial-of-service attacks are usually mitigated using quotas.</span></span> <span data-ttu-id="b3d6e-146">할당량을 초과하면 대개 <xref:System.ServiceModel.QuotaExceededException> 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-146">When a quota is exceeded, a <xref:System.ServiceModel.QuotaExceededException> exception is normally thrown.</span></span> <span data-ttu-id="b3d6e-147">할당량이 없는 경우에는 악의적인 메시지가 사용 가능한 모든 메모리에 액세스하여 <xref:System.OutOfMemoryException> 예외가 발생하거나 사용 가능한 모든 스택에 액세스하여 <xref:System.StackOverflowException>이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-147">Without the quota, a malicious message may cause all available memory to be accessed, resulting in an <xref:System.OutOfMemoryException> exception, or all available stacks to be accessed, resulting in a <xref:System.StackOverflowException>.</span></span>

<span data-ttu-id="b3d6e-148">할당량 초과 시나리오는 복구가 가능합니다. 실행 중인 서비스에서 발생한 경우 현재 처리 중인 메시지를 삭제하면 서비스를 계속 실행하면서 메시지를 더 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-148">The quota exceeded scenario is recoverable; if encountered in a running service, the message currently being processed is discarded and the service keeps running and processes further messages.</span></span> <span data-ttu-id="b3d6e-149">그러나 메모리 부족 및 스택 오버플로 시나리오는 .NET Framework의 어디에서 나 복구할 수 없습니다. 이러한 예외가 발생 하면 서비스가 종료 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-149">The out-of-memory and stack overflow scenarios, however, are not recoverable anywhere in the .NET Framework; the service terminates if it encounters such exceptions.</span></span>

<span data-ttu-id="b3d6e-150">WCF의 할당량에는 사전 할당이 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-150">Quotas in WCF do not involve any pre-allocation.</span></span> <span data-ttu-id="b3d6e-151">예를 들어, 다양한 클래스에 있는 <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> 할당량이 128KB로 설정된 경우 각 메시지에 자동으로 128KB가 할당되는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-151">For example, if the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> quota (found on various classes) is set to 128 KB, it does not mean that 128 KB is automatically allocated for each message.</span></span> <span data-ttu-id="b3d6e-152">실제로 할당되는 양은 실제로 들어오는 메시지 크기에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-152">The actual amount allocated depends on the actual incoming message size.</span></span>

<span data-ttu-id="b3d6e-153">많은 할당량을 전송 계층에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-153">Many quotas are available at the transport layer.</span></span> <span data-ttu-id="b3d6e-154">이러한 할당량은 사용 중인 특정 전송 채널(HTTP, TCP 등)에서 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-154">These are quotas enforced by the specific transport channel in use (HTTP, TCP, and so on).</span></span> <span data-ttu-id="b3d6e-155">이 항목에서는 이러한 할당량 중 일부에 대해 설명하며 자세한 내용은 [Transport Quotas](transport-quotas.md)에 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-155">While this topic discusses some of these quotas, these quotas are described in detail in [Transport Quotas](transport-quotas.md).</span></span>

### <a name="hashtable-vulnerability"></a><span data-ttu-id="b3d6e-156">해시 테이블 취약성</span><span class="sxs-lookup"><span data-stu-id="b3d6e-156">Hashtable Vulnerability</span></span>

<span data-ttu-id="b3d6e-157">데이터 계약에 해시 테이블 또는 컬렉션이 포함된 경우 취약성이 존재합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-157">A vulnerability exists when data contracts contain hashtables or collections.</span></span> <span data-ttu-id="b3d6e-158">해시 테이블에 많은 수의 값을 삽입할 때 이러한 값이 동일한 해시 값을 생성할 경우 문제가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-158">The problem occurs if a large number of values are inserted into a hashtable where a large number of those values generate the same hash value.</span></span> <span data-ttu-id="b3d6e-159">이 방식은 DOS 공격으로 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-159">This can be used as a DOS attack.</span></span>  <span data-ttu-id="b3d6e-160">이 취약점은 MaxReceivedMessageSize 바인딩 할당량을 설정 하 여 완화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-160">This vulnerability can be mitigated by setting the MaxReceivedMessageSize binding quota.</span></span> <span data-ttu-id="b3d6e-161">이러한 공격 방지를 위해 이 할당량을 설정할 때는 주의가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-161">Care must be taken while setting this quota in order to prevent such attacks.</span></span> <span data-ttu-id="b3d6e-162">이 할당량은 WCF 메시지 크기에 상한을 둡니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-162">This quota puts an upper limit on the size of WCF message.</span></span> <span data-ttu-id="b3d6e-163">또한 데이터 계약에서는 해시 테이블 또는 컬렉션을 사용하지 않도록 하십시오.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-163">Additionally, avoid using hashtables or collections in your data contracts.</span></span>

## <a name="limiting-memory-consumption-without-streaming"></a><span data-ttu-id="b3d6e-164">스트리밍을 사용하지 않는 경우 메모리 소비 제한</span><span class="sxs-lookup"><span data-stu-id="b3d6e-164">Limiting Memory Consumption Without Streaming</span></span>

<span data-ttu-id="b3d6e-165">큰 메시지에 대한 보안 모델은 스트리밍 사용 여부에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-165">The security model around large messages depends on whether streaming is in use.</span></span> <span data-ttu-id="b3d6e-166">스트리밍을 사용하지 않는 기본적인 경우에는 메시지가 메모리에 버퍼링됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-166">In the basic, non-streamed case, messages are buffered into memory.</span></span> <span data-ttu-id="b3d6e-167">이 경우 <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> 또는 시스템 제공 바인딩에서 <xref:System.ServiceModel.Channels.TransportBindingElement> 할당량을 사용하면 액세스할 수 있는 최대 메시지 크기를 제한하여 용량이 큰 메시지 문제를 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-167">In this case, use the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> quota on the <xref:System.ServiceModel.Channels.TransportBindingElement> or on the system-provided bindings to protect against large messages by limiting the maximum message size to access.</span></span> <span data-ttu-id="b3d6e-168">서비스는 여러 개의 메시지를 동시에 처리할 수 있으며 이 경우 메시지는 모두 메모리에 들어갑니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-168">Note that a service may be processing multiple messages at the same time, in which case they are all in memory.</span></span> <span data-ttu-id="b3d6e-169">스로틀 기능을 사용하여 이 위협을 완화합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-169">Use the throttling feature to mitigate this threat.</span></span>

<span data-ttu-id="b3d6e-170">`MaxReceivedMessageSize` 는 메시지당 메모리 소비량에 대한 상한을 지정하지는 않지만 상수 계수 이내로 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-170">Also note that `MaxReceivedMessageSize` does not place an upper bound on per-message memory consumption, but limits it to within a constant factor.</span></span> <span data-ttu-id="b3d6e-171">예를 들어, `MaxReceivedMessageSize` 가 1MB인 경우 1MB의 메시지를 받아서 역직렬화하면 역직렬화된 개체 그래프를 포함하기 위해 추가 메모리가 필요하기 때문에 총 메모리 소비량은 1MB를 훨씬 초과합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-171">For example, if the `MaxReceivedMessageSize` is 1 MB and a 1-MB message is received and then deserialized, additional memory is required to contain the deserialized object graph, resulting in total memory consumption well over 1 MB.</span></span> <span data-ttu-id="b3d6e-172">따라서 들어오는 데이터가 많지 않아도 대량의 메모리를 소비할 수 있는 serialize 가능한 형식은 만들지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-172">For this reason, avoid creating serializable types that could result in significant memory consumption without much incoming data.</span></span> <span data-ttu-id="b3d6e-173">예를 들어 데이터 계약 "MyContract"는 50 개의 선택적 데이터 멤버 필드와 추가 100 개인 필드는 XML 생성 ""을 사용 하 여 인스턴스화할 수 있습니다 \<MyContract/> .</span><span class="sxs-lookup"><span data-stu-id="b3d6e-173">For example, a data contract "MyContract" with 50 optional data member fields and an additional 100 private fields could be instantiated with the XML construction "\<MyContract/>".</span></span> <span data-ttu-id="b3d6e-174">이 XML은 150개 필드에 해당되는 메모리에 액세스합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-174">This XML results in memory being accessed for 150 fields.</span></span> <span data-ttu-id="b3d6e-175">데이터 멤버는 기본적으로 선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-175">Note that data members are optional by default.</span></span> <span data-ttu-id="b3d6e-176">이러한 형식이 배열의 일부인 경우에는 문제가 복잡해집니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-176">The problem is compounded when such a type is part of an array.</span></span>

<span data-ttu-id="b3d6e-177">`MaxReceivedMessageSize` 만으로는 모든 서비스 거부 공격을 방지하기에 충분하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-177">`MaxReceivedMessageSize` alone is not enough to prevent all denial-of-service attacks.</span></span> <span data-ttu-id="b3d6e-178">예를 들어, 들어오는 메시지에서 역직렬 변환기에 여러 층으로 중첩된 개체 그래프(한 개체에 포함된 개체에 또 개체가 포함되는 등)의 역직렬화를 요구할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-178">For example, the deserializer may be forced to deserialize a deeply-nested object graph (an object that contains another object that contains yet another one, and so on) by an incoming message.</span></span> <span data-ttu-id="b3d6e-179"><xref:System.Runtime.Serialization.DataContractSerializer> 와 <xref:System.Xml.Serialization.XmlSerializer> 는 모두 중첩된 방식으로 메서드를 호출하여 이러한 그래프를 역직렬화합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-179">Both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Xml.Serialization.XmlSerializer> call methods in a nested way to deserialize such graphs.</span></span> <span data-ttu-id="b3d6e-180">메서드 호출이 너무 많이 중첩되면 <xref:System.StackOverflowException>을 복구하지 못할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-180">Deep nesting of method calls may result in an unrecoverable <xref:System.StackOverflowException>.</span></span> <span data-ttu-id="b3d6e-181"><xref:System.ServiceModel.Configuration.XmlDictionaryReaderQuotasElement.MaxDepth%2A> 할당량을 설정하여 이 항목의 뒷부분 "안전한 XML 사용" 단원에 설명된 대로 XML 중첩의 수준을 제한하면 이 위협을 완화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-181">This threat is mitigated by setting the <xref:System.ServiceModel.Configuration.XmlDictionaryReaderQuotasElement.MaxDepth%2A> quota to limit the level of XML nesting, as discussed in the "Using XML Safely" section later in the topic.</span></span>

<span data-ttu-id="b3d6e-182">이진 XML 인코딩을 사용하는 경우에는 특히 `MaxReceivedMessageSize` 에 추가로 할당량을 설정하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-182">Setting additional quotas to `MaxReceivedMessageSize` is especially important when using binary XML encoding.</span></span> <span data-ttu-id="b3d6e-183">이진 인코딩을 사용하는 것은 압축과 비슷한 면이 있습니다. 들어오는 메시지의 바이트 수가 적어도 표현하는 데이터는 많을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-183">Using binary encoding is somewhat equivalent to compression: a small group of bytes in the incoming message may represent a lot of data.</span></span> <span data-ttu-id="b3d6e-184">따라서 `MaxReceivedMessageSize` 제한에 맞는 메시지도 완전히 확장된 상태에서는 훨씬 더 많은 메모리를 차지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-184">Thus, even a message fitting into the `MaxReceivedMessageSize` limit may take up much more memory in fully expanded form.</span></span> <span data-ttu-id="b3d6e-185">이러한 XML 관련 위협을 완화하려면 이 항목 뒷부분의 "안전한 XML 사용" 단원에 설명된 대로 모든 XML 판독기 할당량을 올바르게 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-185">To mitigate such XML-specific threats, all of the XML reader quotas must be set correctly, as discussed in the "Using XML Safely" section later in this topic.</span></span>

## <a name="limiting-memory-consumption-with-streaming"></a><span data-ttu-id="b3d6e-186">스트리밍 시 메모리 소비 제한</span><span class="sxs-lookup"><span data-stu-id="b3d6e-186">Limiting Memory Consumption with Streaming</span></span>

<span data-ttu-id="b3d6e-187">스트리밍할 때 `MaxReceivedMessageSize` 를 작게 설정하여 서비스 거부 공격으로부터 시스템을 보호할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-187">When streaming, you may use a small `MaxReceivedMessageSize` setting to protect against denial-of-service attacks.</span></span> <span data-ttu-id="b3d6e-188">그러나 스트리밍과 관련된 보다 복잡한 시나리오도 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-188">However, more complicated scenarios are possible with streaming.</span></span> <span data-ttu-id="b3d6e-189">예를 들어, 파일 업로드 서비스에서 사용 가능한 전체 메모리보다 큰 파일을 받는 경우가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-189">For example, a file upload service accepts files larger than all available memory.</span></span> <span data-ttu-id="b3d6e-190">이 경우 데이터가 거의 메모리에 버퍼링되지 않고 메시지가 디스크로 직접 스트리밍될 것을 예상하고 `MaxReceivedMessageSize` 를 매우 큰 값으로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-190">In this case, set the `MaxReceivedMessageSize` to an extremely large value, expecting that almost no data is buffered in memory and the message streams directly to disk.</span></span> <span data-ttu-id="b3d6e-191">악의적인 메시지를 사용 하 여 WCF가 데이터를 스트리밍하는 대신 버퍼링 할 수 있는 경우는 `MaxReceivedMessageSize` 더 이상 사용 가능한 모든 메모리에 액세스 하는 메시지에 대해 보호 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-191">If a malicious message can somehow force WCF to buffer data instead of streaming it in this case, `MaxReceivedMessageSize` no longer protects against the message accessing all available memory.</span></span>

<span data-ttu-id="b3d6e-192">이 위협을 완화 하기 위해 특정 할당량 설정이 버퍼링을 제한 하는 다양 한 WCF 데이터 처리 구성 요소에 존재 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-192">To mitigate this threat, specific quota settings exist on various WCF data-processing components that limit buffering.</span></span> <span data-ttu-id="b3d6e-193">이 중 가장 중요한 것은 다양한 전송 바인딩 요소 및 표준 바인딩에 대한 `MaxBufferSize` 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-193">The most important of these is the `MaxBufferSize` property on various transport binding elements and standard bindings.</span></span> <span data-ttu-id="b3d6e-194">스트리밍 시 메시지당 할당하려는 최대 메모리 크기를 고려해서 이 할당량을 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-194">When streaming, this quota should be set taking into account the maximum amount of memory you are willing to allocate per message.</span></span> <span data-ttu-id="b3d6e-195">이 설정은 `MaxReceivedMessageSize`와 마찬가지로 메모리 소비량에 대한 절대 최대값을 지정하지 않으며 상수 계수 이내로 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-195">As with `MaxReceivedMessageSize`, the setting does not put an absolute maximum on memory consumption but only limits it to within a constant factor.</span></span> <span data-ttu-id="b3d6e-196">또한 `MaxReceivedMessageSize`와 마찬가지로 여러 메시지를 동시에 처리하는 경우를 생각해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-196">Also, as with `MaxReceivedMessageSize`, be aware of the possibility of multiple messages being processed simultaneously.</span></span>

### <a name="maxbuffersize-details"></a><span data-ttu-id="b3d6e-197">MaxBufferSize 세부 정보</span><span class="sxs-lookup"><span data-stu-id="b3d6e-197">MaxBufferSize Details</span></span>

<span data-ttu-id="b3d6e-198">`MaxBufferSize`속성은 WCF에서 수행 하는 모든 대량 버퍼링을 제한 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-198">The `MaxBufferSize` property limits any bulk buffering WCF does.</span></span> <span data-ttu-id="b3d6e-199">예를 들어 WCF는 항상 SOAP 헤더와 SOAP 오류를 버퍼링 하 고 MTOM (메시지 전송 최적화 메커니즘) 메시지에서 자연 스러운 읽기 순서에 있지 않은 것으로 발견 된 모든 MIME 부분을 버퍼링 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-199">For example, WCF always buffers SOAP headers and SOAP faults, as well as any MIME parts found to be not in the natural reading order in an Message Transmission Optimization Mechanism (MTOM) message.</span></span> <span data-ttu-id="b3d6e-200">이 설정은 이러한 모든 경우 버퍼링 크기를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-200">This setting limits the amount of buffering in all these cases.</span></span>

<span data-ttu-id="b3d6e-201">WCF `MaxBufferSize` 는 버퍼링 할 수 있는 다양 한 구성 요소에 값을 전달 하 여이를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-201">WCF accomplishes this by passing the `MaxBufferSize` value to the various components that may buffer.</span></span> <span data-ttu-id="b3d6e-202">예를 들어, <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> 클래스의 일부 <xref:System.ServiceModel.Channels.Message> 오버로드는 `maxSizeOfHeaders` 매개 변수를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-202">For example, some <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> overloads of the <xref:System.ServiceModel.Channels.Message> class take a `maxSizeOfHeaders` parameter.</span></span> <span data-ttu-id="b3d6e-203">WCF는 `MaxBufferSize` 이 매개 변수에 값을 전달 하 여 SOAP 헤더 버퍼링의 양을 제한 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-203">WCF passes the `MaxBufferSize` value to this parameter to limit the amount of SOAP header buffering.</span></span> <span data-ttu-id="b3d6e-204"><xref:System.ServiceModel.Channels.Message> 클래스를 직접 사용하는 경우 이 매개 변수를 설정하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-204">It is important to set this parameter when using the <xref:System.ServiceModel.Channels.Message> class directly.</span></span> <span data-ttu-id="b3d6e-205">일반적으로 WCF에서 할당량 매개 변수를 사용 하는 구성 요소를 사용 하는 경우 이러한 매개 변수의 보안 의미를 이해 하 고이를 올바르게 설정 하는 것이 중요 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-205">In general, when using a component in WCF that takes quota parameters, it is important to understand the security implications of these parameters and set them correctly.</span></span>

<span data-ttu-id="b3d6e-206">MTOM 메시지 인코더에는 또한 `MaxBufferSize` 설정이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-206">The MTOM message encoder also has a `MaxBufferSize` setting.</span></span> <span data-ttu-id="b3d6e-207">표준 바인딩을 사용하는 경우 이 설정은 자동으로 전송 수준 `MaxBufferSize` 값으로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-207">When using standard bindings, this is set automatically to the transport-level `MaxBufferSize` value.</span></span> <span data-ttu-id="b3d6e-208">그러나 MTOM 메시지 인코더 바인딩 요소를 사용하여 사용자 지정 바인딩을 생성하는 경우에는 `MaxBufferSize` 속성을 스트리밍을 사용할 때 안전한 값으로 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-208">However, when using the MTOM message encoder binding element to construct a custom binding, it is important to set the `MaxBufferSize` property to a safe value when streaming is used.</span></span>

## <a name="xml-based-streaming-attacks"></a><span data-ttu-id="b3d6e-209">XML 기반 스트리밍 공격</span><span class="sxs-lookup"><span data-stu-id="b3d6e-209">XML-Based Streaming Attacks</span></span>

<span data-ttu-id="b3d6e-210">`MaxBufferSize`만으로는 스트리밍이 예상 되는 경우 WCF를 강제로 버퍼링 할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-210">`MaxBufferSize` alone is not enough to ensure that WCF cannot be forced into buffering when streaming is expected.</span></span> <span data-ttu-id="b3d6e-211">예를 들어 WCF XML 판독기는 새 요소를 읽기 시작할 때 항상 전체 XML 요소 시작 태그를 버퍼링 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-211">For example, the WCF XML readers always buffer the entire XML element start tag when starting to read a new element.</span></span> <span data-ttu-id="b3d6e-212">이렇게 하면 네임스페이스와 특성이 올바르게 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-212">This is done so that namespaces and attributes are properly processed.</span></span> <span data-ttu-id="b3d6e-213">`MaxReceivedMessageSize` 가 크게(예: 큰 파일을 직접 디스크로 스트리밍하는 시나리오가 가능하도록) 구성된 경우 메시지 본문 전체가 거대한 XML 요소 시작 태그인 악의적인 메시지가 구성될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-213">If `MaxReceivedMessageSize` is configured to be large (for example, to enable a direct-to-disk large file streaming scenario), a malicious message may be constructed where the entire message body is a large XML element start tag.</span></span> <span data-ttu-id="b3d6e-214">이 메시지를 읽으려고 하면 <xref:System.OutOfMemoryException>이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-214">An attempt to read it results in an <xref:System.OutOfMemoryException>.</span></span> <span data-ttu-id="b3d6e-215">이는이 항목의 뒷부분에 나오는 "안전한 XML 사용" 단원에 설명 된 대로 XML 판독기 할당량을 사용 하 여 완화할 수 있는 여러 가지 XML 기반 서비스 거부 공격 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-215">This is one of many possible XML-based denial-of-service attacks that can all be mitigated using XML reader quotas, discussed in the "Using XML Safely" section later in this topic.</span></span> <span data-ttu-id="b3d6e-216">스트리밍을 사용할 때는 이러한 할당량을 모두 설정하는 것이 특히 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-216">When streaming, it is especially important to set all of these quotas.</span></span>

### <a name="mixing-streaming-and-buffering-programming-models"></a><span data-ttu-id="b3d6e-217">스트리밍과 버퍼링 프로그래밍 모델 혼합</span><span class="sxs-lookup"><span data-stu-id="b3d6e-217">Mixing Streaming and Buffering Programming Models</span></span>

<span data-ttu-id="b3d6e-218">동일한 서비스에서 스트리밍과 비스트리밍 프로그래밍 모델을 혼합하여 사용하는 경우 여러 가지 공격이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-218">Many possible attacks arise from mixing streaming and non-streaming programming models in the same service.</span></span> <span data-ttu-id="b3d6e-219"><xref:System.IO.Stream> 을 받는 작업과 일부 사용자 정의 형식의 배열을 받는 작업의 두 가지 작업이 있는 서비스 계약을 가정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-219">Suppose there is a service contract with two operations: one takes a <xref:System.IO.Stream> and another takes an array of some custom type.</span></span> <span data-ttu-id="b3d6e-220">또한 첫 번째 작업에서 큰 스트림을 처리할 수 있도록 `MaxReceivedMessageSize` 가 큰 값으로 설정되었다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-220">Suppose also that `MaxReceivedMessageSize` is set to a large value to enable the first operation to process large streams.</span></span> <span data-ttu-id="b3d6e-221">그러나 이 경우 용량이 큰 메시지가 두 번째 작업으로도 전송될 수 있으며 작업이 호출되기 전에 역직렬 변환기가 데이터를 메모리에 배열로 버퍼링할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-221">Unfortunately, this means that large messages can now be sent to the second operation as well, and the deserializer buffers data in memory as an array before the operation is called.</span></span> <span data-ttu-id="b3d6e-222">그러면 역직렬 변환기에서 작업에 사용하는 메시지 본문의 크기가 `MaxBufferSize` 할당량으로 제한되지 않아 서비스 거부 공격이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-222">This is a potential denial-of-service attack: the `MaxBufferSize` quota does not limit the size of the message body, which is what the deserializer works with.</span></span>

<span data-ttu-id="b3d6e-223">이러한 이유로 동일한 계약에서 스트리밍 기반 작업과 비스트리밍 작업을 혼합하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-223">For this reason, avoid mixing stream-based and non-streamed operations in the same contract.</span></span> <span data-ttu-id="b3d6e-224">두 가지 프로그래밍 모델을 반드시 혼합해야 하는 경우에는 다음 주의 사항에 따르십시오.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-224">If you absolutely must mix the two programming models, use the following precautions:</span></span>

- <span data-ttu-id="b3d6e-225"><xref:System.Runtime.Serialization.IExtensibleDataObject> 의 <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> 속성을 <xref:System.ServiceModel.ServiceBehaviorAttribute> 로 설정하여 `true`기능을 끕니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-225">Turn off the <xref:System.Runtime.Serialization.IExtensibleDataObject> feature by setting the <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> property of the <xref:System.ServiceModel.ServiceBehaviorAttribute> to `true`.</span></span> <span data-ttu-id="b3d6e-226">그러면 계약에 속한 멤버만 역직렬화됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-226">This ensures that only members that are a part of the contract are deserialized.</span></span>

- <span data-ttu-id="b3d6e-227"><xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> 의 <xref:System.Runtime.Serialization.DataContractSerializer> 속성을 안전한 값으로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-227">Set the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> property of the <xref:System.Runtime.Serialization.DataContractSerializer> to a safe value.</span></span> <span data-ttu-id="b3d6e-228">이 할당량은 <xref:System.ServiceModel.ServiceBehaviorAttribute> 특성에서나 구성을 통해서도 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-228">This quota is also available on the <xref:System.ServiceModel.ServiceBehaviorAttribute> attribute or through configuration.</span></span> <span data-ttu-id="b3d6e-229">이 할당량은 한 역직렬화 에피소드에서 역직렬화되는 개체의 수를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-229">This quota limits the number of objects that are deserialized in one deserialization episode.</span></span> <span data-ttu-id="b3d6e-230">일반적으로 메시지 계약에 있는 각 작업 매개 변수 또는 메시지 본문은 한 에피소드로 역직렬화됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-230">Normally, each operation parameter or message body part in a message contract is deserialized in one episode.</span></span> <span data-ttu-id="b3d6e-231">배열을 역직렬화할 때는 각 배열 항목이 개별 개체로 계산됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-231">When deserializing arrays, each array entry is counted as a separate object.</span></span>

- <span data-ttu-id="b3d6e-232">모든 XML 판독기 할당량을 안전한 값으로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-232">Set all of the XML reader quotas to safe values.</span></span> <span data-ttu-id="b3d6e-233"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A>, <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>및 <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A> 에 주의하고 비스트리밍 작업의 문자열을 피해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-233">Pay attention to <xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A>, <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>, and <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A> and avoid strings in non-streaming operations.</span></span>

- <span data-ttu-id="b3d6e-234">알려진 형식의 목록을 검토하며 이러한 형식은 언제든지 인스턴스화할 수 있다는 것에 주의합니다. 이 항목 뒷부분의 "의도하지 않은 형식이 로드되는 것을 방지" 단원을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-234">Review the list of known types, keeping in mind that any one of them can be instantiated at any time (see the "Preventing Unintended Types from Being Loaded" section later in this topic).</span></span>

- <span data-ttu-id="b3d6e-235">많은 데이터를 버퍼링하는 <xref:System.Xml.Serialization.IXmlSerializable> 인터페이스를 구현하는 형식을 사용하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-235">Do not use any types that implement the <xref:System.Xml.Serialization.IXmlSerializable> interface that buffer a lot of data.</span></span> <span data-ttu-id="b3d6e-236">이러한 형식을 알려진 형식의 목록에 추가하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-236">Do not add such types to the list of known types.</span></span>

- <span data-ttu-id="b3d6e-237"><xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> 배열, <xref:System.Byte> 배열 또는 계약에서 <xref:System.Runtime.Serialization.ISerializable> 을 구현하는 형식을 사용하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-237">Do not use the <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> arrays, <xref:System.Byte> arrays, or types that implement <xref:System.Runtime.Serialization.ISerializable> in a contract.</span></span>

- <span data-ttu-id="b3d6e-238"><xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> 배열, <xref:System.Byte> 배열 또는 알려진 형식 목록에서 <xref:System.Runtime.Serialization.ISerializable> 을 구현하는 형식을 사용하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-238">Do not use the <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> arrays, <xref:System.Byte> arrays, or types that implement <xref:System.Runtime.Serialization.ISerializable> in the list of known types.</span></span>

<span data-ttu-id="b3d6e-239">위의 주의 사항은 비스트리밍 작업에서 <xref:System.Runtime.Serialization.DataContractSerializer>를 사용하는 경우에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-239">The preceding precautions apply when the non-streamed operation uses the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="b3d6e-240"><xref:System.Xml.Serialization.XmlSerializer>에는 <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.MaxItemsInObjectGraph%2A> 할당량을 보호하는 기능이 없기 때문에 이를 사용하는 경우 같은 서비스에서 스트리밍 및 비스트리밍 프로그래밍 모델을 혼합해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-240">Never mix streaming and non-streaming programming models on the same service if you are using the <xref:System.Xml.Serialization.XmlSerializer>, because it does not have the protection of the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.MaxItemsInObjectGraph%2A> quota.</span></span>

### <a name="slow-stream-attacks"></a><span data-ttu-id="b3d6e-241">느린 스트림 공격</span><span class="sxs-lookup"><span data-stu-id="b3d6e-241">Slow Stream Attacks</span></span>

<span data-ttu-id="b3d6e-242">스트리밍 서비스 거부 공격의 범주에는 메모리 소비가 포함되지 않으며,</span><span class="sxs-lookup"><span data-stu-id="b3d6e-242">A class of streaming denial-of-service attacks does not involve memory consumption.</span></span> <span data-ttu-id="b3d6e-243">대신 느린 데이터 발신자 또는 수신자가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-243">Instead, the attack involves a slow sender or receiver of data.</span></span> <span data-ttu-id="b3d6e-244">데이터를 보내거나 받는 작업을 기다리는 동안 스레드 및 사용 가능한 연결 등의 리소스가 소모됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-244">While waiting for the data to be sent or received, resources such as threads and available connections are exhausted.</span></span> <span data-ttu-id="b3d6e-245">이러한 상황은 악의적인 공격의 결과로 발생하거나 올바른 발신자/수신자의 네트워크 연결이 느린 경우 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-245">This situation could arise either as a result of a malicious attack or from a legitimate sender/receiver on a slow network connection.</span></span>

<span data-ttu-id="b3d6e-246">이러한 공격을 완화하려면 전송 시간 제한을 올바르게 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-246">To mitigate these attacks, set the transport time-outs correctly.</span></span> <span data-ttu-id="b3d6e-247">자세한 내용은 [전송 할당량](transport-quotas.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-247">For more information, see [Transport Quotas](transport-quotas.md).</span></span> <span data-ttu-id="b3d6e-248">둘째로, `Read` `Write` WCF에서 스트림으로 작업할 때 동기 또는 작업을 사용 하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-248">Secondly, never use synchronous `Read` or `Write` operations when working with streams in WCF.</span></span>

## <a name="using-xml-safely"></a><span data-ttu-id="b3d6e-249">안전하게 XML 사용</span><span class="sxs-lookup"><span data-stu-id="b3d6e-249">Using XML Safely</span></span>

> [!NOTE]
> <span data-ttu-id="b3d6e-250">이 단원에서는 XML에 대한 내용을 다루지만 이 정보는 JSON(JavaScript Object Notation) 문서에도 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-250">Although this section is about XML, the information also applies to JavaScript Object Notation (JSON) documents.</span></span> <span data-ttu-id="b3d6e-251">할당량도 [Mapping Between JSON and XML](mapping-between-json-and-xml.md)을 사용하여 비슷하게 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-251">The quotas work similarly, using [Mapping Between JSON and XML](mapping-between-json-and-xml.md).</span></span>

### <a name="secure-xml-readers"></a><span data-ttu-id="b3d6e-252">보안 XML 판독기</span><span class="sxs-lookup"><span data-stu-id="b3d6e-252">Secure XML Readers</span></span>

<span data-ttu-id="b3d6e-253">XML Infoset은 WCF에서 모든 메시지 처리의 기본을 형성 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-253">The XML Infoset forms the basis of all message processing in WCF.</span></span> <span data-ttu-id="b3d6e-254">신뢰할 수 없는 소스로부터 XML 데이터를 받을 경우에는 완화해야 할 여러 가지 서비스 거부 공격이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-254">When accepting XML data from an untrusted source, a number of denial-of-service attack possibilities exist that must be mitigated.</span></span> <span data-ttu-id="b3d6e-255">WCF는 특수 한 보안 XML 판독기를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-255">WCF provides special, secure XML readers.</span></span> <span data-ttu-id="b3d6e-256">이러한 판독기는 WCF의 표준 인코딩 중 하나 (텍스트, 이진 또는 MTOM)를 사용할 때 자동으로 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-256">These readers are created automatically when using one of the standard encodings in WCF (text, binary, or MTOM).</span></span>

<span data-ttu-id="b3d6e-257">이러한 판독기의 보안 기능 중 일부는 항상 활성화되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-257">Some of the security features on these readers are always active.</span></span> <span data-ttu-id="b3d6e-258">예를 들어, 판독기는 서비스 거부 공격의 소스가 될 가능성이 있으므로 올바른 SOAP 메시지에 표시되어서는 안 되는 DTD(문서 종류 정의)를 처리하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-258">For example, the readers never process document type definitions (DTDs), which are a potential source of denial-of-service attacks and should never appear in legitimate SOAP messages.</span></span> <span data-ttu-id="b3d6e-259">다른 보안 기능에는 구성해야 할 판독기 할당량이 포함되며, 이에 대해서는 다음 단원에서 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-259">Other security features include reader quotas that must be configured, which are described in the following section.</span></span>

<span data-ttu-id="b3d6e-260">사용자 지정 인코더를 작성 하거나 클래스로 직접 작업 하는 경우와 같이 XML 판독기에서 직접 작업할 때는 <xref:System.ServiceModel.Channels.Message> 신뢰할 수 없는 데이터로 작업할 가능성이 있는 경우 항상 WCF 보안 판독기를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-260">When working directly with XML readers (such as when writing your own custom encoder or when working directly with the <xref:System.ServiceModel.Channels.Message> class), always use the WCF secure readers when there is a chance of working with untrusted data.</span></span> <span data-ttu-id="b3d6e-261"><xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>클래스에 있는 <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> 또는 <xref:System.Xml.XmlDictionaryReader> 의 정적 팩터리 메서드 오버로드 중 하나를 호출하여 보안 판독기를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-261">Create the secure readers by calling one of the static factory method overloads of <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>, or <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> on the <xref:System.Xml.XmlDictionaryReader> class.</span></span> <span data-ttu-id="b3d6e-262">판독기를 만들 때 보안 할당량 값을 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-262">When creating a reader, pass in secure quota values.</span></span> <span data-ttu-id="b3d6e-263">`Create` 메서드 오버로드를 호출하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-263">Do not call the `Create` method overloads.</span></span> <span data-ttu-id="b3d6e-264">WCF 판독기는 만들지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-264">These do not create a WCF reader.</span></span> <span data-ttu-id="b3d6e-265">대신 이 단원에서 설명한 보안 기능으로 보호되지 않는 판독기를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-265">Instead, a reader is created that is not protected by the security features described in this section.</span></span>

### <a name="reader-quotas"></a><span data-ttu-id="b3d6e-266">판독기 할당량</span><span class="sxs-lookup"><span data-stu-id="b3d6e-266">Reader Quotas</span></span>

<span data-ttu-id="b3d6e-267">보안 XML 판독기에는 5개의 구성 가능한 할당량이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-267">The secure XML readers have five configurable quotas.</span></span> <span data-ttu-id="b3d6e-268">일반적으로 이러한 할당량은 인코딩 바인딩 요소 또는 표준 바인딩에서 `ReaderQuotas` 속성을 사용하거나 판독기를 만들 때 전달된 <xref:System.Xml.XmlDictionaryReaderQuotas> 개체를 사용하여 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-268">These are normally configured using the `ReaderQuotas` property on the encoding binding elements or standard bindings, or by using an <xref:System.Xml.XmlDictionaryReaderQuotas> object passed when creating a reader.</span></span>

#### <a name="maxbytesperread"></a><span data-ttu-id="b3d6e-269">MaxBytesPerRead</span><span class="sxs-lookup"><span data-stu-id="b3d6e-269">MaxBytesPerRead</span></span>

<span data-ttu-id="b3d6e-270">이 할당량은 요소 시작 태그와 해당 특성을 읽을 때 단일 `Read` 작업에서 읽는 바이트 수를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-270">This quota limits the number of bytes that are read in a single `Read` operation when reading the element start tag and its attributes.</span></span> <span data-ttu-id="b3d6e-271">비스트리밍 작업의 경우 요소 이름 자체는 할당량 계산에서 제외됩니다. <xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A> 가 중요한 이유는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-271">(In non-streamed cases, the element name itself is not counted against the quota.) <xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A> is important for the following reasons:</span></span>

- <span data-ttu-id="b3d6e-272">요소 이름과 해당 특성은 읽을 때 항상 메모리에 버퍼링됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-272">The element name and its attributes are always buffered in memory when they are being read.</span></span> <span data-ttu-id="b3d6e-273">따라서 스트리밍이 예상되는 경우에 스트리밍 모드에서 과다한 버퍼링이 일어나는 것을 방지하려면 이 할당량을 올바르게 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-273">Therefore, it is important to set this quota correctly in streaming mode to prevent excessive buffering when streaming is expected.</span></span> <span data-ttu-id="b3d6e-274">발생하는 실제 버퍼링 크기에 대한 자세한 내용은 `MaxDepth` 할당량 단원을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-274">See the `MaxDepth` quota section for information about the actual amount of buffering that takes place.</span></span>

- <span data-ttu-id="b3d6e-275">XML 특성이 너무 많으면 특성 이름의 고유성을 확인해야 하기 때문에 처리 시간이 과도하게 오래 걸릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-275">Having too many XML attributes may use up disproportionate processing time because attribute names have to be checked for uniqueness.</span></span> <span data-ttu-id="b3d6e-276">`MaxBytesPerRead` 는 이 위협을 완화합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-276">`MaxBytesPerRead` mitigates this threat.</span></span>

#### <a name="maxdepth"></a><span data-ttu-id="b3d6e-277">MaxDepth</span><span class="sxs-lookup"><span data-stu-id="b3d6e-277">MaxDepth</span></span>

<span data-ttu-id="b3d6e-278">이 할당량은 XML 요소의 최대 중첩 깊이를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-278">This quota limits the maximum nesting depth of XML elements.</span></span> <span data-ttu-id="b3d6e-279">예를 들어 문서 " \<A> \<B> \<C/> \</B> \</A> "의 중첩 깊이가 3입니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-279">For example, the document "\<A>\<B>\<C/>\</B>\</A>" has a nesting depth of three.</span></span> <span data-ttu-id="b3d6e-280"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A> 가 중요한 이유는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-280"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A> is important for the following reasons:</span></span>

- <span data-ttu-id="b3d6e-281">`MaxDepth` 는 `MaxBytesPerRead`와 상호 작용합니다. 판독기는 항상 현재 요소와 모든 상위 요소의 데이터를 메모리에 유지하기 때문에 판독기의 최대 메모리 소비량은 이 두 설정을 곱한 값에 비례합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-281">`MaxDepth` interacts with `MaxBytesPerRead`: the reader always keeps data in memory for the current element and all of its ancestors, so the maximum memory consumption of the reader is proportional to the product of these two settings.</span></span>

- <span data-ttu-id="b3d6e-282">여러 층으로 중첩된 개체 그래프를 역직렬화할 때 역직렬 변환기가 전체 스택에 액세스하여 복구할 수 없는 <xref:System.StackOverflowException>이 throw될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-282">When deserializing a deeply-nested object graph, the deserializer is forced to access the entire stack and throw an unrecoverable <xref:System.StackOverflowException>.</span></span> <span data-ttu-id="b3d6e-283">XML 중첩과 <xref:System.Runtime.Serialization.DataContractSerializer> 및 <xref:System.Xml.Serialization.XmlSerializer>모두의 개체 중첩 사이에는 직접적인 상관 관계가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-283">A direct correlation exists between XML nesting and object nesting for both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="b3d6e-284">`MaxDepth` 를 사용하면 이 위협을 완화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-284">Use `MaxDepth` to mitigate this threat.</span></span>

#### <a name="maxnametablecharcount"></a><span data-ttu-id="b3d6e-285">MaxNameTableCharCount</span><span class="sxs-lookup"><span data-stu-id="b3d6e-285">MaxNameTableCharCount</span></span>

<span data-ttu-id="b3d6e-286">이 할당량은 판독기의 *nametable*크기를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-286">This quota limits the size of the reader’s *nametable*.</span></span> <span data-ttu-id="b3d6e-287">nametable에는 XML 문서를 처리할 때 표시되는 특정 문자열(예: 네임스페이스 및 접두사)이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-287">The nametable contains certain strings (such as namespaces and prefixes) that are encountered when processing an XML document.</span></span> <span data-ttu-id="b3d6e-288">이러한 문자열은 메모리에 버퍼링되기 때문에 스트리밍이 예상되는 경우 과도한 버퍼링을 방지하려면 이 할당량을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-288">As these strings are buffered in memory, set this quota to prevent excessive buffering when streaming is expected.</span></span>

#### <a name="maxstringcontentlength"></a><span data-ttu-id="b3d6e-289">MaxStringContentLength</span><span class="sxs-lookup"><span data-stu-id="b3d6e-289">MaxStringContentLength</span></span>

<span data-ttu-id="b3d6e-290">이 할당량은 XML 판독기에서 반환하는 최대 문자열 크기를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-290">This quota limits the maximum string size that the XML reader returns.</span></span> <span data-ttu-id="b3d6e-291">이 할당량은 XML 판독기 자체에서는 메모리 소비량을 제한하지 않지만 판독기를 사용하는 구성 요소의 메모리 소비량을 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-291">This quota does not limit memory consumption in the XML reader itself, but in the component that is using the reader.</span></span> <span data-ttu-id="b3d6e-292">예를 들어, <xref:System.Runtime.Serialization.DataContractSerializer> 가 <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>로 보안이 설정된 판독기를 사용하는 경우에는 이 할당량보다 큰 문자열을 역직렬화하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-292">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> uses a reader secured with <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>, it does not deserialize strings larger than this quota.</span></span> <span data-ttu-id="b3d6e-293"><xref:System.Xml.XmlDictionaryReader> 클래스를 직접 사용할 경우 일부 메서드는 이 할당량을 준수하지 않으며 문자열을 읽도록 특별히 설계된 메서드(예: <xref:System.Xml.XmlDictionaryReader.ReadContentAsString%2A> 메서드)만 이 할당량을 준수합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-293">When using the <xref:System.Xml.XmlDictionaryReader> class directly, not all methods respect this quota, but only the methods that are specifically designed to read strings, such as the <xref:System.Xml.XmlDictionaryReader.ReadContentAsString%2A> method.</span></span> <span data-ttu-id="b3d6e-294">판독기에 대한 <xref:System.Xml.XmlReader.Value%2A> 속성은 이 할당량의 영향을 받지 않기 때문에 이 할당량이 제공하는 보호가 필요한 경우에는 사용해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-294">The <xref:System.Xml.XmlReader.Value%2A> property on the reader is not affected by this quota, and thus should not be used when the protection this quota provides is necessary.</span></span>

#### <a name="maxarraylength"></a><span data-ttu-id="b3d6e-295">MaxArrayLength</span><span class="sxs-lookup"><span data-stu-id="b3d6e-295">MaxArrayLength</span></span>

<span data-ttu-id="b3d6e-296">이 할당량은 바이트 배열을 포함하여 XML 판독기가 반환하는 기본 형식 배열의 최대 크기를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-296">This quota limits the maximum size of an array of primitives that the XML reader returns, including byte arrays.</span></span> <span data-ttu-id="b3d6e-297">이 할당량은 XML 판독기 자체의 메모리 소비량은 제한하지 않지만 판독기를 사용하는 모든 구성 요소의 메모리 소비량을 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-297">This quota does not limit memory consumption in the XML reader itself, but in whatever component that is using the reader.</span></span> <span data-ttu-id="b3d6e-298">예를 들어, <xref:System.Runtime.Serialization.DataContractSerializer> 가 <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A>로 보안이 설정된 판독기를 사용하는 경우에는 이 할당량보다 큰 바이트 배열을 역직렬화하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-298">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> uses a reader secured with <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A>, it does not deserialize byte arrays larger than this quota.</span></span> <span data-ttu-id="b3d6e-299">단일 계약에서 스트리밍 및 버퍼링 프로그래밍 모델을 혼합하려는 경우에는 이 할당량을 설정하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-299">It is important to set this quota when attempting to mix streaming and buffered programming models in a single contract.</span></span> <span data-ttu-id="b3d6e-300"><xref:System.Xml.XmlDictionaryReader> 클래스를 직접 사용하는 경우에는 특정 기본 형식의 배열을 크기에 관계없이 읽도록 특별히 설계된 메서드(예: <xref:System.Xml.XmlDictionaryReader.ReadInt32Array%2A>)만 이 할당량을 준수합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-300">Keep in mind that when using the <xref:System.Xml.XmlDictionaryReader> class directly, only the methods that are specifically designed to read arrays of arbitrary size of certain primitive types, such as <xref:System.Xml.XmlDictionaryReader.ReadInt32Array%2A>, respect this quota.</span></span>

## <a name="threats-specific-to-the-binary-encoding"></a><span data-ttu-id="b3d6e-301">이진 인코딩과 관련된 위협</span><span class="sxs-lookup"><span data-stu-id="b3d6e-301">Threats Specific to the Binary Encoding</span></span>

<span data-ttu-id="b3d6e-302">WCF에서 지 원하는 이진 XML 인코딩에는 *사전 문자열* 기능이 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-302">The binary XML encoding WCF supports includes a *dictionary strings* feature.</span></span> <span data-ttu-id="b3d6e-303">큰 문자열을 몇 바이트만 사용하여 인코딩할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-303">A large string may be encoded using only a few bytes.</span></span> <span data-ttu-id="b3d6e-304">이렇게 하면 성능은 크게 향상되지만 완화해야 할 새로운 서비스 거부 위협이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-304">This enables significant performance gains, but introduces new denial-of-service threats that must be mitigated.</span></span>

<span data-ttu-id="b3d6e-305">사전에는 *정적* 사전과 *동적*사전의 두 가지 종류가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-305">There are two kinds of dictionaries: *static* and *dynamic*.</span></span> <span data-ttu-id="b3d6e-306">정적 사전은 이진 인코딩에서 짧은 코드로 표현할 수 있는 긴 문자열이 포함된 기본 제공 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-306">The static dictionary is a built-in list of long strings that may be represented using a short code in the binary encoding.</span></span> <span data-ttu-id="b3d6e-307">이 문자열 목록은 판독기를 만들 때 고정되며 수정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-307">This list of strings is fixed when the reader is created and cannot be modified.</span></span> <span data-ttu-id="b3d6e-308">WCF가 기본적으로 사용 하는 정적 사전의 문자열은 매우 크기 때문에 심각한 서비스 거부 위협을 야기할 수 있습니다. 하지만이는 사전 확장 공격에 사용 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-308">None of the strings in the static dictionary that WCF uses by default are sufficiently large to pose a serious denial-of-service threat, although they may still be used in a dictionary expansion attack.</span></span> <span data-ttu-id="b3d6e-309">사용자가 직접 정적 사전을 제공하는 고급 시나리오에서 큰 사전 문자열을 사용하는 경우에는 특히 주의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-309">In advanced scenarios where you supply your own static dictionary, be careful when introducing large dictionary strings.</span></span>

<span data-ttu-id="b3d6e-310">동적 사전 기능을 통해 메시지에서 직접 문자열을 정의하고 짧은 코드에 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-310">The dynamic dictionaries feature allows messages to define their own strings and associate them with short codes.</span></span> <span data-ttu-id="b3d6e-311">문자열과 코드 사이의 이러한 매핑은 그 뒤의 메시지에서 문자열을 다시 보낼 필요 없이 이미 정의된 코드를 활용할 수 있도록 전체 통신 세션 동안 메모리에 보존됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-311">These string-to-code mappings are kept in memory during the entire communication session, such that subsequent messages do not have to resend the strings and can utilize codes that are already defined.</span></span> <span data-ttu-id="b3d6e-312">이러한 문자열의 길이는 임의로 지정되기 때문에 정적 사전에 사용되는 것보다 큰 위협을 야기할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-312">These strings may be of arbitrary length and thus pose a more serious threat than those in the static dictionary.</span></span>

<span data-ttu-id="b3d6e-313">완화가 필요한 첫 번째 위협은 동적 사전(문자열과 코드 사이의 매핑 테이블)이 너무 커질 가능성입니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-313">The first threat that must be mitigated is the possibility of the dynamic dictionary (the string-to-code mapping table) becoming too large.</span></span> <span data-ttu-id="b3d6e-314">이 사전은 여러 메시지에 걸쳐 확장될 수 있기 때문에 각 메시지에만 별도로 적용되는 `MaxReceivedMessageSize` 할당량으로 보호할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-314">This dictionary may be expanded over the course of several messages, and so the `MaxReceivedMessageSize` quota offers no protection because it applies only to each message separately.</span></span> <span data-ttu-id="b3d6e-315">따라서 <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> 에 사전의 크기를 제한하는 별도의 <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> 속성이 존재합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-315">Therefore, a separate <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> property exists on the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> that limits the size of the dictionary.</span></span>

<span data-ttu-id="b3d6e-316">대부분의 다른 할당량과 달리, 이 할당량은 메시지를 쓸 때에도 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-316">Unlike most other quotas, this quota also applies when writing messages.</span></span> <span data-ttu-id="b3d6e-317">메시지를 읽는 동안 할당량이 초과되면 일반적인 경우와 마찬가지로 `QuotaExceededException` 이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-317">If it is exceeded when reading a message, the `QuotaExceededException` is thrown as usual.</span></span> <span data-ttu-id="b3d6e-318">메시지를 쓰는 동안 할당량이 초과되면 할당량을 초과하는 모든 문자열은 동적 사전 기능을 사용하지 않고 그대로 작성됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-318">If it is exceeded when writing a message, any strings that cause the quota to be exceeded are written as-is, without using the dynamic dictionaries feature.</span></span>

### <a name="dictionary-expansion-threats"></a><span data-ttu-id="b3d6e-319">사전 확장 위협</span><span class="sxs-lookup"><span data-stu-id="b3d6e-319">Dictionary Expansion Threats</span></span>

<span data-ttu-id="b3d6e-320">사전 확장으로부터 심각한 이진 관련 공격이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-320">A significant class of binary-specific attacks arises from dictionary expansion.</span></span> <span data-ttu-id="b3d6e-321">문자열 사전 기능을 본격적으로 사용하는 경우에는 작은 이진 형식이 완전히 확장된 텍스트 형식에서 매우 큰 메시지로 바뀔 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-321">A small message in binary form may turn into a very large message in fully expanded textual form if it makes extensive use of the string dictionaries feature.</span></span> <span data-ttu-id="b3d6e-322">동적 사전 문자열의 확장 비율은 동적 사전 문자열이 전체 사전의 최대 크기를 초과하지 않도록 <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> 할당량에 의해 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-322">The expansion factor for dynamic dictionary strings is limited by the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> quota, because no dynamic dictionary string exceeds the maximum size of the entire dictionary.</span></span>

<span data-ttu-id="b3d6e-323"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxNameTableCharCount%2A>, `MaxStringContentLength`및 `MaxArrayLength` 속성은 메모리 소비만 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-323">The <xref:System.Xml.XmlDictionaryReaderQuotas.MaxNameTableCharCount%2A>, `MaxStringContentLength`, and `MaxArrayLength` properties only limit memory consumption.</span></span> <span data-ttu-id="b3d6e-324">보통은 메모리 사용이 이미 `MaxReceivedMessageSize`에 의해 제한되기 때문에 스트리밍을 사용하지 않는 경우 따로 위협을 완화할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-324">They are normally not required to mitigate any threats in the non-streamed usage because memory usage is already limited by `MaxReceivedMessageSize`.</span></span> <span data-ttu-id="b3d6e-325">그러나 `MaxReceivedMessageSize` 에서는 확장 전의 바이트 수를 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-325">However, `MaxReceivedMessageSize` counts pre-expansion bytes.</span></span> <span data-ttu-id="b3d6e-326">이진 인코딩을 사용할 때 메모리 소비는 `MaxReceivedMessageSize`를 초과할 수 있으며 <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A>비율로만 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-326">When binary encoding is in use, memory consumption could potentially go beyond `MaxReceivedMessageSize`, limited only by a factor of <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A>.</span></span> <span data-ttu-id="b3d6e-327">따라서 이진 인코딩을 사용하는 경우에는 항상 모든 판독기 할당량(특히 <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>)을 설정하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-327">For this reason, it is important to always set all of the reader quotas (especially <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>) when using the binary encoding.</span></span>

<span data-ttu-id="b3d6e-328">이진 인코딩을 <xref:System.Runtime.Serialization.DataContractSerializer>와 함께 사용할 때 `IExtensibleDataObject` 인터페이스를 사전 확장 공격에 악용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-328">When using binary encoding together with the <xref:System.Runtime.Serialization.DataContractSerializer>, the `IExtensibleDataObject` interface can be misused to mount a dictionary expansion attack.</span></span> <span data-ttu-id="b3d6e-329">이 인터페이스는 기본적으로 계약에 속해 있지 않은 임의의 데이터에 무제한의 스토리지를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-329">This interface essentially provides unlimited storage for arbitrary data that is not a part of the contract.</span></span> <span data-ttu-id="b3d6e-330">`MaxSessionSize` 와 `MaxReceivedMessageSize` 를 곱한 값이 문제를 야기하지 않을 정도로 낮은 할당량을 설정한 경우에는 이진 인코딩을 사용할 때 `IExtensibleDataObject` 기능을 비활성화합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-330">If quotas cannot be set low enough such that `MaxSessionSize` multiplied by `MaxReceivedMessageSize` does not pose a problem, disable the `IExtensibleDataObject` feature when using the binary encoding.</span></span> <span data-ttu-id="b3d6e-331">`IgnoreExtensionDataObject` 특성에서 `true` 속성을 `ServiceBehaviorAttribute` 로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-331">Set the `IgnoreExtensionDataObject` property to `true` on the `ServiceBehaviorAttribute` attribute.</span></span> <span data-ttu-id="b3d6e-332">또는 `IExtensibleDataObject` 인터페이스를 구현하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-332">Alternatively, do not implement the `IExtensibleDataObject` interface.</span></span> <span data-ttu-id="b3d6e-333">자세한 내용은 [호환 가능한 데이터 계약](forward-compatible-data-contracts.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-333">For more information, see [Forward-Compatible Data Contracts](forward-compatible-data-contracts.md).</span></span>

### <a name="quotas-summary"></a><span data-ttu-id="b3d6e-334">할당량 요약</span><span class="sxs-lookup"><span data-stu-id="b3d6e-334">Quotas Summary</span></span>

<span data-ttu-id="b3d6e-335">다음 표에는 할당량에 대한 지침이 요약되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-335">The following table summarizes the guidance about quotas.</span></span>

|<span data-ttu-id="b3d6e-336">조건</span><span class="sxs-lookup"><span data-stu-id="b3d6e-336">Condition</span></span>|<span data-ttu-id="b3d6e-337">설정할 중요 할당량</span><span class="sxs-lookup"><span data-stu-id="b3d6e-337">Important quotas to set</span></span>|
|---------------|-----------------------------|
|<span data-ttu-id="b3d6e-338">스트리밍 없음이나 작은 메시지 스트리밍, 텍스트 또는 MTOM 인코딩</span><span class="sxs-lookup"><span data-stu-id="b3d6e-338">No streaming or streaming small messages, text, or MTOM encoding</span></span>|<span data-ttu-id="b3d6e-339">`MaxReceivedMessageSize`, `MaxBytesPerRead`, `MaxDepth`</span><span class="sxs-lookup"><span data-stu-id="b3d6e-339">`MaxReceivedMessageSize`, `MaxBytesPerRead`, and `MaxDepth`</span></span>|
|<span data-ttu-id="b3d6e-340">스트리밍 없음이나 작은 메시지 스트리밍, 이진 인코딩</span><span class="sxs-lookup"><span data-stu-id="b3d6e-340">No streaming or streaming small messages, binary encoding</span></span>|<span data-ttu-id="b3d6e-341">`MaxReceivedMessageSize`, `MaxSessionSize`및 모든 `ReaderQuotas`</span><span class="sxs-lookup"><span data-stu-id="b3d6e-341">`MaxReceivedMessageSize`, `MaxSessionSize`, and all `ReaderQuotas`</span></span>|
|<span data-ttu-id="b3d6e-342">큰 메시지 스트리밍, 텍스트 또는 MTOM 인코딩</span><span class="sxs-lookup"><span data-stu-id="b3d6e-342">Streaming large messages, text, or MTOM encoding</span></span>|<span data-ttu-id="b3d6e-343">`MaxBufferSize` 및 모든 `ReaderQuotas`</span><span class="sxs-lookup"><span data-stu-id="b3d6e-343">`MaxBufferSize` and all `ReaderQuotas`</span></span>|
|<span data-ttu-id="b3d6e-344">큰 메시지 스트리밍, 이진 인코딩</span><span class="sxs-lookup"><span data-stu-id="b3d6e-344">Streaming large messages, binary encoding</span></span>|<span data-ttu-id="b3d6e-345">`MaxBufferSize`, `MaxSessionSize`및 모든 `ReaderQuotas`</span><span class="sxs-lookup"><span data-stu-id="b3d6e-345">`MaxBufferSize`, `MaxSessionSize`, and all `ReaderQuotas`</span></span>|

- <span data-ttu-id="b3d6e-346">스트리밍을 사용하는 경우에는 큰 메시지나 작은 메시지를 스트리밍하는지에 관계없이 항상 전송 수준 시간 제한을 설정하고 동시 읽기/쓰기를 사용하지 말아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-346">Transport-level time-outs must always be set and never use synchronous reads/writes when streaming is in use, regardless of whether you are streaming large or small messages.</span></span>

- <span data-ttu-id="b3d6e-347">할당량을 정하기 어려울 때는 개방적으로 놓아두지 말고 안전한 값을 설정하십시오.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-347">When in doubt about a quota, set it to a safe value rather than leaving it open.</span></span>

## <a name="preventing-malicious-code-execution"></a><span data-ttu-id="b3d6e-348">악의적인 코드 실행 방지</span><span class="sxs-lookup"><span data-stu-id="b3d6e-348">Preventing Malicious Code Execution</span></span>

<span data-ttu-id="b3d6e-349">다음 일반 위협 클래스에서는 코드를 실행하여 의도하지 않은 결과를 일으킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-349">The following general classes of threats can execute code and have unintended effects:</span></span>

- <span data-ttu-id="b3d6e-350">역직렬 변환기가 악의적이거나, 안전하지 않거나, 보안과 관련된 형식을 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-350">The deserializer loads a malicious, unsafe, or security-sensitive type.</span></span>

- <span data-ttu-id="b3d6e-351">들어오는 메시지에서는 역직렬 변환기에 대해 일반적으로는 안전한 형식의 인스턴스가 의도하지 않은 결과를 일으키도록 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-351">An incoming message causes the deserializer to construct an instance of a normally safe type in such a way that it has unintended consequences.</span></span>

<span data-ttu-id="b3d6e-352">다음 단원에서는 이러한 위협에 대해 자세히 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-352">The following sections discuss these classes of threats further.</span></span>

## <a name="datacontractserializer"></a><span data-ttu-id="b3d6e-353">DataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="b3d6e-353">DataContractSerializer</span></span>

<span data-ttu-id="b3d6e-354">에 대 한 보안 정보는 <xref:System.Xml.Serialization.XmlSerializer> 관련 설명서를 참조 하십시오. 의 보안 모델은의 경우와 <xref:System.Xml.Serialization.XmlSerializer> 비슷하며 <xref:System.Runtime.Serialization.DataContractSerializer> 주로 세부 정보에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-354">(For security information on the <xref:System.Xml.Serialization.XmlSerializer>, see the relevant documentation.) The security model for the <xref:System.Xml.Serialization.XmlSerializer> is similar to that of the <xref:System.Runtime.Serialization.DataContractSerializer>, and differs mostly in details.</span></span> <span data-ttu-id="b3d6e-355">예를 들어, <xref:System.Xml.Serialization.XmlIncludeAttribute> 특성은 <xref:System.Runtime.Serialization.KnownTypeAttribute> 특성 대신 형식 포함에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-355">For example, the <xref:System.Xml.Serialization.XmlIncludeAttribute> attribute is used for type inclusion instead of the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute.</span></span> <span data-ttu-id="b3d6e-356">그러나 <xref:System.Xml.Serialization.XmlSerializer> 의 고유한 위협 몇 가지에 대해서는 이 항목의 뒷부분에서 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-356">However, some threats unique to the <xref:System.Xml.Serialization.XmlSerializer> are discussed later in this topic.</span></span>

### <a name="preventing-unintended-types-from-being-loaded"></a><span data-ttu-id="b3d6e-357">의도하지 않은 형식이 로드되는 것을 방지</span><span class="sxs-lookup"><span data-stu-id="b3d6e-357">Preventing Unintended Types from Being Loaded</span></span>

<span data-ttu-id="b3d6e-358">형식이 악의적이든, 보안 관련 부작용이 있을 뿐이든지에 관계없이 의도하지 않은 형식을 로드하면 심각한 결과가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-358">Loading unintended types may have significant consequences, whether the type is malicious or just has security-sensitive side effects.</span></span> <span data-ttu-id="b3d6e-359">형식에 악용할 수 있는 보안 취약성이 포함되어 있거나, 생성자 또는 클래스 생성자에서 보안 관련 작업을 수행하거나, 메모리 사용량이 커서 서비스 거부 공격을 일으키거나, 복구할 수 없는 예외를 throw할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-359">A type may contain exploitable security vulnerability, perform security-sensitive actions in its constructor or class constructor, have a large memory footprint that facilitates denial-of-service attacks, or may throw non-recoverable exceptions.</span></span> <span data-ttu-id="b3d6e-360">형식에는 형식이 로드되면 인스턴스가 만들어지기 전에 바로 실행되는 클래스 생성자가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-360">Types may have class constructors that run as soon as the type is loaded and before any instances are created.</span></span> <span data-ttu-id="b3d6e-361">그렇기 때문에 역직렬 변환기에서 로드할 수 있는 형식 집합을 제어하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-361">For these reasons, it is important to control the set of types that the deserializer may load.</span></span>

<span data-ttu-id="b3d6e-362"><xref:System.Runtime.Serialization.DataContractSerializer> 는 느슨하게 결합된 방식으로 역직렬화됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-362">The <xref:System.Runtime.Serialization.DataContractSerializer> deserializes in a loosely coupled way.</span></span> <span data-ttu-id="b3d6e-363">여기서는 들어오는 데이터로부터 CLR(공용 언어 런타임) 형식과 어셈블리 이름을 읽지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-363">It never reads common language runtime (CLR) type and assembly names from the incoming data.</span></span> <span data-ttu-id="b3d6e-364">이는 <xref:System.Xml.Serialization.XmlSerializer>의 동작과 비슷하지만 <xref:System.Runtime.Serialization.NetDataContractSerializer>, <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>및 <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>의 동작과는 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-364">This is similar to the behavior of the <xref:System.Xml.Serialization.XmlSerializer>, but differs from the behavior of the <xref:System.Runtime.Serialization.NetDataContractSerializer>, <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>, and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>.</span></span> <span data-ttu-id="b3d6e-365">느슨한 결합에서는 원격 공격자가 임의의 형식을 이용하여 메시지에 형식 이름을 지정하는 것만으로 로드되도록 할 수 없기 때문에 어느 정도 안전을 강화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-365">Loose coupling introduces a degree of safety, because the remote attacker cannot indicate an arbitrary type to load just by naming that type in the message.</span></span>

<span data-ttu-id="b3d6e-366"><xref:System.Runtime.Serialization.DataContractSerializer> 에서는 항상 현재 계약에 따라 예상되는 형식을 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-366">The <xref:System.Runtime.Serialization.DataContractSerializer> is always allowed to load a type that is currently expected according to the contract.</span></span> <span data-ttu-id="b3d6e-367">예를 들어, 데이터 계약에 `Customer`형식의 데이터 멤버가 있으면 <xref:System.Runtime.Serialization.DataContractSerializer> 에서 이 데이터 멤버를 역직렬화할 때 `Customer` 형식을 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-367">For example, if a data contract has a data member of type `Customer`, the <xref:System.Runtime.Serialization.DataContractSerializer> is allowed to load the `Customer` type when it deserializes this data member.</span></span>

<span data-ttu-id="b3d6e-368">또한 <xref:System.Runtime.Serialization.DataContractSerializer> 에서는 다형성을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-368">Additionally, the <xref:System.Runtime.Serialization.DataContractSerializer> supports polymorphism.</span></span> <span data-ttu-id="b3d6e-369">데이터 멤버를 <xref:System.Object>로 선언할 수 있지만 들어오는 데이터에 `Customer` 인스턴스가 포함될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-369">A data member may be declared as <xref:System.Object>, but the incoming data may contain a `Customer` instance.</span></span> <span data-ttu-id="b3d6e-370">이는 다음 메커니즘 중 하나를 통해 역직렬 변환기에 `Customer` 형식이 "알려진" 경우에만 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-370">This is possible only if the `Customer` type has been made "known" to the deserializer through one of these mechanisms:</span></span>

- <span data-ttu-id="b3d6e-371">형식에 적용되는<xref:System.Runtime.Serialization.KnownTypeAttribute> 특성.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-371"><xref:System.Runtime.Serialization.KnownTypeAttribute> attribute applied to a type.</span></span>

- <span data-ttu-id="b3d6e-372">형식 목록을 반환하는 메서드를 지정하는`KnownTypeAttribute` 특성.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-372">`KnownTypeAttribute` attribute specifying a method that returns a list of types.</span></span>

- <span data-ttu-id="b3d6e-373">`ServiceKnownTypeAttribute` 특성.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-373">`ServiceKnownTypeAttribute` attribute.</span></span>

- <span data-ttu-id="b3d6e-374">`KnownTypes` 구성 섹션.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-374">The `KnownTypes` configuration section.</span></span>

- <span data-ttu-id="b3d6e-375">serializer를 직접 사용하는 경우에는 알려진 형식 목록이 생성 중에 <xref:System.Runtime.Serialization.DataContractSerializer> 에 명시적으로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-375">A list of known types explicitly passed to the <xref:System.Runtime.Serialization.DataContractSerializer> during construction, if using the serializer directly.</span></span>

<span data-ttu-id="b3d6e-376">이러한 각 메커니즘은 역직렬 변환기에서 로드할 수 있는 형식을 더 추가하여 노출 영역을 넓힙니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-376">Each of these mechanisms increases the surface area by introducing more types that the deserializer can load.</span></span> <span data-ttu-id="b3d6e-377">알려진 형식 목록에 악의적이거나 의도하지 않은 형식이 추가되지 않도록 이러한 각각의 메커니즘을 제어해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-377">Control each of these mechanisms to ensure no malicious or unintended types are added to the known types list.</span></span>

<span data-ttu-id="b3d6e-378">알려진 형식이 범위 내에 있으면 계약에서 실제로 사용이 금지되어 있는 경우에도 언제든지 로드하고 형식의 인스턴스를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-378">Once a known type is in scope, it can be loaded at any time, and instances of the type can be created, even if the contract forbids actually using it.</span></span> <span data-ttu-id="b3d6e-379">예를 들어, 위 메커니즘 중 하나를 사용하여 알려진 형식 목록에 "MyDangerousType" 형식을 추가하는 경우를 가정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-379">For example, suppose the type "MyDangerousType" is added to the known types list using one of the mechanisms above.</span></span> <span data-ttu-id="b3d6e-380">이는 다음을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-380">This means that:</span></span>

- <span data-ttu-id="b3d6e-381">`MyDangerousType` 이 로드되고 클래스 생성자가 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-381">`MyDangerousType` is loaded and its class constructor runs.</span></span>

- <span data-ttu-id="b3d6e-382">문자열 데이터 멤버가 있는 데이터 계약을 역직렬화하는 경우에도 악의적인 메시지로 인해 `MyDangerousType` 인스턴스가 만들어질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-382">Even when deserializing a data contract with a string data member, a malicious message may still cause an instance of `MyDangerousType` to create.</span></span> <span data-ttu-id="b3d6e-383">속성 setter와 같은 `MyDangerousType`내의 코드가 실행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-383">Code in `MyDangerousType`, such as property setters, may run.</span></span> <span data-ttu-id="b3d6e-384">그러고 나면 역직렬 변환기에서 이 인스턴스를 문자열 데이터 멤버에 할당하려고 하고 실패하며 예외를 일으킵니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-384">After this is done, the deserializer tries to assign this instance to the string data member and fail with an exception.</span></span>

<span data-ttu-id="b3d6e-385">알려진 형식 목록을 반환하는 메서드를 쓰거나 <xref:System.Runtime.Serialization.DataContractSerializer> 생성자에 직접 목록을 전달할 때는 목록을 준비하는 코드가 안전하며 신뢰할 수 있는 데이터만 다루는지 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-385">When writing a method that returns a list of known types, or when passing a list directly to the <xref:System.Runtime.Serialization.DataContractSerializer> constructor, ensure that the code that prepares the list is secure and operates only on trusted data.</span></span>

<span data-ttu-id="b3d6e-386">구성에 알려진 형식을 지정하는 경우에는 구성 파일이 안전한지 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-386">If specifying known types in configuration, ensure that the configuration file is secure.</span></span> <span data-ttu-id="b3d6e-387">구성에는 항상 강력한 이름을 사용하되(형식이 상주하는 서명된 어셈블리의 공개 키 지정) 로드할 형식의 버전은 지정하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-387">Always use strong names in configuration (by specifying the public key of the signed assembly where the type resides), but do not specify the version of the type to load.</span></span> <span data-ttu-id="b3d6e-388">가능한 경우에는 형식 로더에서 자동으로 최신 버전을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-388">The type loader automatically picks the latest version, if possible.</span></span> <span data-ttu-id="b3d6e-389">구성에서 특정 버전을 지정하면, 형식에 이후 버전에서 수정이 가능한 보안 취약성이 있지만 버전이 구성에 명시적으로 지정되어 있기 때문에 여전히 취약한 버전을 로드할 위험성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-389">If you specify a particular version in configuration, you run the following risk: A type may have a security vulnerability that may be fixed in a future version, but the vulnerable version still loads because it is explicitly specified in configuration.</span></span>

<span data-ttu-id="b3d6e-390">알려진 형식이 너무 많으면 또 다른 결과가 발생할 수 있습니다. <xref:System.Runtime.Serialization.DataContractSerializer> 가 직렬화 또는 역직렬화해야 하는 각 형식의 항목과 함께 serialization/deserialization 코드의 캐시를 애플리케이션 도메인에 만들기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-390">Having too many known types has another consequence: The <xref:System.Runtime.Serialization.DataContractSerializer> creates a cache of serialization/deserialization code in the application domain, with an entry for each type it must serialize and deserialize.</span></span> <span data-ttu-id="b3d6e-391">애플리케이션 도메인이 실행되고 있는 동안에는 이 캐시를 결코 지울 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-391">This cache is never cleared as long as the application domain is running.</span></span> <span data-ttu-id="b3d6e-392">따라서 애플리케이션에 사용되는 알려진 형식이 많다는 것을 알고 있는 공격자는 이 모든 형식을 역직렬화하여 캐시에 과도한 메모리가 사용되게 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-392">Therefore, an attacker who is aware that an application uses many known types can cause the deserialization of all these types, causing the cache to consume a disproportionately large amount of memory.</span></span>

### <a name="preventing-types-from-being-in-an-unintended-state"></a><span data-ttu-id="b3d6e-393">형식이 의도하지 않은 상태가 되는 것을 방지</span><span class="sxs-lookup"><span data-stu-id="b3d6e-393">Preventing Types from Being in an Unintended State</span></span>

<span data-ttu-id="b3d6e-394">형식에 적용해야 할 내부 일관성 제약 조건이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-394">A type may have internal consistency constraints that must be enforced.</span></span> <span data-ttu-id="b3d6e-395">deserialization 중에 이러한 제약 조건을 무시하지 않도록 주의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-395">Care must be taken to avoid breaking these constraints during deserialization.</span></span>

<span data-ttu-id="b3d6e-396">다음 형식 예는 우주선의 기밀식 출입구 상태를 나타내며 안쪽 문과 바깥쪽 문을 동시에 열어 둘 수 없다는 제약 조건을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-396">The following example of a type represents the state of an airlock on a spacecraft, and enforces the constraint that both the inner and the outer doors cannot be open at the same time.</span></span>

[!code-csharp[DataContractAttribute#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#3)]
[!code-vb[DataContractAttribute#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#3)]

<span data-ttu-id="b3d6e-397">공격자는 이와 같이 악의적인 메시지를 보내서 제약 조건을 피해 개체를 잘못된 상태가 되도록 할 수 있으며 이로 인해 의도하지 않은 예기치 못한 결과가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-397">An attacker may send a malicious message like this, getting around the constraints and getting the object into an invalid state, which may have unintended and unpredictable consequences.</span></span>

```xml
<SpaceStationAirlock>
    <innerDoorOpen>true</innerDoorOpen>
    <outerDoorOpen>true</outerDoorOpen>
</SpaceStationAirlock>
```

<span data-ttu-id="b3d6e-398">다음과 같은 사항에 주의하면 이러한 상황을 피할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-398">This situation can be avoided by being aware of the following points:</span></span>

- <span data-ttu-id="b3d6e-399"><xref:System.Runtime.Serialization.DataContractSerializer> 에서 대부분의 클래스를 역직렬화할 때는 생성자가 실행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-399">When the <xref:System.Runtime.Serialization.DataContractSerializer> deserializes most classes, constructors do not run.</span></span> <span data-ttu-id="b3d6e-400">따라서 생성자에서 수행하는 상태 관리를 사용하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-400">Therefore, do not rely on any state management done in the constructor.</span></span>

- <span data-ttu-id="b3d6e-401">콜백을 사용하여 개체가 유효한 상태에 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-401">Use callbacks to ensure that the object is in a valid state.</span></span> <span data-ttu-id="b3d6e-402"><xref:System.Runtime.Serialization.OnDeserializedAttribute> 특성으로 표시된 콜백은 deserialization이 완료된 후에 실행되며 전체 상태를 확인하고 수정할 수 있기 때문에 특히 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-402">The callback marked with the <xref:System.Runtime.Serialization.OnDeserializedAttribute> attribute is especially useful because it runs after deserialization is complete and has a chance to examine and correct the overall state.</span></span> <span data-ttu-id="b3d6e-403">자세한 내용은 [버전 허용 Serialization 콜백](version-tolerant-serialization-callbacks.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-403">For more information, see [Version-Tolerant Serialization Callbacks](version-tolerant-serialization-callbacks.md).</span></span>

- <span data-ttu-id="b3d6e-404">속성 setter의 특정 호출 순서를 사용하도록 데이터 계약 형식을 디자인하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-404">Do not design data contract types to rely on any particular order in which property setters must be called.</span></span>

- <span data-ttu-id="b3d6e-405"><xref:System.SerializableAttribute> 특성으로 표시된 레거시 형식은 주의해서 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-405">Take care using legacy types marked with the <xref:System.SerializableAttribute> attribute.</span></span> <span data-ttu-id="b3d6e-406">이들 중 상당수는 신뢰할 수 있는 데이터에만 사용 하기 위해 .NET Framework remoting과 함께 작동 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-406">Many of them were designed to work with .NET Framework remoting for use with trusted data only.</span></span> <span data-ttu-id="b3d6e-407">이 특성으로 표시된 기존 형식은 상태 안전을 고려하지 않은 디자인일 가능성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-407">Existing types marked with this attribute may not have been designed with state safety in mind.</span></span>

- <span data-ttu-id="b3d6e-408">상태 안전에 관해서는 데이터의 존재를 보장하기 위해 <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> 특성의 <xref:System.Runtime.Serialization.DataMemberAttribute> 속성을 사용하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-408">Do not rely on the <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> property of the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute to guarantee presence of data as far as state safety is concerned.</span></span> <span data-ttu-id="b3d6e-409">데이터는 항상 `null`, `zero`또는 `invalid`일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-409">Data could always be `null`, `zero`, or `invalid`.</span></span>

- <span data-ttu-id="b3d6e-410">신뢰할 수 없는 데이터 소스에서 역직렬화된 개체 그래프를 먼저 검사하지 않고 신뢰해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-410">Never trust an object graph deserialized from an untrusted data source without validating it first.</span></span> <span data-ttu-id="b3d6e-411">각 개체의 상태가 일관되어도 개체 그래프 전체는 그렇지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-411">Each individual object may be in a consistent state, but the object graph as a whole may not be.</span></span> <span data-ttu-id="b3d6e-412">또한 개체 그래프 유지 모드가 사용하지 않도록 설정되어 있더라도 역직렬화된 그래프에 같은 개체에 대한 참조가 여러 개 있거나 순환 참조가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-412">Furthermore, even if the object graph preservation mode is disabled, the deserialized graph may have multiple references to the same object or have circular references.</span></span> <span data-ttu-id="b3d6e-413">자세한 내용은 [Serialization 및 Deserialization](serialization-and-deserialization.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-413">For more information, see [Serialization and Deserialization](serialization-and-deserialization.md).</span></span>

### <a name="using-the-netdatacontractserializer-securely"></a><span data-ttu-id="b3d6e-414">안전한 NetDataContractSerializer 사용</span><span class="sxs-lookup"><span data-stu-id="b3d6e-414">Using the NetDataContractSerializer Securely</span></span>

<span data-ttu-id="b3d6e-415"><xref:System.Runtime.Serialization.NetDataContractSerializer> 는 형식에 대한 밀접한 결합을 사용하는 serialization 엔진입니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-415">The <xref:System.Runtime.Serialization.NetDataContractSerializer> is a serialization engine that uses tight coupling to types.</span></span> <span data-ttu-id="b3d6e-416">이는 <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> 및 <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>와 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-416">This is similar to the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>.</span></span> <span data-ttu-id="b3d6e-417">즉, 들어오는 데이터에서 .NET Framework 어셈블리 및 형식 이름을 읽어 인스턴스화할 형식을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-417">That is, it determines which type to instantiate by reading the .NET Framework assembly and type name from the incoming data.</span></span> <span data-ttu-id="b3d6e-418">WCF의 일부 이지만이 serialization 엔진을 연결 하는 방법은 제공 되지 않습니다. 사용자 지정 코드를 작성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-418">Although it is a part of WCF, there is no supplied way of plugging in this serialization engine; custom code must be written.</span></span> <span data-ttu-id="b3d6e-419">는 `NetDataContractSerializer` .NET Framework remoting에서 WCF로 쉽게 마이그레이션할 수 있도록 주로 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-419">The `NetDataContractSerializer` is provided primarily to ease migration from .NET Framework remoting to WCF.</span></span> <span data-ttu-id="b3d6e-420">자세한 내용은 [Serialization 및 Deserialization](serialization-and-deserialization.md)의 관련 섹션을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-420">For more information, see the relevant section in [Serialization and Deserialization](serialization-and-deserialization.md).</span></span>

<span data-ttu-id="b3d6e-421">메시지 자체에서 로드할 형식을 지정할 수 있기 때문에 <xref:System.Runtime.Serialization.NetDataContractSerializer> 메커니즘은 본질적으로 안전하지 않으며 신뢰할 수 있는 데이터에만 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-421">Because the message itself may indicate any type can be loaded, the <xref:System.Runtime.Serialization.NetDataContractSerializer> mechanism is inherently insecure and should be used only with trusted data.</span></span> <span data-ttu-id="b3d6e-422">자세한 내용은 [Binaryformatter 보안 가이드](/dotnet/standard/serialization/binaryformatter-security-guide)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-422">For more information, see the [BinaryFormatter security guide](/dotnet/standard/serialization/binaryformatter-security-guide).</span></span>

<span data-ttu-id="b3d6e-423">신뢰할 수 있는 데이터와 함께 사용하는 경우라도, 들어오는 데이터에서 로드할 형식을 불충분하게 지정할 수가 있습니다. 특히 <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> 속성이 <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple>로 설정되어 있으면 더욱 그렇습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-423">Even when used with trusted data, the incoming data may insufficiently specify the type to load, especially if the <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> property is set to <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple>.</span></span> <span data-ttu-id="b3d6e-424">애플리케이션의 디렉터리나 전역 어셈블리 캐시에 액세스할 수 있는 사람은 로드할 형식을 악의적인 형식으로 대체할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-424">Anyone with access to the application’s directory or to the global assembly cache can substitute a malicious type in place of the one that is supposed to load.</span></span> <span data-ttu-id="b3d6e-425">사용 권한을 올바르게 설정하여 항상 애플리케이션 디렉터리와 전역 어셈블리 캐시의 보안을 보장해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-425">Always ensure the security of your application’s directory and of the global assembly cache by correctly setting permissions.</span></span>

<span data-ttu-id="b3d6e-426">일반적으로 부분적으로 신뢰할 수 있는 코드에서 `NetDataContractSerializer` 인스턴스에 액세스하거나 그 외의 방식으로 서로게이트 선택기(<xref:System.Runtime.Serialization.ISurrogateSelector>) 또는 serialization 바인더(<xref:System.Runtime.Serialization.SerializationBinder>)를 제어하는 경우 코드에서 serialization/deserialization 프로세스를 상당 부분 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-426">In general, if you allow partially trusted code access to your `NetDataContractSerializer` instance or otherwise control the surrogate selector (<xref:System.Runtime.Serialization.ISurrogateSelector>) or the serialization binder (<xref:System.Runtime.Serialization.SerializationBinder>), the code may exercise a great deal of control over the serialization/deserialization process.</span></span> <span data-ttu-id="b3d6e-427">예를 들어 임의의 형식을 삽입하거나, 정보 노출을 일으키거나, 결과 개체 그래프 또는 serialize된 데이터를 변조하거나, 결과적으로 serialize된 스트림을 오버플로시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-427">For example, it may inject arbitrary types, lead to information disclosure, tamper with the resulting object graph or serialized data, or overflow the resultant serialized stream.</span></span>

<span data-ttu-id="b3d6e-428">`NetDataContractSerializer` 와 관련된 다른 보안 문제는 악의적인 코드 실행 위협이 아닌 서비스 거부입니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-428">Another security concern with the `NetDataContractSerializer` is a denial of service, not a malicious code execution threat.</span></span> <span data-ttu-id="b3d6e-429">`NetDataContractSerializer`를 사용할 때는 항상 <xref:System.Runtime.Serialization.NetDataContractSerializer.MaxItemsInObjectGraph%2A> 할당량을 안전한 값으로 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-429">When using the `NetDataContractSerializer`, always set the <xref:System.Runtime.Serialization.NetDataContractSerializer.MaxItemsInObjectGraph%2A> quota to a safe value.</span></span> <span data-ttu-id="b3d6e-430">크기가 이 할당량에 의해서만 제한되는 개체 배열을 할당하는, 작은 악의적인 메시지를 쉽게 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-430">It is easy to construct a small malicious message that allocates an array of objects whose size is limited only by this quota.</span></span>

### <a name="xmlserializer-specific-threats"></a><span data-ttu-id="b3d6e-431">XmlSerializer 관련 위협</span><span class="sxs-lookup"><span data-stu-id="b3d6e-431">XmlSerializer-Specific Threats</span></span>

<span data-ttu-id="b3d6e-432"><xref:System.Xml.Serialization.XmlSerializer> 보안 모델은 <xref:System.Runtime.Serialization.DataContractSerializer>의 경우와 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-432">The <xref:System.Xml.Serialization.XmlSerializer> security model is similar to that of the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="b3d6e-433">그러나 <xref:System.Xml.Serialization.XmlSerializer>에 고유하게 나타나는 위협도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-433">A few threats, however, are unique to the <xref:System.Xml.Serialization.XmlSerializer>.</span></span>

<span data-ttu-id="b3d6e-434"><xref:System.Xml.Serialization.XmlSerializer> 에서는 런타임에 실제로 직렬화 및 역직렬화를 수행하는 *serialization 어셈블리* 를 생성하며 이러한 어셈블리는 임시 파일 디렉터리에 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-434">The <xref:System.Xml.Serialization.XmlSerializer> generates *serialization assemblies* at runtime that contain code that actually serializes and deserializes; these assemblies are created in a temporary files directory.</span></span> <span data-ttu-id="b3d6e-435">다른 프로세스 또는 사용자에게 해당 디렉터리에 대한 권한이 있는 경우에는 serialization/deserialization 코드를 임의의 코드로 덮어쓸 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-435">If some other process or user has access rights to that directory, they may overwrite the serialization/deserialization code with arbitrary code.</span></span> <span data-ttu-id="b3d6e-436">그러면 <xref:System.Xml.Serialization.XmlSerializer> 에서 serialization/deserialization 코드 대신 보안 컨텍스트를 사용하여 이 코드를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-436">The <xref:System.Xml.Serialization.XmlSerializer> then runs this code using its security context, instead of the serialization/deserialization code.</span></span> <span data-ttu-id="b3d6e-437">이 문제를 방지하려면 임시 파일 디렉터리에서 사용 권한이 올바르게 설정되었는지 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-437">Make sure the permissions are set correctly on the temporary files directory to prevent this from happening.</span></span>

<span data-ttu-id="b3d6e-438"><xref:System.Xml.Serialization.XmlSerializer> 에는 실행 시에 새로 생성하는 대신 미리 생성된 serialization 어셈블리를 사용하는 모드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-438">The <xref:System.Xml.Serialization.XmlSerializer> also has a mode in which it uses pre-generated serialization assemblies instead of generating them at runtime.</span></span> <span data-ttu-id="b3d6e-439">이 모드는 <xref:System.Xml.Serialization.XmlSerializer> 에서 적절한 serialization 어셈블리를 찾을 수 있을 때마다 트리거됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-439">This mode is triggered whenever the <xref:System.Xml.Serialization.XmlSerializer> can find a suitable serialization assembly.</span></span> <span data-ttu-id="b3d6e-440"><xref:System.Xml.Serialization.XmlSerializer> 에서는 serialize할 형식이 포함된 어셈블리에 사용된 것과 같은 키를 사용하여 serialization 어셈블리가 서명되었는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-440">The <xref:System.Xml.Serialization.XmlSerializer> checks whether or not the serialization assembly was signed by the same key that was used to sign the assembly that contains the types being serialized.</span></span> <span data-ttu-id="b3d6e-441">그러면 악의적인 어셈블리가 serialization 어셈블리로 위장하는 것을 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-441">This offers protection from malicious assemblies being disguised as serialization assemblies.</span></span> <span data-ttu-id="b3d6e-442">그러나 serialize 가능 형식이 포함된 어셈블리가 서명되지 않은 경우에는 <xref:System.Xml.Serialization.XmlSerializer> 에서 이 확인을 수행할 수 없으며 이름만 정확하면 지정된 어셈블리를 그냥 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-442">However, if the assembly that contains your serializable types is not signed, the <xref:System.Xml.Serialization.XmlSerializer> cannot perform this check and uses any assembly with the correct name.</span></span> <span data-ttu-id="b3d6e-443">그러면 악의적인 코드를 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-443">This makes running malicious code possible.</span></span> <span data-ttu-id="b3d6e-444">serialize 가능한 형식이 포함된 어셈블리에 항상 서명을 하거나 애플리케이션의 디렉터리 및 전역 어셈블리 캐시에 대한 액세스를 엄격하게 제어하여 악의적인 어셈블리가 들어오는 것을 막아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-444">Always sign the assemblies that contain your serializable types, or tightly control access to your application’s directory and the global assembly cache to prevent the introduction of malicious assemblies.</span></span>

<span data-ttu-id="b3d6e-445"><xref:System.Xml.Serialization.XmlSerializer> 는 서비스 거부 공격을 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-445">The <xref:System.Xml.Serialization.XmlSerializer> can be subject to a denial of service attack.</span></span> <span data-ttu-id="b3d6e-446"><xref:System.Xml.Serialization.XmlSerializer> 에는 `MaxItemsInObjectGraph` 에서 사용할 수 있는 것과 같은 <xref:System.Runtime.Serialization.DataContractSerializer>할당량이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-446">The <xref:System.Xml.Serialization.XmlSerializer> does not have a `MaxItemsInObjectGraph` quota (as is available on the <xref:System.Runtime.Serialization.DataContractSerializer>).</span></span> <span data-ttu-id="b3d6e-447">따라서 오로지 메시지 크기로만 제어되는 임의 개수의 개체를 역직렬화합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-447">Thus, it deserializes an arbitrary amount of objects, limited only by the message size.</span></span>

### <a name="partial-trust-threats"></a><span data-ttu-id="b3d6e-448">부분 신뢰 위협</span><span class="sxs-lookup"><span data-stu-id="b3d6e-448">Partial Trust Threats</span></span>

<span data-ttu-id="b3d6e-449">부분 신뢰로 실행되는 코드와 관련된 위협에 대해 다음 사항을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-449">Note the following concerns regarding threats related to code running with partial trust.</span></span> <span data-ttu-id="b3d6e-450">이러한 위협에는 부분적으로 신뢰할 수 있는 악의적인 코드, 그리고 다른 공격 시나리오와 결합된 부분적으로 신뢰할 수 있는 악의적인 코드(예: 특정 문자열을 생성한 다음 역직렬화하는 부분 신뢰 코드)가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-450">These threats include malicious partially-trusted code as well as malicious partially-trusted code in combination with other attack scenarios (for example, partially-trusted code that constructs a specific string and then deserializing it).</span></span>

- <span data-ttu-id="b3d6e-451">serialization 구성 요소를 사용할 때는 serialization 시나리오 전체가 어설션 범위 내에 있고 신뢰할 수 없는 데이터나 개체를 처리하지 않는 경우에도 이러한 식의 사용 전에 권한을 어설션하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-451">When using any serialization components, never assert any permissions before such usage, even if the entire serialization scenario is within the scope of your assert, and you are not dealing with any untrusted data or objects.</span></span> <span data-ttu-id="b3d6e-452">보안 취약성으로 이어질 수 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-452">Such usage may lead to security vulnerabilities.</span></span>

- <span data-ttu-id="b3d6e-453">부분적으로 신뢰할 수 있는 코드에서 확장 지점(서로게이트), serialize되는 형식 또는 기타 방법을 통해 프로세스를 제어하는 경우, 부분 신뢰된 코드는 serializer에서 대량의 데이터를 serialize된 스트림으로 출력하여 이 스트림의 수신자에게 DoS(서비스 거부)를 일으킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-453">In cases where partially-trusted code has control over the serialization process, either through extensibility points (surrogates), types being serialized, or through other means, the partially-trusted code may cause the serializer to output a large amount of data into the serialized stream, which may cause Denial of Service (DoS) to the receiver of this stream.</span></span> <span data-ttu-id="b3d6e-454">DoS 위협에 민감한 대상의 데이터를 serialize하는 경우에는 부분적으로 신뢰할 수 있는 형식을 serialize하거나 기타 방식으로 부분적으로 신뢰할 수 있는 형식의 serialization 제어를 허용하지 말아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-454">If you are serializing data intended for a target that is sensitive to DoS threats, do not serialize partially-trusted types or otherwise let partially-trusted code control serialization.</span></span>

- <span data-ttu-id="b3d6e-455">부분적으로 신뢰할 수 있는 코드에서 <xref:System.Runtime.Serialization.DataContractSerializer> 인스턴스에 액세스 하거나 다른 방식으로 [데이터 계약 서로게이트](../extending/data-contract-surrogates.md)를 제어 하도록 허용 하는 경우 serialization/deserialization 프로세스를 매우 효과적으로 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-455">If you allow partially-trusted code access to your <xref:System.Runtime.Serialization.DataContractSerializer> instance or otherwise control the [Data Contract Surrogates](../extending/data-contract-surrogates.md), it may exercise a great deal of control over the serialization/deserialization process.</span></span> <span data-ttu-id="b3d6e-456">예를 들어 임의의 형식을 삽입하거나, 정보 노출을 일으키거나, 결과 개체 그래프 또는 serialize된 데이터를 변조하거나, 결과적으로 serialize된 스트림을 오버플로시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-456">For example, it may inject arbitrary types, lead to information disclosure, tamper with the resulting object graph or serialized data, or overflow the resultant serialized stream.</span></span> <span data-ttu-id="b3d6e-457">이에 해당하는 <xref:System.Runtime.Serialization.NetDataContractSerializer> 위협에 대한 설명은 "안전한 NetDataContractSerializer 사용" 단원을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-457">An equivalent <xref:System.Runtime.Serialization.NetDataContractSerializer> threat is described in the "Using the NetDataContractSerializer Securely" section.</span></span>

- <span data-ttu-id="b3d6e-458"><xref:System.Runtime.Serialization.DataContractAttribute> 특성이 형식(또는 <xref:System.SerializableAttribute> 로 표시되어 있지만 <xref:System.Runtime.Serialization.ISerializable>이 아닌 형식)에 적용되면 역직렬 변환기에서는 모든 생성자가 public이 아니거나 요청에 의해 보호되지 않더라도 이러한 형식의 인스턴스를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-458">If the <xref:System.Runtime.Serialization.DataContractAttribute> attribute is applied to a type (or the type marked as <xref:System.SerializableAttribute> but is not <xref:System.Runtime.Serialization.ISerializable>), the deserializer can create an instance of such a type even if all constructors are non-public or protected by demands.</span></span>

- <span data-ttu-id="b3d6e-459">역직렬화된 데이터가 신뢰되었고 알려진 모든 형식이 신뢰할 수 있는 형식인 것이 확실한 경우가 아니면 deserialization 결과를 신뢰하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-459">Never trust the result of deserialization unless the data to be deserialized is trusted and you are certain that all known types are types that you trust.</span></span> <span data-ttu-id="b3d6e-460">부분 신뢰에서 실행되는 경우에는 알려진 형식이 애플리케이션 구성 파일에서 로드되지 않지만 컴퓨터 구성 파일에서는 로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-460">Note that known types are not loaded from the application configuration file, (but are loaded from the computer configuration file) when running in partial trust.</span></span>

- <span data-ttu-id="b3d6e-461">서로게이트가 추가된 <xref:System.Runtime.Serialization.DataContractSerializer> 인스턴스를 부분적으로 신뢰할 수 있는 코드에 전달하면 코드에서 서로게이트의 수정 가능한 설정을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-461">If you pass a <xref:System.Runtime.Serialization.DataContractSerializer> instance with a surrogate added to partially-trusted code, the code can change any modifiable settings on that surrogate.</span></span>

- <span data-ttu-id="b3d6e-462">역직렬화된 개체의 경우 XML 판독기나 그 내부의 데이터가 부분적으로 신뢰할 수 있는 코드에서 왔으면 역직렬화된 결과 개체를 신뢰할 수 없는 데이터와 마찬가지로 취급해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-462">For a deserialized object, if the XML reader (or the data therein) comes from partially-trusted code, treat the resulting deserialized object as untrusted data.</span></span>

- <span data-ttu-id="b3d6e-463"><xref:System.Runtime.Serialization.ExtensionDataObject> 형식에 공개 멤버가 없다고 해서 그 내부의 데이터가 안전한 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-463">The fact that the <xref:System.Runtime.Serialization.ExtensionDataObject> type has no public members does not mean that data within it is secure.</span></span> <span data-ttu-id="b3d6e-464">예를 들어, 권한이 있는 데이터 소스에서 일부 데이터가 들어 있는 개체로 역직렬화한 다음 해당 개체를 부분적으로 신뢰할 수 있는 코드로 전달하면 부분적으로 신뢰할 수 있는 코드에서 개체를 serialize하여 `ExtensionDataObject` 에서 데이터를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-464">For example, if you deserialize from a privileged data source into an object in which some data resides, then hand that object to partially-trusted code, the partially-trusted code can read the data in the `ExtensionDataObject` by serializing the object.</span></span> <span data-ttu-id="b3d6e-465">권한이 있는 데이터 소스에서 나중에 부분적으로 신뢰할 수 있는 코드로 전달할 개체로 역직렬화하는 경우에는 <xref:System.Runtime.Serialization.DataContractSerializer.IgnoreExtensionDataObject%2A> 를 `true` 로 설정하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-465">Consider setting <xref:System.Runtime.Serialization.DataContractSerializer.IgnoreExtensionDataObject%2A> to `true` when deserializing from a privileged data source into an object that is later passed to partially-trusted code.</span></span>

- <span data-ttu-id="b3d6e-466"><xref:System.Runtime.Serialization.DataContractSerializer> 및 <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> 는 완전 신뢰로 private, protected, internal 및 public 멤버의 serialization을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-466"><xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> support the serialization of private, protected, internal, and public members in full trust.</span></span> <span data-ttu-id="b3d6e-467">그러나 부분 신뢰에서는 public 멤버만 serialize될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-467">However, in partial trust, only public members can be serialized.</span></span> <span data-ttu-id="b3d6e-468">애플리케이션에서 public 멤버가 아닌 멤버를 serialize하려고 하면 <xref:System.Security.SecurityException> 이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-468">A <xref:System.Security.SecurityException> is thrown if an application attempts to serialize a non-public member.</span></span>

    <span data-ttu-id="b3d6e-469">부분 신뢰에서 internal 또는 protected internal 멤버가 serialize될 수 있도록 허용하려면 <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> 어셈블리 특성을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-469">To allow internal or protected internal members to be serialized in partial trust, use the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> assembly attribute.</span></span> <span data-ttu-id="b3d6e-470">이 특성을 사용하면 어셈블리에서 internal 멤버가 일부 다른 어셈블리에 표시되도록 선언할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-470">This attribute allows an assembly to declare that its internal members are visible to some other assembly.</span></span> <span data-ttu-id="b3d6e-471">이 경우 internal 멤버가 serialize되도록 하려는 어셈블리는 internal 멤버가 System.Runtime.Serialization.dll에 표시되도록 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-471">In this case, an assembly that wants to have its internal members serialized declares that its internal members are visible to System.Runtime.Serialization.dll.</span></span>

    <span data-ttu-id="b3d6e-472">이 방법의 장점은 상승된 코드 생성 경로가 필요하지 않다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-472">The advantage of this approach is that it does not require an elevated code generation path.</span></span>

    <span data-ttu-id="b3d6e-473">이와 동시에 두 가지 주요 단점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-473">At the same time, there are two major disadvantages.</span></span>

    <span data-ttu-id="b3d6e-474">첫 번째 단점은 <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> 특성의 선택 속성이 어셈블리 수준이라는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-474">The first disadvantage is that the opt-in property of the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute is assembly-wide.</span></span> <span data-ttu-id="b3d6e-475">즉, 특정 클래스만 internal 멤버가 serialize되도록 지정할 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-475">That is, you cannot specify that only a certain class can have its internal members serialized.</span></span> <span data-ttu-id="b3d6e-476">물론 <xref:System.Runtime.Serialization.DataMemberAttribute> 특성을 특정 internal 멤버에 추가하지 않는 방법으로 해당 멤버를 serialize하지 않도록 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-476">Of course, you can still choose not to serialize a specific internal member, by simply not adding a <xref:System.Runtime.Serialization.DataMemberAttribute> attribute to that member.</span></span> <span data-ttu-id="b3d6e-477">이와 마찬가지로 개발자는 약간의 표시 문제가 있지만 멤버를 private 또는 protected 대신 internal로 만들도록 선택할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-477">Similarly, a developer can also choose to make a member internal rather than private or protected, with slight visibility concerns.</span></span>

    <span data-ttu-id="b3d6e-478">두 번째 단점은 여전히 private 또는 protected 멤버를 지원하지 않는다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-478">The second disadvantage is that it still does not support private or protected members.</span></span>

    <span data-ttu-id="b3d6e-479">부분 신뢰에서 <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> 특성의 사용을 보려면 다음 프로그램을 사용해 보십시오.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-479">To illustrate the use of the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute in partial trust, consider the following program:</span></span>

    [!code-csharp[CDF_WCF_SecurityConsiderationsForData#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/cdf_wcf_securityconsiderationsfordata/cs/program.cs#1)]

    <span data-ttu-id="b3d6e-480">위의 예제에서 `PermissionsHelper.InternetZone` 은 부분 신뢰의 <xref:System.Security.PermissionSet> 에 해당합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-480">In the example above, `PermissionsHelper.InternetZone` corresponds to the <xref:System.Security.PermissionSet> for partial trust.</span></span> <span data-ttu-id="b3d6e-481">이제 <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> 특성이 없으면 응용 프로그램이 실패 하 고 <xref:System.Security.SecurityException> public이 아닌 멤버가 부분 신뢰로 serialize 될 수 없음을 나타내는을 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-481">Now, without the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute, the application will fail, throwing a <xref:System.Security.SecurityException> indicating that non-public members cannot be serialized in partial trust.</span></span>

    <span data-ttu-id="b3d6e-482">그러나 다음 줄을 소스 파일에 추가하면 프로그램이 성공적으로 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-482">However, if we add the following line to the source file, the program runs successfully.</span></span>

    [!code-csharp[CDF_WCF_SecurityConsiderationsForData#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/cdf_wcf_securityconsiderationsfordata/cs/program.cs#2)]

## <a name="other-state-management-concerns"></a><span data-ttu-id="b3d6e-483">기타 상태 관리 고려 사항</span><span class="sxs-lookup"><span data-stu-id="b3d6e-483">Other State Management Concerns</span></span>

<span data-ttu-id="b3d6e-484">개체 상태 관리에 대해 설명이 필요한 고려 사항이 몇 가지 더 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-484">A few other concerns regarding object state management are worth mentioning:</span></span>

- <span data-ttu-id="b3d6e-485">스트리밍 전송에서 스트림 기반의 프로그래밍 모델을 사용할 때 메시지 처리는 메시지가 도착하는 즉시 이루어집니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-485">When using the stream-based programming model with a streaming transport, processing of the message occurs as the message arrives.</span></span> <span data-ttu-id="b3d6e-486">메시지 발신자가 스트리밍 도중에 콘텐츠가 더 예상되는 상황에서 보내기 작업을 중단하면 코드는 예측할 수 없는 상태가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-486">The sender of the message may abort the send operation in the middle of the stream, leaving your code in an unpredictable state if more content was expected.</span></span> <span data-ttu-id="b3d6e-487">일반적으로 스트림이 완전할 것으로 기대하지 말고 스트림 기반 작업에서 스트림이 중단된 경우에 복원할 수 없는 작업은 수행하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-487">In general, do not rely on the stream being complete, and do not perform any work in a stream-based operation that cannot be rolled back in case the stream is aborted.</span></span> <span data-ttu-id="b3d6e-488">스트리밍 본문 뒤의 메시지 형식이 잘못된 경우에도 마찬가지입니다. SOAP 봉투의 끝 태그가 없거나 두 번째 메시지 본문이 있는 경우를 예로 들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-488">This also applies to the situation where a message may be malformed after the streaming body (for example, it may be missing an end tag for the SOAP envelope or may have a second message body).</span></span>

- <span data-ttu-id="b3d6e-489">`IExtensibleDataObject` 기능을 사용하면 중요한 데이터가 공개될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-489">Using the `IExtensibleDataObject` feature may cause sensitive data to be emitted.</span></span> <span data-ttu-id="b3d6e-490">`IExtensibleObjectData` 를 통해 신뢰할 수 없는 소스에서 데이터 계약으로 데이터를 받아들이고 나중에 메시지가 서명되는 보안 채널을 통해 해당 데이터를 다시 내보내면 전혀 알지 못하는 데이터를 보증하게 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-490">If you are accepting data from an untrusted source into data contracts with `IExtensibleObjectData` and later re-emitting it on a secure channel where messages are signed, you are potentially vouching for data you know nothing about.</span></span> <span data-ttu-id="b3d6e-491">또한 알려진 데이터와 알려지지 않은 데이터를 모두 고려하면 보내는 전반적인 상태가 잘못될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-491">Moreover, the overall state you are sending may be invalid if you take both the known and unknown pieces of data into account.</span></span> <span data-ttu-id="b3d6e-492">확장 데이터 속성을 선택적으로 `null` 로 설정하거나 `IExtensibleObjectData` 기능을 선택적으로 비활성화하여 이러한 상황을 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-492">Avoid this situation by either selectively setting the extension data property to `null` or by selectively disabling the `IExtensibleObjectData` feature.</span></span>

## <a name="schema-import"></a><span data-ttu-id="b3d6e-493">스키마 가져오기</span><span class="sxs-lookup"><span data-stu-id="b3d6e-493">Schema Import</span></span>

<span data-ttu-id="b3d6e-494">일반적으로 스키마를 가져와서 형식을 생성하는 과정은 웹 서비스에서 [ServiceModel Metadata Utility Tool (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md) 를 사용하여 클라이언트 클래스를 생성할 때와 같이 디자인할 때만 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-494">Normally, the process of importing schema to generate types happens only at design time, for example, when using the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md) on a Web service to generate a client class.</span></span> <span data-ttu-id="b3d6e-495">그러나 보다 고급 시나리오에서는 런타임에 스키마를 처리할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-495">However, in more advanced scenarios, you may process schema at runtime.</span></span> <span data-ttu-id="b3d6e-496">이 경우 서비스 거부 위험에 노출될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-496">Be aware that doing so can expose you to denial-of-service risks.</span></span> <span data-ttu-id="b3d6e-497">일부 스키마는 가져오는 데 시간이 오래 걸릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-497">Some schema may take a long time to be imported.</span></span> <span data-ttu-id="b3d6e-498">신뢰할 수 없는 소스에서 스키마가 들어올 가능성이 있는 경우에는 이러한 시나리오에서 <xref:System.Xml.Serialization.XmlSerializer> 스키마 가져오기 구성 요소를 사용하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-498">Never use the <xref:System.Xml.Serialization.XmlSerializer> schema import component in such scenarios if schemas are possibly coming from an untrusted source.</span></span>

## <a name="threats-specific-to-aspnet-ajax-integration"></a><span data-ttu-id="b3d6e-499">ASP.NET AJAX 통합과 관련된 위협</span><span class="sxs-lookup"><span data-stu-id="b3d6e-499">Threats Specific to ASP.NET AJAX Integration</span></span>

<span data-ttu-id="b3d6e-500">사용자가 <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> 또는를 구현할 때 <xref:System.ServiceModel.Description.WebHttpBehavior> WCF는 XML 및 JSON 메시지를 모두 수락할 수 있는 끝점을 노출 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-500">When the user implements <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> or <xref:System.ServiceModel.Description.WebHttpBehavior>, WCF exposes an endpoint that can accept both XML and JSON messages.</span></span> <span data-ttu-id="b3d6e-501">그러나 XML 판독기와 JSON 판독기에서 모두 사용하는 판독기 할당량 집합은 하나밖에 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-501">However, there is only one set of reader quotas, used both by the XML reader and the JSON reader.</span></span> <span data-ttu-id="b3d6e-502">일부 할당량 설정은 이 중 하나의 판독기에는 적합하지만 다른 판독기에는 너무 클 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-502">Some quota settings may be appropriate for one reader but too large for the other.</span></span>

<span data-ttu-id="b3d6e-503">`WebScriptEnablingBehavior`를 구현할 때 사용자는 엔드포인트에서 JavaScript 프록시를 노출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-503">When implementing `WebScriptEnablingBehavior`, the user has the option to expose a JavaScript proxy at the endpoint.</span></span> <span data-ttu-id="b3d6e-504">다음과 같은 보안 문제를 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-504">The following security issues must be considered:</span></span>

- <span data-ttu-id="b3d6e-505">JavaScript 프록시를 검사하여 서비스에 대한 정보(작업 이름, 매개 변수 이름 등)를 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-505">Information about the service (operation names, parameter names, and so on) can be obtained by examining the JavaScript proxy.</span></span>

- <span data-ttu-id="b3d6e-506">JavaScript 엔드포인트를 사용하는 경우 중요한 정보와 개인 정보를 클라이언트 웹 브라우저 캐시에 보존할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-506">When using the JavaScript endpoint, sensitive and private information might be retained in the client Web browser cache.</span></span>

## <a name="a-note-on-components"></a><span data-ttu-id="b3d6e-507">구성 요소 참조</span><span class="sxs-lookup"><span data-stu-id="b3d6e-507">A Note on Components</span></span>

<span data-ttu-id="b3d6e-508">WCF는 유연 하 고 사용자 지정이 가능한 시스템입니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-508">WCF is a flexible and customizable system.</span></span> <span data-ttu-id="b3d6e-509">이 항목의 내용 대부분은 가장 일반적인 WCF 사용 시나리오에 중점을 둡니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-509">Most of the contents of this topic focus on the most common WCF usage scenarios.</span></span> <span data-ttu-id="b3d6e-510">그러나 WCF에서 제공 하는 구성 요소는 다양 한 방식으로 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-510">However, it is possible to compose components WCF provides in many different ways.</span></span> <span data-ttu-id="b3d6e-511">이러한 구성 요소를 사용하는 경우의 보안 영향에 대해 알아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-511">It is important to understand the security implications of using each component.</span></span> <span data-ttu-id="b3d6e-512">특히 다음 사항에 주의하십시오.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-512">In particular:</span></span>

- <span data-ttu-id="b3d6e-513">XML 판독기를 사용해야 하는 경우에는 다른 판독기 대신 <xref:System.Xml.XmlDictionaryReader> 클래스에서 제공하는 판독기를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-513">When you must use XML readers, use the readers the <xref:System.Xml.XmlDictionaryReader> class provides as opposed to any other readers.</span></span> <span data-ttu-id="b3d6e-514">안전한 판독기는 <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>또는 <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> 메서드를 사용하여 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-514">Safe readers are created using <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>, or <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> methods.</span></span> <span data-ttu-id="b3d6e-515"><xref:System.Xml.XmlReader.Create%2A> 메서드를 사용하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-515">Do not use the <xref:System.Xml.XmlReader.Create%2A> method.</span></span> <span data-ttu-id="b3d6e-516">판독기는 항상 안전한 할당량으로 구성해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-516">Always configure the readers with safe quotas.</span></span> <span data-ttu-id="b3d6e-517">Wcf의 serialization 엔진은 WCF의 보안 XML 판독기와 함께 사용 하는 경우에만 안전 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-517">The serialization engines in WCF are secure only when used with secure XML readers from WCF.</span></span>

- <span data-ttu-id="b3d6e-518"><xref:System.Runtime.Serialization.DataContractSerializer> 를 사용하여 신뢰할 수 없는 데이터를 역직렬화할 때는 항상 <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> 속성을 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-518">When using the <xref:System.Runtime.Serialization.DataContractSerializer> to deserialize potentially untrusted data, always set the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> property.</span></span>

- <span data-ttu-id="b3d6e-519">메시지를 만들 때 `maxSizeOfHeaders`에서 제공하는 보호가 충분하지 않은 경우에는 `MaxReceivedMessageSize` 매개 변수를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-519">When creating a message, set the `maxSizeOfHeaders` parameter if `MaxReceivedMessageSize` does not offer enough protection.</span></span>

- <span data-ttu-id="b3d6e-520">인코더를 만들 때는 항상 `MaxSessionSize` 및 `MaxBufferSize`등의 관련 할당량을 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-520">When creating an encoder, always configure the relevant quotas, such as `MaxSessionSize` and `MaxBufferSize`.</span></span>

- <span data-ttu-id="b3d6e-521">XPath 메시지 필터를 사용할 때는 <xref:System.ServiceModel.Dispatcher.XPathMessageFilter.NodeQuota%2A> 를 설정하여 필터에서 방문하는 XML 노드의 수를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-521">When using an XPath message filter, set the <xref:System.ServiceModel.Dispatcher.XPathMessageFilter.NodeQuota%2A> to limit the amount of XML nodes the filter visits.</span></span> <span data-ttu-id="b3d6e-522">여러 노드를 방문하지 않으면 컴퓨팅 시간이 오래 걸리는 XPath 식은 사용하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-522">Do not use XPath expressions that could take a long time to compute without visiting many nodes.</span></span>

- <span data-ttu-id="b3d6e-523">일반적으로 할당량을 수락하는 구성 요소를 사용하는 경우에는 보안상의 영향을 이해하고 안전한 값으로 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3d6e-523">In general, when using any component that accepts a quota, understand its security implications and set it to a safe value.</span></span>

## <a name="see-also"></a><span data-ttu-id="b3d6e-524">참조</span><span class="sxs-lookup"><span data-stu-id="b3d6e-524">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Xml.XmlDictionaryReader>
- <xref:System.Xml.Serialization.XmlSerializer>
- [<span data-ttu-id="b3d6e-525">데이터 계약 알려진 형식</span><span class="sxs-lookup"><span data-stu-id="b3d6e-525">Data Contract Known Types</span></span>](data-contract-known-types.md)
