---
title: Serialization 및 Deserialization
description: .NET Framework 개체와 XML을 양방향으로 변환 하는 WCF serialization 엔진에 대해 알아봅니다.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 3d71814c-bda7-424b-85b7-15084ff9377a
ms.openlocfilehash: 3927c17a2548a094a63ffd95ff8a3701403de281
ms.sourcegitcommit: 358a28048f36a8dca39a9fe6e6ac1f1913acadd5
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 06/23/2020
ms.locfileid: "85244909"
---
# <a name="serialization-and-deserialization"></a><span data-ttu-id="d2141-103">Serialization 및 Deserialization</span><span class="sxs-lookup"><span data-stu-id="d2141-103">Serialization and Deserialization</span></span>
<span data-ttu-id="d2141-104">WCF (Windows Communication Foundation)에는 새로운 serialization 엔진인가 포함 되어 있습니다 <xref:System.Runtime.Serialization.DataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="d2141-104">Windows Communication Foundation (WCF) includes a new serialization engine, the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="d2141-105">는 <xref:System.Runtime.Serialization.DataContractSerializer> .NET Framework 개체와 XML을 양방향으로 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-105">The <xref:System.Runtime.Serialization.DataContractSerializer> translates between .NET Framework objects and XML, in both directions.</span></span> <span data-ttu-id="d2141-106">이 항목에서는 serializer가 작동하는 방식에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-106">This topic explains how the serializer works.</span></span>  
  
 <span data-ttu-id="d2141-107">.NET Framework 개체를 serialize 할 때 serializer는 새 *데이터 계약* 모델을 포함 하 여 다양 한 serialization 프로그래밍 모델을 인식 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-107">When serializing .NET Framework objects, the serializer understands a variety of serialization programming models, including the new *data contract* model.</span></span> <span data-ttu-id="d2141-108">지원되는 형식의 전체 목록은 [Types Supported by the Data Contract Serializer](types-supported-by-the-data-contract-serializer.md)을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="d2141-108">For a full list of supported types, see [Types Supported by the Data Contract Serializer](types-supported-by-the-data-contract-serializer.md).</span></span> <span data-ttu-id="d2141-109">데이터 계약에 대한 소개는 [Using Data Contracts](using-data-contracts.md)을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="d2141-109">For an introduction to data contracts, see [Using Data Contracts](using-data-contracts.md).</span></span>  
  
 <span data-ttu-id="d2141-110">XML을 역직렬화할 때 직렬 변환기에서는 <xref:System.Xml.XmlReader> 및 <xref:System.Xml.XmlWriter> 클래스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-110">When deserializing XML, the serializer uses the <xref:System.Xml.XmlReader> and <xref:System.Xml.XmlWriter> classes.</span></span> <span data-ttu-id="d2141-111">또한 <xref:System.Xml.XmlDictionaryReader> <xref:System.Xml.XmlDictionaryWriter> WCF 이진 XML 형식을 사용 하는 경우와 같은 일부 경우에 최적화 된 XML을 생성할 수 있도록 및 클래스를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-111">It also supports the <xref:System.Xml.XmlDictionaryReader> and <xref:System.Xml.XmlDictionaryWriter> classes to enable it to produce optimized XML in some cases, such as when using the WCF binary XML format.</span></span>  
  
 <span data-ttu-id="d2141-112">WCF에는 도우미 serializer 인도 포함 되어 있습니다 <xref:System.Runtime.Serialization.NetDataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="d2141-112">WCF also includes a companion serializer, the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="d2141-113">는 <xref:System.Runtime.Serialization.NetDataContractSerializer> <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> serialize 된 데이터의 일부로 .NET Framework 형식 이름도 내보내기 때문에 및 serializer와 유사 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-113">The <xref:System.Runtime.Serialization.NetDataContractSerializer> is similar to the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> serializers because it also emits .NET Framework type names as part of the serialized data.</span></span> <span data-ttu-id="d2141-114">그리고 직렬화 측과 역직렬화 측에서 동일한 형식을 공유할 때 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-114">It is used when the same types are shared on the serializing and the deserializing ends.</span></span> <span data-ttu-id="d2141-115"><xref:System.Runtime.Serialization.DataContractSerializer> 및 <xref:System.Runtime.Serialization.NetDataContractSerializer> 는 모두 공통 기본 클래스인 <xref:System.Runtime.Serialization.XmlObjectSerializer>에서 파생됩니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-115">Both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Runtime.Serialization.NetDataContractSerializer> derive from a common base class, the <xref:System.Runtime.Serialization.XmlObjectSerializer>.</span></span>  
  
> [!WARNING]
> <span data-ttu-id="d2141-116"><xref:System.Runtime.Serialization.DataContractSerializer> 는 20 미만의 16진수 값이 있는 제어 문자를 포함하는 문자열을 XML 엔터티로 serialize합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-116">The <xref:System.Runtime.Serialization.DataContractSerializer> serializes strings containing control characters with a hexadecimal value below 20 as XML entities.</span></span> <span data-ttu-id="d2141-117">이렇게 하면 wcf 서비스에 이러한 데이터를 보낼 때 WCF가 아닌 클라이언트에서 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-117">This may cause a problem with a non-WCF client when sending such data to a WCF service.</span></span>  
  
## <a name="creating-a-datacontractserializer-instance"></a><span data-ttu-id="d2141-118">DataContractSerializer 인스턴스 만들기</span><span class="sxs-lookup"><span data-stu-id="d2141-118">Creating a DataContractSerializer Instance</span></span>  
 <span data-ttu-id="d2141-119"><xref:System.Runtime.Serialization.DataContractSerializer> 의 인스턴스를 구성하는 작업은 중요한 단계입니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-119">Constructing an instance of the <xref:System.Runtime.Serialization.DataContractSerializer> is an important step.</span></span> <span data-ttu-id="d2141-120">구성한 후에는 어떤 설정도 변경할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-120">After construction, you cannot change any of the settings.</span></span>  
  
### <a name="specifying-the-root-type"></a><span data-ttu-id="d2141-121">루트 형식 지정</span><span class="sxs-lookup"><span data-stu-id="d2141-121">Specifying the Root Type</span></span>  
 <span data-ttu-id="d2141-122">*루트 형식* 은 직렬화 또는 역직렬화되는 인스턴스의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-122">The *root type* is the type of which instances are serialized or deserialized.</span></span> <span data-ttu-id="d2141-123"><xref:System.Runtime.Serialization.DataContractSerializer> 에는 여러 개의 생성자 오버로드가 있지만, 최소한 `type` 매개 변수를 사용하여 루트 형식을 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-123">The <xref:System.Runtime.Serialization.DataContractSerializer> has many constructor overloads, but, at a minimum, a root type must be supplied using the `type` parameter.</span></span>  
  
 <span data-ttu-id="d2141-124">특정 루트 형식에 대해 만들어진 serializer는 해당 형식이 루트 형식에서 파생된 경우가 아니라면 다른 형식을 직렬화하거나 역직렬화하는 데 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-124">A serializer created for a certain root type cannot be used to serialize (or deserialize) another type, unless the type is derived from the root type.</span></span> <span data-ttu-id="d2141-125">다음 예제에서는 두 개의 클래스가 나옵니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-125">The following example shows two classes.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#1)]
 [!code-vb[c_StandaloneDataContractSerializer#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#1)]  
  
 <span data-ttu-id="d2141-126">이 코드에서는 `DataContractSerializer` 클래스의 인스턴스를 직렬화하거나 역직렬화하는 데에만 사용할 수 있는 `Person` 의 인스턴스를 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-126">This code constructs an instance of the `DataContractSerializer` that can be used only to serialize or deserialize instances of the `Person` class.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#2)]
 [!code-vb[c_StandaloneDataContractSerializer#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#2)]  
  
### <a name="specifying-known-types"></a><span data-ttu-id="d2141-127">알려진 형식 지정</span><span class="sxs-lookup"><span data-stu-id="d2141-127">Specifying Known Types</span></span>  
 <span data-ttu-id="d2141-128">Serialize되는 형식 중 <xref:System.Runtime.Serialization.KnownTypeAttribute> 특성이나 일부 다른 메커니즘을 사용하여 아직 처리되지 않은 형식에 다형성이 포함되는 경우, 알려진 가능한 형식 목록을 `knownTypes` 매개 변수를 사용하여 serializer의 생성자에게 전달해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-128">If polymorphism is involved in the types being serialized that is not already handled using the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute or some other mechanism, a list of possible known types must be passed to the serializer’s constructor using the `knownTypes` parameter.</span></span> <span data-ttu-id="d2141-129">알려진된 형식에 대 한 자세한 내용은 참조 하세요. [데이터 계약 알려진 형식을](data-contract-known-types.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-129">For more information about known types, see [Data Contract Known Types](data-contract-known-types.md).</span></span>  
  
 <span data-ttu-id="d2141-130">다음 예제에서는 특정 형식의 컬렉션인 `LibraryPatron`이 포함된 클래스 `LibraryItem`을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-130">The following example shows a class, `LibraryPatron`, that includes a collection of a specific type, the `LibraryItem`.</span></span> <span data-ttu-id="d2141-131">두 번째 클래스는 `LibraryItem` 형식을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-131">The second class defines the `LibraryItem` type.</span></span> <span data-ttu-id="d2141-132">세 번째와 네 번째 클래스인`Book` 및 `Newspaper`는 `LibraryItem` 클래스에서 상속됩니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-132">The third and four classes (`Book` and `Newspaper`) inherit from the `LibraryItem` class.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#3)]  
 [!code-vb[c_StandaloneDataContractSerializer#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#3)]  
  
 <span data-ttu-id="d2141-133">다음 코드에서는 `knownTypes` 매개 변수를 사용하여 serializer의 인스턴스를 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-133">The following code constructs an instance of the serializer using the `knownTypes` parameter.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#4)]
 [!code-vb[c_StandaloneDataContractSerializer#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#4)]  
  
### <a name="specifying-the-default-root-name-and-namespace"></a><span data-ttu-id="d2141-134">기본 루트 이름 및 네임스페이스 지정</span><span class="sxs-lookup"><span data-stu-id="d2141-134">Specifying the Default Root Name and Namespace</span></span>  
 <span data-ttu-id="d2141-135">일반적으로 개체가 serialize되면 데이터 계약 이름과 네임스페이스에 따라 가장 바깥쪽 XML 요소의 기본 이름과 네임스페이스가 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-135">Normally, when an object is serialized, the default name and namespace of the outermost XML element are determined according to the data contract name and namespace.</span></span> <span data-ttu-id="d2141-136">모든 내부 요소의 이름은 데이터 멤버 이름을 따르며 해당 네임스페이스는 데이터 계약의 네임스페이스와 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-136">The names of all inner elements are determined from data member names, and their namespace is the data contract’s namespace.</span></span> <span data-ttu-id="d2141-137">다음 예제에서는 `Name` 및 `Namespace` 클래스의 생성자에 <xref:System.Runtime.Serialization.DataContractAttribute> 및 <xref:System.Runtime.Serialization.DataMemberAttribute> 값을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-137">The following example sets `Name` and `Namespace` values in the constructors of the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute> classes.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#5)]
 [!code-vb[c_StandaloneDataContractSerializer#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#5)]  
  
 <span data-ttu-id="d2141-138">`Person` 클래스의 인스턴스를 serialize하면 다음과 유사한 XML이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-138">Serializing an instance of the `Person` class produces XML similar to the following.</span></span>  
  
```xml  
<PersonContract xmlns="http://schemas.contoso.com">  
  <AddressMember>  
    <StreetMember>123 Main Street</StreetMember>  
   </AddressMember>  
</PersonContract>  
```  
  
 <span data-ttu-id="d2141-139">그러나 `rootName` 및 `rootNamespace` 매개 변수의 값을 <xref:System.Runtime.Serialization.DataContractSerializer> 생성자에 전달하여 루트 요소의 기본 이름과 네임스페이스를 사용자 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-139">However, you can customize the default name and namespace of the root element by passing the values of the `rootName` and `rootNamespace` parameters to the <xref:System.Runtime.Serialization.DataContractSerializer> constructor.</span></span> <span data-ttu-id="d2141-140">`rootNamespace` 는 데이터 멤버에 해당하는 포함된 요소의 네임스페이스에 영향을 주지 않고,</span><span class="sxs-lookup"><span data-stu-id="d2141-140">Note that the `rootNamespace` does not affect the namespace of the contained elements that correspond to data members.</span></span> <span data-ttu-id="d2141-141">가장 바깥쪽 요소의 네임스페이스에만 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-141">It affects only the namespace of the outermost element.</span></span>  
  
 <span data-ttu-id="d2141-142">이러한 값은 <xref:System.Xml.XmlDictionaryString> 클래스의 인스턴스나 문자열로 전달하여, 이진 XML 형식을 통해 최적화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-142">These values can be passed as strings or instances of the <xref:System.Xml.XmlDictionaryString> class to allow for their optimization using the binary XML format.</span></span>  
  
### <a name="setting-the-maximum-objects-quota"></a><span data-ttu-id="d2141-143">최대 개체 할당량 설정</span><span class="sxs-lookup"><span data-stu-id="d2141-143">Setting the Maximum Objects Quota</span></span>  
 <span data-ttu-id="d2141-144">일부 `DataContractSerializer` 생성자 오버로드에는 `maxItemsInObjectGraph` 매개 변수가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-144">Some `DataContractSerializer` constructor overloads have a `maxItemsInObjectGraph` parameter.</span></span> <span data-ttu-id="d2141-145">이 매개 변수는 직렬 변환기가 단일 <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> 메서드 호출에서 직렬화하거나 역직렬화하는 최대 개체 수를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-145">This parameter determines the maximum number of objects the serializer serializes or deserializes in a single <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> method call.</span></span> <span data-ttu-id="d2141-146">이 메서드는 항상 하나의 루트 개체를 읽지만 이 개체의 데이터 멤버에 다른 개체가 있을 수 있으며,</span><span class="sxs-lookup"><span data-stu-id="d2141-146">(The method always reads one root object, but this object may have other objects in its data members.</span></span> <span data-ttu-id="d2141-147">이러한 개체에는 다른 개체가 있을 수 있습니다. 기본값은 65536입니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-147">Those objects may have other objects, and so on.) The default is 65536.</span></span> <span data-ttu-id="d2141-148">배열을 직렬화하거나 역직렬화할 때 모든 배열 항목은 개별 개체로 계산됩니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-148">Note that when serializing or deserializing arrays, every array entry counts as a separate object.</span></span> <span data-ttu-id="d2141-149">또한 일부 개체에는 큰 메모리 표현이 있을 수 있으므로 서비스 거부 공격을 방지하기에 이 할당량만으로 충분하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-149">Also, note that some objects may have a large memory representation, and so this quota alone may not be sufficient to prevent a denial of service attack.</span></span> <span data-ttu-id="d2141-150">자세한 내용은 [데이터의 보안 고려 사항](security-considerations-for-data.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="d2141-150">For more information, see [Security Considerations for Data](security-considerations-for-data.md).</span></span> <span data-ttu-id="d2141-151">이 할당량을 기본값보다 크게 늘려야 할 경우 데이터를 읽고 쓸 때 보내는 측(직렬화)과 받는 측(역직렬화)에 모두 적용되므로 양측에서 값을 늘려야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-151">If you need to increase this quota beyond the default value, it is important to do so both on the sending (serializing) and receiving (deserializing) sides because it applies to both when reading and writing data.</span></span>  
  
### <a name="round-trips"></a><span data-ttu-id="d2141-152">라운드트립</span><span class="sxs-lookup"><span data-stu-id="d2141-152">Round Trips</span></span>  
 <span data-ttu-id="d2141-153">*라운드트립* 은 개체가 한 번에 역직렬화 및 다시 직렬화될 때 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-153">A *round trip* occurs when an object is deserialized and re-serialized in one operation.</span></span> <span data-ttu-id="d2141-154">예를 들면 XML에서 개체 인스턴스로 이동하고 다시 XML 스트림으로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-154">Thus, it goes from XML to an object instance, and back again into an XML stream.</span></span>  
  
 <span data-ttu-id="d2141-155">일부 `DataContractSerializer` 생성자 오버로드에는 기본적으로 `ignoreExtensionDataObject` 로 설정된 `false` 매개 변수가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-155">Some `DataContractSerializer` constructor overloads have an `ignoreExtensionDataObject` parameter, which is set to `false` by default.</span></span> <span data-ttu-id="d2141-156">이 기본 모드에서는 데이터 계약에서 <xref:System.Runtime.Serialization.IExtensibleDataObject> 인터페이스를 구현하는 한, 라운드트립 시 이전 버전을 통해 최신 버전의 데이터 계약에서 다시 이 최신 버전으로 데이터 손실 없이 데이터를 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-156">In this default mode, data can be sent on a round trip from a newer version of a data contract through an older version and back to the newer version without loss, as long as the data contract implements the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface.</span></span> <span data-ttu-id="d2141-157">예를 들어 `Person` 데이터 계약의 버전 1에 `Name` 및 `PhoneNumber` 데이터 멤버가 들어 있고 버전 2에서 `Nickname` 멤버를 추가한다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-157">For example, suppose version 1 of the `Person` data contract contains the `Name` and `PhoneNumber` data members, and version 2 adds a `Nickname` member.</span></span> <span data-ttu-id="d2141-158">`IExtensibleDataObject` 가 구현되면 버전 2에서 버전 1로 정보를 보낼 때 `Nickname` 데이터가 저장된 다음 다시 serialize될 때 다시 내보내집니다. 따라서 라운드트립 시 데이터가 손실되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-158">If `IExtensibleDataObject` is implemented, when sending information from version 2 to version 1, the `Nickname` data is stored, and then re-emitted when the data is serialized again; therefore, no data is lost in the round trip.</span></span> <span data-ttu-id="d2141-159">자세한 내용은 이전 [버전과 호환 되는 데이터 계약](forward-compatible-data-contracts.md) 및 [데이터 계약 버전 관리](data-contract-versioning.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="d2141-159">For more information, see [Forward-Compatible Data Contracts](forward-compatible-data-contracts.md) and [Data Contract Versioning](data-contract-versioning.md).</span></span>  
  
#### <a name="security-and-schema-validity-concerns-with-round-trips"></a><span data-ttu-id="d2141-160">라운드트립과 관련된 보안 및 스키마 유효성 검사 문제</span><span class="sxs-lookup"><span data-stu-id="d2141-160">Security and Schema Validity Concerns with Round Trips</span></span>  
 <span data-ttu-id="d2141-161">라운드트립 시 보안 관련 문제가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-161">Round trips may have security implications.</span></span> <span data-ttu-id="d2141-162">예를 들어 잘못 사용된 엄청난 양의 데이터를 역직렬화하고 저장하면 보안상 위험이 따를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-162">For example, deserializing and storing large amounts of extraneous data may be a security risk.</span></span> <span data-ttu-id="d2141-163">특히 디지털 서명이 포함된 경우 확인할 방법이 없는 이러한 데이터를 다시 내보낼 경우 보안 문제가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-163">There may be security concerns about re-emitting this data that there is no way to verify, especially if digital signatures are involved.</span></span> <span data-ttu-id="d2141-164">예를 들면 이전 시나리오의 경우 버전 1 엔드포인트에서 악의적인 데이터가 포함된 `Nickname` 값을 서명할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-164">For example, in the previous scenario, the version 1 endpoint could be signing a `Nickname` value that contains malicious data.</span></span> <span data-ttu-id="d2141-165">마지막으로 스키마 유효성 검사 문제가 있을 수 있는데, 엔드포인트에서 명시된 계약을 엄격히 준수하는 데이터를 항상 내보내고 다른 값은 내보내지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-165">Finally, there may be schema validity concerns: an endpoint may want to always emit data that strictly adheres to its stated contract and not any extra values.</span></span> <span data-ttu-id="d2141-166">이전 예제의 경우 버전 1 엔드포인트 계약에는 `Name` 및 `PhoneNumber`만 내보낸다고 명시되어 있는데, 스키마 유효성 검사를 사용 중일 때 추가 `Nickname` 값을 내보내면 유효성 검사에 실패하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-166">In the previous example, the version 1 endpoint’s contract says that it emits only `Name` and `PhoneNumber`, and if schema validation is being used, emitting the extra `Nickname` value causes validation to fail.</span></span>  
  
#### <a name="enabling-and-disabling-round-trips"></a><span data-ttu-id="d2141-167">라운드트립 사용 및 사용 안 함</span><span class="sxs-lookup"><span data-stu-id="d2141-167">Enabling and Disabling Round Trips</span></span>  
 <span data-ttu-id="d2141-168">라운드트립을 해제하려면 <xref:System.Runtime.Serialization.IExtensibleDataObject> 인터페이스를 구현하지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-168">To turn off round trips, do not implement the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface.</span></span> <span data-ttu-id="d2141-169">형식에 대한 제어 권한이 없을 경우 `ignoreExtensionDataObject` 매개 변수를 `true` 로 설정하여 동일한 결과를 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-169">If you have no control over the types, set the `ignoreExtensionDataObject` parameter to `true` to achieve the same effect.</span></span>  
  
### <a name="object-graph-preservation"></a><span data-ttu-id="d2141-170">개체 그래프 유지</span><span class="sxs-lookup"><span data-stu-id="d2141-170">Object Graph Preservation</span></span>  
 <span data-ttu-id="d2141-171">다음 코드에서처럼 serializer는 일반적으로 개체 ID를 고려하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-171">Normally, the serializer does not care about object identity, as in the following code.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#6)]
 [!code-vb[c_StandaloneDataContractSerializer#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#6)]  
  
 <span data-ttu-id="d2141-172">다음 코드에서는 구매 주문서를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-172">The following code creates a purchase order.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#7)]
 [!code-vb[c_StandaloneDataContractSerializer#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#7)]  
  
 <span data-ttu-id="d2141-173">`billTo` 및 `shipTo` 필드는 동일한 개체 인스턴스에 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-173">Notice that `billTo` and `shipTo` fields are set to the same object instance.</span></span> <span data-ttu-id="d2141-174">그러나 생성된 XML은 복제된 정보를 복제하는데, 다음과 유사한 XML이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-174">However, the generated XML duplicates the information duplicated, and looks similar to the following XML.</span></span>  
  
```xml  
<PurchaseOrder>  
  <billTo><street>123 Main St.</street></billTo>  
  <shipTo><street>123 Main St.</street></shipTo>  
</PurchaseOrder>  
```  
  
 <span data-ttu-id="d2141-175">그러나 이 방법은 다음과 같이 바람직하지 않은 특성을 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-175">However, this approach has the following characteristics, which may be undesirable:</span></span>  
  
- <span data-ttu-id="d2141-176">성능.</span><span class="sxs-lookup"><span data-stu-id="d2141-176">Performance.</span></span> <span data-ttu-id="d2141-177">데이터 복제가 비효율적입니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-177">Replicating data is inefficient.</span></span>  
  
- <span data-ttu-id="d2141-178">순환 참조.</span><span class="sxs-lookup"><span data-stu-id="d2141-178">Circular references.</span></span> <span data-ttu-id="d2141-179">개체가 다른 개체를 통해 자신을 참조하는 경우에도, 복제로 serialize하면 무한 루프가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-179">If objects refer to themselves, even through other objects, serializing by replication results in an infinite loop.</span></span> <span data-ttu-id="d2141-180">이 경우 serializer가 <xref:System.Runtime.Serialization.SerializationException> 을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-180">(The serializer throws a <xref:System.Runtime.Serialization.SerializationException> if this happens.)</span></span>  
  
- <span data-ttu-id="d2141-181">의미.</span><span class="sxs-lookup"><span data-stu-id="d2141-181">Semantics.</span></span> <span data-ttu-id="d2141-182">경우에 따라 두 개의 참조가 똑같은 두 개의 개체로 이루어지는 것이 아니라, 하나의 동일한 개체로 이루어지도록 하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-182">Sometimes it is important to preserve the fact that two references are to the same object, and not to two identical objects.</span></span>  
  
 <span data-ttu-id="d2141-183">이러한 이유로 인해, 일부 `DataContractSerializer` 생성자 오버로드에는 기본값이 `preserveObjectReferences` 인 `false`매개 변수가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-183">For these reasons, some `DataContractSerializer` constructor overloads have a `preserveObjectReferences` parameter (the default is `false`).</span></span> <span data-ttu-id="d2141-184">이 매개 변수를로 설정 하면 WCF가 이해 하는 `true` 개체 참조를 인코딩하는 특수 한 방법이 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-184">When this parameter is set to `true`, a special method of encoding object references, which only WCF understands, is used.</span></span> <span data-ttu-id="d2141-185">`true`로 설정된 경우 XML 코드 예제는 이제 다음과 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-185">When set to `true`, the XML code example now resembles the following.</span></span>  
  
```xml  
<PurchaseOrder ser:id="1">  
  <billTo ser:id="2"><street ser:id="3">123 Main St.</street></billTo>  
  <shipTo ser:ref="2"/>  
</PurchaseOrder>  
```  
  
 <span data-ttu-id="d2141-186">"Ser" 네임 스페이스는 표준 serialization 네임 스페이스를 참조 합니다 `http://schemas.microsoft.com/2003/10/Serialization/` .</span><span class="sxs-lookup"><span data-stu-id="d2141-186">The "ser" namespace refers to the standard serialization namespace, `http://schemas.microsoft.com/2003/10/Serialization/`.</span></span> <span data-ttu-id="d2141-187">각 데이터 부분은 단 한 번만 serialize되고 이 데이터에 ID 번호가 제공됩니다. 이후 사용에서는 이미 serialize된 데이터를 참조하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-187">Each piece of data is serialized only once and given an ID number, and subsequent uses result in a reference to the already serialized data.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="d2141-188">데이터 계약 `XMLElement`에 "id" 및 "ref" 특성이 모두 있으면 "ref" 특성이 적용되는 "id" 특성은 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-188">If both "id" and "ref" attributes are present in the data contract `XMLElement`, then the "ref" attribute is honored and the "id" attribute is ignored.</span></span>  
  
 <span data-ttu-id="d2141-189">이 모드의 제한 사항을 파악하는 것도 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-189">It is important to understand the limitations of this mode:</span></span>  
  
- <span data-ttu-id="d2141-190">`DataContractSerializer` 가 `preserveObjectReferences` 로 설정된 상태에서, `true` 에서 생성한 XML은 다른 기술과 상호 운용할 수 없고, 또한 `DataContractSerializer` 가 `preserveObjectReferences` 로 설정된 상태에서는 다른 `true`인스턴스에서만 이 XML에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-190">The XML the `DataContractSerializer` produces with `preserveObjectReferences` set to `true` is not interoperable with any other technologies, and can be accessed only by another `DataContractSerializer` instance, also with `preserveObjectReferences` set to `true`.</span></span>  
  
- <span data-ttu-id="d2141-191">이 기능에 대해서는 메타데이터(스키마)가 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-191">There is no metadata (schema) support for this feature.</span></span> <span data-ttu-id="d2141-192">생성된 스키마는 `preserveObjectReferences` 가 `false`로 설정된 경우에만 유효합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-192">The schema that is produced is valid only for the case when `preserveObjectReferences` is set to `false`.</span></span>  
  
- <span data-ttu-id="d2141-193">이 기능으로 인해 serialization 및 deserialization 프로세스 실행 속도가 느려질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-193">This feature may cause the serialization and deserialization process to run slower.</span></span> <span data-ttu-id="d2141-194">데이터를 복제하지 않아도 되지만 이 모드에서 추가 개체 비교를 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-194">Although data does not have to be replicated, extra object comparisons must be performed in this mode.</span></span>  
  
> [!CAUTION]
> <span data-ttu-id="d2141-195">`preserveObjectReferences` 모드를 사용하는 경우, `maxItemsInObjectGraph` 값을 올바른 할당량으로 설정하는 것이 특히 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-195">When the `preserveObjectReferences` mode is enabled, it is especially important to set the `maxItemsInObjectGraph` value to the correct quota.</span></span> <span data-ttu-id="d2141-196">이 모드에서 배열이 처리되는 방식 때문에, 공격자가 `maxItemsInObjectGraph` 할당량에 의해서만 제한되는 과다한 메모리 소비를 일으키는 작은 악의적인 메시지를 쉽게 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-196">Due to the way arrays are handled in this mode, it is easy for an attacker to construct a small malicious message that results in large memory consumption limited only by the `maxItemsInObjectGraph` quota.</span></span>  
  
### <a name="specifying-a-data-contract-surrogate"></a><span data-ttu-id="d2141-197">데이터 계약 서로게이트 지정</span><span class="sxs-lookup"><span data-stu-id="d2141-197">Specifying a Data Contract Surrogate</span></span>  
 <span data-ttu-id="d2141-198">일부 `DataContractSerializer` 생성자 오버로드에는 `dataContractSurrogate` 로 설정될 수 있는 `null`매개 변수가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-198">Some `DataContractSerializer` constructor overloads have a `dataContractSurrogate` parameter, which may be set to `null`.</span></span> <span data-ttu-id="d2141-199">그렇지 않으면 이 오버로드를 사용하여 *인터페이스를 구현하는 형식인*데이터 계약 서로게이트 <xref:System.Runtime.Serialization.IDataContractSurrogate> 를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-199">Otherwise, you can use it to specify a *data contract surrogate*, which is a type that implements the <xref:System.Runtime.Serialization.IDataContractSurrogate> interface.</span></span> <span data-ttu-id="d2141-200">그러면 인터페이스를 사용하여 serialization 및 deserialization 프로세스를 사용자 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-200">You can then use the interface to customize the serialization and deserialization process.</span></span> <span data-ttu-id="d2141-201">자세한 내용은 [데이터 계약 서로게이트](../extending/data-contract-surrogates.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="d2141-201">For more information, see [Data Contract Surrogates](../extending/data-contract-surrogates.md).</span></span>  
  
## <a name="serialization"></a><span data-ttu-id="d2141-202">Serialization</span><span class="sxs-lookup"><span data-stu-id="d2141-202">Serialization</span></span>  
 <span data-ttu-id="d2141-203">다음과 같은 정보는 <xref:System.Runtime.Serialization.XmlObjectSerializer>및 <xref:System.Runtime.Serialization.DataContractSerializer> 클래스를 포함하여, <xref:System.Runtime.Serialization.NetDataContractSerializer> 에서 상속되는 모든 클래스에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-203">The following information applies to any class that inherits from the <xref:System.Runtime.Serialization.XmlObjectSerializer>, including the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer> classes.</span></span>  
  
### <a name="simple-serialization"></a><span data-ttu-id="d2141-204">간단한 Serialization</span><span class="sxs-lookup"><span data-stu-id="d2141-204">Simple Serialization</span></span>  
 <span data-ttu-id="d2141-205">개체를 serialize하는 가장 기본적인 방법은 개체를 <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> 메서드에 전달하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-205">The most basic way to serialize an object is to pass it to the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> method.</span></span> <span data-ttu-id="d2141-206">그리고 세 개의 오버로드가 있는데, 각각 <xref:System.IO.Stream>, <xref:System.Xml.XmlWriter>또는 <xref:System.Xml.XmlDictionaryWriter>에 쓰기 위한 오버로드입니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-206">There are three overloads, one each for writing to a <xref:System.IO.Stream>, an <xref:System.Xml.XmlWriter>, or an <xref:System.Xml.XmlDictionaryWriter>.</span></span> <span data-ttu-id="d2141-207"><xref:System.IO.Stream> 오버로드를 사용하면 UTF-8 인코딩 형식의 XML로 출력됩니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-207">With the <xref:System.IO.Stream> overload, the output is XML in the UTF-8 encoding.</span></span> <span data-ttu-id="d2141-208"><xref:System.Xml.XmlDictionaryWriter> 오버로드를 사용하면 serializer는 이진 XML에 대한 출력을 최적화합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-208">With the <xref:System.Xml.XmlDictionaryWriter> overload, the serializer optimizes its output for binary XML.</span></span>  
  
 <span data-ttu-id="d2141-209">메서드를 사용 하는 경우 <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> serializer는 래퍼 요소의 기본 이름과 네임 스페이스를 사용 하 여 내용과 함께 씁니다 (이전 "기본 루트 이름 및 네임 스페이스 지정" 섹션 참조).</span><span class="sxs-lookup"><span data-stu-id="d2141-209">When using the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> method, the serializer uses the default name and namespace for the wrapper element and writes it out along with the contents (see the previous "Specifying the Default Root Name and Namespace" section).</span></span>  
  
 <span data-ttu-id="d2141-210">다음 예제에서는 <xref:System.Xml.XmlDictionaryWriter>를 사용하여 작성하는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-210">The following example demonstrates writing with an <xref:System.Xml.XmlDictionaryWriter>.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#8)]
 [!code-vb[c_StandaloneDataContractSerializer#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#8)]  
  
 <span data-ttu-id="d2141-211">이렇게 하면 다음과 유사한 XML이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-211">This produces XML similar to the following.</span></span>  
  
```xml  
<Person>  
  <Name>Jay Hamlin</Name>  
  <Address>123 Main St.</Address>  
</Person>  
```  
  
### <a name="step-by-step-serialization"></a><span data-ttu-id="d2141-212">단계별 Serialization</span><span class="sxs-lookup"><span data-stu-id="d2141-212">Step-By-Step Serialization</span></span>  
 <span data-ttu-id="d2141-213">각각 끝 요소를 작성하고 개체 내용을 작성하며 래퍼 요소를 닫으려면, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A>, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A>및 <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> 메서드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-213">Use the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A>, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A>, and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> methods to write the end element, write the object contents, and close the wrapper element, respectively.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="d2141-214">이러한 메서드의 <xref:System.IO.Stream> 오버로드가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-214">There are no <xref:System.IO.Stream> overloads of these methods.</span></span>  
  
 <span data-ttu-id="d2141-215">이러한 단계별 serialization을 사용하는 방법은 일반적으로 두 가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-215">This step-by-step serialization has two common uses.</span></span> <span data-ttu-id="d2141-216">한 가지 방법은 다음 예제와 같이, 특성 또는 설명 등의 내용을 `WriteStartObject` 와 `WriteObjectContent`사이에 삽입하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-216">One is to insert contents such as attributes or comments between `WriteStartObject` and `WriteObjectContent`,  as shown in the following example.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#9)]
 [!code-vb[c_StandaloneDataContractSerializer#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#9)]  
  
 <span data-ttu-id="d2141-217">이렇게 하면 다음과 유사한 XML이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-217">This produces XML similar to the following.</span></span>  
  
```xml  
<Person serializedBy="myCode">  
  <Name>Jay Hamlin</Name>  
  <Address>123 Main St.</Address>  
</Person>  
```  
  
 <span data-ttu-id="d2141-218">또 다른 일반적인 방법은 다음 코드에서처럼, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> 및 <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> 를 전혀 사용하지 않고 사용자 지정 래퍼 요소를 작성하거나 래퍼 작성도 함께 건너뛰는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-218">Another common use is to avoid using <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> entirely, and to write your own custom wrapper element (or even skip writing a wrapper altogether), as shown in the following code.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#10)]
 [!code-vb[c_StandaloneDataContractSerializer#10](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#10)]  
  
 <span data-ttu-id="d2141-219">이렇게 하면 다음과 유사한 XML이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-219">This produces XML similar to the following.</span></span>  
  
```xml  
<MyCustomWrapper>  
  <Name>Jay Hamlin</Name>  
  <Address>123 Main St.</Address>  
</MyCustomWrapper>  
```  
  
> [!NOTE]
> <span data-ttu-id="d2141-220">단계별 serialization을 사용하면 스키마에 유효하지 않은 XML이 생성될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-220">Using step-by-step serialization may result in schema-invalid XML.</span></span>  
  
## <a name="deserialization"></a><span data-ttu-id="d2141-221">Deserialization</span><span class="sxs-lookup"><span data-stu-id="d2141-221">Deserialization</span></span>  
 <span data-ttu-id="d2141-222">다음과 같은 정보는 <xref:System.Runtime.Serialization.XmlObjectSerializer>및 <xref:System.Runtime.Serialization.DataContractSerializer> 클래스를 포함하여, <xref:System.Runtime.Serialization.NetDataContractSerializer> 에서 상속되는 모든 클래스에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-222">The following information applies to any class that inherits from the <xref:System.Runtime.Serialization.XmlObjectSerializer>, including the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer> classes.</span></span>  
  
 <span data-ttu-id="d2141-223">개체를 역직렬화하는 가장 기본적인 방법은 <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> 메서드 오버로드 중 하나를 호출하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-223">The most basic way to deserialize an object is to call one of the <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> method overloads.</span></span> <span data-ttu-id="d2141-224">그리고 세 개의 오버로드가 있는데, 이 각 오버로드는 <xref:System.Xml.XmlDictionaryReader>, `XmlReader`또는 `Stream`을 사용하여 읽기 위한 오버로드입니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-224">There are three overloads, one each for reading with a <xref:System.Xml.XmlDictionaryReader>, an `XmlReader`, or a `Stream`.</span></span> <span data-ttu-id="d2141-225">`Stream` 오버로드는 할당량으로 보호되지 않고 신뢰할 수 있는 데이터를 읽는 데만 사용해야 하는 텍스트 <xref:System.Xml.XmlDictionaryReader> 를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-225">Note that the `Stream` overload creates a textual <xref:System.Xml.XmlDictionaryReader> that is not protected by any quotas, and should be used only to read trusted data.</span></span>  
  
 <span data-ttu-id="d2141-226">또한 `ReadObject` 메서드가 반환하는 개체는 적합한 형식으로 캐스팅되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-226">Also note that the object the `ReadObject` method returns must be cast to the appropriate type.</span></span>  
  
 <span data-ttu-id="d2141-227">다음 코드에서는 <xref:System.Runtime.Serialization.DataContractSerializer> 및 <xref:System.Xml.XmlDictionaryReader>의 인스턴스를 구성하고 `Person` 인스턴스를 역직렬화합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-227">The following code constructs an instance of the <xref:System.Runtime.Serialization.DataContractSerializer> and an <xref:System.Xml.XmlDictionaryReader>, then deserializes a `Person` instance.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#11)]
 [!code-vb[c_StandaloneDataContractSerializer#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#11)]  
  
 <span data-ttu-id="d2141-228"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> 메서드를 호출하기 전에, 래퍼 요소나 래퍼 요소 앞에 오는 비콘텐츠 노드에 XML 판독기를 배치합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-228">Before calling the <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> method, position the XML reader on the wrapper element or on a non-content node that precedes the wrapper element.</span></span> <span data-ttu-id="d2141-229">이렇게 하려면 다음 코드에서처럼, <xref:System.Xml.XmlReader.Read%2A> 의 <xref:System.Xml.XmlReader> 메서드 또는 해당 파생 항목을 호출하고 <xref:System.Xml.XmlReader.NodeType%2A>을 테스트하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-229">You can do this by calling the <xref:System.Xml.XmlReader.Read%2A> method of the <xref:System.Xml.XmlReader> or its derivation, and testing the <xref:System.Xml.XmlReader.NodeType%2A>, as shown in the following code.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#12](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#12)]
 [!code-vb[c_StandaloneDataContractSerializer#12](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#12)]  
  
 <span data-ttu-id="d2141-230">`ReadObject`로 판독기를 전달하기 전에 이 래퍼 요소의 특성을 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-230">Note that you can read attributes on this wrapper element before handing the reader to `ReadObject`.</span></span>  
  
 <span data-ttu-id="d2141-231">간단한 오버 로드 중 하나를 사용 하 `ReadObject` 는 경우 역직렬 변환기는 래퍼 요소의 기본 이름과 네임 스페이스를 찾고 (이전 섹션인 "기본 루트 이름 및 네임 스페이스 지정" 참조) 알 수 없는 요소를 찾은 경우 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-231">When using one of the simple `ReadObject` overloads, the deserializer looks for the default name and namespace on the wrapper element (see the preceding section, "Specifying the Default Root Name and Namespace") and throws an exception if it finds an unknown element.</span></span> <span data-ttu-id="d2141-232">이전 예에서는 `<Person>` 래퍼 요소가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-232">In the preceding example, the `<Person>` wrapper element is expected.</span></span> <span data-ttu-id="d2141-233">판독기가 명명된 요소에 예상한 대로 배치되었는지 확인하기 위해 <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> 메서드가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-233">The <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> method is called to verify that the reader is positioned on an element that is named as expected.</span></span>  
  
 <span data-ttu-id="d2141-234">이 래퍼 요소 이름을 확인하지 않도록 설정하는 방법이 있습니다. `ReadObject` 메서드의 일부 오버로드는 기본적으로 `verifyObjectName`로 설정된 부울 매개 변수 `true` 을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-234">There is a way to disable this wrapper element name check; some overloads of the `ReadObject` method take the Boolean parameter `verifyObjectName`, which is set to `true` by default.</span></span> <span data-ttu-id="d2141-235">`false`로 설정하면 래퍼 요소의 이름과 네임스페이스를 무시합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-235">When set to `false`, the name and namespace of the wrapper element is ignored.</span></span> <span data-ttu-id="d2141-236">이는 이전에 설명한 단계별 serialization 메커니즘을 사용하여 작성된 XML을 읽을 때 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-236">This is useful for reading XML that was written using the step-by-step serialization mechanism described previously.</span></span>  
  
## <a name="using-the-netdatacontractserializer"></a><span data-ttu-id="d2141-237">NetDataContractSerializer 사용</span><span class="sxs-lookup"><span data-stu-id="d2141-237">Using the NetDataContractSerializer</span></span>  
 <span data-ttu-id="d2141-238">와의 주요 차이점은 `DataContractSerializer` <xref:System.Runtime.Serialization.NetDataContractSerializer> 는 `DataContractSerializer` 데이터 계약 이름을 사용 하는 반면,는 serialize 된 `NetDataContractSerializer` XML에서 전체 .NET Framework 어셈블리와 형식 이름을 출력 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-238">The primary difference between the `DataContractSerializer` and the <xref:System.Runtime.Serialization.NetDataContractSerializer> is that the `DataContractSerializer` uses data contract names, whereas the `NetDataContractSerializer` outputs full .NET Framework assembly and type names in the serialized XML.</span></span> <span data-ttu-id="d2141-239">즉, 정확히 동일한 형식은 serialization 엔드포인트와 deserialization 엔드포인트 간에 공유되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-239">This means that the exact same types must be shared between the serialization and deserialization endpoints.</span></span> <span data-ttu-id="d2141-240">다시 말하면 역직렬화할 정확한 형식을 이미 알고 있으므로 알려진 형식 메커니즘은 `NetDataContractSerializer` 에 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-240">This means that the known types mechanism is not required with the `NetDataContractSerializer` because the exact types to be deserialized are always known.</span></span>  
  
 <span data-ttu-id="d2141-241">그러나 여러 가지 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-241">However, several problems can occur:</span></span>  
  
- <span data-ttu-id="d2141-242">보안.</span><span class="sxs-lookup"><span data-stu-id="d2141-242">Security.</span></span> <span data-ttu-id="d2141-243">XML에 역직렬화되고 있는 모든 형식이 로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-243">Any type found in the XML being deserialized is loaded.</span></span> <span data-ttu-id="d2141-244">이를 악용해 악의적인 형식이 로드될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-244">This can be exploited to force the loading of malicious types.</span></span> <span data-ttu-id="d2141-245">`NetDataContractSerializer` 속성 또는 생성자 매개 변수로 *Serialization 바인더* 를 사용하는 경우에만, 신뢰할 수 없는 데이터에 <xref:System.Runtime.Serialization.NetDataContractSerializer.Binder%2A> 를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-245">Using the `NetDataContractSerializer` with untrusted data should be done only if a *Serialization Binder* is used (using the <xref:System.Runtime.Serialization.NetDataContractSerializer.Binder%2A> property or constructor parameter).</span></span> <span data-ttu-id="d2141-246">바인더는 안전한 형식만 로드할 수 있도록 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-246">The binder permits only safe types to be loaded.</span></span> <span data-ttu-id="d2141-247">바인더 메커니즘은 <xref:System.Runtime.Serialization> 네임스페이스의 형식에서 사용하는 메커니즘과 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-247">The Binder mechanism is identical to the one that types in the <xref:System.Runtime.Serialization> namespace use.</span></span>  
  
- <span data-ttu-id="d2141-248">버전 관리.</span><span class="sxs-lookup"><span data-stu-id="d2141-248">Versioning.</span></span> <span data-ttu-id="d2141-249">XML에 전체 형식 및 어셈블리 이름을 사용하면 형식 버전을 관리할 수 있는 방식이 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-249">Using full type and assembly names in the XML severely restricts how types can be versioned.</span></span> <span data-ttu-id="d2141-250">형식 이름, 네임스페이스, 어셈블리 이름 및 어셈블리 버전은 변경할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-250">The following cannot be changed: type names, namespaces, assembly names, and assembly versions.</span></span> <span data-ttu-id="d2141-251"><xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> 속성이나 생성자 매개 변수를 <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple> 의 기본값 대신 <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Full> 로 설정하면, 어셈블리 버전을 변경할 수 있지만 일반 매개 변수의 형식 버전은 변경할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-251">Setting the <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> property or constructor parameter to <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple> instead of the default value of <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Full> allows for assembly version changes, but not for generic parameter types.</span></span>  
  
- <span data-ttu-id="d2141-252">상호 운용성.</span><span class="sxs-lookup"><span data-stu-id="d2141-252">Interoperability.</span></span> <span data-ttu-id="d2141-253">.NET Framework 형식 및 어셈블리 이름은 XML에 포함 되어 있으므로 .NET Framework 이외의 플랫폼에서는 결과 데이터에 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-253">Because .NET Framework type and assembly names are included in the XML, platforms other than the .NET Framework cannot access the resulting data.</span></span>  
  
- <span data-ttu-id="d2141-254">성능.</span><span class="sxs-lookup"><span data-stu-id="d2141-254">Performance.</span></span> <span data-ttu-id="d2141-255">형식 및 어셈블리 이름을 작성하면 생성되는 XML의 크기가 크게 늘어납니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-255">Writing out the type and assembly names significantly increases the size of the resulting XML.</span></span>  
  
 <span data-ttu-id="d2141-256">이 메커니즘은 .NET Framework remoting에서 사용 하는 이진 또는 SOAP serialization과 비슷합니다 (특히 <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> 및 <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> ).</span><span class="sxs-lookup"><span data-stu-id="d2141-256">This mechanism is similar to binary or SOAP serialization used by .NET Framework remoting (specifically, the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>).</span></span>  
  
 <span data-ttu-id="d2141-257">`NetDataContractSerializer` 사용 방식은 `DataContractSerializer`사용 방식과 비슷하지만 다음과 같은 차이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-257">Using the `NetDataContractSerializer` is similar to using the `DataContractSerializer`, with the following differences:</span></span>  
  
- <span data-ttu-id="d2141-258">생성자를 사용하기 위해 루트 형식을 지정하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-258">The constructors do not require you to specify a root type.</span></span> <span data-ttu-id="d2141-259">`NetDataContractSerializer`의 같은 인스턴스를 사용하여 형식을 serialize할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-259">You can serialize any type with the same instance of the `NetDataContractSerializer`.</span></span>  
  
- <span data-ttu-id="d2141-260">생성자는 알려진 형식의 목록을 허용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-260">The constructors do not accept a list of known types.</span></span> <span data-ttu-id="d2141-261">형식 이름이 XML로 serialize되는 경우 알려진 형식 메커니즘은 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-261">The known types mechanism is unnecessary if type names are serialized into the XML.</span></span>  
  
- <span data-ttu-id="d2141-262">생성자는 데이터 계약 서로게이트를 허용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-262">The constructors do not accept a data contract surrogate.</span></span> <span data-ttu-id="d2141-263">대신 <xref:System.Runtime.Serialization.ISurrogateSelector> 속성에 매핑되는 `surrogateSelector` 라고 하는 <xref:System.Runtime.Serialization.NetDataContractSerializer.SurrogateSelector%2A> 매개 변수를 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-263">Instead, they accept an <xref:System.Runtime.Serialization.ISurrogateSelector> parameter called `surrogateSelector` (which maps to the <xref:System.Runtime.Serialization.NetDataContractSerializer.SurrogateSelector%2A> property).</span></span> <span data-ttu-id="d2141-264">이것이 바로 레거시 서로게이트 메커니즘입니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-264">This is a legacy surrogate mechanism.</span></span>  
  
- <span data-ttu-id="d2141-265">생성자는 `assemblyFormat` 속성에 매핑되는 <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> 의 <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> 이라는 매개 변수를 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-265">The constructors accept a parameter called `assemblyFormat` of the <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> that maps to the <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> property.</span></span> <span data-ttu-id="d2141-266">이전에 설명한 대로 이 메커니즘은 serializer의 버전 관리 기능을 향상시키는 데 사용할 수 있으며,</span><span class="sxs-lookup"><span data-stu-id="d2141-266">As discussed previously, this can be used to enhance the versioning capabilities of the serializer.</span></span> <span data-ttu-id="d2141-267">이진 또는 SOAP serialization의 <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> 메커니즘과 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-267">This is identical to the <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> mechanism in binary or SOAP serialization.</span></span>  
  
- <span data-ttu-id="d2141-268">생성자는 <xref:System.Runtime.Serialization.StreamingContext> 속성에 매핑되는 `context` 라는 <xref:System.Runtime.Serialization.NetDataContractSerializer.Context%2A> 매개 변수를 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-268">The constructors accept a <xref:System.Runtime.Serialization.StreamingContext> parameter called `context` that maps to the <xref:System.Runtime.Serialization.NetDataContractSerializer.Context%2A> property.</span></span> <span data-ttu-id="d2141-269">이 메커니즘은 정보를 serialize되고 있는 형식으로 전달할 수 있으며,</span><span class="sxs-lookup"><span data-stu-id="d2141-269">You can use this to pass information into types being serialized.</span></span> <span data-ttu-id="d2141-270">이 사용 방법은 다른 <xref:System.Runtime.Serialization.StreamingContext> 클래스에 사용된 <xref:System.Runtime.Serialization> 메커니즘의 사용 방법과 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-270">This usage is identical to that of the <xref:System.Runtime.Serialization.StreamingContext> mechanism used in other <xref:System.Runtime.Serialization> classes.</span></span>  
  
- <span data-ttu-id="d2141-271"><xref:System.Runtime.Serialization.NetDataContractSerializer.Serialize%2A> 및 <xref:System.Runtime.Serialization.NetDataContractSerializer.Deserialize%2A> 메서드는 <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> 및 <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> 메서드의 별칭입니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-271">The <xref:System.Runtime.Serialization.NetDataContractSerializer.Serialize%2A> and <xref:System.Runtime.Serialization.NetDataContractSerializer.Deserialize%2A> methods are aliases for the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> methods.</span></span> <span data-ttu-id="d2141-272">이러한 메서드는 이진 또는 SOAP serialization에 보다 일관된 프로그래밍 모델을 제공하기 위해 존재합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-272">These exist to provide a more consistent programming model with binary or SOAP serialization.</span></span>  
  
 <span data-ttu-id="d2141-273">이러한 기능에 대 한 자세한 내용은 [이진 Serialization](../../../standard/serialization/binary-serialization.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="d2141-273">For more information about these features, see [Binary Serialization](../../../standard/serialization/binary-serialization.md).</span></span>  
  
 <span data-ttu-id="d2141-274">`NetDataContractSerializer` 및 `DataContractSerializer` 에서 사용하는 XML 형식은 일반적으로 호환되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-274">The XML formats that the `NetDataContractSerializer` and the `DataContractSerializer` use are normally not compatible.</span></span> <span data-ttu-id="d2141-275">즉, 이러한 직렬 변환기 중 하나로 직렬화하고 다른 직렬 변환기로 역직렬화하도록 시도할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-275">That is, attempting to serialize with one of these serializers and deserialize with the other is not a supported scenario.</span></span>  
  
 <span data-ttu-id="d2141-276">또한는 `NetDataContractSerializer` 개체 그래프의 각 노드에 대 한 전체 .NET Framework 형식 및 어셈블리 이름을 출력 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-276">Also, note that the `NetDataContractSerializer` does not output the full .NET Framework type and assembly name for each node in the object graph.</span></span> <span data-ttu-id="d2141-277">모호한 정보만을 출력하는데,</span><span class="sxs-lookup"><span data-stu-id="d2141-277">It outputs that information only where it is ambiguous.</span></span> <span data-ttu-id="d2141-278">즉, 루트 개체 수준에서 다형적 경우에 대해 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="d2141-278">That is, it outputs at the root object level and for any polymorphic cases.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="d2141-279">참조</span><span class="sxs-lookup"><span data-stu-id="d2141-279">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Runtime.Serialization.NetDataContractSerializer>
- <xref:System.Runtime.Serialization.XmlObjectSerializer>
- [<span data-ttu-id="d2141-280">이진 serialization</span><span class="sxs-lookup"><span data-stu-id="d2141-280">Binary Serialization</span></span>](../../../standard/serialization/binary-serialization.md)
- [<span data-ttu-id="d2141-281">데이터 계약 직렬 변환기에서 지원하는 형식</span><span class="sxs-lookup"><span data-stu-id="d2141-281">Types Supported by the Data Contract Serializer</span></span>](types-supported-by-the-data-contract-serializer.md)
