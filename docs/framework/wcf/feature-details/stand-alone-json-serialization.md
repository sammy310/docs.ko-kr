---
title: DataContractJsonSerializer를 사용 하는 독립 실행형 JSON Serialization
ms.date: 03/30/2017
ms.assetid: 312bd7b2-1300-4b12-801e-ebe742bd2287
ms.openlocfilehash: 65cae13d0185ea1f18bdd54cd26f703fde984f69
ms.sourcegitcommit: dfd612ba454ce775a766bcc6fe93bc1d43dfda47
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/09/2019
ms.locfileid: "72180240"
---
# <a name="stand-alone-json-serialization-using-datacontractjsonserializer"></a><span data-ttu-id="a4041-102">DataContractJsonSerializer를 사용 하는 독립 실행형 JSON Serialization</span><span class="sxs-lookup"><span data-stu-id="a4041-102">Stand-Alone JSON Serialization using DataContractJsonSerializer</span></span>

> [!NOTE]
> <span data-ttu-id="a4041-103">이 문서는 <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>입니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-103">This article is about <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span></span> <span data-ttu-id="a4041-104">JSON 직렬화 및 역직렬화를 포함 하는 대부분의 시나리오에서는 system.xml [네임 스페이스](../../../standard/serialization/system-text-json-overview.md)의 도구를 권장 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-104">For most scenarios that involve serializing and deserializing JSON, we recommend the tools in the [System.Text.Json namespace](../../../standard/serialization/system-text-json-overview.md).</span></span> 

<span data-ttu-id="a4041-105">JSON (JavaScript Object Notation)은 브라우저 내의 웹 페이지에서 실행되는 JavaScript 코드에 의해 사용되도록 특별히 디자인된 데이터 형식이며</span><span class="sxs-lookup"><span data-stu-id="a4041-105">JSON (JavaScript Object Notation) is a data format that is specifically designed to be used by JavaScript code running on Web pages inside the browser.</span></span> <span data-ttu-id="a4041-106">Windows Communication Foundation (WCF)에서 만든 ASP.NET AJAX 서비스에서 사용 하는 기본 데이터 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-106">It is the default data format used by ASP.NET AJAX services created in Windows Communication Foundation (WCF).</span></span>

<span data-ttu-id="a4041-107">이 형식은 ASP.NET과 결합하지 않고 AJAX 서비스를 만드는 경우에도 사용할 수 있습니다. 이 경우 XML이 기본값이지만 JSON을 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-107">This format can also be used when creating AJAX services without integrating with ASP.NET - in this case, XML is the default but JSON can be chosen.</span></span>

<span data-ttu-id="a4041-108">마지막으로 JSON 지원이 필요하지만 AJAX 서비스는 만들지 않을 경우 <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>를 사용하면 .NET 개체를 JSON 데이터로 serialize하고 다시 .NET 형식의 인스턴스로 직접 해당 데이터를 deserialize할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-108">Finally, if you require JSON support but are not creating an AJAX service, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> makes it possible to directly serialize .NET objects into JSON data and to deserialize such data back into instances of .NET types.</span></span> <span data-ttu-id="a4041-109">이 작업을 수행 하는 방법에 대 한 자세한 내용은 [How to: JSON 데이터 Serialize 및 Deserialize @ no__t-0.</span><span class="sxs-lookup"><span data-stu-id="a4041-109">For a description of how to do this, see [How to: Serialize and Deserialize JSON Data](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).</span></span>

<span data-ttu-id="a4041-110">JSON으로 작업할 경우 몇 가지 예외를 제외하고는 <xref:System.Runtime.Serialization.DataContractSerializer>에서 지원하는 것과 같은 .NET 형식이 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-110">When working with JSON, the same .NET types are supported, with a few exceptions, as are supported by the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="a4041-111">지원 되는 형식 목록은 [데이터 계약 Serializer에서 지 원하는 형식](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="a4041-111">For a list of the types supported, see [Types Supported by the Data Contract Serializer](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span></span> <span data-ttu-id="a4041-112">여기에는 대부분의 기본 형식, 대부분의 배열 및 컬렉션 형식뿐만 아니라 <xref:System.Runtime.Serialization.DataContractAttribute> 및 <xref:System.Runtime.Serialization.DataMemberAttribute>를 사용하는 복합 형식도 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-112">This includes most primitive types, most array and collection types, as well as complex types that use the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute>.</span></span>

## <a name="mapping-net-types-to-json-types"></a><span data-ttu-id="a4041-113">JSON 형식에 .NET 형식 매핑</span><span class="sxs-lookup"><span data-stu-id="a4041-113">Mapping .NET types to JSON Types</span></span>

<span data-ttu-id="a4041-114">다음 표에서는 serialization 및 deserialization 절차를 통해 매핑될 때 .NET 형식과 JSON/JavaScript 형식 간의 대응 관계를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-114">The following table shows the correspondence between .NET types and JSON/JavaScript types when mapped by serialization and deserialization procedures.</span></span>

|<span data-ttu-id="a4041-115">.NET 형식</span><span class="sxs-lookup"><span data-stu-id="a4041-115">.NET Types</span></span>|<span data-ttu-id="a4041-116">JSON/JavaScript</span><span class="sxs-lookup"><span data-stu-id="a4041-116">JSON/JavaScript</span></span>|<span data-ttu-id="a4041-117">참고</span><span class="sxs-lookup"><span data-stu-id="a4041-117">Notes</span></span>|
|----------------|----------------------|-----------|
|<span data-ttu-id="a4041-118">모든 숫자 형식. 예: <xref:System.Int32>, <xref:System.Decimal> 또는 <xref:System.Double></span><span class="sxs-lookup"><span data-stu-id="a4041-118">All numeric types, for example <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double></span></span>|<span data-ttu-id="a4041-119">Number</span><span class="sxs-lookup"><span data-stu-id="a4041-119">Number</span></span>|<span data-ttu-id="a4041-120">`Double.NaN`, `Double.PositiveInfinity` 및 `Double.NegativeInfinity`와 같은 특수한 값은 지원되지 않으므로 잘못된 JSON이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-120">Special values such as  `Double.NaN`, `Double.PositiveInfinity` and `Double.NegativeInfinity` are not supported and result in invalid JSON.</span></span>|
|<xref:System.Enum>|<span data-ttu-id="a4041-121">Number</span><span class="sxs-lookup"><span data-stu-id="a4041-121">Number</span></span>|<span data-ttu-id="a4041-122">이 항목의 뒷부분에 있는 "열거 및 JSON"을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="a4041-122">See "Enumerations and JSON" later in this topic.</span></span>|
|<xref:System.Boolean>|<span data-ttu-id="a4041-123">Boolean</span><span class="sxs-lookup"><span data-stu-id="a4041-123">Boolean</span></span>|--|
|<span data-ttu-id="a4041-124"><xref:System.String>, <xref:System.Char></span><span class="sxs-lookup"><span data-stu-id="a4041-124"><xref:System.String>, <xref:System.Char></span></span>|<span data-ttu-id="a4041-125">문자열</span><span class="sxs-lookup"><span data-stu-id="a4041-125">String</span></span>|--|
|<span data-ttu-id="a4041-126"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span><span class="sxs-lookup"><span data-stu-id="a4041-126"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span></span>|<span data-ttu-id="a4041-127">문자열</span><span class="sxs-lookup"><span data-stu-id="a4041-127">String</span></span>|<span data-ttu-id="a4041-128">JSON에서 이러한 형식의 형식은 XML에서와 동일 합니다 (기본적으로 ISO 8601 기간 형식의 TimeSpan, "12345678-1234567890AB의 GUID," http://www.example.com "과 같이 자연 문자열 형식으로 된 URI).</span><span class="sxs-lookup"><span data-stu-id="a4041-128">The format of these types in JSON is the same as in XML (essentially, TimeSpan in the ISO 8601 Duration format, GUID in the "12345678-ABCD-ABCD-ABCD-1234567890AB" format and URI in its natural string form like "http://www.example.com").</span></span> <span data-ttu-id="a4041-129">자세한 내용은 [데이터 계약 스키마 참조](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="a4041-129">For precise information, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span>|
|<xref:System.Xml.XmlQualifiedName>|<span data-ttu-id="a4041-130">문자열</span><span class="sxs-lookup"><span data-stu-id="a4041-130">String</span></span>|<span data-ttu-id="a4041-131">형식은 "name:namespace"이며 첫 번째 콜론 앞에 오는 것이 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-131">The format is "name:namespace" (anything before the first colon is the name).</span></span> <span data-ttu-id="a4041-132">이름 또는 네임스페이스가 없는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-132">Either the name or the namespace can be missing.</span></span> <span data-ttu-id="a4041-133">네임스페이스가 없는 경우 콜론도 생략할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-133">If there is no namespace the colon can be omitted as well.</span></span>|
|<span data-ttu-id="a4041-134"><xref:System.Array>의 <xref:System.Byte> 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-134"><xref:System.Array> of type <xref:System.Byte></span></span>|<span data-ttu-id="a4041-135">숫자 배열</span><span class="sxs-lookup"><span data-stu-id="a4041-135">Array of numbers</span></span>|<span data-ttu-id="a4041-136">각 숫자는 1바이트 값을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-136">Each number represents the value of one byte.</span></span>|
|<xref:System.DateTime>|<span data-ttu-id="a4041-137">날짜/시간 또는 문자열</span><span class="sxs-lookup"><span data-stu-id="a4041-137">DateTime or String</span></span>|<span data-ttu-id="a4041-138">이 항목의 뒷부분에 있는 날짜/시간 및 JSON을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="a4041-138">See Dates/Times and JSON later in this topic.</span></span>|
|<xref:System.DateTimeOffset>|<span data-ttu-id="a4041-139">복합 형식</span><span class="sxs-lookup"><span data-stu-id="a4041-139">Complex type</span></span>|<span data-ttu-id="a4041-140">이 항목의 뒷부분에 있는 날짜/시간 및 JSON을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="a4041-140">See Dates/Times and JSON later in this topic.</span></span>|
|<span data-ttu-id="a4041-141">XML 및 ADO.NET 형식(<xref:System.Xml.XmlElement>,</span><span class="sxs-lookup"><span data-stu-id="a4041-141">XML and ADO.NET types (<xref:System.Xml.XmlElement>,</span></span><br /><br /> <span data-ttu-id="a4041-142"><xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="a4041-142"><xref:System.Xml.Linq.XElement>.</span></span> <span data-ttu-id="a4041-143"><xref:System.Xml.XmlNode>의 배열,</span><span class="sxs-lookup"><span data-stu-id="a4041-143">Arrays of <xref:System.Xml.XmlNode>,</span></span><br /><br /> <span data-ttu-id="a4041-144"><xref:System.Runtime.Serialization.ISerializable>,</span><span class="sxs-lookup"><span data-stu-id="a4041-144"><xref:System.Runtime.Serialization.ISerializable>,</span></span><br /><br /> <span data-ttu-id="a4041-145"><xref:System.Data.DataSet>).</span><span class="sxs-lookup"><span data-stu-id="a4041-145"><xref:System.Data.DataSet>).</span></span>|<span data-ttu-id="a4041-146">문자열</span><span class="sxs-lookup"><span data-stu-id="a4041-146">String</span></span>|<span data-ttu-id="a4041-147">이 항목의 XML 형식 및 JSON 단원을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="a4041-147">See the XML Types and JSON section of this topic.</span></span>|
|<xref:System.DBNull>|<span data-ttu-id="a4041-148">빈 복합 형식</span><span class="sxs-lookup"><span data-stu-id="a4041-148">Empty complex type</span></span>|--|
|<span data-ttu-id="a4041-149">컬렉션, 사전 및 배열</span><span class="sxs-lookup"><span data-stu-id="a4041-149">Collections, dictionaries, and arrays</span></span>|<span data-ttu-id="a4041-150">String</span><span class="sxs-lookup"><span data-stu-id="a4041-150">Array</span></span>|<span data-ttu-id="a4041-151">이 항목의 컬렉션, 사전 및 배열 단원을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="a4041-151">See the Collections, Dictionaries, and Arrays section of this topic.</span></span>|
|<span data-ttu-id="a4041-152">복합 형식(<xref:System.Runtime.Serialization.DataContractAttribute> 또는 <xref:System.SerializableAttribute> 적용)</span><span class="sxs-lookup"><span data-stu-id="a4041-152">Complex types (with the <xref:System.Runtime.Serialization.DataContractAttribute> or <xref:System.SerializableAttribute> applied)</span></span>|<span data-ttu-id="a4041-153">복합 형식</span><span class="sxs-lookup"><span data-stu-id="a4041-153">Complex type</span></span>|<span data-ttu-id="a4041-154">데이터 멤버는 JavaScript 복합 형식의 멤버가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-154">Data members become members of the JavaScript complex type.</span></span>|
|<span data-ttu-id="a4041-155"><xref:System.Runtime.Serialization.ISerializable> 인터페이스를 구현하는 복합 형식)</span><span class="sxs-lookup"><span data-stu-id="a4041-155">Complex types implementing the <xref:System.Runtime.Serialization.ISerializable> interface)</span></span>|<span data-ttu-id="a4041-156">복합 형식</span><span class="sxs-lookup"><span data-stu-id="a4041-156">Complex type</span></span>|<span data-ttu-id="a4041-157">다른 복합 형식과 같지만 일부 <xref:System.Runtime.Serialization.ISerializable> 형식이 지원되지 않습니다. 이 항목의 고급 정보 단원에 있는 ISerializable 지원 부분을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="a4041-157">Same as other complex types but some <xref:System.Runtime.Serialization.ISerializable> types are not supported – see the ISerializable Support part of the Advanced Information section of this topic.</span></span>|
|<span data-ttu-id="a4041-158">모든 형식에 대해 `Null` 값</span><span class="sxs-lookup"><span data-stu-id="a4041-158">`Null` value for any type</span></span>|<span data-ttu-id="a4041-159">Null</span><span class="sxs-lookup"><span data-stu-id="a4041-159">Null</span></span>|<span data-ttu-id="a4041-160">Nullable 형식은 nullable이 아닌 형식과 같은 방식으로 지원되고 JSON에 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-160">Nullable types are also supported and map to JSON in the same way as non-nullable types.</span></span>|

### <a name="enumerations-and-json"></a><span data-ttu-id="a4041-161">열거 및 JSON</span><span class="sxs-lookup"><span data-stu-id="a4041-161">Enumerations and JSON</span></span>

<span data-ttu-id="a4041-162">열거형 멤버 값은 JSON에서 숫자로 처리되며 이는 열거형 멤버 값이 멤버 이름으로 포함되는 데이터 계약에서의 처리 방식과 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-162">Enumeration member values are treated as numbers in JSON, which is different from how they are treated in data contracts, where they are included as member names.</span></span> <span data-ttu-id="a4041-163">데이터 계약 처리에 대 한 자세한 내용은 [데이터 계약의 열거형 형식](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="a4041-163">For more information about the data contract treatment, see [Enumeration Types in Data Contracts](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md).</span></span>

- <span data-ttu-id="a4041-164">예를 들어, `public enum Color {red, green, blue, yellow, pink}`가 있을 경우 `yellow`를 serialize하면 문자열 "yellow"가 아닌 숫자 3이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-164">For example, if you have `public enum Color {red, green, blue, yellow, pink}`, serializing `yellow` produces the number 3 and not the string "yellow".</span></span>

- <span data-ttu-id="a4041-165">모든 `enum` 멤버는 serialize할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-165">All `enum` members are serializable.</span></span> <span data-ttu-id="a4041-166"><xref:System.Runtime.Serialization.EnumMemberAttribute> 및 <xref:System.NonSerializedAttribute> 특성은 사용될 경우 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-166">The <xref:System.Runtime.Serialization.EnumMemberAttribute> and the <xref:System.NonSerializedAttribute> attributes are ignored if used.</span></span>

- <span data-ttu-id="a4041-167">존재하지 않는 `enum` 값을 deserialize할 수 있습니다. 예를 들어, 해당 색 이름이 정의되어 있지 않더라도 값 87을 이전 Color 열거형으로 deserialize할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-167">It is possible to deserialize a nonexistent `enum` value - for example, the value 87 can be deserialized into the previous Color enum even though there is no corresponding color name defined.</span></span>

- <span data-ttu-id="a4041-168">플래그 `enum`은 특수한 플래그가 아니며 `enum`과 동일하게 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-168">A flags `enum` is not special and is treated the same as any other `enum`.</span></span>

### <a name="datestimes-and-json"></a><span data-ttu-id="a4041-169">날짜/시간 및 JSON</span><span class="sxs-lookup"><span data-stu-id="a4041-169">Dates/Times and JSON</span></span>

<span data-ttu-id="a4041-170">JSON 형식은 날짜 및 시간을 직접적으로 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-170">The JSON format does not directly support dates and times.</span></span> <span data-ttu-id="a4041-171">그러나 매우 일반적으로 사용되며 ASP.NET AJAX는 이러한 형식을 특수한 방식으로 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-171">However, they are very commonly used and ASP.NET AJAX provides special support for these types.</span></span> <span data-ttu-id="a4041-172">ASP.NET AJAX 프록시를 사용할 경우 .NET의 <xref:System.DateTime> 형식은 JavaScrip의 `DateTime` 형식과 완전히 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-172">When using ASP.NET AJAX proxies, the <xref:System.DateTime> type in .NET fully corresponds to the `DateTime` type in JavaScript.</span></span>

- <span data-ttu-id="a4041-173">ASP.NET을 사용하지 않을 경우 <xref:System.DateTime> 형식은 JSON에서 이 항목의 고급 정보 단원에 설명된 특수 형식의 문자열로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-173">When not using ASP.NET, a <xref:System.DateTime> type is represented in JSON as a string with a special format that is described in the Advanced Information section of this topic.</span></span>

- <span data-ttu-id="a4041-174"><xref:System.DateTimeOffset>은 JSON에 복합 형식 {"DateTime":dateTime,"OffsetMinutes":offsetMinutes}로 표현됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-174"><xref:System.DateTimeOffset> is represented in JSON as a complex type: {"DateTime":dateTime,"OffsetMinutes":offsetMinutes}.</span></span> <span data-ttu-id="a4041-175">`offsetMinutes` 멤버는 GMT(그리니치 표준시)의 현지 시간 오프셋으로, 관련 이벤트의 위치와 연관된 UTC(세계 협정시)라고도 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-175">The `offsetMinutes` member is the local time offset from Greenwich Mean Time (GMT), also now referred to as Coordinated Universal Time (UTC), associated with the location of the event of interest.</span></span> <span data-ttu-id="a4041-176">`dateTime` 멤버는 관련 이벤트가 발행했을 때의 시간 인스턴스를 나타내며, ASP.NET AJAX를 사용할 때는 JavaScript에서 `DateTime`이 되고 사용하지 않을 때는 문자열이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-176">The `dateTime` member represents the instance in time when the event of interest occurred (again, it becomes a `DateTime` in JavaScript when ASP.NET AJAX is in use and a string when it is not).</span></span> <span data-ttu-id="a4041-177">serialization 시 `dateTime` 멤버는 항상 GMT로 serialize됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-177">On serialization, the `dateTime` member is always serialized in GMT.</span></span> <span data-ttu-id="a4041-178">따라서 뉴욕 시간으로 오전 3시인 경우 `dateTime` 시간 구성 요소는 오전 8시이고 `offsetMinutes`는 300(GMT에서 300분 또는 5시간을 뺀 값)입니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-178">So, if describing 3:00 AM New York time, `dateTime` has a time component of 8:00 AM and `offsetMinutes` are 300 (minus 300 minutes or 5 hours from GMT).</span></span>

  > [!NOTE]
  > <span data-ttu-id="a4041-179">JSON으로 serialize한 경우 <xref:System.DateTime> 및 <xref:System.DateTimeOffset> 개체는 밀리초 수준의 정보만 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-179"><xref:System.DateTime> and <xref:System.DateTimeOffset> objects, when serialized to JSON, only preserve information to millisecond precision.</span></span> <span data-ttu-id="a4041-180">서브-밀리초 값(마이크로초/나노초)은 serialization 중에 손실됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-180">Sub-millisecond values (micro/nanoseconds) are lost during serialization.</span></span>

### <a name="xml-types-and-json"></a><span data-ttu-id="a4041-181">XML 형식 및 JSON</span><span class="sxs-lookup"><span data-stu-id="a4041-181">XML Types and JSON</span></span>

<span data-ttu-id="a4041-182">XML 형식은 JSON 문자열이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-182">XML types become JSON strings.</span></span>

- <span data-ttu-id="a4041-183">예를 들어 XElement 형식의 데이터 멤버 "q"에 \<abc/>가 포함 된 경우 JSON은 {"q": "\<abc/>"}입니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-183">For example, if a data member "q" of type XElement contains \<abc/>, the JSON is {"q":"\<abc/>"}.</span></span>

- <span data-ttu-id="a4041-184">XML 래핑 방법을 지정하는 몇 가지 특수한 규칙이 있습니다. 자세한 내용은 이 항목의 뒷부분에 있는 고급 정보 단원을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="a4041-184">There are some special rules that specify how XML is wrapped - for more information, see the Advanced Information section later in this topic.</span></span>

- <span data-ttu-id="a4041-185">ASP.NET AJAX를 사용 중인 경우 JavaScript에서 문자열을 사용하는 대신 XML DOM을 사용하려면 <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A>에서<xref:System.ServiceModel.Web.WebGetAttribute> 속성을 XML로 설정하거나 <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A>에서 <xref:System.ServiceModel.Web.WebInvokeAttribute> 속성을 XML로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-185">If you are using ASP.NET AJAX and do not want to use strings in the JavaScript, but want the XML DOM instead, set the <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> property to XML on <xref:System.ServiceModel.Web.WebGetAttribute> or the <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> property to XML on the <xref:System.ServiceModel.Web.WebInvokeAttribute>.</span></span>

### <a name="collections-dictionaries-and-arrays"></a><span data-ttu-id="a4041-186">컬렉션, 사전 및 배열</span><span class="sxs-lookup"><span data-stu-id="a4041-186">Collections, Dictionaries and Arrays</span></span>

<span data-ttu-id="a4041-187">모든 컬렉션, 사전 및 배열은 JSON에서 배열로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-187">All collections, dictionaries, and arrays are represented in JSON as arrays.</span></span>

- <span data-ttu-id="a4041-188"><xref:System.Runtime.Serialization.CollectionDataContractAttribute>를 사용하는 모든 사용자 지정은 JSON 표현에서 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-188">Any customization that uses the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> is ignored in the JSON representation.</span></span>

- <span data-ttu-id="a4041-189">사전은 JSON에 직접 사용할 수 있는 방식이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-189">Dictionaries are not a way to work directly with JSON.</span></span> <span data-ttu-id="a4041-190">사전 @ no__t-0string, object >은 다른 JSON 기술 작업에서 예상 되는 것과 동일한 방식으로 WCF에서 지원 되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-190">Dictionary\<string,object> may not be supported in the same way in WCF as expected from working with other JSON technologies.</span></span> <span data-ttu-id="a4041-191">예를 들어 "abc"가 "xyz"로 매핑되고 "def"가 사전의 42로 매핑되는 경우 JSON 표현은 {"abc":"xyz","def":42}가 아니라 [{"Key":"abc","Value":"xyz"},{"Key":"def","Value":42}]입니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-191">For example, if "abc" is mapped to "xyz" and "def" is mapped to 42 in a dictionary, the JSON representation is not {"abc":"xyz","def":42} but is [{"Key":"abc","Value":"xyz"},{"Key":"def","Value":42}] instead.</span></span>

- <span data-ttu-id="a4041-192">JSON으로 직접 작업하려는 경우(엄격한 계약을 미리 정의하지 않고 키 및 값에 동적으로 액세스하는 경우) 다음과 같은 몇 가지 옵션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-192">If you would like to work with JSON directly (accessing keys and values dynamically, without pre-defining a rigid contract), you have several options:</span></span>

  - <span data-ttu-id="a4041-193">[약한 형식의 JSON Serialization (AJAX)](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md) 샘플을 사용 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-193">Consider using the [Weakly-typed JSON Serialization (AJAX)](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md) sample.</span></span>

  - <span data-ttu-id="a4041-194"><xref:System.Runtime.Serialization.ISerializable> 인터페이스와 deserialization 생성자를 사용합니다. 이 두 메커니즘을 사용하면 serialization과 deserialization 시 각각 JSON 키/값 쌍에 액세스할 수 있지만 부분 신뢰 시나리오에서 작업할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-194">Consider using the <xref:System.Runtime.Serialization.ISerializable> interface and deserialization constructors - these two mechanisms allow you to access JSON key/value pairs on serialization and deserialization respectively, but do not work in partial trust scenarios.</span></span>

  - <span data-ttu-id="a4041-195">Serializer를 사용 하는 대신 [JSON과 XML 간의 매핑으로](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md) 작업 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-195">Consider working with the [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md) instead of using a serializer.</span></span>

  - <span data-ttu-id="a4041-196">Serialization 컨텍스트의 *다형성* 은 기본 형식이 필요한 경우 파생 형식을 serialize 하는 기능을 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-196">*Polymorphism* in the context of serialization refers to the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="a4041-197">예를 들어 컬렉션을 <xref:System.Object>에 할당할 때처럼 컬렉션을 다형적으로 사용하는 경우 특수한 JSON 관련 규칙이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-197">There are special JSON-specific rules when using collections polymorphically, when, for example, assigning a collection to an <xref:System.Object>.</span></span> <span data-ttu-id="a4041-198">이러한 내용은 이 항목의 뒷부분에 있는 고급 정보 단원에 자세히 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-198">This issue is more fully discussed in the Advanced Information section later in this topic.</span></span>

## <a name="additional-details"></a><span data-ttu-id="a4041-199">추가 정보</span><span class="sxs-lookup"><span data-stu-id="a4041-199">Additional Details</span></span>

### <a name="order-of-data-members"></a><span data-ttu-id="a4041-200">데이터 멤버 순서</span><span class="sxs-lookup"><span data-stu-id="a4041-200">Order of Data Members</span></span>

<span data-ttu-id="a4041-201">JSON을 사용할 때 데이터 멤버의 순서는 중요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-201">Order of data members is not important when using JSON.</span></span> <span data-ttu-id="a4041-202">특히 <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A>가 설정된 경우에도 JSON 데이터를 원하는 순서로 deserialize할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-202">Specifically, even if <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> is set, JSON data can still be deserialized in any order.</span></span>

### <a name="json-types"></a><span data-ttu-id="a4041-203">JSON 형식</span><span class="sxs-lookup"><span data-stu-id="a4041-203">JSON Types</span></span>

<span data-ttu-id="a4041-204">deserialization 시 JSON 형식은 위의 표와 일치하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-204">The JSON type does not have to match the preceding table on deserialization.</span></span> <span data-ttu-id="a4041-205">예를 들어 `Int`는 일반적으로 JSON 숫자로 매핑되지만 JSON 문자열에 유효한 숫자가 있으면 이 문자열에서 deserialize할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-205">For example, an `Int` normally maps to a JSON number, but it can also be successfully deserialized from a JSON string as long as that string contains a valid number.</span></span> <span data-ttu-id="a4041-206">즉, "q"라고 하는 `Int` 데이터 멤버가 있는 경우 {"q":42} 및 {"q":"42"}는 유효합니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-206">That is, both {"q":42} and {"q":"42"} are valid if there is an `Int` data member called "q".</span></span>

### <a name="polymorphism"></a><span data-ttu-id="a4041-207">다형성</span><span class="sxs-lookup"><span data-stu-id="a4041-207">Polymorphism</span></span>

<span data-ttu-id="a4041-208">다형 serialization은 기본 형식이 필요한 경우에 파생 형식을 serialize하는 기능으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-208">Polymorphic serialization consists of the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="a4041-209">이는 XML serialization이 지원 되는 방식과 비교할 수 있는 WCF의 JSON serialization에 대해 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-209">This is supported for JSON serialization by WCF comparable to the way XML serialization is supported.</span></span> <span data-ttu-id="a4041-210">예를 들어 `MyBaseType`이 예상 되는 `MyDerivedType`을 serialize 하거나 `Object`이 필요한 `Int`를 직렬화 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-210">For example, you can serialize `MyDerivedType` where `MyBaseType` is expected, or serialize `Int` where `Object` is expected.</span></span>

<span data-ttu-id="a4041-211">복합 형식을 deserialize하지 않는 한 기본 형식이 필요한 경우에 파생 형식을 deserialize하면 형식 정보가 손실될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-211">Type information may be lost when deserializing a derived type if the base type is expected, unless you are deserializing a complex type.</span></span> <span data-ttu-id="a4041-212">예를 들어 <xref:System.Uri>가 필요한 경우 <xref:System.Object>를 serialize하면 JSON 문자열이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-212">For example, if <xref:System.Uri> is serialized where <xref:System.Object> is expected, it results in a JSON string.</span></span> <span data-ttu-id="a4041-213">이 문자열을 다시 <xref:System.Object>로 deserialize하면 .NET <xref:System.String>이 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-213">If this string is then deserialized back into <xref:System.Object>, a .NET <xref:System.String> is returned.</span></span> <span data-ttu-id="a4041-214">deserializer는 문자열이 처음에 <xref:System.Uri> 형식이었음을 인식하지 못합니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-214">The deserializer does not know that the string was initially of type <xref:System.Uri>.</span></span> <span data-ttu-id="a4041-215">일반적으로 <xref:System.Object>가 필요한 경우 실제 원본 형식에 관계없이 모든 JSON 문자열은 .NET 문자열로 deserialize되고 .NET 컬렉션, 사전 및 배열을 serialize하는 데 사용되는 모든 JSON 배열은 <xref:System.Array> 형식의 .NET <xref:System.Object>로 deserialize됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-215">Generally, when expecting <xref:System.Object>, all JSON strings are deserialized as .NET strings, and all JSON arrays used to serialize .NET collections, dictionaries, and arrays are deserialized as .NET <xref:System.Array> of type <xref:System.Object>, regardless of what the actual original type had been.</span></span> <span data-ttu-id="a4041-216">JSON 부울은 .NET <xref:System.Boolean>로 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-216">A JSON boolean maps to a .NET <xref:System.Boolean>.</span></span> <span data-ttu-id="a4041-217">그러나 <xref:System.Object>가 필요한 경우 JSON 숫자는 .NET <xref:System.Int32>, <xref:System.Decimal> 또는 <xref:System.Double>로 deserialize되며, 이때 가장 적합한 형식이 자동으로 선택됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-217">However when expecting an <xref:System.Object>, JSON numbers are deserialized as either .NET <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double>, where the most appropriate type is automatically picked.</span></span>

<span data-ttu-id="a4041-218"><xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>는 인터페이스 형식으로 deserialize될 때 선언된 형식이 개체인 것처럼 deserialize됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-218">When deserializing into an interface type, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> deserializes as if the declared type were object.</span></span>

<span data-ttu-id="a4041-219">사용자 고유의 기본 형식 및 파생 형식으로 작업하는 경우에는 일반적으로 <xref:System.Runtime.Serialization.KnownTypeAttribute>, <xref:System.ServiceModel.ServiceKnownTypeAttribute> 또는 이와 동등한 메커니즘을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-219">When working with your own base and derived types, using the <xref:System.Runtime.Serialization.KnownTypeAttribute>, <xref:System.ServiceModel.ServiceKnownTypeAttribute> or an equivalent mechanism is normally required.</span></span> <span data-ttu-id="a4041-220">예를 들어 `Animal` 반환 값을 포함 하는 작업을 실제로 반환 하 고 `Cat`의 인스턴스를 반환 하는 경우 (`Animal`에서 파생 됨) <xref:System.Runtime.Serialization.KnownTypeAttribute>을 `Animal` 형식에 적용 하 고 <xref:System.ServiceModel.ServiceKnownTypeAttribute>를 작업에 적용 하 여 이러한 특성</span><span class="sxs-lookup"><span data-stu-id="a4041-220">For example, if you have an operation that has an `Animal` return value and it actually returns an instance of `Cat` (derived from `Animal`), you should either apply the <xref:System.Runtime.Serialization.KnownTypeAttribute>, to the `Animal` type or the <xref:System.ServiceModel.ServiceKnownTypeAttribute> to the operation and specify the `Cat` type in these attributes.</span></span> <span data-ttu-id="a4041-221">자세한 내용은 [데이터 계약 알려진 형식을](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-221">For more information, see [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span></span>

<span data-ttu-id="a4041-222">다형 serialization 작동 방식에 대한 자세한 내용 및 다형 serialization 사용 시 고려해야 할 제한 사항에 대한 설명은 이 항목의 뒷부분에 있는 고급 정보 단원을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="a4041-222">For details of how polymorphic serialization works and a discussion of some of the limitations that must be respected when using it, see the Advanced Information section later in this topic.</span></span>

### <a name="versioning"></a><span data-ttu-id="a4041-223">버전 관리</span><span class="sxs-lookup"><span data-stu-id="a4041-223">Versioning</span></span>

<span data-ttu-id="a4041-224">JSON에서는 <xref:System.Runtime.Serialization.IExtensibleDataObject> 인터페이스를 포함한 데이터 계약 버전 관리 기능이 완벽하게 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-224">The data contract versioning features, including the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface, are fully supported in JSON.</span></span> <span data-ttu-id="a4041-225">또한 대부분의 경우에 형식을 한 가지 형식(예: XML)으로 deserialize한 다음 다른 형식(예: JSON)으로 serialize할 수 있으며 이 경우 데이터를 <xref:System.Runtime.Serialization.IExtensibleDataObject>에 유지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-225">Furthermore, in most cases it is possible to deserialize a type in one format (for example, XML) and then serialize it into another format (for example, JSON) and still preserve the data in <xref:System.Runtime.Serialization.IExtensibleDataObject>.</span></span> <span data-ttu-id="a4041-226">자세한 내용은 [호환 가능한 데이터 계약](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="a4041-226">For more information, see [Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).</span></span> <span data-ttu-id="a4041-227">JSON은 순서가 지정되지 않으므로 순서 정보가 손실됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-227">Remember that JSON is unordered so any order information is lost.</span></span> <span data-ttu-id="a4041-228">또한 JSON은 키 이름이 같은 여러 키/값 쌍을 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-228">Furthermore, JSON does not support multiple key/value pairs with the same key name.</span></span> <span data-ttu-id="a4041-229">마지막으로, <xref:System.Runtime.Serialization.IExtensibleDataObject>의 모든 작업은 원래 다형적입니다. 즉, 모든 형식의 기본 형식인 <xref:System.Object>에 파생 형식이 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-229">Finally, all operations on <xref:System.Runtime.Serialization.IExtensibleDataObject> are inherently polymorphic - that is their derived type are assigned to <xref:System.Object>, the base type for all types.</span></span>

## <a name="json-in-urls"></a><span data-ttu-id="a4041-230">URL의 JSON</span><span class="sxs-lookup"><span data-stu-id="a4041-230">JSON in URLs</span></span>

<span data-ttu-id="a4041-231">ASP.NET AJAX 엔드포인트를 <xref:System.ServiceModel.Web.WebGetAttribute> 특성을 사용하는 HTTP GET 동사와 함께 사용하는 경우 요청 URL에 메시지 본문 대신 들어오는 매개 변수가 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-231">When using ASP.NET AJAX endpoints with the HTTP GET verb (using the <xref:System.ServiceModel.Web.WebGetAttribute> attribute), incoming parameters appear in the request URL instead of the message body.</span></span> <span data-ttu-id="a4041-232">JSON은 요청 URL 에서도 지원 되므로 "number" 라는 `Int`을 사용 하 고 "p" 라는 `Person` 복합 형식을 사용 하는 작업이 있는 경우 URL은 다음 URL과 유사할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-232">JSON is supported even in the request URL, so if you have an operation that takes an `Int` called "number" and a `Person` complex type called "p", the URL may resemble the following URL.</span></span>

```
http://example.com/myservice.svc/MyOperation?number=7&p={"name":"John","age":42}
```

<span data-ttu-id="a4041-233">ASP.NET AJAX Script Manager 컨트롤 및 프록시를 사용하여 서비스를 호출하는 경우 프록시에 의해 이 URL이 자동으로 생성되지만 표시되지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-233">If you are using an ASP.NET AJAX Script Manager control and proxy to call the service, this URL is automatically generated by the proxy and is not seen.</span></span> <span data-ttu-id="a4041-234">JSON은 ASP.NET AJAX가 아닌 엔드포인트에 있는 URL에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-234">JSON cannot be used in URLs on non-ASP.NET AJAX endpoints.</span></span>

## <a name="advanced-information"></a><span data-ttu-id="a4041-235">고급 정보</span><span class="sxs-lookup"><span data-stu-id="a4041-235">Advanced information</span></span>

### <a name="iserializable-support"></a><span data-ttu-id="a4041-236">ISerializable 지원</span><span class="sxs-lookup"><span data-stu-id="a4041-236">ISerializable Support</span></span>

#### <a name="supported-and-unsupported-iserializable-types"></a><span data-ttu-id="a4041-237">지원되는 ISerializable 형식과 지원되지 않는 ISerializable 형식</span><span class="sxs-lookup"><span data-stu-id="a4041-237">Supported and Unsupported ISerializable Types</span></span>

<span data-ttu-id="a4041-238">일반적으로 <xref:System.Runtime.Serialization.ISerializable> 인터페이스를 구현하는 형식은 JSON을 serialize하거나 deserialize할 때 완전히 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-238">In general, types that implement the <xref:System.Runtime.Serialization.ISerializable> interface are fully supported when serializing/deserializing JSON.</span></span> <span data-ttu-id="a4041-239">그러나 이러한 형식 중에는 JSON 관련 serialization의 영향을 받으면 deserialize하지 않도록 구현되는 형식(일부 .NET Framework 형식 포함)도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-239">However, some of these types (including some .NET Framework types) are implemented in such a way that the JSON-specific serialization aspects cause them to not deserialize correctly:</span></span>

- <span data-ttu-id="a4041-240"><xref:System.Runtime.Serialization.ISerializable>을 사용하면 개별 데이터 멤버의 형식을 미리 알 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-240">With <xref:System.Runtime.Serialization.ISerializable>, the type of individual data members is never known in advance.</span></span> <span data-ttu-id="a4041-241">따라서 다형적 상황은 형식을 개체로 deserialize하는 상황과 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-241">This leads to a polymorphic situation similar to deserializing types into an object.</span></span> <span data-ttu-id="a4041-242">앞서 설명한 바와 같이 이로 인해 JSON에서 형식 정보가 손실될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-242">As mentioned before, this may lead to loss of type information in JSON.</span></span> <span data-ttu-id="a4041-243">예를 들어, 해당 `enum` 구현에서 <xref:System.Runtime.Serialization.ISerializable>을 serialize한 형식이 적절한 캐스팅 없이 바로 `enum`으로 다시 deserialize를 시도하는 경우 실패하게 됩니다. 이는 `enum`이 JSON에서 숫자를 사용하여 serialize되고 JSON 숫자는 기본 제공 .NET 숫자 형식(Int32, Decimal 또는 Double)으로 deserialize되기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-243">For example, a type that serializes an `enum` in its <xref:System.Runtime.Serialization.ISerializable> implementation and attempts to deserialize back directly into an `enum` (without proper casts) fails, because an `enum` is serialized using numbers in JSON and JSON numbers deserialize into built-in .NET numeric types (Int32, Decimal or Double).</span></span> <span data-ttu-id="a4041-244">따라서 `enum` 값으로 사용된 숫자가 손실됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-244">So the fact that the number used to be an `enum` value is lost.</span></span>

- <span data-ttu-id="a4041-245">대부분의 JSON은 특정 순서를 보장하지 않기 때문에 해당 deserialization 생성자에서 특정 deserialization 순서에 의존하는 <xref:System.Runtime.Serialization.ISerializable> 형식도 일부 JSON 데이터를 deserialize하지 못할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-245">An <xref:System.Runtime.Serialization.ISerializable> type that depends on a particular order of deserialization in its deserialization constructor may also fail to deserialize some JSON data, because most JSON serializers do not guarantee any specific order.</span></span>

#### <a name="factory-types"></a><span data-ttu-id="a4041-246">팩터리 형식</span><span class="sxs-lookup"><span data-stu-id="a4041-246">Factory Types</span></span>

<span data-ttu-id="a4041-247"><xref:System.Runtime.Serialization.IObjectReference> 인터페이스는 일반적으로 JSON에서 지원되지만, 인터페이스를 구현하는 형식과 다른 형식의 인스턴스를 <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29>에서 반환하는 "팩터리 형식" 기능을 필요로 하는 형식은 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-247">While the <xref:System.Runtime.Serialization.IObjectReference> interface is supported in JSON in general, any types that require the "factory type" feature (returning an instance of a different type from <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> than the type that implements the interface) are not supported.</span></span>

### <a name="datetime-wire-format"></a><span data-ttu-id="a4041-248">DateTime 통신 형식</span><span class="sxs-lookup"><span data-stu-id="a4041-248">DateTime Wire Format</span></span>

<span data-ttu-id="a4041-249"><xref:System.DateTime> 값은 "/Date(700000+0500)/" 형식의 JSON 문자열로 표시됩니다. 여기서 첫 번째 숫자(이 예제에서는 700000)는 1970년 1월 1일 자정부터의 정규 시간(일광 절약 시간이 아님)인 GMT 시간대의 시간(밀리초)입니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-249"><xref:System.DateTime> values appear as JSON strings in the form of "/Date(700000+0500)/", where the first number (700000 in the example provided) is the number of milliseconds in the GMT time zone, regular (non-daylight savings) time since midnight, January 1, 1970.</span></span> <span data-ttu-id="a4041-250">이 숫자는 이보다 이전 시간을 나타낼 경우 음수가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-250">The number may be negative to represent earlier times.</span></span> <span data-ttu-id="a4041-251">예제에서 "+0500"으로 구성된 부분은 선택적 요소이며, 시간이 <xref:System.DateTimeKind.Local> 종류, 즉 deserialization 시 현지 시간대로 변환되어야 함을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-251">The part that consists of "+0500" in the example is optional and indicates that the time is of the <xref:System.DateTimeKind.Local> kind - that is, should be converted to the local time zone on deserialization.</span></span> <span data-ttu-id="a4041-252">이 부분이 없으면 시간은 <xref:System.DateTimeKind.Utc>로 deserialize됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-252">If it is absent, the time is deserialized as <xref:System.DateTimeKind.Utc>.</span></span> <span data-ttu-id="a4041-253">실제 숫자(이 예제에서는 "0500")와 해당 기호(+ 또는 -)는 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-253">The actual number ("0500" in this example) and its sign (+ or -) are ignored.</span></span>

<span data-ttu-id="a4041-254"><xref:System.DateTime>을 serialize하는 경우 <xref:System.DateTimeKind.Local> 및 <xref:System.DateTimeKind.Unspecified> 시간은 오프셋과 함께 기록되고 <xref:System.DateTimeKind.Utc>는 오프셋 없이 기록됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-254">When serializing <xref:System.DateTime>, <xref:System.DateTimeKind.Local> and <xref:System.DateTimeKind.Unspecified> times are written with an offset, and <xref:System.DateTimeKind.Utc> is written without.</span></span>

<span data-ttu-id="a4041-255">ASP.NET AJAX 클라이언트 JavaScript 코드는 이러한 문자열을 JavaScript `DateTime` 인스턴스로 자동으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-255">The ASP.NET AJAX client JavaScript code automatically converts such strings into JavaScript `DateTime` instances.</span></span> <span data-ttu-id="a4041-256">.NET에 <xref:System.DateTime> 형식이 아닌 유사한 형식을 지닌 다른 문자열이 있는 경우 이 문자열 또한 변환됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-256">If there are other strings that have a similar form that are not of type <xref:System.DateTime> in .NET, they are converted as well.</span></span>

<span data-ttu-id="a4041-257">변환은 "/" 문자가 이스케이프 되는 경우에만 발생 합니다. 즉, JSON은 "\\/날짜 (700000 + 0500) \\/")로 표시 되며,이 때문에 WCF의 JSON 인코더 (<xref:System.ServiceModel.WebHttpBinding>에서 사용 하도록 설정 됨)는 항상 "/" 문자를 이스케이프 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-257">The conversion only takes place if the "/" characters are escaped (that is, the JSON looks like "\\/Date(700000+0500)\\/"), and for this reason WCF's JSON encoder (enabled by the <xref:System.ServiceModel.WebHttpBinding>) always escapes the "/" character.</span></span>

### <a name="xml-in-json-strings"></a><span data-ttu-id="a4041-258">JSON 문자열의 XML</span><span class="sxs-lookup"><span data-stu-id="a4041-258">XML in JSON Strings</span></span>

#### <a name="xmlelement"></a><span data-ttu-id="a4041-259">XmlElement</span><span class="sxs-lookup"><span data-stu-id="a4041-259">XmlElement</span></span>

<span data-ttu-id="a4041-260"><xref:System.Xml.XmlElement>는 래핑 없이 그대로 serialize됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-260"><xref:System.Xml.XmlElement> is serialized as is, with no wrapping.</span></span> <span data-ttu-id="a4041-261">예를 들어 \<abc/>를 포함 하는 <xref:System.Xml.XmlElement> 형식의 데이터 멤버 "x"는 다음과 같이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-261">For example, data member "x" of type <xref:System.Xml.XmlElement> that contains \<abc/> is as represented as follows.</span></span>

```json
{"x":"<abc/>"}
```

#### <a name="arrays-of-xmlnode"></a><span data-ttu-id="a4041-262">XmlNode 배열</span><span class="sxs-lookup"><span data-stu-id="a4041-262">Arrays of XmlNode</span></span>

<span data-ttu-id="a4041-263"><xref:System.Array> 형식의 <xref:System.Xml.XmlNode> 개체는 형식에 대한 표준 데이터 계약 네임스페이스에서 ArrayOfXmlNode라는 요소에 래핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-263"><xref:System.Array> objects of type <xref:System.Xml.XmlNode> are wrapped in an element called ArrayOfXmlNode in the standard data contract namespace for the type.</span></span> <span data-ttu-id="a4041-264">"x"가 "value"와 빈 요소 노드 "M"을 포함하는 네임스페이스 "ns"에 특성 노드 "N"을 포함하는 배열인 경우 해당 표현은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-264">If "x" is an array that contains attribute node "N" in namespace "ns" that contains "value" and an empty element node "M", the representation is as follows.</span></span>

```json
{"x":"<ArrayOfXmlNode xmlns=\"http://schemas.datacontract.org/2004/07/System.Xml\" a:N=\"value\" xmlns:a=\"ns\"><M/></ArrayOfXmlNode>"}
```

 <span data-ttu-id="a4041-265">XmlNode 배열의 시작 부분(다른 요소들 앞)에서 빈 네임스페이스의 특성은 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-265">Attributes in the empty namespace at the beginning of XmlNode arrays (before other elements) are unsupported.</span></span>

#### <a name="ixmlserializable-types-including-xelement-and-dataset"></a><span data-ttu-id="a4041-266">XElement 및 DataSet을 포함한 IXmlSerializable 형식</span><span class="sxs-lookup"><span data-stu-id="a4041-266">IXmlSerializable Types including XElement and DataSet</span></span>

<span data-ttu-id="a4041-267"><xref:System.Runtime.Serialization.ISerializable> 형식은 "콘텐츠 형식", "DataSet 형식" 및 "요소 형식"으로 나누어집니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-267"><xref:System.Runtime.Serialization.ISerializable> types subdivide into "content types", "DataSet types" and "element types".</span></span> <span data-ttu-id="a4041-268">이러한 형식에 대 한 정의는 [데이터 계약의 XML 및 ADO.NET 형식](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="a4041-268">For definitions of these types, see [XML and ADO.NET Types in Data Contracts](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span></span>

<span data-ttu-id="a4041-269">"콘텐츠" 및 "DataSet" 형식은 이전 단원에서 설명한 <xref:System.Array>의 <xref:System.Xml.XmlNode> 개체와 비슷하게 serialize됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-269">"Content" and "DataSet" types are serialized similar to <xref:System.Array> objects of <xref:System.Xml.XmlNode> discussed in the previous section.</span></span> <span data-ttu-id="a4041-270">"콘텐츠" 및 "DataSet" 형식은 이름과 네임스페이스가 해당 형식의 데이터 계약 이름과 네임스페이스에 해당하는 요소에 래핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-270">They are wrapped in an element whose name and namespace corresponds to the data contract name and namespace of the type in question.</span></span>

<span data-ttu-id="a4041-271"><xref:System.Xml.Linq.XElement>와 같은 "요소" 형식은 이 항목의 앞에서 설명한 <xref:System.Xml.XmlElement>와 비슷하게 그대로 serialize됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-271">"Element" types such as <xref:System.Xml.Linq.XElement> are serialized as is, similar to <xref:System.Xml.XmlElement> previously discussed in this topic.</span></span>

### <a name="polymorphism"></a><span data-ttu-id="a4041-272">다형성</span><span class="sxs-lookup"><span data-stu-id="a4041-272">Polymorphism</span></span>

#### <a name="preserving-type-information"></a><span data-ttu-id="a4041-273">형식 정보 유지</span><span class="sxs-lookup"><span data-stu-id="a4041-273">Preserving Type Information</span></span>

<span data-ttu-id="a4041-274">위에서 설명한 것처럼 다형성은 JSON에서 지원되지만 몇 가지 제한 사항이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-274">As stated earlier, polymorphism is supported in JSON with some limitations.</span></span> <span data-ttu-id="a4041-275">JavaScript는 약한 형식의 언어이며 형식 일치는 일반적으로 문제가 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-275">JavaScript is a weakly-typed language and type identity is normally not an issue.</span></span> <span data-ttu-id="a4041-276">그러나 JSON을 사용하여 강력한 형식 시스템(.NET)과 약한 형식 시스템(JavaScript) 간에 통신하는 경우에는 형식 일치를 유지하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-276">However, when using JSON to communicate between a strongly-typed system (.NET) and a weakly-typed system (JavaScript), it is useful to preserve type identity.</span></span> <span data-ttu-id="a4041-277">예를 들어 데이터 계약 이름이 "Shape"인 형식에서 데이터 계약 이름이 "Square"와 "Circle"인 형식이 파생됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-277">For example, types with data contract names "Square" and "Circle" derive from a type with a data contract name of "Shape".</span></span> <span data-ttu-id="a4041-278">"Circle"을 .NET에서 JavaScript로 보낸 다음 나중에 "Shape"이 필요한 .NET 메서드에 반환하는 경우 .NET 측에서 해당 개체가 원래 "Circle"이었음을 알고 있는 것이 좋습니다. 그렇지 않으면 파생 형식에 특정한 정보(예: "Circle"의 "radius" 데이터 멤버)가 손실될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-278">If "Circle" is sent from .NET to JavaScript and is later returned to a .NET method that expects "Shape", it is useful for the .NET side to know that the object in question was originally a "Circle" - otherwise any information specific to the derived type (for example, "radius" data member on "Circle") may be lost.</span></span>

<span data-ttu-id="a4041-279">형식 일치를 유지하려면 복합 형식을 JSON으로 serialize할 때 "형식 힌트"를 추가하면 deserializer가 힌트를 인식하고 적절히 작동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-279">To preserve type identity, when serializing complex types to JSON a "type hint" can be added, and the deserializer recognizes the hint and acts appropriately.</span></span> <span data-ttu-id="a4041-280">"형식 힌트"는 키 이름이 "\_ @ no__t-1 형식" 인 JSON 키/값 쌍입니다 (두 개의 밑줄 뒤에 "type" 단어가 옴).</span><span class="sxs-lookup"><span data-stu-id="a4041-280">The "type hint" is a JSON key/value pair with the key name of "\_\_type" (two underscores followed by the word "type").</span></span> <span data-ttu-id="a4041-281">값은 "DataContractName:DataContractNamespace"(첫 번째 콜론까지는 이름) 형식의 JSON 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-281">The value is a JSON string of the form "DataContractName:DataContractNamespace" (anything up to the first colon is the name).</span></span> <span data-ttu-id="a4041-282">앞의 예제를 사용하면 "Circle"은 다음과 같이 serialize될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-282">Using the earlier example, "Circle" can be serialized as follows.</span></span>

```json
{"__type":"Circle:http://example.com/myNamespace","x":50,"y":70,"radius":10}
```

<span data-ttu-id="a4041-283">형식 암시는 XML 스키마 인스턴스 표준을 통해 정의되고 XML을 serialize/deserialize할 때 사용되는 `xsi:type` 특성과 매우 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-283">The type hint is very similar to the `xsi:type` attribute defined by the XML Schema Instance standard and used when serializing/deserializing XML.</span></span>

<span data-ttu-id="a4041-284">"@No__t-0 @ no__t-1type" 이라는 데이터 멤버는 형식 힌트와의 잠재적 충돌로 인해 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-284">Data members called "\_\_type" are forbidden due to potential conflict with the type hint.</span></span>

#### <a name="reducing-the-size-of-type-hints"></a><span data-ttu-id="a4041-285">형식 암시 크기 줄이기</span><span class="sxs-lookup"><span data-stu-id="a4041-285">Reducing the Size of Type Hints</span></span>

<span data-ttu-id="a4041-286">JSON 메시지의 크기를 줄이기 위해 기본 데이터 계약 네임 스페이스 접두사 (`http://schemas.datacontract.org/2004/07/`)는 "#" 문자로 바뀝니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-286">To reduce the size of JSON messages, the default data contract namespace prefix (`http://schemas.datacontract.org/2004/07/`) is replaced with the "#" character.</span></span> <span data-ttu-id="a4041-287">이 대체를 되돌릴 수 있도록 하기 위해 이스케이프 규칙이 사용 됩니다. 네임 스페이스가 "#" 또는 "\\" 문자로 시작 하는 경우 추가 "\\" 문자가 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-287">(To make this replacement reversible, an escaping rule is used: if the namespace starts with the "#" or "\\" characters, they are appended with an extra "\\" character).</span></span> <span data-ttu-id="a4041-288">따라서 "Circle"이 .NET 네임 스페이스 "MyApp. Shapes"의 형식인 경우 기본 데이터 계약 네임 스페이스는 `http://schemas.datacontract.org/2004/07/MyApp`입니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-288">Thus, if "Circle" is a type in the .NET namespace "MyApp.Shapes", its default data contract namespace is `http://schemas.datacontract.org/2004/07/MyApp`.</span></span> <span data-ttu-id="a4041-289">Shapes와 JSON 표현은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-289">Shapes and the JSON representation is as follows.</span></span>

```json
{"__type":"Circle:#MyApp.Shapes","x":50,"y":70,"radius":10}
```

<span data-ttu-id="a4041-290">잘린 (#MyApp 셰이프)와 전체 (0 @no__t 이름 모두 deserialization에서 인식 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-290">Both the truncated (#MyApp.Shapes) and the full (http://schemas.datacontract.org/2004/07/MyApp.Shapes) names is understood on deserialization.</span></span>

#### <a name="type-hint-position-in-json-objects"></a><span data-ttu-id="a4041-291">JSON 개체의 형식 힌트 위치</span><span class="sxs-lookup"><span data-stu-id="a4041-291">Type Hint Position in JSON Objects</span></span>

<span data-ttu-id="a4041-292">형식 힌트는 JSON 표현에서 맨 처음에 와야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-292">Note that the type hint must appear first in the JSON representation.</span></span> <span data-ttu-id="a4041-293">이 경우에만 JSON 처리에서 키/값 쌍의 순서가 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-293">This is the only case where order of key/value pairs is important in JSON processing.</span></span> <span data-ttu-id="a4041-294">예를 들어 다음은 형식 힌트를 지정하는 올바른 방법이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-294">For example, the following is not a valid way to specify the type hint.</span></span>

```json
{"x":50,"y":70,"radius":10,"__type":"Circle:#MyApp.Shapes"}
```

<span data-ttu-id="a4041-295">WCF 및 ASP.NET AJAX 클라이언트 페이지에서 사용 하는 <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>은 항상 형식 힌트를 먼저 내보냅니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-295">Both the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> used by WCF and ASP.NET AJAX client pages always emit the type hint first.</span></span>

#### <a name="type-hints-apply-only-to-complex-types"></a><span data-ttu-id="a4041-296">형식 힌트는 복합 형식에만 적용</span><span class="sxs-lookup"><span data-stu-id="a4041-296">Type Hints Apply Only to Complex Types</span></span>

<span data-ttu-id="a4041-297">복합 형식이 아닌 경우에는 형식 힌트를 내보낼 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-297">There is no way to emit a type hint for non-complex types.</span></span> <span data-ttu-id="a4041-298">예를 들어, 작업에 <xref:System.Object> 반환 형식이 있지만 Circle을 반환하는 경우 JSON 표현은 앞에서 보여 준 것과 같을 수 있으며 형식 정보는 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-298">For example, if an operation has an <xref:System.Object> return type but returns a Circle, the JSON representation can be as shown earlier and the type information is preserved.</span></span> <span data-ttu-id="a4041-299">그러나 URI가 반환되는 경우 JSON 표현은 문자열이고 URI를 표현하는 데 사용된 문자열은 손실됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-299">However, if Uri is returned, the JSON representation is a string and the fact that the string used to represent a Uri is lost.</span></span> <span data-ttu-id="a4041-300">이것은 기본 형식뿐 아니라 컬렉션 및 배열에도 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-300">This applies not only to primitive types but also to collections and arrays.</span></span>

#### <a name="when-are-type-hints-emitted"></a><span data-ttu-id="a4041-301">형식 힌트를 내보내는 시기</span><span class="sxs-lookup"><span data-stu-id="a4041-301">When Are Type Hints Emitted</span></span>

<span data-ttu-id="a4041-302">형식 힌트는 메시지 크기를 상당히 증가시킬 수 있습니다. 이 문제를 완화하기 위한 한 가지 방법은 가능한 경우 더 짧은 데이터 계약 네임스페이스를 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-302">Type hints may increase message size significantly (one way to mitigate this is to use shorter data contract namespaces if possible).</span></span> <span data-ttu-id="a4041-303">따라서 다음 규칙에 따라 형식 힌트를 내보낼지 여부가 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-303">Therefore, the following rules govern whether type hints are emitted:</span></span>

- <span data-ttu-id="a4041-304">ASP.NET AJAX를 사용하는 경우, 기본/파생 할당이 없을 때(예를 들어 Circle이 Circle에 할당된 경우)에도 가능하면 항상 형식 힌트를 내보냅니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-304">When using ASP.NET AJAX, type hints are always emitted whenever possible, even if there is no base/derived assignment - for example, even if a Circle is assigned to a Circle.</span></span> <span data-ttu-id="a4041-305">이는 정보의 큰 손실 없이 약한 형식 JSON 환경에서 강력한 형식 .NET 환경으로 호출하는 프로세스를 완벽하게 지원하기 위해 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-305">(This is required to fully enable the process of calling from the weakly-typed JSON environment into the strongly-typed .NET environment with no surprising loss of information.)</span></span>

- <span data-ttu-id="a4041-306">ASP.NET과 통합되지 않은 AJAX 서비스를 사용하는 경우에는 기본/파생 할당이 있는 경우에만 형식 힌트를 내보냅니다. 즉, Circle이 Shape 또는 <xref:System.Object>에 할당되었지만 Circle에는 할당되지 않은 경우에 형식 힌트를 내보냅니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-306">When using AJAX services with no ASP.NET integration, type hints are only emitted when there is a base/derived assignment - that is, emitted when Circle is assigned to Shape or <xref:System.Object> but not when assigned to Circle.</span></span> <span data-ttu-id="a4041-307">이를 통해 JavaScript 클라이언트를 올바르게 구현하는 데 필요한 최소 정보가 제공되므로 성능이 향상되지만 잘못 디자인된 클라이언트의 경우 형식 정보 손실을 방지할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-307">This provides the minimum information required to correctly implement a JavaScript client, thus improving performance, but does not protect against type information loss in incorrectly-designed clients.</span></span> <span data-ttu-id="a4041-308">클라이언트에서 이 문제를 처리하지 않으려면 서버에 기본/파생 할당이 없도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-308">Avoid base/derived assignments altogether on the server if you want to avoid dealing with this issue on the client.</span></span>

- <span data-ttu-id="a4041-309"><xref:System.Runtime.Serialization.DataContractSerializer> 형식을 사용하는 경우 `alwaysEmitTypeInformation` 생성자 매개 변수를 사용하면 기본값을 "`false`"(필요한 경우에만 형식 힌트를 내보냄)로 설정하여 앞의 두 모드 간에 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-309">When using the <xref:System.Runtime.Serialization.DataContractSerializer> type, the `alwaysEmitTypeInformation` constructor parameter allows you to choose between the preceding two modes, with the default being "`false`" (only emit type hints when required).</span></span>

#### <a name="duplicate-data-member-names"></a><span data-ttu-id="a4041-310">중복 데이터 멤버 이름</span><span class="sxs-lookup"><span data-stu-id="a4041-310">Duplicate Data Member Names</span></span>

<span data-ttu-id="a4041-311">파생 형식 정보는 기본 형식 정보와 함께 동일한 JSON 개체에 있으며 순서에 구애 받지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-311">Derived type information is present in the same JSON object together with base type information, and can occur in any order.</span></span> <span data-ttu-id="a4041-312">예를 들어 `Shape`은 다음과 같이 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-312">For example, `Shape` may be represented as follows.</span></span>

```json
{"__type":"Shape:#MyApp.Shapes","x":50,"y":70}
```

<span data-ttu-id="a4041-313">반면 Circle은 다음과 같이 표시될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-313">Whereas Circle may be represented as follows.</span></span>

```json
{"__type":"Circle:#MyApp.Shapes","x":50, "radius":10,"y":70}
```

<span data-ttu-id="a4041-314">기본 `Shape` 형식에 "`radius`" 이라는 데이터 멤버가 포함 된 경우 JSON 개체는 반복 키 이름을 가질 수 없기 때문에 serialization에서 충돌을 발생 시킵니다. "radius"가 `Shape.radius` @no__ 또는을 참조 하는지 여부는 명확 하지 않기 때문입니다. t-3).</span><span class="sxs-lookup"><span data-stu-id="a4041-314">If the base `Shape` type also contained a data member called "`radius`", this leads to a collision on both serialization (because JSON objects cannot have repeating key names) and deserialization (because it is unclear whether "radius" refers to `Shape.radius` or `Circle.radius`).</span></span> <span data-ttu-id="a4041-315">그러므로 데이터 계약 클래스에서 "속성 숨기기"(기본 클래스와 파생 클래스에서 동일한 이름의 데이터 멤버)는 일반적으로 권장되지 않으며 JSON의 경우에는 금지됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-315">Therefore, while the concept of "property hiding" (data members of the same name on based and derived classes) is generally not recommended in data contract classes, it is actually forbidden in the case of JSON.</span></span>

#### <a name="polymorphism-and-ixmlserializable-types"></a><span data-ttu-id="a4041-316">다형성 및 IXmlSerializable 형식</span><span class="sxs-lookup"><span data-stu-id="a4041-316">Polymorphism and IXmlSerializable Types</span></span>

<span data-ttu-id="a4041-317"><xref:System.Xml.Serialization.IXmlSerializable> 형식은 보통 일반 데이터 계약 규칙에 따라 알려진 형식 요구 사항을 충족하는 한 서로 다형적으로 할당될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-317"><xref:System.Xml.Serialization.IXmlSerializable> types may be polymorphically assigned to each other as usual as long as Known Types requirements are met, according to usual data contract rules.</span></span> <span data-ttu-id="a4041-318">그러나 <xref:System.Xml.Serialization.IXmlSerializable> 대신 <xref:System.Object> 형식을 serialize하면 JSON 문자열이 되므로 형식 정보가 손실됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-318">However, serializing an <xref:System.Xml.Serialization.IXmlSerializable> type in place of <xref:System.Object> results in loss of type information as the result is a JSON string.</span></span>

#### <a name="polymorphism-and-certain-interface-types"></a><span data-ttu-id="a4041-319">다형성 및 특정 인터페이스 형식</span><span class="sxs-lookup"><span data-stu-id="a4041-319">Polymorphism and Certain Interface Types</span></span>

<span data-ttu-id="a4041-320">컬렉션 형식 또는 <xref:System.Xml.Serialization.IXmlSerializable>이 아닌 비컬렉션 형식(<xref:System.Xml.Serialization.IXmlSerializable> 예외)이 필요한 <xref:System.Object>을 구현하는 형식은 serialize할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-320">It is forbidden to serialize a collection type or a type that implements <xref:System.Xml.Serialization.IXmlSerializable> where a non-collection type that is not <xref:System.Xml.Serialization.IXmlSerializable> (except for <xref:System.Object>) is expected.</span></span> <span data-ttu-id="a4041-321">예를 들어 `IMyInterface` 이라는 사용자 지정 인터페이스와 `int` 및 @no__t 형식의 <xref:System.Collections.Generic.IEnumerable%601>를 모두 구현 하는 형식 `MyType`입니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-321">For example, a custom interface called `IMyInterface` and a type `MyType` that implement both <xref:System.Collections.Generic.IEnumerable%601> of type `int` and `IMyInterface`.</span></span> <span data-ttu-id="a4041-322">반환 형식이 `IMyInterface` 인 작업에서 `MyType`을 반환할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-322">It is forbidden to return `MyType` from an operation whose return type is `IMyInterface`.</span></span> <span data-ttu-id="a4041-323">이는 `MyType`은 JSON 배열로 serialize 되어야 하며 형식 힌트가 필요 하기 때문입니다. 앞에서 설명한 것 처럼 복합 형식만 포함 하 여 배열에 형식 힌트를 포함할 수 없기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-323">This is because `MyType` must be serialized as a JSON array and requires a type hint, and as stated before you cannot include a type hint with arrays, only with complex types.</span></span>

#### <a name="known-types-and-configuration"></a><span data-ttu-id="a4041-324">알려진 형식 및 구성</span><span class="sxs-lookup"><span data-stu-id="a4041-324">Known Types and Configuration</span></span>

<span data-ttu-id="a4041-325"><xref:System.Runtime.Serialization.DataContractSerializer>에서 사용되는 알려진 형식 메커니즘은 <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>에서도 동일한 방식으로 모두 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-325">All of the Known Type mechanisms used by the <xref:System.Runtime.Serialization.DataContractSerializer> are also supported in the same way by the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span></span> <span data-ttu-id="a4041-326">두 serializer는 동일한 구성 요소인 [\<dataContractSerializer >](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) 를 [\<bdbs >](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md)에 읽고 구성 파일을 통해 추가 된 알려진 형식을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-326">Both serializers read the same configuration element, [\<dataContractSerializer>](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) in [\<system.runtime.serialization>](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md), to discover known types added through a configuration file.</span></span>

#### <a name="collections-assigned-to-object"></a><span data-ttu-id="a4041-327">개체에 할당된 컬렉션</span><span class="sxs-lookup"><span data-stu-id="a4041-327">Collections Assigned to Object</span></span>

<span data-ttu-id="a4041-328">개체에 할당된 컬렉션은 <xref:System.Collections.Generic.IEnumerable%601>을 구현하는 컬렉션인 것처럼 serialize됩니다(복합 형식인 경우 각 항목에 형식 힌트가 있는 JSON 배열).</span><span class="sxs-lookup"><span data-stu-id="a4041-328">Collections assigned to Object are serialized as if they are collections that implement <xref:System.Collections.Generic.IEnumerable%601>: a JSON array with each entry that has a type hint if it is a complex type.</span></span> <span data-ttu-id="a4041-329">예를 들어 <xref:System.Object>에 할당 된 @no__t 형식의 <xref:System.Collections.Generic.List%601>은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-329">For example, a <xref:System.Collections.Generic.List%601> of type `Shape` assigned to <xref:System.Object> looks like the following.</span></span>

```json
[{"__type":"Shape:#MyApp.Shapes","x":50,"y":70},
{"__type":"Shape:#MyApp.Shapes","x":58,"y":73},
{"__type":"Shape:#MyApp.Shapes","x":41,"y":32}]
```

<span data-ttu-id="a4041-330"><xref:System.Object>로 다시 deserialize하는 경우:</span><span class="sxs-lookup"><span data-stu-id="a4041-330">When deserialized back into <xref:System.Object>:</span></span>

- <span data-ttu-id="a4041-331">`Shape`은 알려진 형식 목록에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-331">`Shape` must be in the Known Types list.</span></span> <span data-ttu-id="a4041-332">알려진 형식에서-1 @no__t 형식의 <xref:System.Collections.Generic.List%601> 인 경우에는 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-332">Having <xref:System.Collections.Generic.List%601> of type `Shape` in known types has no effect.</span></span> <span data-ttu-id="a4041-333">이 경우에는 serialization에서 알려진 형식에 `Shape`을 추가할 필요가 없습니다 .이 작업은 자동으로 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-333">Note that you do not have to add `Shape` to known types on serialization in this case - this is done automatically.</span></span>

- <span data-ttu-id="a4041-334">컬렉션은 `Shape` 인스턴스를 포함 하는 <xref:System.Object> 형식의 <xref:System.Array>으로 deserialize 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-334">The collection is deserialized as an <xref:System.Array> of type <xref:System.Object> that contains `Shape` instances.</span></span>

#### <a name="derived-collections-assigned-to-base-collections"></a><span data-ttu-id="a4041-335">기본 컬렉션에 할당된 파생 컬렉션</span><span class="sxs-lookup"><span data-stu-id="a4041-335">Derived Collections Assigned to Base Collections</span></span>

<span data-ttu-id="a4041-336">파생 컬렉션을 기본 컬렉션에 할당하면, 일반적으로 기본 형식의 컬렉션인 것처럼 컬렉션이 serialize됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-336">When a derived collection is assigned to a base collection, the collection is usually serialized as if it was a collection of the base type.</span></span> <span data-ttu-id="a4041-337">그러나 파생 컬렉션의 항목 형식을 기본 컬렉션의 항목 형식에 할당할 수 없는 경우 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-337">However, if the item type of the derived collection cannot be assigned to the item type of the base collection, an exception is thrown.</span></span>

#### <a name="type-hints-and-dictionaries"></a><span data-ttu-id="a4041-338">형식 힌트 및 사전</span><span class="sxs-lookup"><span data-stu-id="a4041-338">Type Hints and Dictionaries</span></span>

<span data-ttu-id="a4041-339">사전을 <xref:System.Object>에 할당하면 사전의 각 Key 및 Value 항목이 <xref:System.Object>에 할당된 것처럼 처리되고 형식 힌트를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-339">When a dictionary is assigned to an <xref:System.Object>, each Key and Value entry in the dictionary is treated as if it was assigned to <xref:System.Object> and gets a type hint.</span></span>

<span data-ttu-id="a4041-340">사전 형식을 serialize하는 경우 "Key" 및 "Value" 멤버를 포함하는 JSON 개체는 `alwaysEmitTypeInformation` 설정의 영향을 받지 않고 이전 컬렉션 규칙에서 요구하는 경우에만 형식 힌트를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-340">When serializing dictionary types, the JSON object that contains the "Key" and "Value" members is unaffected by the `alwaysEmitTypeInformation` setting and only contains a type hint when the preceding collection rules require it.</span></span>

### <a name="valid-json-key-names"></a><span data-ttu-id="a4041-341">유효한 JSON 키 이름</span><span class="sxs-lookup"><span data-stu-id="a4041-341">Valid JSON Key Names</span></span>

<span data-ttu-id="a4041-342">serializer는 유효한 XML 이름이 아닌 키 이름을 XML 인코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-342">The serializer XML-encodes key names that are not valid XML names.</span></span> <span data-ttu-id="a4041-343">예를 들어 이름이 "123" 인 데이터 멤버에는 "123"가 잘못 된 XML 요소 이름 (숫자로 시작) 이기 때문에 "\_x0031 @ no__t-1 @ no__t-2x0032 @ no__t-3 @ no__t-4x0033 @ no__t-5"와 같이 인코딩된 이름이 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-343">For example, a data member with the name of "123" would have an encoded name such as "\_x0031\_\_x0032\_\_x0033\_" because "123" is an invalid XML element name (starts with a digit).</span></span> <span data-ttu-id="a4041-344">XML 이름에 유효하지 않은 일부 국제 문자 집합이 포함되는 경우에도 비슷한 상황이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a4041-344">A similar situation may arise with some international character sets not valid in XML names.</span></span> <span data-ttu-id="a4041-345">JSON 처리의 이러한 XML 효과에 대 한 설명은 [json과 Xml 간의 매핑](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="a4041-345">For an explanation of this effect of XML on JSON processing, see [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="a4041-346">참조</span><span class="sxs-lookup"><span data-stu-id="a4041-346">See also</span></span>

- [<span data-ttu-id="a4041-347">JSON 및 기타 데이터 전송 형식에 대한 지원</span><span class="sxs-lookup"><span data-stu-id="a4041-347">Support for JSON and Other Data Transfer Formats</span></span>](../../../../docs/framework/wcf/feature-details/support-for-json-and-other-data-transfer-formats.md)
