---
title: 성능 카운터 및 In-Process Side-By-Side 애플리케이션
description: .NET에서 성능 카운터 및 in-process side-by-side 응용 프로그램을 검토 합니다. 런타임 별로 성능 카운터를 구분 하려면 Perfmon.exe을 사용 합니다.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- performance counters
- performance counters,and in-process side-by-side applications
- performance,.NET Framework applications
- performance monitoring,counters
ms.assetid: 6888f9be-c65b-4b03-a07b-df7ebdee2436
ms.openlocfilehash: eb05d9f5f930420827c6b3d94ea0ed34f64464fd
ms.sourcegitcommit: c23d9666ec75b91741da43ee3d91c317d68c7327
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/01/2020
ms.locfileid: "85803861"
---
# <a name="performance-counters-and-in-process-side-by-side-applications"></a><span data-ttu-id="f2019-104">성능 카운터 및 In-Process Side-By-Side 애플리케이션</span><span class="sxs-lookup"><span data-stu-id="f2019-104">Performance Counters and In-Process Side-By-Side Applications</span></span>
<span data-ttu-id="f2019-105">성능 모니터(Perfmon.exe)를 사용하면 런타임별로 성능 카운터를 구분할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2019-105">Using the Performance Monitor (Perfmon.exe), it is possible to differentiate the performance counters on a per-runtime basis.</span></span> <span data-ttu-id="f2019-106">이 항목에서는 이 기능을 사용하는 데 필요한 레지스트리 변경 사항에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="f2019-106">This topic describes the registry change needed to enable this functionality.</span></span>  
  
## <a name="the-default-behavior"></a><span data-ttu-id="f2019-107">기본 동작</span><span class="sxs-lookup"><span data-stu-id="f2019-107">The Default Behavior</span></span>  
 <span data-ttu-id="f2019-108">기본적으로 성능 모니터는 애플리케이션별로 성능 카운터를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="f2019-108">By default, the Performance Monitor displays performance counters on a per-application basis.</span></span> <span data-ttu-id="f2019-109">그러나 이 동작이 문제가 될 수 있는 두 가지 시나리오가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2019-109">However, there are two scenarios in which this is problematic:</span></span>  
  
- <span data-ttu-id="f2019-110">이름이 동일한 두 개의 애플리케이션을 모니터링하는 경우.</span><span class="sxs-lookup"><span data-stu-id="f2019-110">When you monitor two applications that have the same name.</span></span> <span data-ttu-id="f2019-111">예를 들어 두 애플리케이션의 이름을 모두 myapp.exe로 지정하면 **인스턴스** 열에 하나는 **myapp**으로 표시되고 다른 하나는 **myapp#1**오 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="f2019-111">For example, if both applications are named myapp.exe, one will be displayed as **myapp** and the other as **myapp#1** in the **Instance** column.</span></span> <span data-ttu-id="f2019-112">이 경우 성능 카운터를 특정 애플리케이션과 일치시키는 것은 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="f2019-112">In this case, it is difficult to match a performance counter to a particular application.</span></span> <span data-ttu-id="f2019-113">**myapp#1**용으로 수집한 데이터가 첫 번째 myapp.exe를 참조하는지 아니면 두 번째 myapp.exe를 참조하는지 명확하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f2019-113">It is not clear whether the data collected for **myapp#1** refers to the first myapp.exe or the second myapp.exe.</span></span>  
  
- <span data-ttu-id="f2019-114">애플리케이션에서 공용 언어 런타임의 인스턴스를 여러 개 사용하는 경우.</span><span class="sxs-lookup"><span data-stu-id="f2019-114">When an application uses multiple instances of the common language runtime.</span></span> <span data-ttu-id="f2019-115">.NET Framework 4는 in-process side-by-side 호스팅 시나리오를 지원 합니다. 즉, 단일 프로세스나 응용 프로그램에서 공용 언어 런타임의 인스턴스를 여러 개 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2019-115">The .NET Framework 4 supports in-process side-by-side hosting scenarios; that is, a single process or application can load multiple instances of the common language runtime.</span></span> <span data-ttu-id="f2019-116">myapp.exe라는 단일 애플리케이션에서 두 개의 런타임 인스턴스를 로드하는 경우 기본적으로 **Instance** 열이 **myapp** 및 **myapp#1**로 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="f2019-116">If a single application named myapp.exe loads two runtime instances, by default, they will be designated in the **Instance** column as **myapp** and **myapp#1**.</span></span> <span data-ttu-id="f2019-117">이 경우 **myapp** 및 **myapp#1**이 이름이 같은 두 애플리케이션을 나타내는지 아니면 런타임이 두 개인 동일한 애플리케이션을 나타내는지 명확하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f2019-117">In this case, it is not clear whether **myapp** and **myapp#1** refer to two applications with the same name, or to the same application with two runtimes.</span></span> <span data-ttu-id="f2019-118">이름이 같은 여러 애플리케이션에서 여러 런타임을 로드하는 경우 모호성은 더 커집니다.</span><span class="sxs-lookup"><span data-stu-id="f2019-118">If multiple applications with the same name load multiple runtimes, the ambiguity is even greater.</span></span>  
  
 <span data-ttu-id="f2019-119">이 모호성을 제거하기 위해 레지스트리 키를 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2019-119">You can set a registry key to eliminate this ambiguity.</span></span> <span data-ttu-id="f2019-120">.NET Framework 4를 사용 하 여 개발 된 응용 프로그램의 경우이 레지스트리 변경 내용에 따라 **인스턴스** 열의 응용 프로그램 이름에 프로세스 식별자와 런타임 인스턴스 식별자가 차례로 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f2019-120">For applications developed using the .NET Framework 4, this registry change adds a process identifier followed by a runtime instance identifier to the application name in the **Instance** column.</span></span> <span data-ttu-id="f2019-121">*응용 프로그램 또는* 응용 *프로그램 #1 대신*응용 프로그램은 이제 *application* `p` *processID* \_ `r` **Instance** 열에서 application _ processID*runtimeID* 로 식별 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f2019-121">Instead of *application* or *application*#1, the application is now identified as *application*_`p`*processID*\_`r`*runtimeID* in the **Instance** column.</span></span> <span data-ttu-id="f2019-122">응용 프로그램이 이전 버전의 공용 언어 런타임을 사용 하 여 개발 된 경우 해당 인스턴스는 .NET Framework 4가 설치 된 경우 \*응용 프로그램 \_ \*processID로 표시 됩니다 `p` *processID* .</span><span class="sxs-lookup"><span data-stu-id="f2019-122">If an application was developed using a previous version of the common language runtime, that instance is represented as *application\_*`p`*processID* provided that the .NET Framework 4 is installed.</span></span>  
  
## <a name="performance-counters-for-in-process-side-by-side-applications"></a><span data-ttu-id="f2019-123">In-Process Side-by-Side 애플리케이션의 성능 카운터</span><span class="sxs-lookup"><span data-stu-id="f2019-123">Performance Counters for In-Process Side-by-Side Applications</span></span>  
 <span data-ttu-id="f2019-124">단일 애플리케이션에서 호스팅되는 여러 공용 언어 런타임 버전의 성능 카운터를 처리하려면 다음 표에 표시된 대로 단일 레지스트리 키 설정을 변경해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f2019-124">To handle performance counters for multiple common language runtime versions that are hosted in a single application, you must change a single registry key setting, as shown in the following table.</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f2019-125">키 이름</span><span class="sxs-lookup"><span data-stu-id="f2019-125">Key name</span></span>|<span data-ttu-id="f2019-126">HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\\.NETFramework\Performance</span><span class="sxs-lookup"><span data-stu-id="f2019-126">HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\\.NETFramework\Performance</span></span>|  
|<span data-ttu-id="f2019-127">값 이름</span><span class="sxs-lookup"><span data-stu-id="f2019-127">Value name</span></span>|<span data-ttu-id="f2019-128">ProcessNameFormat</span><span class="sxs-lookup"><span data-stu-id="f2019-128">ProcessNameFormat</span></span>|  
|<span data-ttu-id="f2019-129">값 형식</span><span class="sxs-lookup"><span data-stu-id="f2019-129">Value type</span></span>|<span data-ttu-id="f2019-130">REG_DWORD</span><span class="sxs-lookup"><span data-stu-id="f2019-130">REG_DWORD</span></span>|  
|<span data-ttu-id="f2019-131">값</span><span class="sxs-lookup"><span data-stu-id="f2019-131">Value</span></span>|<span data-ttu-id="f2019-132">1 (0x00000001)</span><span class="sxs-lookup"><span data-stu-id="f2019-132">1 (0x00000001)</span></span>|  
  
 <span data-ttu-id="f2019-133">`ProcessNameFormat`의 값이 0이면 기본 동작이 사용되는 것을 나타냅니다. 즉, Perfmon.exe에서 애플리케이션별로 성능 카운터를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="f2019-133">A value of 0 for `ProcessNameFormat` indicates that the default behavior is enabled; that is, Perfmon.exe displays performance counters on a per-application basis.</span></span> <span data-ttu-id="f2019-134">이 값을 1로 설정하면 Perfmon.exe에서 여러 버전의 애플리케이션을 명확하게 구분하고 런타임별로 성능 카운터를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f2019-134">When you set this value to 1, Perfmon.exe disambiguates multiple versions of an application and provides performance counters on a per-runtime basis.</span></span> <span data-ttu-id="f2019-135">`ProcessNameFormat` 레지스트리 키 설정의 다른 값은 지원되지 않으며 나중에 사용하도록 예약됩니다.</span><span class="sxs-lookup"><span data-stu-id="f2019-135">Any other value for the `ProcessNameFormat` registry key setting is unsupported and reserved for future use.</span></span>  
  
 <span data-ttu-id="f2019-136">새로운 인스턴스 이름 지정 기능이 제대로 작동하도록 `ProcessNameFormat` 레지스트리 키 설정을 업데이트한 다음 Perfmon.exe 또는 성능 카운터의 다른 소비자를 다시 시작해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f2019-136">After you update the `ProcessNameFormat` registry key setting, you must restart Perfmon.exe or any other consumers of performance counters so that the new instance naming feature works correctly.</span></span>  
  
 <span data-ttu-id="f2019-137">다음 예제에서는 프로그래밍 방식으로 `ProcessNameFormat` 값을 변경하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f2019-137">The following example shows how to change the `ProcessNameFormat` value programmatically.</span></span>  
  
 [!code-csharp[Conceptual.PerfCounters.InProSxS#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.perfcounters.inprosxs/cs/regsetting1.cs#1)]
 [!code-vb[Conceptual.PerfCounters.InProSxS#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.perfcounters.inprosxs/vb/regsetting1.vb#1)]  
  
 <span data-ttu-id="f2019-138">이 레지스트리를 변경 하면 Perfmon.exe .NET Framework 4를 대상으로 하는 응용 프로그램의 *이름이 응용 프로그램 _* processid runtimeID로 표시 됩니다. `p` *processID* \_ `r` *runtimeID*여기서 *application* 은 응용 프로그램의 이름이 고, *processID* 는 응용 프로그램의 프로세스 식별자 이며, *runtimeID* 는 공용 언어 런타임 식별자입니다.</span><span class="sxs-lookup"><span data-stu-id="f2019-138">When you make this registry change, Perfmon.exe displays the names of applications that target the .NET Framework 4 as *application*_`p`*processID*\_`r`*runtimeID*, where *application* is the name of the application, *processID* is the application's process identifier, and *runtimeID* is a common language runtime identifier.</span></span> <span data-ttu-id="f2019-139">예를 들어 myapp.exe라는 애플리케이션에서 공용 언어 런타임의 인스턴스를 두 개 로드하는 경우 Perfmon.exe에서는 하나의 인스턴스를 myapp_p1416_r10으로 식별하고 두 번째는 myapp_p3160_r10으로 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="f2019-139">For example, if an application named myapp.exe loads two instances of the common language runtime, Perfmon.exe may identify one instance as myapp_p1416_r10 and the second as myapp_p3160_r10.</span></span> <span data-ttu-id="f2019-140">런타임 ID는 프로세스에 있는 런타임만 구분합니다. 런타임에 대한 다른 정보는 제공하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f2019-140">The runtime identifier only disambiguates the runtimes within a process; it does not provide any other information about the runtime.</span></span> <span data-ttu-id="f2019-141">(예를 들어, 런타임 ID는 버전이나 런타임의 SKU와 아무 관계가 없습니다.)</span><span class="sxs-lookup"><span data-stu-id="f2019-141">(For example, the runtime ID has no relation to the version or the SKU of the runtime.)</span></span>  
  
 <span data-ttu-id="f2019-142">.NET Framework 4가 설치 되어 있는 경우 레지스트리 변경 내용은 이전 버전의 .NET Framework를 사용 하 여 개발 된 응용 프로그램에도 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f2019-142">If the .NET Framework 4 is installed, the registry change also affects applications that were developed using earlier versions of the .NET Framework.</span></span> <span data-ttu-id="f2019-143">이러한 Perfmon.exe *application_* processID로 표시 됩니다. `p` *processID*여기서 *응용* 프로그램은 응용 프로그램 이름이 고 *processID* 는 프로세스 식별자입니다.</span><span class="sxs-lookup"><span data-stu-id="f2019-143">These appear in Perfmon.exe as *application_*`p`*processID*, where *application* is the application name and *processID* is the process identifier.</span></span> <span data-ttu-id="f2019-144">예를 들어, myapp.exe라는 두 애플리케이션의 성능 카운터를 모니터하는 경우 하나는 myapp_p23900으로 표시되고 다른 하나는 myapp_p24908로 표시될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2019-144">For example, if the performance counters of two applications named myapp.exe are monitored, one might appear as myapp_p23900 and the other as myapp_p24908.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="f2019-145">프로세스 식별자를 사용하면 이전 버전의 런타임을 사용하는 이름이 동일한 두 애플리케이션을 확인할 때 모호성이 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="f2019-145">The process identifier eliminates the ambiguity of resolving two applications with the same name that use earlier versions of the runtime.</span></span> <span data-ttu-id="f2019-146">이전 버전의 공용 언어 런타임에서는 병렬 시나리오를 지원하지 않으므로 이전 버전에는 런타임 ID가 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f2019-146">A runtime identifier is not required for previous versions, because previous versions of the common language runtime do not support side-by-side scenarios.</span></span>  
  
 <span data-ttu-id="f2019-147">.NET Framework 4가 없거나 제거 된 경우 레지스트리 키를 설정 해도 아무런 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f2019-147">If the .NET Framework 4 is not present or was uninstalled, setting the registry key has no effect.</span></span> <span data-ttu-id="f2019-148">즉, 이름이 같은 두 개의 애플리케이션이 Perfmon.exe에 계속 *application* 및 *application#1*(예: **myapp** 및 **myapp#1**)로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="f2019-148">This means that two applications with the same name will continue to appear in Perfmon.exe as *application* and *application#1* (for example, as **myapp** and **myapp#1**).</span></span>
