---
title: .NET Framework 4 마이그레이션 문제
ms.date: 05/02/2017
helpviewer_keywords:
- .NET Framework 4, migration
- application compatibility
ms.assetid: df478548-8c05-4de2-8ba7-adcdbe1c2a60
ms.openlocfilehash: c1c3298d87ad0f481fa30182e40cd5edcd535d6a
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/15/2020
ms.locfileid: "73975614"
---
# <a name="net-framework-4-migration-issues"></a><span data-ttu-id="73c1f-102">.NET Framework 4 마이그레이션 문제</span><span class="sxs-lookup"><span data-stu-id="73c1f-102">.NET Framework 4 migration issues</span></span>

<span data-ttu-id="73c1f-103">이 항목에서는 수정, 표준 준수 및 보안에 대한 변경 내용, 고객 피드백 기반의 변경 내용을 포함하여 .NET Framework 버전 3.5 서비스 팩 1과 .NET Framework 버전 4 간의 마이그레이션 문제에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-103">This topic describes migration issues between the .NET Framework version 3.5 Service Pack 1 and the .NET Framework version 4, including fixes, changes for standards compliance and security, and changes based on customer feedback.</span></span> <span data-ttu-id="73c1f-104">이러한 변경 내용은 대부분 애플리케이션에서 프로그래밍을 수정할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-104">Most of these changes do not require any programming modifications in your applications.</span></span> <span data-ttu-id="73c1f-105">수정이 필요한 경우 표의 권장 변경 내용 열을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-105">For those that may involve modifications, see the Recommended changes column of the table.</span></span> <span data-ttu-id="73c1f-106">중요한 변경 내용은 ASP.NET 및 WPF(Windows Presentation Foundation)와 같이 영역별로 세분화되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-106">Notable changes are broken down by area, for example, ASP.NET and Windows Presentation Foundation (WPF).</span></span>

<span data-ttu-id="73c1f-107">이 항목의 문제에 대한 좀 더 간략한 개요는 [.NET Framework 4 마이그레이션 가이드](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ff657133%28v=vs.100%29)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-107">For a higher-level overview of the issues in this topic, see the [Migration Guide to the .NET Framework 4](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ff657133%28v=vs.100%29).</span></span>

<span data-ttu-id="73c1f-108">새로운 기능에 대한 자세한 내용은 [.NET Framework 4의 새로운 기능](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms171868%28v=vs.100%29)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-108">For information about new features, see [What's New in the .NET Framework 4](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms171868%28v=vs.100%29).</span></span>

## <a name="aspnet-and-web"></a><span data-ttu-id="73c1f-109">ASP.NET 및 웹</span><span class="sxs-lookup"><span data-stu-id="73c1f-109">ASP.NET and Web</span></span>

<span data-ttu-id="73c1f-110">네임스페이스: <xref:System.Web>, <xref:System.Web.Mobile>, <xref:System.Web.Security>, <xref:System.Web.UI.WebControls>; 어셈블리: System.Web(System.Web.dll의)</span><span class="sxs-lookup"><span data-stu-id="73c1f-110">Namespaces: <xref:System.Web>, <xref:System.Web.Mobile>, <xref:System.Web.Security>, <xref:System.Web.UI.WebControls>; assembly: System.Web (in System.Web.dll)</span></span>

| <span data-ttu-id="73c1f-111">기능</span><span class="sxs-lookup"><span data-stu-id="73c1f-111">Feature</span></span> | <span data-ttu-id="73c1f-112">3\.5 SP1과의 차이점</span><span class="sxs-lookup"><span data-stu-id="73c1f-112">Differences from 3.5 SP1</span></span> | <span data-ttu-id="73c1f-113">권장 변경 내용</span><span class="sxs-lookup"><span data-stu-id="73c1f-113">Recommended changes</span></span> |
| ------- | ------------------------ | ------------------- |
| <span data-ttu-id="73c1f-114">**브라우저 정의 파일**</span><span class="sxs-lookup"><span data-stu-id="73c1f-114">**Browser definition files**</span></span> | <span data-ttu-id="73c1f-115">브라우저 정의 파일은 새롭고 업데이트된 브라우저 및 디바이스에 대한 정보를 포함하도록 업데이트되었습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-115">The browser definition files have been updated to include information about new and updated browsers and devices.</span></span> <span data-ttu-id="73c1f-116">Netscape Navigator와 같은 오래된 브라우저와 디바이스는 제거되었으며 Google Chrome 및 Apple iPhone과 같은 최신 브라우저와 디바이스가 추가되었습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-116">Older browsers and devices such as Netscape Navigator have been removed, and newer browsers and devices such as Google Chrome and Apple iPhone have been added.</span></span><br><br><span data-ttu-id="73c1f-117">애플리케이션에 제거된 브라우저 정의 중 하나를 상속하는 사용자 지정 브라우저 정의가 포함되어 있으면 오류가 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-117">If your application contains custom browser definitions that inherit from one of the browser definitions that have been removed, you will see an error.</span></span><br><br><span data-ttu-id="73c1f-118"><xref:System.Web.HttpBrowserCapabilities> 개체(페이지의 `Request.Browse` 속성에 의해 노출됨)는 브라우저 정의 파일에 의해 구동됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-118">The <xref:System.Web.HttpBrowserCapabilities> object (which is exposed by the page's `Request.Browse` property) is driven by the browser definition files.</span></span> <span data-ttu-id="73c1f-119">따라서 ASP.NET 4에서 이 개체의 속성에 액세스하여 반환되는 정보는 이전 버전의 ASP.NET에서 반환된 정보와 다를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-119">Therefore, the information that is returned by accessing a property of this object in ASP.NET 4 might be different than the information that was returned in an earlier version of ASP.NET.</span></span> | <span data-ttu-id="73c1f-120">애플리케이션에서 이전 브라우저 정의 파일을 사용하는 경우 다음 폴더에서 해당 파일을 복사할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-120">If your application relies on the old browser definition files, you can copy them from the following folder:</span></span><br><br><span data-ttu-id="73c1f-121">*Windows\\Microsoft.NET\\Framework\\v2.0.50727\\CONFIG\\Browsers*</span><span class="sxs-lookup"><span data-stu-id="73c1f-121">*Windows\\Microsoft.NET\\Framework\\v2.0.50727\\CONFIG\\Browsers*</span></span><br><br><span data-ttu-id="73c1f-122">ASP.NET 4의 해당 *\\CONFIG\\Browsers* 폴더에 파일을 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-122">Copy the files into the corresponding *\\CONFIG\\Browsers* folder for ASP.NET 4.</span></span> <span data-ttu-id="73c1f-123">파일을 복사한 후 [Aspnet_regbrowsers.exe](https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms229858(v=vs.90)) 명령줄 도구를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-123">After you copy the files, run the [Aspnet_regbrowsers.exe](https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms229858(v=vs.90)) command-line tool.</span></span> <span data-ttu-id="73c1f-124">자세한 내용은 [https://www.asp.net/mobile](/aspnet/mobile/overview) 웹 사이트를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-124">For more information, see the [https://www.asp.net/mobile](/aspnet/mobile/overview) Web site.</span></span> |
| <span data-ttu-id="73c1f-125">**혼합된 버전의 ASP.NET에서 실행 중인 자식 애플리케이션**</span><span class="sxs-lookup"><span data-stu-id="73c1f-125">**Child applications running under mixed versions of ASP.NET**</span></span> | <span data-ttu-id="73c1f-126">이전 버전의 ASP.NET을 실행하는 애플리케이션의 자식으로서 구성된 ASP.NET 4 애플리케이션은 구성 또는 컴파일 오류로 인해 시작하지 못할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-126">ASP.NET 4 applications that are configured as children of applications that run earlier versions of ASP.NET might fail to start because of configuration or compilation errors.</span></span> <span data-ttu-id="73c1f-127">발생하는 특정 오류는 애플리케이션이 IIS 6.0에서 실행되는지 아니면 IIS 7 또는 IIS 7.5에서 실행되는지에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-127">The specific error that occurs depends on whether the application runs under IIS 6.0, or under IIS 7 or IIS 7.5.</span></span> | <span data-ttu-id="73c1f-128">구성 시스템이 ASP.NET 4 애플리케이션을 올바르게 인식할 수 있도록 영향을 받는 애플리케이션의 구성 파일을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-128">You can make changes to the configuration files of the affected applications so that the configuration system correctly recognizes the ASP.NET 4 application.</span></span> <span data-ttu-id="73c1f-129">반드시 수행해야 할 변경 내용에 대한 자세한 내용은 ASP.NET 웹 사이트에 있는 [ASP.NET 4 Breaking Changes](/aspnet/whitepapers/aspnet4/breaking-changes)(ASP.NET 4 주요 변경 내용) 문서의 “ASP.NET 4 Child Applications Fail to Start When Under ASP.NET 2.0 or ASP.NET 3.5 Applications”(ASP.NET 4 자식 애플리케이션이 ASP.NET 2.0 또는 ASP.NET 3.5 애플리케이션에서 시작되지 않음) 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-129">For information about the changes you must make, see the section "ASP.NET 4 Child Applications Fail to Start When Under ASP.NET 2.0 or ASP.NET 3.5 Applications" in the document [ASP.NET 4 Breaking Changes](/aspnet/whitepapers/aspnet4/breaking-changes) on the ASP.NET Web site.</span></span> |
| <span data-ttu-id="73c1f-130">**ClientID 변경 내용**</span><span class="sxs-lookup"><span data-stu-id="73c1f-130">**ClientID changes**</span></span> | <span data-ttu-id="73c1f-131">ASP.NET 4의 새로운 `clientIDMode` 설정을 통해 ASP.NET이 HTML 요소에 대해 `id` 특성을 생성하는 방법을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-131">The new `clientIDMode` setting in ASP.NET 4 lets you specify how ASP.NET generates the `id` attribute for HTML elements.</span></span> <span data-ttu-id="73c1f-132">ASP.NET의 이전 버전에서는 기본 동작이 `clientIDMode`의 `AutoID` 설정과 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-132">In previous versions of ASP.NET, the default behavior was equivalent to the `AutoID` setting of `clientIDMode`.</span></span> <span data-ttu-id="73c1f-133">이제 기본 설정은 `Predictable`입니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-133">The default setting is now `Predictable`.</span></span> <span data-ttu-id="73c1f-134">자세한 내용은 [ASP.NET 웹 서버 컨트롤 식별](https://docs.microsoft.com/previous-versions/aspnet/1d04y8ss%28v=vs.100%29)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-134">For more information, see [ASP.NET Web Server Control Identification](https://docs.microsoft.com/previous-versions/aspnet/1d04y8ss%28v=vs.100%29).</span></span> | <span data-ttu-id="73c1f-135">Visual Studio를 사용하여 ASP.NET 2.0 또는 ASP.NET 3.5에서 애플리케이션을 업그레이드하는 경우, .NET Framework 이전 버전의 동작을 유지하는 Web.config 파일에 설정이 자동으로 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-135">If you use Visual Studio to upgrade your application from ASP.NET 2.0 or ASP.NET 3.5, the tool automatically adds a setting to the Web.config file that preserves the behavior of earlier versions of the .NET Framework.</span></span> <span data-ttu-id="73c1f-136">그러나 .NET Framework 4를 대상으로 하도록 IIS에서 애플리케이션 풀을 변경하여 애플리케이션을 업그레이드하는 경우 ASP.NET은 기본적으로 새 모드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-136">However, if you upgrade an application by changing the application pool in IIS to target the .NET Framework 4, ASP.NET uses the new mode by default.</span></span> <span data-ttu-id="73c1f-137">새 클라이언트 ID 모드를 사용하지 않으려면 Web.config 파일에 다음 설정을 추가하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-137">To disable the new client ID mode, add the following setting to the Web.config file:</span></span><br><br>`<pages clientIDMode="AutoID" />` |
| <span data-ttu-id="73c1f-138">**CAS(코드 액세스 보안)**</span><span class="sxs-lookup"><span data-stu-id="73c1f-138">**Code access security (CAS)**</span></span> | <span data-ttu-id="73c1f-139">ASP.NET 3.5에 추가된 ASP.NET 2.0 NET 기능은 .NET Framework 1.1 및 .NET Framework 2.0 CAS(코드 액세스 보안) 모델을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-139">ASP.NET 2.0 NET features that were added in ASP.NET 3.5 use the .NET Framework 1.1 and .NET Framework 2.0 code access security (CAS) model.</span></span> <span data-ttu-id="73c1f-140">그러나 ASP.NET 4의 CAS 구현은 크게 개선되었습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-140">However, the implementation of CAS in ASP.NET 4 has been substantially overhauled.</span></span> <span data-ttu-id="73c1f-141">따라서 전역 어셈블리 캐시에서 실행되는 신뢰할 수 있는 코드를 사용하는 부분 신뢰 ASP.NET 애플리케이션은 다양한 보안 예외와 함께 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-141">As a result, partial-trust ASP.NET applications that rely on trusted code running in the global assembly cache might fail with various security exceptions.</span></span> <span data-ttu-id="73c1f-142">컴퓨터 CAS 정책에 대한 광범위한 수정에 의존하는 부분 신뢰 애플리케이션도 실패하고 보안 예외를 throw할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-142">Partial-trust applications that rely on extensive modifications to machine CAS policy might also fail and throw security exceptions.</span></span> | <span data-ttu-id="73c1f-143">다음 예제와 같이 `trust` 구성 요소에서 새 `legacyCasModel` 특성을 사용하여 부분 신뢰 ASP.NET 4 애플리케이션을 ASP.NET 1.1 및 2.0의 동작으로 되돌릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-143">You can revert partial-trust ASP.NET 4 applications to the behavior of ASP.NET 1.1 and 2.0 by using the new `legacyCasModel` attribute in the `trust` configuration element, as shown in the following example:</span></span><br><br>`<trust level= "Medium" legacyCasModel="true" />`<br><br><span data-ttu-id="73c1f-144">중요: 이전 CAS 모델로 되돌리면 보안이 약화될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-144">Important: Reverting to the older CAS model might represent reduced security.</span></span><br><br><span data-ttu-id="73c1f-145">새로운 ASP.NET 4 코드 액세스 보안 모델에 대한 자세한 내용은 [ASP.NET 4 애플리케이션의 코드 액세스 보안](https://docs.microsoft.com/previous-versions/dd984947(v=vs.100))을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-145">For more information about the new ASP.NET 4 code access security model, see [Code Access Security in ASP.NET 4 Applications](https://docs.microsoft.com/previous-versions/dd984947(v=vs.100)).</span></span> |
| <span data-ttu-id="73c1f-146">**구성 파일**</span><span class="sxs-lookup"><span data-stu-id="73c1f-146">**Configuration files**</span></span> | <span data-ttu-id="73c1f-147">.NET Framework 및 ASP.NET 4의 루트 구성 파일(machine.config 파일 및 루트 Web.config 파일)은 ASP.NET 3.5의 애플리케이션 Web.config 파일에 있는 대부분의 상용구 구성 정보를 포함하도록 업데이트되었습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-147">The root configuration files (the machine.config file and the root Web.config file) for the .NET Framework and ASP.NET 4 have been updated to include most of the boilerplate configuration information that was found in the application Web.config files in ASP.NET 3.5.</span></span> <span data-ttu-id="73c1f-148">관리되는 IIS 7 및 IIS 7.5 구성 시스템의 복잡성 때문에 ASP.NET 4, IIS 7 및 IIS 7.5에서 ASP.NET 3.5 애플리케이션을 실행하면 ASP.NET 오류 또는 IIS 오류가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-148">Because of the complexity of the managed IIS 7 and IIS 7.5 configuration systems, running ASP.NET 3.5 applications under ASP.NET 4 and under IIS 7 and IIS 7.5 can result in either ASP.NET errors or IIS errors.</span></span> | <span data-ttu-id="73c1f-149">Visual Studio의 프로젝트 업그레이드 도구를 사용하여 ASP.NET 3.5 애플리케이션을 ASP.NET 4로 업그레이드하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-149">Upgrade ASP.NET 3.5 applications to ASP.NET 4 by using the project upgrade tools in Visual Studio.</span></span> <span data-ttu-id="73c1f-150">Visual Studio 2010은 ASP.NET 3.5 애플리케이션의 Web.config 파일을 자동으로 수정하여 ASP.NET 4에 대한 적절한 설정을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-150">Visual Studio 2010 automatically modifies the ASP.NET 3.5 application's Web.config file to contain the appropriate settings for ASP.NET 4.</span></span><br><br><span data-ttu-id="73c1f-151">그러나 다시 컴파일하지 않고 .NET Framework 4를 사용하여 ASP.NET 3.5 애플리케이션을 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-151">However, you can run ASP.NET 3.5 applications using the .NET Framework 4 without recompilation.</span></span> <span data-ttu-id="73c1f-152">이 경우 .NET Framework 4 및 IIS 7 또는 IIS 7.5에서 애플리케이션을 실행하기 전에 애플리케이션의 Web.config 파일을 수동으로 수정해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-152">In that case, you might have to manually modify the application's Web.config file before you run the application under the .NET Framework 4 and under IIS 7 or IIS 7.5.</span></span> <span data-ttu-id="73c1f-153">반드시 변경해야 하는 구체적인 내용은 SP(서비스 팩) 릴리스를 비롯하여 작업 중인 소프트웨어의 조합에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-153">The specific change you must make depends on the combination of software you are working with, including Service Pack (SP) releases.</span></span> <span data-ttu-id="73c1f-154">이 변경으로 인해 영향을 받을 수 있는 소프트웨어 조합 및 특정 조합의 문제를 해결하는 방법에 대한 자세한 내용은 ASP.NET 웹 사이트에 있는 [ASP.NET 4 Breaking Changes](/aspnet/whitepapers/aspnet4/breaking-changes)(ASP.NET 4 주요 변경 내용) 문서의 “Configuration Errors Related to New ASP.NET 4 Root Configuration”(새 ASP.NET 4 루트 구성과 관련된 구성 오류) 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-154">For information about the possible software combinations that are affected by this change and how to resolve problems with specific combinations, see the section "Configuration Errors Related to New ASP.NET 4 Root Configuration" in the document [ASP.NET 4 Breaking Changes](/aspnet/whitepapers/aspnet4/breaking-changes) on the ASP.NET Web site.</span></span> |
| <span data-ttu-id="73c1f-155">**컨트롤 렌더링**</span><span class="sxs-lookup"><span data-stu-id="73c1f-155">**Control rendering**</span></span> | <span data-ttu-id="73c1f-156">이전 버전의 ASP.NET에서는 일부 컨트롤에서 비활성화할 수 없는 태그를 내보냈습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-156">In previous versions of ASP.NET, some controls emitted markup that you could not disable.</span></span> <span data-ttu-id="73c1f-157">기본적으로 이 형식의 태그는 ASP.NET 4에서 더 이상 생성되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-157">By default, this type of markup is no longer generated in ASP.NET 4.</span></span> <span data-ttu-id="73c1f-158">이러한 렌더링 변경은 다음 컨트롤에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-158">The rendering changes affect the following controls:</span></span><br><br><span data-ttu-id="73c1f-159">\* `Image` 및 `ImageButton` 컨트롤은 더 이상 `border="0"` 특성을 렌더링하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-159">\* The `Image` and `ImageButton` controls no longer render a `border="0"` attribute.</span></span><br><span data-ttu-id="73c1f-160">\* `BaseValidator` 클래스와 그로부터 파생된 유효성 검사 컨트롤은 더 이상 기본적으로 빨간색 텍스트를 렌더링하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-160">\* The `BaseValidator` class and validation controls that derive from it no longer render red text by default.</span></span><br><span data-ttu-id="73c1f-161">\* `HtmlForm` 컨트롤은 `name` 특성을 렌더링하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-161">\* The `HtmlForm` control does not render a `name` attribute.</span></span><br><span data-ttu-id="73c1f-162">\* `Table` 컨트롤이 더 이상 `border="0"` 특성을 렌더링하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-162">\* The `Table` control no longer renders a `border="0"` attribute.</span></span><br><br><span data-ttu-id="73c1f-163">사용자 입력용으로 디자인되지 않은 컨트롤(예: `Label` 컨트롤)은 `Enabled` 속성이 `false`로 설정된 경우(또는 컨테이너 컨트롤에서 이 설정을 상속하는 경우) 더 이상 `disabled="disabled"` 특성을 렌더링하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-163">Controls that are not designed for user input (for example, the `Label` control) no longer render the `disabled="disabled"` attribute if their `Enabled` property is set to `false` (or if they inherit this setting from a container control).</span></span> | <span data-ttu-id="73c1f-164">Visual Studio를 사용하여 ASP.NET 2.0 또는 ASP.NET 3.5에서 애플리케이션을 업그레이드하는 경우, 레거시 렌더링을 유지하는 Web.config 파일에 설정이 자동으로 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-164">If you use Visual Studio to upgrade your application from ASP.NET 2.0 or ASP.NET 3.5, the tool automatically adds a setting to the Web.config file that preserves legacy rendering.</span></span> <span data-ttu-id="73c1f-165">그러나 .NET Framework 4를 대상으로 하도록 IIS에서 애플리케이션 풀을 변경하여 애플리케이션을 업그레이드하는 경우 ASP.NET은 기본적으로 새 렌더링 모드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-165">However, if you upgrade an application by changing the application pool in IIS to target the .NET Framework 4, ASP.NET uses the new rendering mode by default.</span></span> <span data-ttu-id="73c1f-166">새 렌더링 모드를 사용하지 않으려면 Web.config 파일에 다음 설정을 추가하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-166">To disable the new rendering mode, add the following setting to the Web.config file:</span></span><br><br>`<pages controlRenderingCompatibilityVersion="3.5" />` |
| <span data-ttu-id="73c1f-167">**기본 문서의 이벤트 처리기**</span><span class="sxs-lookup"><span data-stu-id="73c1f-167">**Event handlers in default documents**</span></span> | <span data-ttu-id="73c1f-168">ASP.NET 4는 기본 문서가 매핑된 확장명 없는 URL에 대한 요청이 있을 때 HTML `form` 요소의 `action` 특성 값을 빈 문자열로 렌더링합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-168">ASP.NET  4 renders the HTML `form` element's `action` attribute value as an empty string when a request is made to an extensionless URL that has a default document mapped to it.</span></span> <span data-ttu-id="73c1f-169">이전 버전의 ASP.NET에서는 `http://contoso.com`에 대한 요청이 결국 Default.aspx에 대한 요청이 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-169">In earlier releases of ASP.NET, a request to `http://contoso.com` would result in a request to Default.aspx.</span></span> <span data-ttu-id="73c1f-170">이 문서에서 여는 `form` 태그는 다음 예제와 같이 렌더링됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-170">In that document, the opening `form` tag would be rendered as in the following example:</span></span><br><br>`<form action="Default.aspx" />`<br><br><span data-ttu-id="73c1f-171">ASP.NET 4에서는 `http://contoso.com`에 대한 요청이 결국 Default.aspx에 대한 요청이 되지만, ASP.NET에서는 이제 다음 예제와 같이 HTML 열기 `form` 태그를 렌더링합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-171">In ASP.NET 4, a request to `http://contoso.com` also results in a request to Default.aspx, but ASP.NET now renders the HTML opening `form` tag as in the following example:</span></span><br><br>`<form action="" />`<br><br><span data-ttu-id="73c1f-172">`action` 특성이 빈 문자열이면 IIS `DefaultDocumentModule` 개체가 Default.aspx에 대한 자식 요청을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-172">When the `action` attribute is an empty string, the IIS `DefaultDocumentModule` object creates a child request to Default.aspx.</span></span> <span data-ttu-id="73c1f-173">대부분의 상황에서 이 자식 요청은 애플리케이션 코드에 대해 투명하며, Default.aspx 페이지는 정상적으로 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-173">Under most conditions, this child request is transparent to application code, and the Default.aspx page runs normally.</span></span> <span data-ttu-id="73c1f-174">그러나 관리 코드와 IIS 7 또는 IIS 7.5 통합 모드 간의 잠재적 상호 작용으로 인해 관리되는 .aspx 페이지가 자식 요청 중에 제대로 작동하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-174">However, a potential interaction between managed code and IIS 7 or IIS 7.5 Integrated mode can cause managed .aspx pages to stop working properly during the child request.</span></span> <span data-ttu-id="73c1f-175">다음 상황이 발생하면 기본 .aspx 문서에 대한 자식 요청으로 인해 오류가 발생하거나 예기치 않은 동작이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-175">If the following conditions occur, the child request to a default .aspx document will result in an error or in unexpected behavior:</span></span><br><br><span data-ttu-id="73c1f-176">\* `form` 요소의 `action` 특성이 ""로 설정된 상태로 .aspx 페이지가 브라우저로 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-176">\* An .aspx page is sent to the browser with the `form` element's `action` attribute set to "".</span></span><br><span data-ttu-id="73c1f-177">\* 양식이 ASP.NET에 다시 게시됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-177">\* The form is posted back to ASP.NET.</span></span><br><span data-ttu-id="73c1f-178">\* 관리되는 HTTP 모듈은 `Request.Form` 또는 `Request.Params` 등 엔터티 본문의 일부를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-178">\* A managed HTTP module reads some part of the entity body, such as `Request.Form` or `Request.Params`.</span></span> <span data-ttu-id="73c1f-179">이렇게 하면 POST 요청의 엔터티 본문이 관리되는 메모리로 읽힙니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-179">This causes the entity body of the POST request to be read into managed memory.</span></span> <span data-ttu-id="73c1f-180">결과적으로 IIS 7 또는 IIS 7.5 통합 모드에서 실행 중인 모든 네이티브 코드 모듈에서 더 이상 엔터티 본문을 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-180">As a result, the entity body is no longer available to any native code modules that are running in IIS 7 or IIS 7.5 Integrated mode.</span></span><br><span data-ttu-id="73c1f-181">\* IIS `DefaultDocumentModule` 개체가 결국 실행되어 Default.aspx 문서에 대한 자식 요청을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-181">\* The IIS `DefaultDocumentModule` object eventually runs and creates a child request to the Default.aspx document.</span></span> <span data-ttu-id="73c1f-182">그러나 엔터티 본문은 이미 관리 코드에 의해 읽혔기 때문에 자식 요청에 보낼 수 있는 엔터티 본문이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-182">However, because the entity body has already been read by a piece of managed code, there is no entity body available to send to the child request.</span></span><br><span data-ttu-id="73c1f-183">\* HTTP 파이프라인이 자식 요청에 대해 실행되면 .aspx 파일의 처리기가 처리기 실행 단계 중에 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-183">\* When the HTTP pipeline runs for the child request, the handler for .aspx files runs during the handler-execute phase.</span></span><br><br><span data-ttu-id="73c1f-184">엔터티 본문이 없기 때문에 양식 변수 및 보기 상태가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-184">Because there is no entity body, there are no form variables and no view state.</span></span> <span data-ttu-id="73c1f-185">따라서 .aspx 페이지 처리기가 발생해야 하는 이벤트(있는 경우)를 결정하는 데 사용할 수 있는 정보가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-185">Therefore there is no information available for the .aspx page handler to determine what event (if any) should be raised.</span></span> <span data-ttu-id="73c1f-186">그 결과, 영향을 받는 .aspx 페이지의 포스트백 이벤트 처리기는 실행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-186">As a result, none of the postback event handlers for the affected .aspx page run.</span></span> | <span data-ttu-id="73c1f-187">이 변경의 결과 발생할 수 있는 문제를 해결하는 방법에 대한 자세한 내용은 ASP.NET 웹 사이트에 있는 [ASP.NET 4 Breaking Changes](/aspnet/whitepapers/aspnet4/breaking-changes)(ASP.NET 4 주요 변경 내용) 문서의 “Event Handlers Might Not Be Not Raised in a Default Document in IIS 7 or IIS 7.5 Integrated Mode”(IIS 7 또는 IIS 7.5 통합 모드의 기본 문서에서 이벤트 처리기가 작동하지 않을 수 있음) 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-187">For information about ways to work around problems that might arise as a result of this change, see "Event Handlers Might Not Be Not Raised in a Default Document in IIS 7 or IIS 7.5 Integrated Mode" in the document [ASP.NET 4 Breaking Changes](/aspnet/whitepapers/aspnet4/breaking-changes) on the ASP.NET Web site.</span></span> |
| <span data-ttu-id="73c1f-188">**해시 알고리즘**</span><span class="sxs-lookup"><span data-stu-id="73c1f-188">**Hashing algorithm**</span></span> | <span data-ttu-id="73c1f-189">ASP.NET은 암호화 및 해시 알고리즘을 모두 사용하여 양식 인증 쿠키 및 보기 상태와 같은 데이터를 보호합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-189">ASP.NET uses both encryption and hashing algorithms to help secure data such as forms authentication cookies and view state.</span></span> <span data-ttu-id="73c1f-190">기본적으로 ASP.NET 4는 쿠키 및 보기 상태의 해시 작업에 <xref:System.Security.Cryptography.HMACSHA256> 알고리즘을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-190">By default, ASP.NET 4 uses the <xref:System.Security.Cryptography.HMACSHA256> algorithm for hash operations on cookies and view state.</span></span> <span data-ttu-id="73c1f-191">이전 버전의 ASP.NET에서는 이전 <xref:System.Security.Cryptography.HMACSHA1> 알고리즘을 사용했습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-191">Earlier versions of ASP.NET used the older <xref:System.Security.Cryptography.HMACSHA1> algorithm.</span></span> | <span data-ttu-id="73c1f-192">양식 인증 쿠키와 같은 데이터가 .NET Framework 버전 전체에서 작동해야 하는, ASP.NET 2.0 및 ASP.NET 4가 혼합된 애플리케이션을 실행하는 경우, Web.config 파일에서 다음 설정을 추가하여 ASP.NET 4 웹 애플리케이션이 이전 <xref:System.Security.Cryptography.HMACSHA1> 알고리즘을 사용하도록 구성하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-192">If you run applications that mix ASP.NET 2.0 and ASP.NET 4, where data such as forms authentication cookies must work across .NET Framework versions, configure an ASP.NET 4 Web application to use the older <xref:System.Security.Cryptography.HMACSHA1> algorithm by adding the following setting in the Web.config file:</span></span><br><br>`<machineKey validation="SHA1" />` |
| <span data-ttu-id="73c1f-193">**Internet Explorer의 컨트롤 호스팅**</span><span class="sxs-lookup"><span data-stu-id="73c1f-193">**Hosting controls in Internet Explorer**</span></span> | <span data-ttu-id="73c1f-194">웹에 컨트롤을 호스트하는 더 나은 솔루션이 있기 때문에 더 이상 Internet Explorer에서 Windows Forms 컨트롤을 호스트할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-194">You can no longer host Windows Forms controls in the Internet Explorer, because there are better solutions for hosting controls on the Web.</span></span> <span data-ttu-id="73c1f-195">따라서 IEHost.dll 및 IEExec.exe 어셈블리는 .NET Framework에서 제거되었습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-195">Therefore, the IEHost.dll and IEExec.exe assemblies have been removed from the .NET Framework.</span></span> | <span data-ttu-id="73c1f-196">웹 애플리케이션에서 사용자 지정 컨트롤 개발을 위해 다음 기술을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-196">You can use the following technologies for custom control development in Web applications:</span></span><br><br><span data-ttu-id="73c1f-197">\* Silverlight 애플리케이션을 만들고 브라우저 외부에서 실행되도록 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-197">\* You can create a Silverlight application and configure it to run outside the browser.</span></span> <span data-ttu-id="73c1f-198">자세한 내용은 [브라우저 외부에서 실행 지원](https://docs.microsoft.com/previous-versions/windows/silverlight/dotnet-windows-silverlight/dd550721%28v=vs.95%29)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-198">For more information, see [Out-of-Browser Support](https://docs.microsoft.com/previous-versions/windows/silverlight/dotnet-windows-silverlight/dd550721%28v=vs.95%29).</span></span><br><span data-ttu-id="73c1f-199">\* XBAP(XAML 브라우저 애플리케이션)를 빌드하여 WPF 기능을 활용할 수 있습니다(클라이언트 컴퓨터에 .NET Framework 필요).</span><span class="sxs-lookup"><span data-stu-id="73c1f-199">\* You can build a XAML browser application (XBAP) to take advantage of WPF capabilities (requires the .NET Framework on client machines).</span></span> <span data-ttu-id="73c1f-200">자세한 내용은 [WPF XAML 브라우저 애플리케이션 개요](../wpf/app-development/wpf-xaml-browser-applications-overview.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-200">For more information, see [WPF XAML Browser Applications Overview](../wpf/app-development/wpf-xaml-browser-applications-overview.md).</span></span> |
| <span data-ttu-id="73c1f-201">**HtmlEncode 및 UrlEncode 메서드**</span><span class="sxs-lookup"><span data-stu-id="73c1f-201">**HtmlEncode and UrlEncode methods**</span></span> | <span data-ttu-id="73c1f-202"><xref:System.Web.HttpUtility> 및 <xref:System.Web.HttpServerUtility> 클래스의 `HtmlEncode` 및 `UrlEncode` 메서드가 다음과 같이 작은따옴표 문자(')를 인코딩하도록 업데이트되었습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-202">The `HtmlEncode` and `UrlEncode` methods of the <xref:System.Web.HttpUtility> and <xref:System.Web.HttpServerUtility> classes have been updated to encode the single quotation mark character (') as follows:</span></span><br><br><span data-ttu-id="73c1f-203">\* `HtmlEncode` 메서드는 작은따옴표의 인스턴스를 `&#39;`으로 인코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-203">\* The `HtmlEncode` method encodes instances of the single quotation mark as `&#39;`</span></span><br><span data-ttu-id="73c1f-204">\* `UrlEncode` 메서드는 작은따옴표의 인스턴스를 `%27`로 인코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-204">\* The `UrlEncode` method encodes instances of the single quotation mark as `%27`</span></span> | <span data-ttu-id="73c1f-205">`HtmlEncode` 및 `UrlEncode` 메서드를 사용하는 장소에 대한 코드를 검사하고 인코딩의 변경으로 인해 애플리케이션에 영향을 주는 변경이 발생하지 않는지 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-205">Examine your code for places where you use the `HtmlEncode` and `UrlEncode` methods, and make sure that the change in encoding does not result in a change that would affect your application.</span></span> |
| <span data-ttu-id="73c1f-206">**ASP.NET 2.0 애플리케이션의 HttpException 오류**</span><span class="sxs-lookup"><span data-stu-id="73c1f-206">**HttpException errors in ASP.NET 2.0 applications**</span></span> | <span data-ttu-id="73c1f-207">IIS 6에서 ASP.NET 4를 사용하도록 설정한 경우 IIS 6(Windows Server 2003 또는 Windows Server 2003 R2)에서 실행되는 ASP.NET 2.0 애플리케이션에서 다음과 같은 오류가 발생할 수 있습니다. `System.Web.HttpException: Path '/[yourApplicationRoot]/eurl.axd/[Value]' was not found.`</span><span class="sxs-lookup"><span data-stu-id="73c1f-207">After ASP.NET 4 has been enabled on IIS 6, ASP.NET 2.0 applications that run on IIS 6 (in either Windows Server 2003 or Windows Server 2003 R2) might generate errors such as the following: `System.Web.HttpException: Path '/[yourApplicationRoot]/eurl.axd/[Value]' was not found.`</span></span> | <span data-ttu-id="73c1f-208">\* 웹 사이트를 실행하기 위해 ASP.NET 4가 필요하지 않은 경우 대신 ASP.NET 2.0을 사용하도록 사이트를 다시 매핑합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-208">\* If ASP.NET 4 is not required in order to run the Web site, remap the site to use ASP.NET 2.0 instead.</span></span><br><br><span data-ttu-id="73c1f-209">또는</span><span class="sxs-lookup"><span data-stu-id="73c1f-209">-or-</span></span><br><br><span data-ttu-id="73c1f-210">\* 웹 사이트를 실행하기 위해 ASP.NET 4가 필요한 경우 자식 ASP.NET 2.0 가상 디렉터리를 ASP.NET 2.0에 매핑된 다른 웹 사이트로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-210">\* If ASP.NET 4 is required in order to run the Web site, move any child ASP.NET 2.0 virtual directories to a different Web site that is mapped to ASP.NET 2.0.</span></span><br><br><span data-ttu-id="73c1f-211">또는</span><span class="sxs-lookup"><span data-stu-id="73c1f-211">-or-</span></span><br><br><span data-ttu-id="73c1f-212">\* 확장명 없는 URL을 사용하지 않도록 설정하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-212">\* Disable extensionless URLs.</span></span> <span data-ttu-id="73c1f-213">자세한 내용은 ASP.NET 웹 사이트에 있는 [ASP.NET 4 Breaking Changes](/aspnet/whitepapers/aspnet4/breaking-changes)(ASP.NET 4 주요 변경 내용) 문서의 “ASP.NET 2.0 Applications Might Generate HttpException Errors That Reference eurl.axd”(ASP.NET 2.0 애플리케이션이 eurl.axd를 참조하는 HttpException 오류를 생성할 수 있음)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-213">For more information, see "ASP.NET 2.0 Applications Might Generate HttpException Errors That Reference eurl.axd" in the document [ASP.NET 4 Breaking Changes](/aspnet/whitepapers/aspnet4/breaking-changes) on the ASP.NET Web site.</span></span> |
| <span data-ttu-id="73c1f-214">**멤버 자격 유형**</span><span class="sxs-lookup"><span data-stu-id="73c1f-214">**Membership types**</span></span> | <span data-ttu-id="73c1f-215">ASP.NET 멤버 자격에서 사용되는 일부 형식(예: <xref:System.Web.Security.MembershipProvider>)이 System.Web.dll에서 System.Web.ApplicationServices.dll 어셈블리로 이동했습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-215">Some types (for example, <xref:System.Web.Security.MembershipProvider>) that are used in ASP.NET membership have been moved from System.Web.dll to the System.Web.ApplicationServices.dll assembly.</span></span> <span data-ttu-id="73c1f-216">클라이언트 형식 및 확장된 .NET Framework SKU 형식 간 아키텍처 계층화 종속성을 해결하기 위해 형식을 이동했습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-216">The types were moved in order to resolve architectural layering dependencies between types in the client and in extended .NET Framework SKUs.</span></span> | <span data-ttu-id="73c1f-217">ASP.NET의 이전 버전에서 업그레이드되었고 이동된 멤버 자격 유형을 사용하는 클래스 라이브러리는 ASP.NET 4 프로젝트에서 사용될 때 컴파일되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-217">Class libraries that have been upgraded from earlier versions of ASP.NET and that use membership types that have been moved might fail to compile when used in an ASP.NET 4 project.</span></span> <span data-ttu-id="73c1f-218">이 경우 클래스 라이브러리 프로젝트의 참조를 System.Web.ApplicationServices.dll에 추가하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-218">If so, add a reference in the class library project to System.Web.ApplicationServices.dll.</span></span> |
| <span data-ttu-id="73c1f-219">**메뉴 컨트롤 변경**</span><span class="sxs-lookup"><span data-stu-id="73c1f-219">**Menu control changes**</span></span> | <span data-ttu-id="73c1f-220"><xref:System.Web.UI.WebControls.Menu> 컨트롤을 변경하면 다음과 같은 동작이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-220">Changes to the <xref:System.Web.UI.WebControls.Menu> control result in the following behavior:</span></span><br><br><span data-ttu-id="73c1f-221">\* <xref:System.Web.UI.WebControls.MenuRenderingMode>가 `List`로 설정되거나 <xref:System.Web.UI.WebControls.MenuRenderingMode>가 `Default`로 설정되고 <xref:System.Web.Configuration.PagesSection.ControlRenderingCompatibilityVersion>이 `4.0` 이상으로 설정된 경우 <xref:System.Web.UI.WebControls.MenuItem.PopOutImageUrl> 속성은 아무런 효과도 없습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-221">\* If <xref:System.Web.UI.WebControls.MenuRenderingMode> is set to `List`, or if <xref:System.Web.UI.WebControls.MenuRenderingMode> is set to `Default` and <xref:System.Web.Configuration.PagesSection.ControlRenderingCompatibilityVersion> is set to `4.0` or later, the <xref:System.Web.UI.WebControls.MenuItem.PopOutImageUrl> property has no effect.</span></span><br><span data-ttu-id="73c1f-222">\* <xref:System.Web.UI.WebControls.Menu.StaticPopOutImageUrl%2A> 및 <xref:System.Web.UI.WebControls.Menu.DynamicPopOutImageUrl> 속성에 설정된 경로에 백슬래시(\\)가 포함되어 있으면 이미지가 렌더링되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-222">\* If the path that is set in the <xref:System.Web.UI.WebControls.Menu.StaticPopOutImageUrl%2A> and <xref:System.Web.UI.WebControls.Menu.DynamicPopOutImageUrl> properties contains a backslash (\\), the images do not render.</span></span> <span data-ttu-id="73c1f-223">(ASP.NET의 이전 버전에서는 경로에 백슬래시를 포함할 수 있었습니다.)</span><span class="sxs-lookup"><span data-stu-id="73c1f-223">(In earlier versions of ASP.NET, the path could include a backslash.)</span></span> | <span data-ttu-id="73c1f-224">\* 개별 메뉴 항목의 <xref:System.Web.UI.WebControls.MenuItem.PopOutImageUrl> 속성을 설정하는 대신 부모 <xref:System.Web.UI.WebControls.Menu> 컨트롤의 <xref:System.Web.UI.WebControls.Menu.StaticPopOutImageUrl%2A> 또는 <xref:System.Web.UI.WebControls.Menu.DynamicPopOutImageUrl>을 설정하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-224">\* Instead of setting the <xref:System.Web.UI.WebControls.MenuItem.PopOutImageUrl> property for individual menu items, set the <xref:System.Web.UI.WebControls.Menu.StaticPopOutImageUrl%2A> or <xref:System.Web.UI.WebControls.Menu.DynamicPopOutImageUrl> of the parent <xref:System.Web.UI.WebControls.Menu> control.</span></span><br><br><span data-ttu-id="73c1f-225">또는</span><span class="sxs-lookup"><span data-stu-id="73c1f-225">-or-</span></span><br><br><span data-ttu-id="73c1f-226"><xref:System.Web.UI.WebControls.MenuRenderingMode>를 `Table`, <xref:System.Web.UI.WebControls.MenuRenderingMode>를 `Default`, <xref:System.Web.Configuration.PagesSection.ControlRenderingCompatibilityVersion>을 `3.5`로 설정하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-226">Set <xref:System.Web.UI.WebControls.MenuRenderingMode> to `Table`, or set <xref:System.Web.UI.WebControls.MenuRenderingMode> to `Default` and set <xref:System.Web.Configuration.PagesSection.ControlRenderingCompatibilityVersion> to `3.5`.</span></span> <span data-ttu-id="73c1f-227">이렇게 설정하면 <xref:System.Web.UI.WebControls.Menu> 컨트롤이 이전 버전의 ASP.NET에서 사용한 HTML 테이블 기반 레이아웃을 사용하게 합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-227">These settings cause the <xref:System.Web.UI.WebControls.Menu> control to use the HTML table-based layout that it used in earlier versions of ASP.NET.</span></span><br><span data-ttu-id="73c1f-228">\* <xref:System.Web.UI.WebControls.Menu.StaticPopOutImageUrl%2A> 또는 <xref:System.Web.UI.WebControls.Menu.DynamicPopOutImageUrl> 속성의 경로에 백슬래시(\\)가 포함되어 있으면 슬래시 문자(/)를 대체하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-228">\* If the path in the <xref:System.Web.UI.WebControls.Menu.StaticPopOutImageUrl%2A> or <xref:System.Web.UI.WebControls.Menu.DynamicPopOutImageUrl> property contains a backslash (\\), substitute a slash character (/).</span></span> |
| <span data-ttu-id="73c1f-229">**Web.config 파일의 모바일 어셈블리**</span><span class="sxs-lookup"><span data-stu-id="73c1f-229">**Mobile assembly in Web.config file**</span></span> | <span data-ttu-id="73c1f-230">ASP.NET의 이전 버전에서는 System.Web.Mobile.dll 어셈블리에 대한 참조가 `system.web`/`compilation`의 `assemblies` 섹션에 있는 루트 Web.config 파일에 포함되었습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-230">In previous versions of ASP.NET, a reference to the System.Web.Mobile.dll assembly was included in the root Web.config file in the `assemblies` section under `system.web`/`compilation`.</span></span> <span data-ttu-id="73c1f-231">성능 향상을 위해 이 어셈블리에 대한 참조가 제거되었습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-231">To improve performance, the reference to this assembly has been removed.</span></span><br><br><span data-ttu-id="73c1f-232">참고: System.Web.Mobile.dll 어셈블리 및 ASP.NET 모바일 컨트롤은 ASP.NET 4에 포함되지만 사용되지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-232">Note: The System.Web.Mobile.dll assembly and the ASP.NET mobile controls are included in ASP.NET 4, but they are deprecated.</span></span> | <span data-ttu-id="73c1f-233">이 어셈블리의 형식을 사용하려면 루트 Web.config 파일 또는 애플리케이션 Web.config 파일의 어셈블리에 대한 참조를 추가하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-233">If you want to use types from this assembly, add a reference to the assembly in either the root Web.config file or in an application Web.config file.</span></span> |
| <span data-ttu-id="73c1f-234">**출력 캐싱**</span><span class="sxs-lookup"><span data-stu-id="73c1f-234">**Output caching**</span></span> | <span data-ttu-id="73c1f-235">ASP.NET 1.0에서는 `Location="ServerAndClient"`를 출력 캐시 설정으로 지정한 캐시된 페이지가 응답에서 `Vary:*` HTTP 헤더를 내보내는 버그가 있었습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-235">In ASP.NET 1.0, a bug caused cached pages that specified `Location="ServerAndClient"` as an output€“cache setting to emit a `Vary:*` HTTP header in the response.</span></span> <span data-ttu-id="73c1f-236">이로 인해 클라이언트 브라우저가 페이지를 로컬에 캐시하지 못했습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-236">This had the effect of telling client browsers to never cache the page locally.</span></span> <span data-ttu-id="73c1f-237">ASP.NET 1.1에서는 `Vary:*` 헤더를 억제하기 위해 호출할 수 있는 <xref:System.Web.HttpCachePolicy.SetOmitVaryStar%2A> 메서드가 추가되었습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-237">In ASP.NET 1.1, the <xref:System.Web.HttpCachePolicy.SetOmitVaryStar%2A> method was added, which could be called in order to suppress the `Vary:*` header.</span></span> <span data-ttu-id="73c1f-238">그러나 버그 보고서에 따르면 개발자는 기존의 `SetOmitVaryStar` 동작을 인식하지 못합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-238">However, bug reports suggest that developers are unaware of the existing `SetOmitVaryStar` behavior.</span></span><br><br><span data-ttu-id="73c1f-239">ASP.NET 4에서는 다음 지시문을 지정하는 응답에서 더 이상 `Vary:*` HTTP 헤더를 내보내지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-239">In ASP.NET 4, the `Vary:*` HTTP header is no longer emitted from responses that specify the following directive:</span></span><br><br>`<%@ OutputCache Location="ServerAndClient" %>`<br><br><span data-ttu-id="73c1f-240">결과적으로 `Vary:*` 헤더를 억제하기 위해 <xref:System.Web.HttpCachePolicy.SetOmitVaryStar%2A> 메서드가 더 이상 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-240">As a result, the <xref:System.Web.HttpCachePolicy.SetOmitVaryStar%2A> method is no longer needed in order to suppress the `Vary:*` header.</span></span> <span data-ttu-id="73c1f-241">`Location` 특성에 대해 “ServerAndClient”를 지정하는 애플리케이션에서는 <xref:System.Web.HttpCachePolicy.SetOmitVaryStar%2A>를 호출할 필요 없이 브라우저에서 페이지를 캐시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-241">In applications that specify "ServerAndClient" for the `Location` attribute, pages will be cacheable in the browser without requiring that you call <xref:System.Web.HttpCachePolicy.SetOmitVaryStar%2A>.</span></span> | <span data-ttu-id="73c1f-242">애플리케이션의 페이지가 `Vary:*`을 내보내야 하는 경우 다음 예제와 같이 <xref:System.Web.HttpResponse.AppendHeader%2A> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-242">If pages in the application must emit `Vary:*`, call the <xref:System.Web.HttpResponse.AppendHeader%2A> method as shown in the following example:</span></span><br><br>`System.Web.HttpResponse.AppendHeader("Vary","*");`<br><br><span data-ttu-id="73c1f-243">또는 출력 캐싱 `Location` 특성의 값을 “Server”로 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-243">Alternatively, you can change the value of the output caching `Location` attribute to "Server".</span></span> |
| <span data-ttu-id="73c1f-244">**페이지 구문 분석**</span><span class="sxs-lookup"><span data-stu-id="73c1f-244">**Page parsing**</span></span> | <span data-ttu-id="73c1f-245">ASP.NET 웹 페이지(.aspx 파일) 및 사용자 컨트롤(.ascx 파일)의 페이지 파서는 이전 버전의 ASP.NET보다 ASP.NET 4에서 더 엄격하며, 이전 버전보다 더 많은 태그를 잘못된 것으로 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-245">The page parser for ASP.NET Web pages (.aspx files) and user controls (.ascx files) is stricter in ASP.NET 4 than in earlier versions of ASP.NET, and it flags more markup as invalid than in earlier versions.</span></span> | <span data-ttu-id="73c1f-246">페이지가 실행될 때 생성되는 오류 메시지를 검사하고 잘못된 태그에서 발생하는 오류를 수정하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-246">Examine error messages that are produced when a page runs and fix errors that result from invalid markup.</span></span> |
| <span data-ttu-id="73c1f-247">**Passport 형식**</span><span class="sxs-lookup"><span data-stu-id="73c1f-247">**Passport types**</span></span> | <span data-ttu-id="73c1f-248">ASP.NET 2.0에 내장된 Passport 지원은 사용되지 않으며 Passport(이제 Live ID SDK)의 변경으로 인해 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-248">The Passport support built into ASP.NET 2.0 is obsolete and is unsupported due to changes in Passport (now Live ID SDK).</span></span> <span data-ttu-id="73c1f-249">그 결과 <xref:System.Web.Security>의 Passport와 관련된 형식이 이제 `ObsoleteAttribute` 특성으로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-249">As a result, the types related to Passport in <xref:System.Web.Security> are now marked with the `ObsoleteAttribute` attribute.</span></span> | <span data-ttu-id="73c1f-250"><xref:System.Web.Security> 네임스페이스(예: <xref:System.Web.Security.PassportIdentity>)에서 Passport 형식을 사용하는 코드를 Windows Live ID SDK를 사용하도록 변경하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-250">Change any code you have that uses Passport types in the <xref:System.Web.Security> namespace (for example, <xref:System.Web.Security.PassportIdentity>) to use the Windows Live ID SDK.</span></span> |
| <span data-ttu-id="73c1f-251">**FilePath 속성의 PathInfo 정보**</span><span class="sxs-lookup"><span data-stu-id="73c1f-251">**PathInfo information in the FilePath property**</span></span> | <span data-ttu-id="73c1f-252">ASP.NET 4는 <xref:System.Web.HttpRequest.FilePath>, <xref:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath>, <xref:System.Web.HttpRequest.CurrentExecutionFilePath>와 같은 속성의 반환 값에 더 이상 `PathInfo` 값을 포함하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-252">ASP.NET 4 no longer includes the `PathInfo` value in the return values from properties such as <xref:System.Web.HttpRequest.FilePath>, <xref:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath>, and <xref:System.Web.HttpRequest.CurrentExecutionFilePath>.</span></span> <span data-ttu-id="73c1f-253">대신, `PathInfo` 정보를 <xref:System.Web.HttpRequest.PathInfo>에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-253">Instead, the `PathInfo` information is available in <xref:System.Web.HttpRequest.PathInfo>.</span></span> <span data-ttu-id="73c1f-254">예를 들어 다음과 같은 URL 조각을 가정해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-254">For example, imagine the following URL fragment:</span></span><br><br>`/testapp/Action.mvc/SomeAction`<br><br><span data-ttu-id="73c1f-255">이전 버전의 ASP.NET에서 <xref:System.Web.HttpRequest> 속성은 다음과 같은 값을 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-255">In earlier versions of ASP.NET, <xref:System.Web.HttpRequest> properties have the following values:</span></span><br><br><span data-ttu-id="73c1f-256">\* <xref:System.Web.HttpRequest.FilePath>: `/testapp/Action.mvc/SomeAction`</span><span class="sxs-lookup"><span data-stu-id="73c1f-256">\* <xref:System.Web.HttpRequest.FilePath>: `/testapp/Action.mvc/SomeAction`</span></span><br><span data-ttu-id="73c1f-257">\* <xref:System.Web.HttpRequest.PathInfo>: (empty)</span><span class="sxs-lookup"><span data-stu-id="73c1f-257">\* <xref:System.Web.HttpRequest.PathInfo>: (empty)</span></span><br><br><span data-ttu-id="73c1f-258">ASP.NET 4에서 <xref:System.Web.HttpRequest> 속성은 대신 다음과 같은 값을 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-258">In ASP.NET 4, <xref:System.Web.HttpRequest> properties instead have the following values:</span></span><br><br><span data-ttu-id="73c1f-259">\* <xref:System.Web.HttpRequest.FilePath>: `/testapp/Action.mvc`</span><span class="sxs-lookup"><span data-stu-id="73c1f-259">\* <xref:System.Web.HttpRequest.FilePath>: `/testapp/Action.mvc`</span></span><br><span data-ttu-id="73c1f-260">\* <xref:System.Web.HttpRequest.PathInfo>: `SomeAction`</span><span class="sxs-lookup"><span data-stu-id="73c1f-260">\* <xref:System.Web.HttpRequest.PathInfo>: `SomeAction`</span></span> | <span data-ttu-id="73c1f-261">경로 정보를 반환하기 위해 <xref:System.Web.HttpRequest> 클래스의 속성에 의존하는 위치에 대한 코드를 검사하세요. 경로 정보가 반환되는 방식의 변화를 반영하도록 코드를 변경하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-261">Examine your code for places where you rely on properties of the <xref:System.Web.HttpRequest> class to return path information; change the code to reflect the changes in how path information is returned.</span></span> |
| <span data-ttu-id="73c1f-262">**요청 유효성 검사**</span><span class="sxs-lookup"><span data-stu-id="73c1f-262">**Request validation**</span></span> | <span data-ttu-id="73c1f-263">요청 유효성 검사를 향상하기 위해, 요청 수명 주기의 초기에 ASP.NET 요청 유효성 검사가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-263">To improve request validation, the ASP.NET request validation is invoked earlier in the request life cycle.</span></span> <span data-ttu-id="73c1f-264">따라서 웹 서비스 호출 및 사용자 지정 처리기 등 .aspx 파일 이외의 요청에 대해서는 요청 유효성 검사가 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-264">As a result, request validation runs for requests that are not for .aspx files, such as for Web service calls and for custom handlers.</span></span> <span data-ttu-id="73c1f-265">또한 요청 처리 파이프라인에서 사용자 지정 HTTP 모듈이 실행 중일 때 요청 유효성 검사가 활성화됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-265">Request validation will also be active when custom HTTP modules are running in the request processing pipeline.</span></span><br><br><span data-ttu-id="73c1f-266">이러한 변경 결과로 .aspx 파일 이외의 리소스에 대한 요청은 요청 유효성 검사 오류를 throw할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-266">As a result of this change, requests for resources other than .aspx files might throw request validation errors.</span></span> <span data-ttu-id="73c1f-267">요청 파이프라인(예: 사용자 지정 HTTP 모듈)에서 실행되는 사용자 지정 코드는 요청 유효성 검사 오류를 throw할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-267">Custom code that runs in the request pipeline (for example, custom HTTP modules) might also throw request validation errors.</span></span> | <span data-ttu-id="73c1f-268">필요한 경우 웹 구성 파일에서 다음 설정을 사용하여 요청 유효성 검사를 트리거하는 .aspx 페이지만 이전 동작으로 되돌릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-268">If necessary, you can revert to the old behavior of having only .aspx pages triggering request validation by using the following setting in the Web configuration file:</span></span><br><br>`<httpRuntime requestValidationMode="2.0" />`<br><br><span data-ttu-id="73c1f-269">경고: 이전 동작으로 되돌리는 경우 기존 처리기, 모듈 및 기타 사용자 지정 코드의 모든 코드가 XSS 공격 벡터일 수 있는, 잠재적으로 안전하지 않은 HTTP 입력에 대한 검사를 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-269">Warning: If you revert to the old behavior, make sure that all code in existing handlers, modules, and other custom code performs checks for potentially unsafe HTTP inputs that could be XSS attack vectors.</span></span> |
| <span data-ttu-id="73c1f-270">**라우팅**</span><span class="sxs-lookup"><span data-stu-id="73c1f-270">**Routing**</span></span> | <span data-ttu-id="73c1f-271">Visual Studio 2010에서 파일 시스템 웹 사이트를 만든 경우 이름에 점(.)이 포함된 폴더에 웹 사이트가 있으면 URL 라우팅이 안정적으로 작동하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-271">If you create a file system Web site in Visual Studio 2010 and the Web site is in a folder that contains a dot (.) in the folder name, URL routing will not work reliably.</span></span> <span data-ttu-id="73c1f-272">일부 가상 경로에서 HTTP 404 오류가 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-272">An HTTP 404 error is returned from some virtual paths.</span></span> <span data-ttu-id="73c1f-273">이 오류는 Visual Studio 2010이 루트 가상 디렉터리의 잘못된 경로를 사용하여 Visual Studio 개발 서버를 시작하기 때문에 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-273">This occurs because Visual Studio 2010 launches the Visual Studio Development Server using an incorrect path for the root virtual directory.</span></span> | <span data-ttu-id="73c1f-274">\* 파일 기반 웹 사이트의 **속성** 페이지에서 **가상 경로** 특성을 “/”로 변경하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-274">\* In the **Properties** page for the file-based Web site, change the **Virtual Path** attribute to "/".</span></span><br><br><span data-ttu-id="73c1f-275">또는</span><span class="sxs-lookup"><span data-stu-id="73c1f-275">-or-</span></span><br><br><span data-ttu-id="73c1f-276">\* 웹 사이트 프로젝트를 대신 웹 애플리케이션 프로젝트를 만드세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-276">\* Create a Web application project instead of a Web site project.</span></span> <span data-ttu-id="73c1f-277">웹 애플리케이션 프로젝트에는 이 문제가 없으며, 프로젝트 폴더의 이름에 점이 있는 경우에도 URL 라우팅이 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-277">Web application projects do not have this issue, and URL routing works even if the project folder has a dot in its name.</span></span><br><br><span data-ttu-id="73c1f-278">또는</span><span class="sxs-lookup"><span data-stu-id="73c1f-278">-or-</span></span><br><br><span data-ttu-id="73c1f-279">\* IIS에서 호스트되는 HTTP 기반 웹 사이트를 만드세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-279">\* Create an HTTP-based Web site that is hosted in IIS.</span></span> <span data-ttu-id="73c1f-280">IIS에서 호스트하는 웹 사이트는 가상 경로는 물론 프로젝트 파일 폴더에도 점을 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-280">IIS-hosted Web sites can have dots in the virtual path as well as in the project file folder.</span></span> |
| <span data-ttu-id="73c1f-281">**SharePoint 사이트**</span><span class="sxs-lookup"><span data-stu-id="73c1f-281">**SharePoint sites**</span></span> | <span data-ttu-id="73c1f-282">`WSS_Minimal`이라는 사용자 지정 부분 신뢰 수준이 포함된 SharePoint 웹 사이트의 자식으로 배포된 ASP.NET 4 웹 사이트를 실행하려고 하면 다음 오류가 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-282">If you try to run an ASP.NET 4 Web site that is deployed as a child of a SharePoint Web site that contains a custom partial-trust level named `WSS_Minimal`, you will see the following error:</span></span><br><br>`Could not find permission set named 'ASP.Net'.` | <span data-ttu-id="73c1f-283">지금은 ASP.NET과 호환되는 SharePoint 버전이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-283">Currently, no versions of SharePoint are compatible with ASP.NET.</span></span> <span data-ttu-id="73c1f-284">따라서 ASP.NET 4 웹 사이트를 SharePoint 웹 사이트의 자식으로 실행해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-284">As a result, you should not attempt to run an ASP.NET 4 Web site as a child of a SharePoint Web site.</span></span> |
| <span data-ttu-id="73c1f-285">**XHTML 1.1 표준**</span><span class="sxs-lookup"><span data-stu-id="73c1f-285">**XHTML 1.1 standards**</span></span> | <span data-ttu-id="73c1f-286">새로운 웹 사이트에 XHTML 1.1 규격을 사용하기 위해 .NET Framework 4의 ASP.NET 컨트롤은 XHTML 1.1 규격 HTML을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-286">To enable XHTML 1.1 compliance for new Web sites, the ASP.NET controls in the .NET Framework 4 will generate XHTML 1.1 compliant HTML.</span></span> <span data-ttu-id="73c1f-287">`<system.Web>` 요소 내부의 Web.config 파일에서 다음 옵션을 사용하여 이 렌더링을 사용하도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-287">This rendering is enabled using the following option in the Web.config file inside the `<system.Web>` element:</span></span><br><br>`<pages controlRenderingCompatibilityVersion="4.0"/>`<br><br><span data-ttu-id="73c1f-288">이 옵션은 기본적으로 4.0으로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-288">This option is set by default to 4.0.</span></span> <span data-ttu-id="73c1f-289">Visual Studio 2008에서 업그레이드되는 웹 프로젝트는 호환성을 위해 3.5 설정을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-289">Web projects that are upgraded from Visual Studio 2008 have the 3.5 setting enabled for compatibility.</span></span> | <span data-ttu-id="73c1f-290">없음</span><span class="sxs-lookup"><span data-stu-id="73c1f-290">None.</span></span> |

## <a name="core"></a><span data-ttu-id="73c1f-291">코어</span><span class="sxs-lookup"><span data-stu-id="73c1f-291">Core</span></span>

### <a name="general-features"></a><span data-ttu-id="73c1f-292">일반 기능</span><span class="sxs-lookup"><span data-stu-id="73c1f-292">General features</span></span>

| <span data-ttu-id="73c1f-293">기능</span><span class="sxs-lookup"><span data-stu-id="73c1f-293">Feature</span></span> | <span data-ttu-id="73c1f-294">3\.5 SP1과의 차이점</span><span class="sxs-lookup"><span data-stu-id="73c1f-294">Differences from 3.5 SP1</span></span> | <span data-ttu-id="73c1f-295">권장 변경 내용</span><span class="sxs-lookup"><span data-stu-id="73c1f-295">Recommended changes</span></span> |
| ------- | ------------------------ | ------------------- |
| <span data-ttu-id="73c1f-296">**CardSpace**</span><span class="sxs-lookup"><span data-stu-id="73c1f-296">**CardSpace**</span></span> | <span data-ttu-id="73c1f-297">Windows CardSpace는 이제 .NET Framework에 포함되지 않으며 별도로 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-297">Windows CardSpace is no longer included in the .NET Framework; it is provided separately.</span></span> | <span data-ttu-id="73c1f-298">[Microsoft 다운로드 센터](https://go.microsoft.com/fwlink/?LinkId=199868)에서 Windows CardSpace를 다운로드하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-298">Download Windows CardSpace from the [Microsoft Download Center](https://go.microsoft.com/fwlink/?LinkId=199868).</span></span> |
| <span data-ttu-id="73c1f-299">**구성 파일**</span><span class="sxs-lookup"><span data-stu-id="73c1f-299">**Configuration files**</span></span> | <span data-ttu-id="73c1f-300">.NET Framework가 애플리케이션 구성 파일에 액세스하는 방법이 수정되었습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-300">Corrections have been made in how the .NET Framework accesses application configuration files.</span></span> | <span data-ttu-id="73c1f-301">애플리케이션 구성 파일의 이름이 *application-name.config*인 경우 이름을 *application-name.exe.config*로 바꾸세요. 예를 들어 *MyApp.config*를 *MyApp.exe.config*로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-301">If your application configuration file is named *application-name.config*, rename it to *application-name.exe.config*. For example, rename *MyApp.config* to *MyApp.exe.config*.</span></span> |
| <span data-ttu-id="73c1f-302">**C# 코드 컴파일러**</span><span class="sxs-lookup"><span data-stu-id="73c1f-302">**C# code compiler**</span></span> | <span data-ttu-id="73c1f-303"><xref:Microsoft.CSharp> 네임스페이스에 있던 `Compiler`, `CompilerError` 및 `ErrorLevel` 클래스는 더 이상 사용할 수 없으며 해당 어셈블리(cscompmgd.dll)는 .NET Framework에 더 이상 포함되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-303">The `Compiler`, `CompilerError`, and `ErrorLevel` classes that were in the <xref:Microsoft.CSharp> namespace are no longer available, and their assembly (cscompmgd.dll) is no longer included in the .NET Framework.</span></span> | <span data-ttu-id="73c1f-304"><xref:System.CodeDom.Compiler.CodeDomProvider> 클래스 및 <xref:System.CodeDom.Compiler> 네임스페이스의 기타 클래스를 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-304">Use the <xref:System.CodeDom.Compiler.CodeDomProvider> class and other classes in the <xref:System.CodeDom.Compiler> namespace.</span></span> <span data-ttu-id="73c1f-305">자세한 내용은 [CodeDOM 사용](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/y2k85ax6%28v=vs.100%29)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-305">For more information, see [Using the CodeDOM](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/y2k85ax6%28v=vs.100%29).</span></span> |
| <span data-ttu-id="73c1f-306">**호스팅**(관리되지 않는 API)</span><span class="sxs-lookup"><span data-stu-id="73c1f-306">**Hosting** (unmanaged API)</span></span> | <span data-ttu-id="73c1f-307">호스팅 기능의 향상을 위해 일부 호스팅 활성화 API가 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-307">To improve hosting capabilities, some of the hosting activation APIs have been deprecated.</span></span> <span data-ttu-id="73c1f-308">In-Process Side-by-Side 실행 기능을 통해 애플리케이션은 동일한 프로세스에서 여러 버전의 .NET Framework를 로드하고 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-308">In-process side-by-side execution features enable an application to load and start multiple versions of the .NET Framework in the same process.</span></span> <span data-ttu-id="73c1f-309">예를 들어 .NET Framework 2.0 SP1을 기반으로 하는 추가 기능(또는 구성 요소) 및 동일한 프로세스에서 .NET Framework 4를 기반으로 하는 추가 기능을 로드하는 애플리케이션을 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-309">For example, you can run applications that load add-ins (or components) that are based on the .NET Framework 2.0 SP1 and add-ins that are based on the .NET Framework 4 in the same process.</span></span> <span data-ttu-id="73c1f-310">이전 구성 요소는 이전 .NET Framework 버전을 계속 사용하고 새 구성 요소는 새 .NET Framework 버전을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-310">Older components continue to use the older .NET Framework version, and new components use the new .NET Framework version.</span></span> | <span data-ttu-id="73c1f-311">[In-Process Side-by-Side 실행](../deployment/in-process-side-by-side-execution.md)에 설명된 구성을 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-311">Use the configurations described in [In-Process Side-by-Side Execution](../deployment/in-process-side-by-side-execution.md).</span></span> |
| <span data-ttu-id="73c1f-312">**새 보안 모델**</span><span class="sxs-lookup"><span data-stu-id="73c1f-312">**New security model**</span></span> | <span data-ttu-id="73c1f-313">[.NET Framework 4의 보안 변경 내용](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/dd233103%28v=vs.100%29)에 설명된 대로 CAS(코드 액세스 보안) 정책이 해제되어 단순화된 모델로 대체되었습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-313">The code access security (CAS) policy has been turned off and replaced with a simplified model, as described in [Security Changes in the .NET Framework 4](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/dd233103%28v=vs.100%29).</span></span> | <span data-ttu-id="73c1f-314">애플리케이션에서 CAS를 사용하는 경우 수정이 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-314">Modifications may be required if you depend on CAS in your applications.</span></span> <span data-ttu-id="73c1f-315">자세한 내용은 [코드 액세스 보안 정책 호환성 및 마이그레이션](../misc/code-access-security-policy-compatibility-and-migration.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-315">For more information, see [Code Access Security Policy Compatibility and Migration](../misc/code-access-security-policy-compatibility-and-migration.md).</span></span> |

### <a name="date-and-time"></a><span data-ttu-id="73c1f-316">날짜 및 시간</span><span class="sxs-lookup"><span data-stu-id="73c1f-316">Date and time</span></span>

<span data-ttu-id="73c1f-317">네임스페이스: <xref:System>; 어셈블리: mscorlib(mscorlib.dll)</span><span class="sxs-lookup"><span data-stu-id="73c1f-317">Namespace: <xref:System>; assembly: mscorlib (in mscorlib.dll)</span></span>

| <span data-ttu-id="73c1f-318">기능</span><span class="sxs-lookup"><span data-stu-id="73c1f-318">Feature</span></span> | <span data-ttu-id="73c1f-319">3\.5 SP1과의 차이점</span><span class="sxs-lookup"><span data-stu-id="73c1f-319">Differences from 3.5 SP1</span></span> | <span data-ttu-id="73c1f-320">권장 변경 내용</span><span class="sxs-lookup"><span data-stu-id="73c1f-320">Recommended changes</span></span> |
| ------- | ------------------------ | ------------------- |
| <span data-ttu-id="73c1f-321">**일광 절약**</span><span class="sxs-lookup"><span data-stu-id="73c1f-321">**Daylight savings**</span></span> | <span data-ttu-id="73c1f-322">시스템 시계와의 일관성을 위해, 시간 속성(예: <xref:System.TimeZoneInfo.Local> 및 <xref:System.DateTime.Now>)은 일광 절약 시간제 작업에 대해 다른 .NET Framework 데이터 대신 운영 체제 규칙을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-322">To be consistent with the system clock, time properties (such as <xref:System.TimeZoneInfo.Local> and <xref:System.DateTime.Now>) now use operating system rules instead of other .NET Framework data for daylight saving time operations.</span></span> | <span data-ttu-id="73c1f-323">없음</span><span class="sxs-lookup"><span data-stu-id="73c1f-323">None.</span></span> |
| <span data-ttu-id="73c1f-324">**문자열 서식 지정**</span><span class="sxs-lookup"><span data-stu-id="73c1f-324">**Formatting strings**</span></span> | <span data-ttu-id="73c1f-325">문화권에 민감한 서식을 지원하기 위해 새로운 `ParseExact` 및 `TryParseExact` 메서드 외에도 `ToString`, `Parse` 및 `TryParse` 메서드의 새로운 오버로드가 <xref:System.TimeSpan> 구조에 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-325">To support culture-sensitive formatting, the <xref:System.TimeSpan> structure includes new overloads of the `ToString`, `Parse`, and `TryParse` methods in addition to new `ParseExact` and `TryParseExact` methods.</span></span> | <span data-ttu-id="73c1f-326">없음</span><span class="sxs-lookup"><span data-stu-id="73c1f-326">None.</span></span> |

### <a name="globalization"></a><span data-ttu-id="73c1f-327">전역화</span><span class="sxs-lookup"><span data-stu-id="73c1f-327">Globalization</span></span>

<span data-ttu-id="73c1f-328">중립적인 새로운 특정 문화권 목록은 [세계화 및 지역화의 새로운 기능](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/dd997383%28v=vs.100%29)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-328">For a list of new neutral and specific cultures, see [What's New in Globalization and Localization](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/dd997383%28v=vs.100%29).</span></span>

<span data-ttu-id="73c1f-329">네임스페이스: <xref:System.Globalization>; 어셈블리: mscorlib(mscorlib.dll)</span><span class="sxs-lookup"><span data-stu-id="73c1f-329">Namespace: <xref:System.Globalization>; assembly: mscorlib (in mscorlib.dll)</span></span>

| <span data-ttu-id="73c1f-330">기능</span><span class="sxs-lookup"><span data-stu-id="73c1f-330">Feature</span></span> | <span data-ttu-id="73c1f-331">3\.5 SP1과의 차이점</span><span class="sxs-lookup"><span data-stu-id="73c1f-331">Differences from 3.5 SP1</span></span> | <span data-ttu-id="73c1f-332">권장 변경 내용</span><span class="sxs-lookup"><span data-stu-id="73c1f-332">Recommended changes</span></span> |
| ------- | ------------------------ | ------------------- |
| <span data-ttu-id="73c1f-333">**문화권 이름**</span><span class="sxs-lookup"><span data-stu-id="73c1f-333">**Culture names**</span></span> | <span data-ttu-id="73c1f-334">다음과 같은 이름 변경은 독일, 디베히 및 아프리카 문화권에 영향을 미칩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-334">The following name changes affect the German, Divehi, and African cultures:</span></span><br><br><span data-ttu-id="73c1f-335">\* <xref:System.Globalization.CultureAndRegionInfoBuilder.CurrencyEnglishName>: 독일어(스위스)(de-CH) 문화권의 통화 이름이 “sFr.”에서</span><span class="sxs-lookup"><span data-stu-id="73c1f-335">\* <xref:System.Globalization.CultureAndRegionInfoBuilder.CurrencyEnglishName>: The currency name for the German (Switizerland) (de-CH) culture has changed from "sFr."</span></span> <span data-ttu-id="73c1f-336">“Fr.”로 변경되었습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-336">to "Fr.".</span></span><br><span data-ttu-id="73c1f-337">\* <xref:System.Globalization.DateTimeFormatInfo.LongDatePattern>: 디베히어(몰디브)(dv-MV) 문화권의 긴 날짜 패턴이 “dd/MMMM/yyyy”에서 “dd/MM/yyyy”로 변경되었습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-337">\* <xref:System.Globalization.DateTimeFormatInfo.LongDatePattern>: The long date pattern for the Divehi (Maldives) (dv-MV) culture has changed from "dd/MMMM/yyyy" to "dd/MM/yyyy".</span></span><br><span data-ttu-id="73c1f-338">\* <xref:System.Globalization.DateTimeFormatInfo.PMDesignator>: 아프리카어(남아프리카)(af-ZA) 문화권의 P.M.</span><span class="sxs-lookup"><span data-stu-id="73c1f-338">\* <xref:System.Globalization.DateTimeFormatInfo.PMDesignator>: The P.M.</span></span> <span data-ttu-id="73c1f-339">지정자가 “nm”에서 “PM”으로 변경되었습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-339">designator of the Afrikaans (South Africa) (af-ZA) culture has changed from "nm" to "PM".</span></span> | <span data-ttu-id="73c1f-340">문화권 이름이 변경됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-340">Note culture name changes.</span></span> |
| <span data-ttu-id="73c1f-341">**LCID 매개 변수**</span><span class="sxs-lookup"><span data-stu-id="73c1f-341">**LCID parameter**</span></span> | <span data-ttu-id="73c1f-342">자동화 서버 설정에서 예상되는 동작과의 일관성을 위해, CLR은 더 이상 `LCID` 매개 변수에 대한 현재 문화권을 관리되지 않는 COM 기반 애플리케이션에 전달하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-342">To be consistent with expected behavior in automation server settings, the CLR no longer passes the current culture for the `LCID` parameter to unmanaged COM-based applications.</span></span> <span data-ttu-id="73c1f-343">대신, 문화권에 1033(en-us)을 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-343">Instead, it passes 1033 (en-us) for the culture.</span></span> | <span data-ttu-id="73c1f-344">특정 문화권을 요구하는 기본 애플리케이션을 제외하고는 수정이 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-344">No modifications necessary except for native applications that require a specified culture.</span></span> |
| <span data-ttu-id="73c1f-345">**사용되지 않는 문화권 형식**</span><span class="sxs-lookup"><span data-stu-id="73c1f-345">**Obsolete culture types**</span></span> | <span data-ttu-id="73c1f-346"><xref:System.Globalization.CultureTypes> 및 <xref:System.Globalization.CultureTypes> 문화권 형식은 이제 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-346">The <xref:System.Globalization.CultureTypes> and <xref:System.Globalization.CultureTypes> culture types are now obsolete.</span></span><br><br><span data-ttu-id="73c1f-347">이전 버전과의 호환성을 위해 이제 <xref:System.Globalization.CultureTypes>는 이전 .NET Framework에 포함되었던 중립적인 특정 문화권을 반환하고, <xref:System.Globalization.CultureTypes>는 빈 목록을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-347">For backward compatibility, <xref:System.Globalization.CultureTypes> now returns neutral and specific cultures that were included with the previous .NET Framework, and <xref:System.Globalization.CultureTypes> now returns an empty list.</span></span> | <span data-ttu-id="73c1f-348"><xref:System.Globalization.CultureTypes> 열거형의 다른 값을 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-348">Use other values of the <xref:System.Globalization.CultureTypes> enumeration.</span></span> |
| <span data-ttu-id="73c1f-349">**문화권 검색**</span><span class="sxs-lookup"><span data-stu-id="73c1f-349">**Retrieving culture**</span></span> | <span data-ttu-id="73c1f-350">Windows 7부터 .NET Framework 4는 데이터 자체를 저장하는 대신 운영 체제에서 문화권 정보를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-350">Beginning with Windows 7, the .NET Framework 4 retrieves culture information from the operating system instead of storing the data itself.</span></span> <span data-ttu-id="73c1f-351">또한 .NET Framework는 데이터 정렬 및 대/소문자 처리를 위해 Windows와 동기화됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-351">In addition, the .NET Framework synchronizes with Windows for sorting and casing data.</span></span> | <span data-ttu-id="73c1f-352">없음</span><span class="sxs-lookup"><span data-stu-id="73c1f-352">None.</span></span> |
| <span data-ttu-id="73c1f-353">**Unicode 5.1 표준**</span><span class="sxs-lookup"><span data-stu-id="73c1f-353">**Unicode 5.1 standards**</span></span> | <span data-ttu-id="73c1f-354">이제 .NET Framework는 모든 유니코드 5.1 문자(약 1,400자 추가)를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-354">The .NET Framework now supports all Unicode 5.1 characters -- an addition of approximately 1400 characters.</span></span> <span data-ttu-id="73c1f-355">추가 문자에는 새로운 기호, 화살표, 분음 부호, 구두점, 수학 기호, CJK 스트로크 및 표의 문자, 추가 말라얄람어 및 텔루구어 숫자 문자, 다양한 미얀마어, 라틴어, 아랍어, 그리스어, 몽골어 및 키릴 문자가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-355">The additional characters include new symbols, arrows, diacritics, punctuation, mathematical symbols, CJK strokes and ideographs, additional Malayalam and Telugu numeric characters, and various Myanmar, Latin, Arabic, Greek, Mongolian, and Cyrillic characters.</span></span> <span data-ttu-id="73c1f-356">유니코드 5.1에서는 다음 새 스크립트가 지원됩니다. 순다어, 렙차어, 올치키어, 바이어(Vai), 사우라슈트라어, 카야리어(Kayah Li), 레장어, 구르무키어, 오리야어, 타밀어, 텔구루어, 말라얌람어 문자 및 참어(Cham)입니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-356">The following new scripts are supported with Unicode 5.1: Sundanese, Lepcha, Ol Chiki, Vai, Saurashtra, Kayah Li, Rejang, Gurmukhi, Odia, Tamil, Telugu, and Malayalam characters and Cham.</span></span> | <span data-ttu-id="73c1f-357">없음</span><span class="sxs-lookup"><span data-stu-id="73c1f-357">None.</span></span> |

### <a name="exceptions"></a><span data-ttu-id="73c1f-358">예외</span><span class="sxs-lookup"><span data-stu-id="73c1f-358">Exceptions</span></span>

<span data-ttu-id="73c1f-359">네임스페이스: <xref:System>, <xref:System.Runtime.ExceptionServices>; 어셈블리: mscorlib(mscorlib.dll)</span><span class="sxs-lookup"><span data-stu-id="73c1f-359">Namespaces: <xref:System>, <xref:System.Runtime.ExceptionServices>; assembly: mscorlib (in mscorlib.dll)</span></span>

| <span data-ttu-id="73c1f-360">기능</span><span class="sxs-lookup"><span data-stu-id="73c1f-360">Feature</span></span> | <span data-ttu-id="73c1f-361">3\.5 SP1과의 차이점</span><span class="sxs-lookup"><span data-stu-id="73c1f-361">Differences from 3.5 SP1</span></span> | <span data-ttu-id="73c1f-362">권장 변경 내용</span><span class="sxs-lookup"><span data-stu-id="73c1f-362">Recommended changes</span></span> |
| ------- | ------------------------ | ------------------- |
| <span data-ttu-id="73c1f-363">**손상된 프로세스 상태에 대한 예외**</span><span class="sxs-lookup"><span data-stu-id="73c1f-363">**Exceptions for corrupted process state**</span></span> | <span data-ttu-id="73c1f-364">CLR은 더 이상 손상된 프로세스 상태에 대한 예외를 관리 코드의 예외 처리기로 전달하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-364">The CLR no longer delivers exceptions for corrupted process state to exception handlers in managed code.</span></span> | <span data-ttu-id="73c1f-365">이러한 예외는 프로세스의 상태가 손상되었음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-365">These exceptions indicate that the state of a process has been corrupted.</span></span> <span data-ttu-id="73c1f-366">이 상태에서는 애플리케이션을 실행하는 것이 좋지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-366">We do not recommend that you run your application in this state.</span></span><br><br><span data-ttu-id="73c1f-367">자세한 내용은 MSDN Magazine의 <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> 및 [손상된 상태 예외 처리](https://docs.microsoft.com/archive/msdn-magazine/2009/february/clr-inside-out-handling-corrupted-state-exceptions) 항목을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-367">For more information, see the <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> and the entry [Handling Corrupted State Exceptions](https://docs.microsoft.com/archive/msdn-magazine/2009/february/clr-inside-out-handling-corrupted-state-exceptions) in the MSDN magazine.</span></span> |
| <span data-ttu-id="73c1f-368">**실행 엔진 예외**</span><span class="sxs-lookup"><span data-stu-id="73c1f-368">**Execution engine exceptions**</span></span> | <span data-ttu-id="73c1f-369">catchable 예외로 인해 불안정한 프로세스가 계속 실행될 수 있으므로 <xref:System.ExecutionEngineException>은 이제는 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-369"><xref:System.ExecutionEngineException> is now obsolete, because a catchable exception will allow an unstable process to continue to run.</span></span> <span data-ttu-id="73c1f-370">이러한 변경 덕분에 예측 가능성 및 런타임 시 안정성이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-370">This change improves predictability and reliability in the runtime.</span></span> | <span data-ttu-id="73c1f-371"><xref:System.InvalidOperationException>을 사용하여 조건을 알리세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-371">Use an <xref:System.InvalidOperationException> to signal the condition.</span></span> |

### <a name="reflection"></a><span data-ttu-id="73c1f-372">반사</span><span class="sxs-lookup"><span data-stu-id="73c1f-372">Reflection</span></span>

<span data-ttu-id="73c1f-373">네임스페이스: <xref:System.Reflection>; 어셈블리: mscorlib(mscorlib.dll)</span><span class="sxs-lookup"><span data-stu-id="73c1f-373">Namespace: <xref:System.Reflection>; assembly: mscorlib (in mscorlib.dll)</span></span>

| <span data-ttu-id="73c1f-374">기능</span><span class="sxs-lookup"><span data-stu-id="73c1f-374">Feature</span></span> | <span data-ttu-id="73c1f-375">3\.5 SP1과의 차이점</span><span class="sxs-lookup"><span data-stu-id="73c1f-375">Differences from 3.5 SP1</span></span> | <span data-ttu-id="73c1f-376">권장 변경 내용</span><span class="sxs-lookup"><span data-stu-id="73c1f-376">Recommended changes</span></span> |
| ------- | ------------------------ | ------------------- |
| <span data-ttu-id="73c1f-377">**어셈블리 해시 알고리즘**</span><span class="sxs-lookup"><span data-stu-id="73c1f-377">**Assembly hash algorithms**</span></span> | <span data-ttu-id="73c1f-378">어셈블리가 로드되지 않을 경우 런타임에서 참조된 어셈블리의 해시 알고리즘을 알지 못하기 때문에 <xref:System.Reflection.AssemblyName.HashAlgorithm> 속성은 이제 <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm>을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-378">The <xref:System.Reflection.AssemblyName.HashAlgorithm> property now returns <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm>, because the runtime does not know the hash algorithm of the referenced assembly when the assembly is not loaded.</span></span> <span data-ttu-id="73c1f-379">이는 <xref:System.Reflection.Assembly.GetReferencedAssemblies%2A> 메서드에 의해 반환된 것과 같이 참조된 어셈블리의 속성을 사용함을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-379">(This refers to using the property on a referenced assembly such as that returned by the <xref:System.Reflection.Assembly.GetReferencedAssemblies%2A> method.)</span></span> | <span data-ttu-id="73c1f-380">없음</span><span class="sxs-lookup"><span data-stu-id="73c1f-380">None.</span></span> |
| <span data-ttu-id="73c1f-381">**어셈블리 로딩**</span><span class="sxs-lookup"><span data-stu-id="73c1f-381">**Assembly loading**</span></span> | <span data-ttu-id="73c1f-382">어셈블리의 중복 로드를 방지하고 가상 주소 공간을 절약하기 위해 이제 CLR은 Win32 `MapViewOfFile` 함수만 사용하여 어셈블리를 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-382">To prevent redundant loading of assemblies and to save virtual address space, the CLR now loads assemblies by using only the Win32 `MapViewOfFile` function.</span></span> <span data-ttu-id="73c1f-383">또한 더 이상 `LoadLibrary` 함수를 호출하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-383">It no longer also calls the `LoadLibrary` function.</span></span><br><br><span data-ttu-id="73c1f-384">이러한 변경은 진단 애플리케이션에 다음과 같은 방식으로 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-384">This change affects diagnostic applications in the following ways:</span></span><br><br><span data-ttu-id="73c1f-385">\* <xref:System.Diagnostics.ProcessModuleCollection>에는 `Process.GetCurrentProcess().Modules`에 대한 호출에서 가져온 클래스 라이브러리(.dll 파일)의 모듈이 더 이상 포함되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-385">\* A <xref:System.Diagnostics.ProcessModuleCollection> will no longer contain any modules from a class library (.dll file), as obtained from a call to `Process.GetCurrentProcess().Modules`.</span></span><br><span data-ttu-id="73c1f-386">`EnumProcessModules` 함수를 사용하는 Win32 애플리케이션은 나열된 관리되는 모듈을 모두 볼 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-386">\* Win32 applications that use the `EnumProcessModules` function will not see all managed modules listed.</span></span> | <span data-ttu-id="73c1f-387">없음</span><span class="sxs-lookup"><span data-stu-id="73c1f-387">None.</span></span> |
| <span data-ttu-id="73c1f-388">**선언 형식**</span><span class="sxs-lookup"><span data-stu-id="73c1f-388">**Declaring type**</span></span> | <span data-ttu-id="73c1f-389">형식에 선언 형식이 없으면 이제 <xref:System.Type.DeclaringType> 속성이 올바르게 null을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-389">The <xref:System.Type.DeclaringType> property now correctly returns null when the type does not have a declaring type.</span></span> | <span data-ttu-id="73c1f-390">없음</span><span class="sxs-lookup"><span data-stu-id="73c1f-390">None.</span></span> |
| <span data-ttu-id="73c1f-391">**대리자**</span><span class="sxs-lookup"><span data-stu-id="73c1f-391">**Delegates**</span></span> | <span data-ttu-id="73c1f-392">대리자의 생성자에 null 값이 전달되면 이제 대리자가 <xref:System.NullReferenceException> 대신 <xref:System.ArgumentNullException>을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-392">A delegate now throws an <xref:System.ArgumentNullException> instead of a <xref:System.NullReferenceException> when a null value is passed to the delegate's constructor.</span></span> | <span data-ttu-id="73c1f-393">예외 처리가 <xref:System.ArgumentNullException>을 catch하는지 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-393">Ensure that any exception handling catches <xref:System.ArgumentNullException>.</span></span> |
| <span data-ttu-id="73c1f-394">**전역 어셈블리 캐시 위치 변경**</span><span class="sxs-lookup"><span data-stu-id="73c1f-394">**Global assembly cache location change**</span></span> | <span data-ttu-id="73c1f-395">.NET Framework 4 어셈블리의 경우 전역 어셈블리 캐시가 Windows 디렉터리(%WINDIR%)에서 Microsoft.Net 하위 디렉터리( *%WINDIR%\\Microsoft.Net*)로 이동했습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-395">For .NET Framework 4 assemblies, the global assembly cache has been moved from the Windows directory (%WINDIR%) to the Microsoft.Net subdirectory (*%WINDIR%\\Microsoft.Net*).</span></span> <span data-ttu-id="73c1f-396">이전 버전의 어셈블리는 이전 디렉터리에 남아 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-396">Assemblies from earlier versions remain in the older directory.</span></span><br><br><span data-ttu-id="73c1f-397">관리되지 않는 [ASM_CACHE_FLAGS](../unmanaged-api/fusion/asm-cache-flags-enumeration.md) 열거형에 새 `ASM_CACHE_ROOT_EX` 플래그가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-397">The unmanaged [ASM_CACHE_FLAGS](../unmanaged-api/fusion/asm-cache-flags-enumeration.md) enumeration contains the new `ASM_CACHE_ROOT_EX` flag.</span></span> <span data-ttu-id="73c1f-398">이 플래그는 [GetCachePath](../unmanaged-api/fusion/getcachepath-function.md) 함수로 얻을 수 있는 .NET Framework 4 어셈블리의 캐시 위치를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-398">This flag gets the cache location for .NET Framework 4 assemblies, which can be obtained by the [GetCachePath](../unmanaged-api/fusion/getcachepath-function.md) function.</span></span> | <span data-ttu-id="73c1f-399">애플리케이션이 어셈블리에 대한 명시적 경로를 사용하지 않는다고 가정할 경우에는 이 방식이 권장되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-399">None, assuming that applications do not use explicit paths to assemblies, which is not a recommended practice.</span></span> |
| <span data-ttu-id="73c1f-400">**전역 어셈블리 캐시 도구**</span><span class="sxs-lookup"><span data-stu-id="73c1f-400">**Global assembly cache tool**</span></span> | <span data-ttu-id="73c1f-401">[Gacutil.exe(전역 어셈블리 캐시 도구)](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ex0ss12c%28v=vs.100%29)는 더 이상 셸 플러그 인 뷰어를 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-401">The [Gacutil.exe (Global Assembly Cache Tool)](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ex0ss12c%28v=vs.100%29) no longer supports the shell plugin viewer.</span></span> | <span data-ttu-id="73c1f-402">없음</span><span class="sxs-lookup"><span data-stu-id="73c1f-402">None.</span></span> |

### <a name="interoperability"></a><span data-ttu-id="73c1f-403">상호 운용성</span><span class="sxs-lookup"><span data-stu-id="73c1f-403">Interoperability</span></span>

<span data-ttu-id="73c1f-404">네임스페이스: <xref:System.Runtime.InteropServices>; 어셈블리: mscorlib(mscorlib.dll)</span><span class="sxs-lookup"><span data-stu-id="73c1f-404">Namespace: <xref:System.Runtime.InteropServices>; assembly: mscorlib (in mscorlib.dll)</span></span>

| <span data-ttu-id="73c1f-405">기능</span><span class="sxs-lookup"><span data-stu-id="73c1f-405">Feature</span></span> | <span data-ttu-id="73c1f-406">3\.5 SP1과의 차이점</span><span class="sxs-lookup"><span data-stu-id="73c1f-406">Differences from 3.5 SP1</span></span> | <span data-ttu-id="73c1f-407">권장 변경 내용</span><span class="sxs-lookup"><span data-stu-id="73c1f-407">Recommended changes</span></span> |
| ------- | ------------------------ | ------------------- |
| <span data-ttu-id="73c1f-408">**버퍼 길이**(관리되지 않는 API)</span><span class="sxs-lookup"><span data-stu-id="73c1f-408">**Buffer length** (unmanaged API)</span></span> | <span data-ttu-id="73c1f-409">메모리를 절약하기 위해 [ICorProfilerInfo2::GetStringLayout](../unmanaged-api/profiling/icorprofilerinfo2-getstringlayout-method.md) 메서드에 대한 `pBufferLengthOffset` 매개 변수의 기능이 `pStringLengthOffset` 매개 변수와 일치하도록 변경되었습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-409">To save memory, the functionality for the `pBufferLengthOffset` parameter for the [ICorProfilerInfo2::GetStringLayout](../unmanaged-api/profiling/icorprofilerinfo2-getstringlayout-method.md) method has been changed to match the `pStringLengthOffset` parameter.</span></span> <span data-ttu-id="73c1f-410">이제 두 매개 변수가 문자열 길이의 오프셋 위치를 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-410">Both parameters now point to the offset location of the string's length.</span></span> <span data-ttu-id="73c1f-411">문자열 클래스의 표시에서 버퍼 길이가 제거되었습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-411">Buffer length has been removed from the representation of the string class.</span></span> | <span data-ttu-id="73c1f-412">버퍼 길이에 대한 종속성을 제거하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-412">Remove any dependency on the buffer length.</span></span> |
| <span data-ttu-id="73c1f-413">**JIT 디버깅**</span><span class="sxs-lookup"><span data-stu-id="73c1f-413">**JIT debugging**</span></span> | <span data-ttu-id="73c1f-414">JIT(Just-In-Time) 디버깅에 대한 등록을 단순화하기 위해 .NET Framework 디버거는 이제 네이티브 코드의 JIT 디버깅 동작을 제어하는 AeDebug 레지스트리 키만 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-414">To simplify registration for just-in-time (JIT) debugging, the .NET Framework debugger now uses only the AeDebug registry key, which controls the JIT debugging behavior for native code.</span></span> <span data-ttu-id="73c1f-415">이 변경의 결과는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-415">This change results in the following:</span></span><br><br><span data-ttu-id="73c1f-416">\* 더 이상 관리되는 네이티브 코드에 대해 서로 다른 두 가지 디버거를 등록할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-416">\* You can no longer register two different debuggers for managed and native code.</span></span><br><span data-ttu-id="73c1f-417">\* 비대화형 프로세스에 대해 자동으로 디버거를 시작할 수는 없지만, 사용자에게 대화형 프로세스를 요구할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-417">\* You can no longer start the debugger automatically for a non-interactive process, but you can prompt the user for an interactive process.</span></span><br><span data-ttu-id="73c1f-418">\* 디버거가 시작되지 않거나 시작해야 하는 등록된 디버거가 없을 때 더 이상 알림이 표시되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-418">\* You are no longer notified when the debugger fails to start, or when there is no registered debugger that should be started.</span></span><br><span data-ttu-id="73c1f-419">\* 애플리케이션의 대화형 작업에 의존하는 자동 시작 정책이 더 이상 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-419">\* Auto-launch policies that depend on the interactivity of the application are no longer supported.</span></span> | <span data-ttu-id="73c1f-420">필요에 따라 디버깅 작업을 조정하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-420">Adjust debugging operations as required.</span></span> |
| <span data-ttu-id="73c1f-421">**플랫폼 호출**</span><span class="sxs-lookup"><span data-stu-id="73c1f-421">**Platform invoke**</span></span> | <span data-ttu-id="73c1f-422">비관리 코드와의 상호 운용성 성능을 향상하기 위해, 이제 플랫폼 호출에 잘못된 호출 규칙이 있으면 애플리케이션이 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-422">To improve performance in interoperability with unmanaged code, incorrect calling conventions in a platform invoke now cause the application to fail.</span></span> <span data-ttu-id="73c1f-423">이전 버전에서는 마샬링 계층이 스택 위에서 이러한 오류를 해결했습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-423">In previous versions, the marshaling layer resolved these errors up the stack.</span></span> | <span data-ttu-id="73c1f-424">Microsoft Visual Studio에서 애플리케이션을 디버그하면 이러한 오류를 알려주므로 수정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-424">Debugging your applications in Microsoft Visual Studio alerts you to these errors so you can correct them.</span></span><br><br><span data-ttu-id="73c1f-425">업데이트할 수 없는 이진 파일이 있는 경우 애플리케이션의 구성 파일에 [\<NetFx40_PInvokeStackResilience&gt;](../configure-apps/file-schema/runtime/netfx40-pinvokestackresilience-element.md) 요소를 포함하면 이전 버전과 마찬가지로 스택 위에서 호출 오류를 해결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-425">If you have binaries that cannot be updated, you can include the [\<NetFx40_PInvokeStackResilience>](../configure-apps/file-schema/runtime/netfx40-pinvokestackresilience-element.md) element in your application's configuration file to enable calling errors to be resolved up the stack as in earlier versions.</span></span> <span data-ttu-id="73c1f-426">그러나 이 경우 애플리케이션의 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-426">However, this may affect the performance of your application.</span></span> |
| <span data-ttu-id="73c1f-427">**제거된 인터페이스**(관리되지 않는 API)</span><span class="sxs-lookup"><span data-stu-id="73c1f-427">**Removed interfaces** (unmanaged API)</span></span> | <span data-ttu-id="73c1f-428">개발자에게 혼란을 주지 않도록 다음 인터페이스가 제거되었습니다. 이러한 인터페이스는 유용한 런타임 시나리오를 제공하지 않았고 CLR이 구현을 제공하거나 수락하지 않았기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-428">To avoid developer confusion, the following interfaces were removed, because they did not provide any useful run-time scenarios, and the CLR did not provide or accept any implementations:</span></span><br><br><span data-ttu-id="73c1f-429">\* **INativeImageINativeImageDependency**</span><span class="sxs-lookup"><span data-stu-id="73c1f-429">\* **INativeImageINativeImageDependency**</span></span><br><span data-ttu-id="73c1f-430">\* **INativeImageInstallInfo**</span><span class="sxs-lookup"><span data-stu-id="73c1f-430">\* **INativeImageInstallInfo**</span></span><br><span data-ttu-id="73c1f-431">\* **INativeImageEvaluate**</span><span class="sxs-lookup"><span data-stu-id="73c1f-431">\* **INativeImageEvaluate**</span></span><br><span data-ttu-id="73c1f-432">\* **INativeImageConverter**</span><span class="sxs-lookup"><span data-stu-id="73c1f-432">\* **INativeImageConverter**</span></span><br><span data-ttu-id="73c1f-433">\* **ICorModule**</span><span class="sxs-lookup"><span data-stu-id="73c1f-433">\* **ICorModule**</span></span><br><span data-ttu-id="73c1f-434">\* **IMetaDataConverter**</span><span class="sxs-lookup"><span data-stu-id="73c1f-434">\* **IMetaDataConverter**</span></span> | <span data-ttu-id="73c1f-435">없음</span><span class="sxs-lookup"><span data-stu-id="73c1f-435">None.</span></span> |

## <a name="data"></a><span data-ttu-id="73c1f-436">데이터</span><span class="sxs-lookup"><span data-stu-id="73c1f-436">Data</span></span>

<span data-ttu-id="73c1f-437">이 섹션에서는 데이터 집합 및 SQL 클라이언트, Entity Framework, LINQ to SQL, WCF Data Services(이전의 ADO.NET Data Services) 사용에 대한 마이그레이션 문제를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-437">This section describes migration issues for using data sets and SQL clients, the Entity Framework, LINQ to SQL, and WCF Data Servers (formerly known as ADO.NET Data Services).</span></span>

### <a name="dataset-and-sql-client"></a><span data-ttu-id="73c1f-438">데이터 세트 및 SQL 클라이언트</span><span class="sxs-lookup"><span data-stu-id="73c1f-438">DataSet and SQL Client</span></span>

<span data-ttu-id="73c1f-439">다음 표에서는 이전에 제한 사항이었거나 기타 문제가 있던 기능의 개선 내용을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-439">The following table describes improvements to features that previously had limitations or other issues.</span></span>

<span data-ttu-id="73c1f-440">네임스페이스: <xref:System.Data>, <xref:System.Data.Objects.DataClasses>, <xref:System.Data.SqlClient>; 어셈블리: System.Data(System.Data.dll의), System.Data.Entity(System.Data.Entity.dll의)</span><span class="sxs-lookup"><span data-stu-id="73c1f-440">Namespaces: <xref:System.Data>, <xref:System.Data.Objects.DataClasses>, <xref:System.Data.SqlClient>; assemblies: System.Data (in System.Data.dll), System.Data.Entity (in System.Data.Entity.dll)</span></span>

| <span data-ttu-id="73c1f-441">기능</span><span class="sxs-lookup"><span data-stu-id="73c1f-441">Feature</span></span> | <span data-ttu-id="73c1f-442">3\.5 SP1과의 차이점</span><span class="sxs-lookup"><span data-stu-id="73c1f-442">Differences from 3.5 SP1</span></span> |
| ------- | ------------------------ |
| <span data-ttu-id="73c1f-443">**POCO 시나리오**</span><span class="sxs-lookup"><span data-stu-id="73c1f-443">**POCO Scenarios**</span></span> | <span data-ttu-id="73c1f-444"><xref:System.Data.Objects.DataClasses.IRelatedEnd> 인터페이스에는 POCO(Plain Old CLR Object) 시나리오의 유용성을 개선하기 위한 새로운 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-444">The <xref:System.Data.Objects.DataClasses.IRelatedEnd> interface has new methods to improve its usability in Plain Old CLR Object (POCO) scenarios.</span></span> <span data-ttu-id="73c1f-445">이 새로운 메서드는 매개 변수로 <xref:System.Data.Objects.DataClasses.IEntityWithRelationships> 엔터티 대신 <xref:System.Object>를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-445">These new methods take an <xref:System.Object> instead of an <xref:System.Data.Objects.DataClasses.IEntityWithRelationships> entity as a parameter.</span></span> |
| <span data-ttu-id="73c1f-446">**행 편집**</span><span class="sxs-lookup"><span data-stu-id="73c1f-446">**Editing Rows**</span></span> | <span data-ttu-id="73c1f-447"><xref:System.Data.DataView> 클래스에 의해 구현된 <xref:System.Collections.IList.IndexOf%2A> 메서드는 이제 -1을 반환하는 대신 편집 중인 행의 값을 올바르게 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-447">The <xref:System.Collections.IList.IndexOf%2A> method, as implemented by the <xref:System.Data.DataView> class, now correctly returns the value of a row that is being edited, instead of returning -1.</span></span> |
| <span data-ttu-id="73c1f-448">**이벤트**</span><span class="sxs-lookup"><span data-stu-id="73c1f-448">**Events**</span></span> | <span data-ttu-id="73c1f-449">행이 수정된 상태이고 <xref:System.Data.DataRow.RejectChanges%2A> 메서드가 호출되면 이제 <xref:System.Data.DataRowView.PropertyChanged> 이벤트가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-449">The <xref:System.Data.DataRowView.PropertyChanged> event is now raised when a row is in a modified state and the <xref:System.Data.DataRow.RejectChanges%2A> method is called.</span></span> <span data-ttu-id="73c1f-450">이러한 변경을 통해 <xref:System.Data.DataSet> 개체의 내용을 노출하는 UI 컨트롤을 더 쉽게 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-450">This change makes it easier to create UI controls that expose the contents of a <xref:System.Data.DataSet> object.</span></span> |
| <span data-ttu-id="73c1f-451">**예외**</span><span class="sxs-lookup"><span data-stu-id="73c1f-451">**Exceptions**</span></span> | <span data-ttu-id="73c1f-452">연결이 설정되어 있지 않거나 <xref:System.NullReferenceException> 대신 열려 있으면 이제 <xref:System.Data.SqlClient.SqlCommand.Prepare%2A> 메서드가 <xref:System.InvalidOperationException>을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-452">The <xref:System.Data.SqlClient.SqlCommand.Prepare%2A> method now throws an <xref:System.InvalidOperationException> when a connection is not set or open instead of a <xref:System.NullReferenceException>.</span></span> |
| <span data-ttu-id="73c1f-453">**매핑 보기**</span><span class="sxs-lookup"><span data-stu-id="73c1f-453">**Mapping Views**</span></span> | <span data-ttu-id="73c1f-454">쿼리 뷰 매핑 오류가 이제 런타임에 <xref:System.NullReferenceException>을 throw하는 대신 디자인 타임에 catch됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-454">Query view mapping errors are now caught at design time instead of throwing a <xref:System.NullReferenceException> at run time.</span></span><br><br><span data-ttu-id="73c1f-455">이제 매핑 유효성 검사는 개념 스키마(CSDL)의 두 연결 집합이 동일한 열로 매핑되는 오류를 catch합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-455">Mapping validation now catches the error in which two association sets in Conceptual Schema (CSDL) are mapped to the same column.</span></span> |
| <span data-ttu-id="73c1f-456">**트랜잭션**</span><span class="sxs-lookup"><span data-stu-id="73c1f-456">**Transactions**</span></span> | <span data-ttu-id="73c1f-457">트랜잭션이 완료된 후(중단되거나 롤백된 경우 포함) 애플리케이션이 연결에서 명령문을 실행하려고 하면 이제 <xref:System.InvalidOperationException>이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-457">If an application tries to execute a statement on a connection after a transaction has been completed (including aborted or rolled back), an <xref:System.InvalidOperationException> is now thrown.</span></span> <span data-ttu-id="73c1f-458">이전 버전에서는 예외가 throw되지 않았으므로 트랜잭션이 중단되더라도 추가 명령을 실행할 수 있었습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-458">Previous versions did not throw an exception and let you execute additional commands even if a transaction was aborted.</span></span> |

### <a name="entity-framework"></a><span data-ttu-id="73c1f-459">Entity Framework</span><span class="sxs-lookup"><span data-stu-id="73c1f-459">Entity Framework</span></span>

<span data-ttu-id="73c1f-460">다음 표에서는 이전에 제한 사항이었거나 기타 문제가 있던 기능의 개선 내용을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-460">The following table describes improvements to features that previously had limitations or other issues.</span></span>

<span data-ttu-id="73c1f-461">네임스페이스: <xref:System.Data>, <xref:System.Data.Objects>, <xref:System.Data.Objects.DataClasses>; 어셈블리: System.Data.Entity(System.Data.Entity.dll의)</span><span class="sxs-lookup"><span data-stu-id="73c1f-461">Namespaces: <xref:System.Data>, <xref:System.Data.Objects>, <xref:System.Data.Objects.DataClasses>; assembly: System.Data.Entity (in System.Data.Entity.dll)</span></span>

| <span data-ttu-id="73c1f-462">기능</span><span class="sxs-lookup"><span data-stu-id="73c1f-462">Feature</span></span> | <span data-ttu-id="73c1f-463">3\.5 SP1과의 차이점</span><span class="sxs-lookup"><span data-stu-id="73c1f-463">Differences from 3.5 SP1</span></span> |
| ------- | ------------------------ |
| <span data-ttu-id="73c1f-464">**엔터티 개체**</span><span class="sxs-lookup"><span data-stu-id="73c1f-464">**Entity objects**</span></span> | <span data-ttu-id="73c1f-465">이제 <xref:System.Data.Objects.ObjectContext.Detach%2A> 메서드와 <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> 메서드가 호출될 때 엔터티 개체의 상태 간에 패리티가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-465">There is now parity between the <xref:System.Data.Objects.ObjectContext.Detach%2A> method and the state of the entity object when the <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> method is called.</span></span> <span data-ttu-id="73c1f-466">이렇게 일관성이 향상되어 예기치 않은 예외가 throw되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-466">This improved consistency prevents unexpected exceptions from being thrown.</span></span> |
| <span data-ttu-id="73c1f-467">**Entity SQL**</span><span class="sxs-lookup"><span data-stu-id="73c1f-467">**Entity SQL**</span></span> | <span data-ttu-id="73c1f-468">Entity SQL에서 식별자 해결에 대한 규칙이 개선되었습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-468">Rules have been improved for identifier resolutions in Entity SQL.</span></span><br><br><span data-ttu-id="73c1f-469">Entity SQL 파서에서 다중 파트 식별자 확인에 대한 논리가 개선되었습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-469">The Entity SQL parser has improved logic for resolving multipart identifiers.</span></span> |
| <span data-ttu-id="73c1f-470">**구조적 주석**</span><span class="sxs-lookup"><span data-stu-id="73c1f-470">**Structural annotations**</span></span> | <span data-ttu-id="73c1f-471">이제 Entity Framework가 구조적 주석을 인식합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-471">The Entity Framework now recognizes structural annotations.</span></span> |
| <span data-ttu-id="73c1f-472">**쿼리**</span><span class="sxs-lookup"><span data-stu-id="73c1f-472">**Queries**</span></span> | <span data-ttu-id="73c1f-473">쿼리는 다음과 같이 향상되었습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-473">The following improvements were made in queries:</span></span><br><br><span data-ttu-id="73c1f-474">\* 빈 컬렉션에 대해 null 키를 사용하는 `GroupBy` 쿼리는 쿼리에 추가 선택 항목이 있는지에 관계없이 행을 반환하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-474">\* A `GroupBy` query using a null key over an empty collection will not return any rows, regardless if there are any additional selects in the query.</span></span><br><span data-ttu-id="73c1f-475">\* LINQ 및 Entity-SQL 쿼리에서 생성된 SQL은 기본적으로 문자열 매개 변수를 유니코드가 아닌 값으로 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-475">\* Generated SQL in LINQ and Entity-SQL queries now treat string parameters as non-Unicode values by default.</span></span> |

### <a name="linq-to-sql"></a><span data-ttu-id="73c1f-476">LINQ to SQL</span><span class="sxs-lookup"><span data-stu-id="73c1f-476">LINQ to SQL</span></span>

<span data-ttu-id="73c1f-477">다음 표에서는 이전에 제한 사항이었거나 기타 문제가 있던 기능의 개선 내용을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-477">The following table describes improvements to features that previously had limitations or other issues.</span></span>

<span data-ttu-id="73c1f-478">네임스페이스: <xref:System.Data.Linq>; 어셈블리: System.Data.Linq(System.Data.Linq.dll의)</span><span class="sxs-lookup"><span data-stu-id="73c1f-478">Namespace: <xref:System.Data.Linq>; assembly: System.Data.Linq (in System.Data.Linq.dll)</span></span>

| <span data-ttu-id="73c1f-479">기능</span><span class="sxs-lookup"><span data-stu-id="73c1f-479">Feature</span></span> | <span data-ttu-id="73c1f-480">3\.5 SP1과의 차이점</span><span class="sxs-lookup"><span data-stu-id="73c1f-480">Differences from 3.5 SP1</span></span> |
| ------- | ------------------------ |
| <span data-ttu-id="73c1f-481">**이벤트**</span><span class="sxs-lookup"><span data-stu-id="73c1f-481">**Events**</span></span> | <span data-ttu-id="73c1f-482">컬렉션이 로드될 때 이벤트를 일으키는 것 외에도, <xref:System.Data.Linq.EntitySet%601>가 언로드될 때 <xref:System.Data.Linq.EntitySet%601> 컬렉션은 이제 추가 및 제거 작업에 대해 <xref:System.Data.Linq.EntitySet%601.ListChanged> 이벤트를 발생시킵니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-482">A <xref:System.Data.Linq.EntitySet%601> collection now raises the <xref:System.Data.Linq.EntitySet%601.ListChanged> event for add and remove operations if the <xref:System.Data.Linq.EntitySet%601> is unloaded, in addition to raising the event when the collection is loaded.</span></span> |
| <span data-ttu-id="73c1f-483">**쿼리**</span><span class="sxs-lookup"><span data-stu-id="73c1f-483">**Queries**</span></span> | <span data-ttu-id="73c1f-484">`Skip(0)`은 LINQ to SQL 쿼리에서 더 이상 무시되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-484">`Skip(0)` is no longer ignored in LINQ to SQL queries.</span></span> <span data-ttu-id="73c1f-485">따라서 이 메서드가 있는 쿼리가 다르게 동작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-485">As a result, queries that have this method might behave differently.</span></span> <span data-ttu-id="73c1f-486">예를 들면 경우에 따라 `Skip(0)`에 `OrderBy` 절이 필요하며, `OrderBy` 절이 포함되지 않은 경우 이제 쿼리에서 <xref:System.NotSupportedException> 예외를 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-486">For example in some cases, an `OrderBy` clause is required with `Skip(0)`, and the query will now throw a <xref:System.NotSupportedException> exception if the `OrderBy` clause was not included.</span></span> |

### <a name="wcf-data-services"></a><span data-ttu-id="73c1f-487">WCF Data Services</span><span class="sxs-lookup"><span data-stu-id="73c1f-487">WCF Data Services</span></span>

<span data-ttu-id="73c1f-488">다음 표에서는 이전에 제한 사항이었거나 기타 문제가 있던 기능의 개선 내용을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-488">The following table describes improvements to features that previously had limitations or other issues.</span></span>

<span data-ttu-id="73c1f-489">네임스페이스: <xref:System.Data.Services>, <xref:System.Data.Services.Client>, <xref:System.Data.Services.Common>, <xref:System.Data.Services.Providers>; 어셈블리: System.Data.Services(System.Data.Services.dll의), System.Data.Services.Client(System.Data.Services.Client.dll의)</span><span class="sxs-lookup"><span data-stu-id="73c1f-489">Namespaces: <xref:System.Data.Services>, <xref:System.Data.Services.Client>, <xref:System.Data.Services.Common>, <xref:System.Data.Services.Providers>; assemblies: System.Data.Services (in System.Data.Services.dll), System.Data.Services.Client (in System.Data.Services.Client.dll)</span></span>

| <span data-ttu-id="73c1f-490">기능</span><span class="sxs-lookup"><span data-stu-id="73c1f-490">Feature</span></span> | <span data-ttu-id="73c1f-491">3\.5 SP1과의 차이점</span><span class="sxs-lookup"><span data-stu-id="73c1f-491">Differences from 3.5 SP1</span></span> |
| ------- | ------------------------ |
| <span data-ttu-id="73c1f-492">**일괄 처리된 이진 콘텐츠**</span><span class="sxs-lookup"><span data-stu-id="73c1f-492">**Batched Binary Content**</span></span> | <span data-ttu-id="73c1f-493">이제 WCF 데이터 서비스는 요청 및 응답에서 일괄 처리된 이진 콘텐츠를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-493">WCF Data Services now supports batched binary content in requests and responses.</span></span> |
| <span data-ttu-id="73c1f-494">**변경 인터셉터**</span><span class="sxs-lookup"><span data-stu-id="73c1f-494">**Change interceptors**</span></span> | <span data-ttu-id="73c1f-495">이제 삭제 요청에 대해 변경 인터셉터가 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-495">Change interceptors are now executed for a delete request.</span></span><br><br><span data-ttu-id="73c1f-496">변경 인터셉터는 엔터티 집합의 엔터티를 수정하기 위해 서버에서 요청을 수신할 때마다 실행되는 메서드로서,</span><span class="sxs-lookup"><span data-stu-id="73c1f-496">A change interceptor is a method that runs every time a request is received by the server to modify an entity in the entity set.</span></span> <span data-ttu-id="73c1f-497">들어오는 요청이 실행되기 전에 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-497">It runs before the incoming request is executed.</span></span> <span data-ttu-id="73c1f-498">또한 변경되고 있는 엔터티 및 여기에서 수행되는 작업에 대한 액세스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-498">The change interceptor provides access to the entity that is being changed and the operation that is being performed on it.</span></span> |
| <span data-ttu-id="73c1f-499">**예외**</span><span class="sxs-lookup"><span data-stu-id="73c1f-499">**Exceptions**</span></span> | <span data-ttu-id="73c1f-500">다음 조건은 이제 <xref:System.NullReferenceException> 대신 좀 더 유용한 예외를 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-500">The following conditions now throw more useful exceptions instead of a <xref:System.NullReferenceException>:</span></span><br><br><span data-ttu-id="73c1f-501">\* 데이터 서비스 호출이 시간 초과될 때 <xref:System.ServiceProcess.TimeoutException>.</span><span class="sxs-lookup"><span data-stu-id="73c1f-501">\* A <xref:System.ServiceProcess.TimeoutException> when a call to a data service times out.</span></span><br><span data-ttu-id="73c1f-502">\* 데이터 서비스에 대한 잘못된 요청이 있을 때 <xref:System.Data.Services.Client.DataServiceRequestException>.</span><span class="sxs-lookup"><span data-stu-id="73c1f-502">\* A <xref:System.Data.Services.Client.DataServiceRequestException> when a bad request is made to a data service.</span></span><br><br><span data-ttu-id="73c1f-503">애플리케이션에서 새 예외를 catch하려면 예외 처리를 변경해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-503">In your applications, you should change exception handling to catch the new exceptions.</span></span> |
| <span data-ttu-id="73c1f-504">**헤더**</span><span class="sxs-lookup"><span data-stu-id="73c1f-504">**Headers**</span></span> | <span data-ttu-id="73c1f-505">헤더는 다음과 같이 향상되었습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-505">The following improvements were made to headers:</span></span><br><br><span data-ttu-id="73c1f-506">\* WCF Data Services는 이제 지정되지 않은 값을 가지고 있는 `eTag` 헤더를 올바르게 거부합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-506">\* WCF Data Services now correctly rejects an `eTag` header that has an unspecified value.</span></span><br><span data-ttu-id="73c1f-507">\* WCF Data Services는 이제 오류를 반환하고, 요청에 `if-*` 헤더가 있을 때 링크에 대한 삭제 요청을 실행하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-507">\* WCF Data Services now returns an error and does not execute the request for a delete request to a link when an `if-*` header is in the request.</span></span><br><span data-ttu-id="73c1f-508">\* WCF Data Services는 이제 클라이언트가 Accept 헤더에 지정한 형식(Atom, JSON)으로 클라이언트에 오류를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-508">\* WCF Data Services now returns an error to the client in the format (Atom, JSON) that the client specified in the Accept header.</span></span> |
| <span data-ttu-id="73c1f-509">**JSON 판독기**</span><span class="sxs-lookup"><span data-stu-id="73c1f-509">**JSON Reader**</span></span> | <span data-ttu-id="73c1f-510">JSON(JavaScript Object Notation) 판독기는 이제 WCF 데이터 서비스로 전송된 JSON 페이로드를 처리할 때 단일 백 슬래시(“\\”) 이스케이프 문자를 읽을 경우 올바르게 오류를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-510">The JavaScript Object Notation (JSON) reader now correctly returns an error when it reads the single backslash ("\\") escape character, when it processes JSON payloads sent to a WCF Data Service.</span></span> |
| <span data-ttu-id="73c1f-511">**병합**</span><span class="sxs-lookup"><span data-stu-id="73c1f-511">**Merges**</span></span> | <span data-ttu-id="73c1f-512"><xref:System.Data.Services.Client.MergeOption> 열거형은 다음과 같이 향상되었습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-512">The following improvements were made to the <xref:System.Data.Services.Client.MergeOption> enumeration:</span></span><br><br><span data-ttu-id="73c1f-513">\* <xref:System.Data.Services.Client.MergeOption> 병합 옵션은 더 이상 데이터 서비스에서 오는 후속 응답의 결과로 클라이언트의 엔터티를 수정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-513">\* The <xref:System.Data.Services.Client.MergeOption> merge option no longer modifies the entity on the client as a result of any subsequent response from a data service.</span></span><br><span data-ttu-id="73c1f-514">\* <xref:System.Data.Services.Client.MergeOption> 옵션은 이제 동적 SQL과 저장 프로시저 기반 업데이트 간에 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-514">\* The <xref:System.Data.Services.Client.MergeOption> option is now consistent between dynamic SQL and stored procedure-based updates.</span></span> |
| <span data-ttu-id="73c1f-515">**요청**</span><span class="sxs-lookup"><span data-stu-id="73c1f-515">**Requests**</span></span> | <span data-ttu-id="73c1f-516"><xref:System.Data.Services.DataService%601.OnStartProcessingRequest%2A> 메서드는 이제 데이터 서비스에 대한 요청이 처리되기 전에 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-516">The <xref:System.Data.Services.DataService%601.OnStartProcessingRequest%2A> method is now called before a request to data services is processed.</span></span> <span data-ttu-id="73c1f-517">따라서 <xref:System.Data.Services.Providers.ServiceOperation> 서비스에 대한 요청이 올바르게 작동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-517">This enables the request to work correctly for <xref:System.Data.Services.Providers.ServiceOperation> services.</span></span> |
| <span data-ttu-id="73c1f-518">**스트림**</span><span class="sxs-lookup"><span data-stu-id="73c1f-518">**Streams**</span></span> | <span data-ttu-id="73c1f-519">WCF Data Services는 더 이상 읽기 및 쓰기 작업에 대한 기본 스트림을 닫지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-519">WCF Data Services no longer closes the underlying stream for read and write operations.</span></span> |
| <span data-ttu-id="73c1f-520">**URI**</span><span class="sxs-lookup"><span data-stu-id="73c1f-520">**URIs**</span></span> | <span data-ttu-id="73c1f-521">WCF Data Services 클라이언트에서 URI의 이스케이프가 수정되었습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-521">The escaping of URIs by WCF Data Services client has been corrected.</span></span> |

## <a name="windows-communication-foundation-wcf"></a><span data-ttu-id="73c1f-522">WCF(Windows Communication Foundation)</span><span class="sxs-lookup"><span data-stu-id="73c1f-522">Windows Communication Foundation (WCF)</span></span>

<span data-ttu-id="73c1f-523">다음 표에서는 이전에 제한 사항이었거나 기타 문제가 있던 기능의 개선 내용을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-523">The following table describes improvements to features that previously had limitations or other issues.</span></span>

| <span data-ttu-id="73c1f-524">기능</span><span class="sxs-lookup"><span data-stu-id="73c1f-524">Feature</span></span> | <span data-ttu-id="73c1f-525">3\.5 SP1과의 차이점</span><span class="sxs-lookup"><span data-stu-id="73c1f-525">Differences from 3.5 SP1</span></span> |
| ------- | ------------------------ |
| <span data-ttu-id="73c1f-526">**구성 파일**</span><span class="sxs-lookup"><span data-stu-id="73c1f-526">**Configuration files**</span></span> | <span data-ttu-id="73c1f-527">구성 파일 계층 구조를 통해 동작을 상속할 수 있도록 WCF는 이제 구성 파일 간 병합을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-527">To enable inheritance of behaviors through the configuration file hierarchy, WCF now supports merging across configuration files.</span></span><br><br><span data-ttu-id="73c1f-528">이제 구성 상속 모델이 확장되어 컴퓨터에서 실행 중인 모든 서비스에 적용될 동작을 사용자가 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-528">The configuration inheritance model is now expanded to let users define behaviors that will be applied to all the services that are running on the computer.</span></span><br><br><span data-ttu-id="73c1f-529">계층 구조의 서로 다른 수준에 같은 이름의 동작이 있는 경우 동작 변경이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-529">You may encounter behavioral changes if there are behaviors with the same name at different levels of the hierarchy.</span></span> |
| <span data-ttu-id="73c1f-530">**서비스 호스팅**</span><span class="sxs-lookup"><span data-stu-id="73c1f-530">**Service hosting**</span></span> | <span data-ttu-id="73c1f-531">요소 정의에 `allowDefinition="MachineToApplication"` 특성을 추가하여 서비스 수준에서 더 이상 `<serviceHostingEnvironment>` 구성 요소를 지정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-531">You can no longer specify the `<serviceHostingEnvironment>` configuration element at the service level by adding the attribute `allowDefinition="MachineToApplication"` to the element definition.</span></span><br><br><span data-ttu-id="73c1f-532">서비스 수준에서 `<serviceHostingEnvironment>` 요소를 지정하는 것은 기술적으로 올바르지 않으며, 이로 인해 일관성 없는 동작이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-532">Specifying the `<serviceHostingEnvironment>` element at the service level is technically incorrect and causes inconsistent behavior.</span></span> |

## <a name="windows-presentation-foundation-wpf"></a><span data-ttu-id="73c1f-533">WPF(Windows Presentation Foundation)</span><span class="sxs-lookup"><span data-stu-id="73c1f-533">Windows Presentation Foundation (WPF)</span></span>

### <a name="applications"></a><span data-ttu-id="73c1f-534">애플리케이션</span><span class="sxs-lookup"><span data-stu-id="73c1f-534">Applications</span></span>

<span data-ttu-id="73c1f-535">네임스페이스: <xref:System.Windows>, <xref:System.Windows.Controls>; 어셈블리: PresentationFramework(PresentationFramework.dll의)</span><span class="sxs-lookup"><span data-stu-id="73c1f-535">Namespaces: <xref:System.Windows>, <xref:System.Windows.Controls>; assembly: PresentationFramework (in PresentationFramework.dll)</span></span>

| <span data-ttu-id="73c1f-536">기능</span><span class="sxs-lookup"><span data-stu-id="73c1f-536">Feature</span></span> | <span data-ttu-id="73c1f-537">3\.5 SP1과의 차이점</span><span class="sxs-lookup"><span data-stu-id="73c1f-537">Differences from 3.5 SP1</span></span> | <span data-ttu-id="73c1f-538">권장 변경 내용</span><span class="sxs-lookup"><span data-stu-id="73c1f-538">Recommended changes</span></span> |
| ------- | ------------------------ | ------------------- |
| <span data-ttu-id="73c1f-539">**예외 처리**</span><span class="sxs-lookup"><span data-stu-id="73c1f-539">**Exception handling**</span></span> | <span data-ttu-id="73c1f-540">오류를 더 일찍 검색할 수 있도록 WPF는 <xref:System.Reflection.TargetInvocationException>을 throw하고 원래 예외를 catch하는 대신 <xref:System.Exception.InnerException> 속성을 <xref:System.NullReferenceException>, <xref:System.OutOfMemoryException>, <xref:System.StackOverflowException> 및 <xref:System.Security.SecurityException>과 같은 심각한 예외로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-540">To enable errors to be detected earlier, WPF throws a <xref:System.Reflection.TargetInvocationException> and sets the <xref:System.Exception.InnerException> property to critical exceptions, such as <xref:System.NullReferenceException>, <xref:System.OutOfMemoryException>, <xref:System.StackOverflowException>, and <xref:System.Security.SecurityException>, instead of catching the original exception.</span></span> | <span data-ttu-id="73c1f-541">없음</span><span class="sxs-lookup"><span data-stu-id="73c1f-541">None.</span></span> |
| <span data-ttu-id="73c1f-542">**연결된 리소스**</span><span class="sxs-lookup"><span data-stu-id="73c1f-542">**Linked resources**</span></span> | <span data-ttu-id="73c1f-543">좀 더 쉬운 연결을 위해, 프로젝트의 폴더 구조가 아닌 다른 위치에 있는 리소스 파일(예: 이미지)은 애플리케이션을 빌드할 때 파일 이름 대신 리소스 파일의 전체 경로를 리소스 ID로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-543">To make linking easier, resource files (such as images) that are located in a location other than the project's folder structure use the resource file's full path instead of just its file name as the resource ID when the application is built.</span></span> <span data-ttu-id="73c1f-544">애플리케이션은 런타임 시 파일을 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-544">The application will be able to locate the files at run time.</span></span> | <span data-ttu-id="73c1f-545">없음</span><span class="sxs-lookup"><span data-stu-id="73c1f-545">None.</span></span> |
| <span data-ttu-id="73c1f-546">**부분 신뢰 애플리케이션**</span><span class="sxs-lookup"><span data-stu-id="73c1f-546">**Partial-trust applications**</span></span> | <span data-ttu-id="73c1f-547">보안상의 이유로, 부분 신뢰로 실행되고 HTML이 포함된 <xref:System.Windows.Controls.WebBrowser> 컨트롤 또는 <xref:System.Windows.Controls.Frame> 컨트롤을 포함하는 Windows 기반 애플리케이션은 컨트롤이 생성될 때 <xref:System.Security.SecurityException>을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-547">For security considerations, Windows-based applications that run in partial trust and contain a <xref:System.Windows.Controls.WebBrowser> control or a <xref:System.Windows.Controls.Frame> control that contains HTML will throw a <xref:System.Security.SecurityException> when the control is created.</span></span><br><br><span data-ttu-id="73c1f-548">브라우저 애플리케이션은 예외를 throw하고 다음 조건이 모두 충족될 경우 메시지를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-548">Browser applications will throw an exception and display a message if all of the following conditions are met:</span></span><br><br><span data-ttu-id="73c1f-549">\* 애플리케이션이 Firefox에서 실행되고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-549">\* The application is running in Firefox.</span></span><br><span data-ttu-id="73c1f-550">\* 애플리케이션이 신뢰할 수 없는 사이트의 인터넷 영역에서 부분 신뢰로 실행되고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-550">\* The application is running in partial trust in the Internet zone from non-trusted sites.</span></span><br><span data-ttu-id="73c1f-551">\* 애플리케이션에 HTML이 포함된 <xref:System.Windows.Controls.WebBrowser> 컨트롤 또는 <xref:System.Windows.Controls.Frame> 컨트롤이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-551">\* The application contains a <xref:System.Windows.Controls.WebBrowser> control or a <xref:System.Windows.Controls.Frame> control that contains HTML.</span></span><br><br><span data-ttu-id="73c1f-552">신뢰할 수 있는 사이트 또는 인트라넷 영역에서 실행되는 애플리케이션은 영향을 받지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-552">Note that applications that run from trusted sites or from the intranet zone will not be affected.</span></span> | <span data-ttu-id="73c1f-553">브라우저 애플리케이션에서 다음 중 하나를 수행하여 이 변경의 영향을 완화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-553">In your browser applications, you can ease this change by doing one of the following:</span></span><br><br><span data-ttu-id="73c1f-554">\* 완전 신뢰에서 브라우저 애플리케이션을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-554">\* Run the browser application in full trust.</span></span><br><span data-ttu-id="73c1f-555">\* 고객이 애플리케이션의 사이트를 신뢰할 수 있는 사이트 영역에 추가하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-555">\* Have customers add the application's site to the trusted sites zone.</span></span><br><span data-ttu-id="73c1f-556">\* 고객이 Internet Explorer에서 애플리케이션을 실행하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-556">\* Have customers run the application in Internet Explorer.</span></span> |
| <span data-ttu-id="73c1f-557">**리소스 사전**</span><span class="sxs-lookup"><span data-stu-id="73c1f-557">**Resource dictionaries**</span></span> | <span data-ttu-id="73c1f-558">테마 수준 리소스 사전을 개선하고, 변경하지 못하도록 리소스 사전에 정의되어 있고 테마 수준 사전에 병합된 고정 가능한 리소스는 항상 고정된 것으로 표시되며 변경되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-558">To improve theme-level resource dictionaries and prevent them from changing, freezable resources that are defined in a resource dictionary and merged into a theme-level dictionary are now always marked as frozen and are immutable.</span></span> <span data-ttu-id="73c1f-559">이것이 고정 가능한 리소스에 대해 예상되는 동작입니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-559">This is the expected behavior for freezable resources.</span></span> | <span data-ttu-id="73c1f-560">테마 수준에서 병합된 사전에 정의된 리소스를 수정하는 애플리케이션은 리소스를 복제하고 복제된 복사본을 수정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-560">Applications that modify a resource that is defined in a theme-level merged dictionary should clone the resource and modify the cloned copy.</span></span> <span data-ttu-id="73c1f-561">또는 리소스를 쿼리할 때마다 <xref:System.Windows.ResourceDictionary>에서 새 복사본을 만들도록 리소스를 `x:Shared="false"`로 표시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-561">Alternatively, the resource can be marked `x:Shared="false"` so that the <xref:System.Windows.ResourceDictionary> creates a new copy every time the resource is queried.</span></span> |
| <span data-ttu-id="73c1f-562">**Windows 7**</span><span class="sxs-lookup"><span data-stu-id="73c1f-562">**Windows 7**</span></span> | <span data-ttu-id="73c1f-563">WPF 애플리케이션이 Windows 7에서 더 잘 작동할 수 있도록 다음과 같이 창 동작이 수정되었습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-563">To make WPF applications work better on Windows 7, the following improvements were made to correct the behavior of a window:</span></span><br><br><span data-ttu-id="73c1f-564">\* 도킹 및 제스처 상태가 이제 사용자 상호 작용을 기반으로 예상대로 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-564">\* Dock and gesture states now work as expected based on user interactions.</span></span><br><span data-ttu-id="73c1f-565">\* 작업 표시줄 명령 **Cascade windows, Show windows stacked** 및 **Show windows side-by-side**가 이제 올바르게 작동하고 적절한 속성을 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-565">\* The taskbar commands **Cascade windows, Show windows stacked**, and **Show windows side-by-side** now have the correct behavior and update the appropriate properties.</span></span><br><span data-ttu-id="73c1f-566">\* 이제 최대화 또는 최소화된 창의 `Top`, `Left`, `Width` 및 `Height` 속성에 모니터에 따라 다른 값 대신 창의 올바른 복원 위치가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-566">\* The `Top`, `Left`, `Width`, and `Height` properties for a maximized or minimized window now contain the correct restore location of the window instead of other values, depending on the monitor.</span></span> | <span data-ttu-id="73c1f-567">없음</span><span class="sxs-lookup"><span data-stu-id="73c1f-567">None.</span></span> |
| <span data-ttu-id="73c1f-568">**창 스타일 및 투명도**</span><span class="sxs-lookup"><span data-stu-id="73c1f-568">**Windows style and transparency**</span></span> | <span data-ttu-id="73c1f-569"><xref:System.Windows.Window.AllowsTransparency>가 `true`이고 <xref:System.Windows.WindowState>가 <xref:System.Windows.WindowState>일 때 <xref:System.Windows.Window.WindowStyle>을 <xref:System.Windows.WindowStyle> 이외의 값으로 설정하려고 하면 <xref:System.InvalidOperationException>이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-569">An <xref:System.InvalidOperationException> is thrown if you try to set <xref:System.Windows.Window.WindowStyle> to a value other than <xref:System.Windows.WindowStyle> when <xref:System.Windows.Window.AllowsTransparency> is `true` and <xref:System.Windows.WindowState> is <xref:System.Windows.WindowState>.</span></span> | <span data-ttu-id="73c1f-570"><xref:System.Windows.Window.AllowsTransparency>가 `true`일 때 <xref:System.Windows.Window.WindowStyle>을 변경해야 하는 경우 Win32 `SetWindowLongPtr` 기능을 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-570">If you must change the <xref:System.Windows.Window.WindowStyle> when <xref:System.Windows.Window.AllowsTransparency> is `true`, you can call the Win32 `SetWindowLongPtr` function.</span></span> |
| <span data-ttu-id="73c1f-571">**XPS 뷰어**</span><span class="sxs-lookup"><span data-stu-id="73c1f-571">**XPS Viewer**</span></span> | <span data-ttu-id="73c1f-572">WPF에는 Microsoft XPSEP(XML Paper Specification Essentials Pack)가 포함되어 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-572">WPF does not include the Microsoft XML Paper Specification Essentials Pack (XPSEP).</span></span> <span data-ttu-id="73c1f-573">XPSEP는 Windows 7 및 Windows Vista에 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-573">XPSEP is included with Windows 7 and Windows Vista.</span></span><br><br><span data-ttu-id="73c1f-574">.NET Framework 3.5 SP1을 설치하지 않고 Windows XP를 실행하는 컴퓨터에서는 <xref:System.Windows.Controls.PrintDialog>에 있는 것 이외의 WPF API를 사용하여 인쇄할 때 WINSPOOL에 의존하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-574">On a computer that is running Windows XP without the .NET Framework 3.5 SP1 installed, printing by using a WPF API other than those in <xref:System.Windows.Controls.PrintDialog> will rely on the WINSPOOL.</span></span> <span data-ttu-id="73c1f-575">일부 프린터 기능은 보고되지 않으며 일부 프린터 설정은 인쇄 중에 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-575">Some printer capabilities will not be reported and some printer settings will not be applied during printing.</span></span> | <span data-ttu-id="73c1f-576">필요한 경우 [Microsoft XML Paper Specification Essentials Pack](https://go.microsoft.com/fwlink/?LinkId=178895)을 설치하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-576">If needed, install the [Microsoft XML Paper Specification Essentials Pack](https://go.microsoft.com/fwlink/?LinkId=178895).</span></span> |

### <a name="controls"></a><span data-ttu-id="73c1f-577">컨트롤</span><span class="sxs-lookup"><span data-stu-id="73c1f-577">Controls</span></span>

<span data-ttu-id="73c1f-578">네임스페이스: <xref:System.Windows>, <xref:System.Windows.Controls>, <xref:System.Windows.Data>, <xref:System.Windows.Input>; 어셈블리: PresentationFramework(PresentationFramework.dll의), PresentationCore(PresentationCore.dll의), WindowsBase(WindowsBase.dll의)</span><span class="sxs-lookup"><span data-stu-id="73c1f-578">Namespaces: <xref:System.Windows>, <xref:System.Windows.Controls>, <xref:System.Windows.Data>, <xref:System.Windows.Input>; assemblies: PresentationFramework (in PresentationFramework.dll), PresentationCore (in PresentationCore.dll), WindowsBase (in WindowsBase.dll)</span></span>

| <span data-ttu-id="73c1f-579">기능</span><span class="sxs-lookup"><span data-stu-id="73c1f-579">Feature</span></span> | <span data-ttu-id="73c1f-580">3\.5 SP1과의 차이점</span><span class="sxs-lookup"><span data-stu-id="73c1f-580">Differences from 3.5 SP1</span></span> | <span data-ttu-id="73c1f-581">권장 변경 내용</span><span class="sxs-lookup"><span data-stu-id="73c1f-581">Recommended changes</span></span> |
| ------- | ------------------------ | ------------------- |
| <span data-ttu-id="73c1f-582">**대화 상자**</span><span class="sxs-lookup"><span data-stu-id="73c1f-582">**Dialog boxes**</span></span> | <span data-ttu-id="73c1f-583">안정성을 높이기 위해 <xref:Microsoft.Win32.CommonDialog.ShowDialog%2A> 메서드는 <xref:Microsoft.Win32.FileDialog> 컨트롤을 만든 동일한 스레드에서 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-583">To improve reliability, the <xref:Microsoft.Win32.CommonDialog.ShowDialog%2A> method is called on the same thread that created the <xref:Microsoft.Win32.FileDialog> control.</span></span> | <span data-ttu-id="73c1f-584">반드시 <xref:Microsoft.Win32.FileDialog> 컨트롤을 만들고 동일한 스레드에서 <xref:Microsoft.Win32.CommonDialog.ShowDialog%2A> 메서드를 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-584">Be sure to create a <xref:Microsoft.Win32.FileDialog> control and call the <xref:Microsoft.Win32.CommonDialog.ShowDialog%2A> method on the same thread.</span></span> |
| <span data-ttu-id="73c1f-585">**부동 창**</span><span class="sxs-lookup"><span data-stu-id="73c1f-585">**Floating windows**</span></span> | <span data-ttu-id="73c1f-586">부동 창을 올바르지 않게 계속해서 다시 활성화하여 모달 대화 상자처럼 표시되게 하는 포커스 복원 논리를 수정하기 위해, 이제 후보가 창의 자식이 아닌 경우 포커스 복원이 방지됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-586">To fix focus restoration logic that incorrectly keeps reactivating a floating window (making it appear like a modal dialog box), focus restoration is now prevented if the candidate is not a child of the window.</span></span> | <span data-ttu-id="73c1f-587">없음</span><span class="sxs-lookup"><span data-stu-id="73c1f-587">None.</span></span> |
| <span data-ttu-id="73c1f-588">**컬렉션의 항목**</span><span class="sxs-lookup"><span data-stu-id="73c1f-588">**Items in collections**</span></span> | <span data-ttu-id="73c1f-589">항목을 기본 컬렉션으로 이동하거나 추가할 경우, <xref:System.Windows.Data.CollectionView>가 정렬되지 않으면 동일한 상대 위치의 <xref:System.Windows.Data.CollectionView>에 항목이 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-589">When an item is moved or added to an underlying collection, it appears in the <xref:System.Windows.Data.CollectionView> in the same relative location if the <xref:System.Windows.Data.CollectionView> is not sorted.</span></span> <span data-ttu-id="73c1f-590">이렇게 하면 컬렉션의 항목 위치 및 연관된 <xref:System.Windows.Data.CollectionView>의 항목 위치 간에 일관성이 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-590">This provides consistency between the item's position in the collection and in the associated <xref:System.Windows.Data.CollectionView>.</span></span> | <span data-ttu-id="73c1f-591">항목의 고정된 위치에 의존하는 대신 <xref:System.Windows.Data.CollectionView>에서 항목의 위치를 찾으려면 <xref:System.Windows.Controls.ItemContainerGenerator.ContainerFromItem%2A> 또는 <xref:System.Windows.Data.CollectionView.IndexOf%2A> 메서드를 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-591">Use the <xref:System.Windows.Controls.ItemContainerGenerator.ContainerFromItem%2A> or <xref:System.Windows.Data.CollectionView.IndexOf%2A> method to find the location of an item in a <xref:System.Windows.Data.CollectionView> instead of relying on a fixed location of an item.</span></span> |
| <span data-ttu-id="73c1f-592">**레이아웃**</span><span class="sxs-lookup"><span data-stu-id="73c1f-592">**Layouts**</span></span> | <span data-ttu-id="73c1f-593">불필요한 레이아웃 재작업을 제거하기 위해 <xref:System.Windows.Controls.Page.ShowsNavigationUI>를 변경하면 더 이상 레이아웃이 무효화되지 않거나 다른 레이아웃이 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-593">To eliminate unnecessary re-layouts, changing the <xref:System.Windows.Controls.Page.ShowsNavigationUI> no longer invalidates layout or causes another layout pass.</span></span> | <span data-ttu-id="73c1f-594"><xref:System.Windows.Controls.Page.ShowsNavigationUI>를 변경하면 다른 레이아웃이 전달될 것으로 예상하는 경우, 속성을 설정한 후에 <xref:System.Windows.UIElement.InvalidateVisual%2A>을 호출하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-594">If you expect that changing <xref:System.Windows.Controls.Page.ShowsNavigationUI> will cause another layout pass, call <xref:System.Windows.UIElement.InvalidateVisual%2A> after you set the property.</span></span> |
| <span data-ttu-id="73c1f-595">**메뉴**</span><span class="sxs-lookup"><span data-stu-id="73c1f-595">**Menus**</span></span> | <span data-ttu-id="73c1f-596">메뉴 팝업에서 ClearType 텍스트를 사용할 수 있도록 <xref:System.Windows.Controls.ControlTemplate> 클래스와 <xref:System.Windows.Controls.MenuItem> 컨트롤 및 기타 컨트롤이 수정되었습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-596">To enable ClearType text in menu pop-ups, modifications were made to the <xref:System.Windows.Controls.ControlTemplate> class and to the <xref:System.Windows.Controls.MenuItem> control and other controls.</span></span> | <span data-ttu-id="73c1f-597">애플리케이션은 컨트롤 템플릿의 시각적 구조에 의존해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-597">Applications should not rely on the visual structure of control templates.</span></span> <span data-ttu-id="73c1f-598"><xref:System.Windows.Controls.ControlTemplate>의 명명된 부분만 공용 계약의 일부입니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-598">Only named parts of a <xref:System.Windows.Controls.ControlTemplate> are part of the public contract.</span></span> <span data-ttu-id="73c1f-599">애플리케이션이 <xref:System.Windows.Controls.ControlTemplate>에서 특정 개체를 찾아야 하는 경우, 트리에서 개체의 고정된 위치에 의존하는 대신 시각적 트리에서 특정 형식을 검색하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-599">If an application must find a certain object in a <xref:System.Windows.Controls.ControlTemplate>, search the visual tree for a specific type instead of relying on a fixed location of an object in the tree.</span></span> |
| <span data-ttu-id="73c1f-600">**탐색**</span><span class="sxs-lookup"><span data-stu-id="73c1f-600">**Navigating**</span></span> | <span data-ttu-id="73c1f-601"><xref:System.Windows.Controls.Frame>이 특정 위치로 직접 이동하면 초기 탐색 후 <xref:System.Windows.Navigation.NavigatingCancelEventArgs.IsNavigationInitiator> 속성은 `true`입니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-601">If a <xref:System.Windows.Controls.Frame> directly navigates to a location, the <xref:System.Windows.Navigation.NavigatingCancelEventArgs.IsNavigationInitiator> property is `true` after the initial navigation.</span></span> <span data-ttu-id="73c1f-602">이러한 변경 덕분에 시작 시나리오 중에 추가 이벤트가 발생하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-602">This change prevents additional events from being raised during startup scenarios.</span></span> | <span data-ttu-id="73c1f-603">없음</span><span class="sxs-lookup"><span data-stu-id="73c1f-603">None.</span></span> |
| <span data-ttu-id="73c1f-604">**팝업**</span><span class="sxs-lookup"><span data-stu-id="73c1f-604">**Pop-ups**</span></span> | <span data-ttu-id="73c1f-605">레이아웃 전달 중에 <xref:System.Windows.Controls.Primitives.CustomPopupPlacementCallback> 대리자를 한 번만 호출하는 대신 여러 번 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-605">The <xref:System.Windows.Controls.Primitives.CustomPopupPlacementCallback> delegate can now be called multiple times during a layout pass instead of only once.</span></span> | <span data-ttu-id="73c1f-606"><xref:System.Windows.Controls.Primitives.CustomPopupPlacementCallback> 대리자가 이전 위치를 기반으로 <xref:System.Windows.Controls.Primitives.Popup>의 위치를 계산할 때 `popupSize`, `targetSize` 또는 `offset` 매개 변수의 값이 변경되는 경우에만 위치를 다시 계산하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-606">If your <xref:System.Windows.Controls.Primitives.CustomPopupPlacementCallback> delegate calculates the position of a <xref:System.Windows.Controls.Primitives.Popup> based on its previous position, recalculate the position only if the values of the `popupSize`, `targetSize`, or `offset` parameters change.</span></span> |
| <span data-ttu-id="73c1f-607">**속성 값**</span><span class="sxs-lookup"><span data-stu-id="73c1f-607">**Property values**</span></span> | <span data-ttu-id="73c1f-608"><xref:System.Windows.DependencyObject.SetCurrentValue%2A> 메서드를 사용할 경우 속성에 영향을 미치는 모든 바인딩, 스타일 또는 트리거는 계속 준수되지만, 속성을 유효한 값으로 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-608">The <xref:System.Windows.DependencyObject.SetCurrentValue%2A> method now lets you set a property to an effective value, although it continues to respects any binding, style, or trigger that affects the property.</span></span> | <span data-ttu-id="73c1f-609">컨트롤 작성자는 사용자 조작을 포함하여 다른 동작의 부작용으로 속성 값이 변경될 때마다 <xref:System.Windows.DependencyObject.SetCurrentValue%2A>를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-609">Control authors should use <xref:System.Windows.DependencyObject.SetCurrentValue%2A> whenever the property value changes as a side-effect of some other action, including user manipulation.</span></span> |
| <span data-ttu-id="73c1f-610">**텍스트 상자**</span><span class="sxs-lookup"><span data-stu-id="73c1f-610">**Text boxes**</span></span> | <span data-ttu-id="73c1f-611">보안상의 이유로, <xref:System.Windows.Forms.TextBoxBase.Copy%2A> 및 <xref:System.Windows.Forms.TextBoxBase.Cut%2A> 메서드는 부분 신뢰로 호출될 때 자동으로 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-611">For security considerations, the <xref:System.Windows.Forms.TextBoxBase.Copy%2A> and <xref:System.Windows.Forms.TextBoxBase.Cut%2A> methods silently fail when they are called in partial trust.</span></span><br><br><span data-ttu-id="73c1f-612">또한 <xref:System.Windows.Controls.Primitives.TextBoxBase>에서 상속한 컨트롤의 <xref:System.Windows.Input.ApplicationCommands.Copy> 또는 <xref:System.Windows.Input.ApplicationCommands.Cut> 속성을 프로그래밍 방식으로 실행하면 부분 신뢰에서 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-612">In addition, programmatic execution of the <xref:System.Windows.Input.ApplicationCommands.Copy> or <xref:System.Windows.Input.ApplicationCommands.Cut> property on a control that inherits from <xref:System.Windows.Controls.Primitives.TextBoxBase> will be blocked in partial trust.</span></span> <span data-ttu-id="73c1f-613">그러나 <xref:System.Windows.Controls.Primitives.ButtonBase.Command> 속성이 이러한 명령 중 하나에 바인딩된 단추를 클릭하는 등 사용자가 시작한 복사 및 잘라내기 명령은 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-613">However, user-initiated copy and cut commands, such as clicking a button whose <xref:System.Windows.Controls.Primitives.ButtonBase.Command> property is bound to one of these commands, will work.</span></span> <span data-ttu-id="73c1f-614">바로 가기 키를 통한 표준 복사 및 잘라내기와 상황에 맞는 메뉴는 이전과 마찬가지로 부분 신뢰로 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-614">Standard copy and cut through keyboard shortcuts and the context menu will still work as before in partial trust.</span></span> | <span data-ttu-id="73c1f-615">단추 클릭 등 사용자가 시작한 작업에 <xref:System.Windows.Input.ApplicationCommands.Copy> 또는 <xref:System.Windows.Input.ApplicationCommands.Cut> 명령을 바인딩하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-615">Bind the <xref:System.Windows.Input.ApplicationCommands.Copy> or <xref:System.Windows.Input.ApplicationCommands.Cut> command to a user-initiated action, such as clicking a button.</span></span> |

### <a name="graphics"></a><span data-ttu-id="73c1f-616">그래픽</span><span class="sxs-lookup"><span data-stu-id="73c1f-616">Graphics</span></span>

<span data-ttu-id="73c1f-617">네임스페이스: <xref:System.Windows>, <xref:System.Windows.Controls>, <xref:System.Windows.Data>, <xref:System.Windows.Input>, <xref:System.Windows.Media.Effects>; 어셈블리: PresentationFramework(PresentationFramework.dll의), PresentationCore(PresentationCore.dll의), WindowsBase(WindowsBase.dll의)</span><span class="sxs-lookup"><span data-stu-id="73c1f-617">Namespaces: <xref:System.Windows>, <xref:System.Windows.Controls>, <xref:System.Windows.Data>, <xref:System.Windows.Input>, <xref:System.Windows.Media.Effects>; assemblies: PresentationFramework (in PresentationFramework.dll), PresentationCore (in PresentationCore.dll), WindowsBase (in WindowsBase.dll)</span></span>

| <span data-ttu-id="73c1f-618">기능</span><span class="sxs-lookup"><span data-stu-id="73c1f-618">Feature</span></span> | <span data-ttu-id="73c1f-619">3\.5 SP1과의 차이점</span><span class="sxs-lookup"><span data-stu-id="73c1f-619">Differences from 3.5 SP1</span></span> | <span data-ttu-id="73c1f-620">권장 변경 내용</span><span class="sxs-lookup"><span data-stu-id="73c1f-620">Recommended changes</span></span> |
| ------- | ------------------------ | ------------------- |
| <span data-ttu-id="73c1f-621">**비트맵 효과**</span><span class="sxs-lookup"><span data-stu-id="73c1f-621">**Bitmap effects**</span></span> | <span data-ttu-id="73c1f-622">성능 향상을 위해, <xref:System.Windows.Media.Effects.BitmapEffect> 클래스 및 <xref:System.Windows.Media.Effects.BitmapEffect> 클래스에서 상속한 클래스는 여전히 존재하지만 비활성화되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-622">To improve performance, the <xref:System.Windows.Media.Effects.BitmapEffect> class and the classes that inherit from the <xref:System.Windows.Media.Effects.BitmapEffect> class, although still present, are disabled.</span></span> <span data-ttu-id="73c1f-623">다음 조건이 참인 경우 하드웨어 가속 렌더링 파이프라인을 사용하여 효과가 렌더링됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-623">The effect will render by using the hardware-accelerated rendering pipeline if the following conditions are true:</span></span><br><br><span data-ttu-id="73c1f-624">\* 애플리케이션은 반경 속성이 100DIU 미만인 <xref:System.Windows.Media.Effects.DropShadowBitmapEffect> 또는 <xref:System.Windows.Media.Effects.BlurBitmapEffect>를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-624">\* The application uses a <xref:System.Windows.Media.Effects.DropShadowBitmapEffect> or a <xref:System.Windows.Media.Effects.BlurBitmapEffect> that has a radius property set less than 100 DIU.</span></span><br><span data-ttu-id="73c1f-625">\* 애플리케이션을 실행하는 컴퓨터의 비디오 카드는 픽셀 셰이더 2.0을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-625">\* The video card on the computer that runs the application supports pixel shader 2.0.</span></span><br><br><span data-ttu-id="73c1f-626">이러한 조건이 충족되지 않으면 <xref:System.Windows.Media.Effects.BitmapEffect> 개체는 아무 효과도 없습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-626">If these conditions are not met, a <xref:System.Windows.Media.Effects.BitmapEffect> object will have no effect.</span></span><br><br><span data-ttu-id="73c1f-627">또한 Visual Studio는 <xref:System.Windows.Media.Effects.BitmapEffect> 개체 또는 하위 클래스를 발견하면 컴파일러 경고를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-627">Also, Visual Studio produces a compiler warning when it encounters the <xref:System.Windows.Media.Effects.BitmapEffect> object or a subclass.</span></span><br><br><span data-ttu-id="73c1f-628"><xref:System.Windows.Media.DrawingContext.PushEffect%2A> 메서드는 사용되지 않는 것으로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-628">The <xref:System.Windows.Media.DrawingContext.PushEffect%2A> method is marked obsolete.</span></span> | <span data-ttu-id="73c1f-629">기존의 <xref:System.Windows.Media.Effects.BitmapEffect> 및 파생 클래스 사용을 중단하고 대신 <xref:System.Windows.Media.Effects.Effect>에서 파생된 새 클래스(<xref:System.Windows.Media.Effects.BlurEffect>, <xref:System.Windows.Media.Effects.DropShadowEffect> 및 <xref:System.Windows.Media.Effects.ShaderEffect>)를 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-629">Discontinue using the legacy <xref:System.Windows.Media.Effects.BitmapEffect> and derived classes and instead use the new classes derived from <xref:System.Windows.Media.Effects.Effect>: <xref:System.Windows.Media.Effects.BlurEffect>, <xref:System.Windows.Media.Effects.DropShadowEffect>, and <xref:System.Windows.Media.Effects.ShaderEffect>.</span></span><br><br><span data-ttu-id="73c1f-630"><xref:System.Windows.Media.Effects.ShaderEffect> 클래스로부터 상속받아 자신의 고유한 효과를 만들 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-630">You can also create your own effects by inheriting from the <xref:System.Windows.Media.Effects.ShaderEffect> class.</span></span> |
| <span data-ttu-id="73c1f-631">**비트맵 프레임**</span><span class="sxs-lookup"><span data-stu-id="73c1f-631">**Bitmap frames**</span></span> | <span data-ttu-id="73c1f-632">복제된 <xref:System.Windows.Media.Imaging.BitmapFrame> 개체는 이제 <xref:System.Windows.Media.Imaging.BitmapSource.DownloadProgress>, <xref:System.Windows.Media.Imaging.BitmapSource.DownloadCompleted> 및 <xref:System.Windows.Media.Imaging.BitmapSource.DownloadFailed> 이벤트를 수신합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-632">The cloned <xref:System.Windows.Media.Imaging.BitmapFrame> objects now receive the <xref:System.Windows.Media.Imaging.BitmapSource.DownloadProgress>, <xref:System.Windows.Media.Imaging.BitmapSource.DownloadCompleted>, and <xref:System.Windows.Media.Imaging.BitmapSource.DownloadFailed> events.</span></span> <span data-ttu-id="73c1f-633">이렇게 하면, 웹에서 다운로드되어 <xref:System.Windows.Controls.Image> 컨트롤에 적용된 이미지가 <xref:System.Windows.Style>을 통해 올바르게 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-633">This enables images that are downloaded from the Web and applied to the <xref:System.Windows.Controls.Image> control through a <xref:System.Windows.Style> to work correctly.</span></span><br><br><span data-ttu-id="73c1f-634">다음이 모두 참인 경우에만 동작이 변경됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-634">You will see a change in behavior only if all of the following statements are true:</span></span><br><br><span data-ttu-id="73c1f-635">\* <xref:System.Windows.Media.Imaging.BitmapSource.DownloadProgress>, <xref:System.Windows.Media.Imaging.BitmapSource.DownloadCompleted> 또는 <xref:System.Windows.Media.Imaging.BitmapSource.DownloadFailed> 이벤트를 구독합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-635">\* You subscribe to the <xref:System.Windows.Media.Imaging.BitmapSource.DownloadProgress>, <xref:System.Windows.Media.Imaging.BitmapSource.DownloadCompleted>, or <xref:System.Windows.Media.Imaging.BitmapSource.DownloadFailed> event.</span></span><br><span data-ttu-id="73c1f-636">\* <xref:System.Windows.Media.Imaging.BitmapFrame>의 소스가 웹에서 온 것입니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-636">\* The source of the <xref:System.Windows.Media.Imaging.BitmapFrame> is from the Web.</span></span><br><span data-ttu-id="73c1f-637">\* 다운로드가 진행되는 동안 <xref:System.Windows.Media.Imaging.BitmapFrame>이 복제됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-637">\* The <xref:System.Windows.Media.Imaging.BitmapFrame> is cloned while the download is still in progress.</span></span> | <span data-ttu-id="73c1f-638">이벤트 처리기에서 전송자를 확인하고 전송자가 원래 <xref:System.Windows.Media.Imaging.BitmapFrame>인 경우에만 조치를 취하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-638">Check the sender in the event handler and take action only if the sender is the original <xref:System.Windows.Media.Imaging.BitmapFrame>.</span></span> |
| <span data-ttu-id="73c1f-639">**이미지 디코딩**</span><span class="sxs-lookup"><span data-stu-id="73c1f-639">**Decoding images**</span></span> | <span data-ttu-id="73c1f-640">이미지가 디코딩되지 않을 때 <xref:System.IO.IOException>이 처리되지 않도록 <xref:System.Windows.Media.Imaging.BitmapSource> 클래스는 이미지를 디코딩하지 않을 때 <xref:System.Windows.Media.Imaging.BitmapSource.DecodeFailed> 이벤트를 일으킵니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-640">To prevent an <xref:System.IO.IOException> from not being handled when images may not decode, the <xref:System.Windows.Media.Imaging.BitmapSource> class will raise the <xref:System.Windows.Media.Imaging.BitmapSource.DecodeFailed> event when it does not decode an image.</span></span> | <span data-ttu-id="73c1f-641"><xref:System.IO.IOException>에 대한 예외 처리를 제거하고 <xref:System.Windows.Media.Imaging.BitmapSource.DecodeFailed> 이벤트를 사용하여 디코딩 실패를 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-641">Remove any exception handling for <xref:System.IO.IOException>, and use the <xref:System.Windows.Media.Imaging.BitmapSource.DecodeFailed> event to check for decode failure.</span></span> |

### <a name="input"></a><span data-ttu-id="73c1f-642">입력</span><span class="sxs-lookup"><span data-stu-id="73c1f-642">Input</span></span>

<span data-ttu-id="73c1f-643">네임스페이스: <xref:System.Windows>, <xref:System.Windows.Controls>, <xref:System.Windows.Data>, <xref:System.Windows.Input>; 어셈블리: PresentationFramework(PresentationFramework.dll의), PresentationCore(PresentationCore.dll의), WindowsBase(WindowsBase.dll의)</span><span class="sxs-lookup"><span data-stu-id="73c1f-643">Namespaces: <xref:System.Windows>, <xref:System.Windows.Controls>, <xref:System.Windows.Data>, <xref:System.Windows.Input>; assemblies: PresentationFramework (in PresentationFramework.dll), PresentationCore (in PresentationCore.dll), WindowsBase (in WindowsBase.dll)</span></span>

| <span data-ttu-id="73c1f-644">기능</span><span class="sxs-lookup"><span data-stu-id="73c1f-644">Feature</span></span> | <span data-ttu-id="73c1f-645">3\.5 SP1과의 차이점</span><span class="sxs-lookup"><span data-stu-id="73c1f-645">Differences from 3.5 SP1</span></span> | <span data-ttu-id="73c1f-646">권장 변경 내용</span><span class="sxs-lookup"><span data-stu-id="73c1f-646">Recommended changes</span></span> |
| ------- | ------------------------ | ------------------- |
| <span data-ttu-id="73c1f-647">**명령 인스턴스 바인딩**</span><span class="sxs-lookup"><span data-stu-id="73c1f-647">**Binding command instances**</span></span> | <span data-ttu-id="73c1f-648">보기-모델 기반 명령 인스턴스를 보기 기반 입력 제스처에 바인딩하는 메커니즘을 제공하기 위해 <xref:System.Windows.Input.InputBinding> 클래스는 이제 <xref:System.Windows.DependencyObject> 대신 <xref:System.Windows.Freezable>에서 상속받습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-648">To provide a mechanism to bind View-Model-based command instances to View-based input gestures, the <xref:System.Windows.Input.InputBinding> class now inherits from <xref:System.Windows.Freezable> instead of <xref:System.Windows.DependencyObject>.</span></span> <span data-ttu-id="73c1f-649">이제 다음 속성이 종속성 속성이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-649">The following properties are now dependency properties:</span></span><br><br>* <xref:System.Windows.Input.InputBinding.Command><br>* <xref:System.Windows.Input.InputBinding.CommandParameter><br>* <xref:System.Windows.Input.InputBinding.CommandTarget><br><br><span data-ttu-id="73c1f-650">이 변경의 결과는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-650">This change results in the following:</span></span><br><br><span data-ttu-id="73c1f-651">\* 이제 <xref:System.Windows.Input.InputBinding> 개체는 변경 가능한 상태로 유지되는 대신 등록 시 고정됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-651">\* An <xref:System.Windows.Input.InputBinding> object is now frozen when it is registered instead of remaining mutable.</span></span><br><span data-ttu-id="73c1f-652">\* <xref:System.Windows.DependencyObject> 클래스의 제한 때문에 다중 스레드에서 인스턴스 수준 <xref:System.Windows.Input.InputBinding> 개체에 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-652">\* You cannot access instance-level <xref:System.Windows.Input.InputBinding> objects from multiple threads, due to the restrictions of the <xref:System.Windows.DependencyObject> class.</span></span><br><span data-ttu-id="73c1f-653">\* <xref:System.Windows.Freezable> 클래스의 제한 때문에 등록 이후에 클래스 수준 입력 바인딩을 변경할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-653">\* You cannot mutate class-level input bindings after their registration, due to the restrictions of the <xref:System.Windows.Freezable> class.</span></span><br><span data-ttu-id="73c1f-654">\* 보기-모델에서 작성된 명령 인스턴스에는 입력 바인딩을 지정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-654">\* You cannot specify input bindings on command instances that are created in a View-Model.</span></span> | <span data-ttu-id="73c1f-655">바인딩이 변경될 수 있는 경우 개별 스레드에 <xref:System.Windows.Input.InputBinding> 클래스의 개별 인스턴스를 작성하거나 아니면 고정하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-655">Create separate instances of an <xref:System.Windows.Input.InputBinding> class on separate threads if bindings are to be mutable, or freeze them otherwise.</span></span> <span data-ttu-id="73c1f-656">등록된 후에는 클래스 수준의 정적 <xref:System.Windows.Input.InputBinding>을 변경하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-656">Do not mutate a class-level static <xref:System.Windows.Input.InputBinding> after it has been registered.</span></span> |
| <span data-ttu-id="73c1f-657">**브라우저 애플리케이션**</span><span class="sxs-lookup"><span data-stu-id="73c1f-657">**Browser applications**</span></span> | <span data-ttu-id="73c1f-658">WPF 브라우저 애플리케이션(.XBAP)은 이제 개체가 올바른 순서로 라우팅된 키 이벤트를 수신할 수 있도록 독립 실행형 WPF 애플리케이션과 마찬가지로 키 이벤트를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-658">WPF Browser applications (.XBAP) now process key events just like stand-alone WPF applications so that objects receive routed key events in the correct order.</span></span> | <span data-ttu-id="73c1f-659">없음</span><span class="sxs-lookup"><span data-stu-id="73c1f-659">None.</span></span> |
| <span data-ttu-id="73c1f-660">**데드 키 조합**</span><span class="sxs-lookup"><span data-stu-id="73c1f-660">**Dead key combinations**</span></span> | <span data-ttu-id="73c1f-661">WPF는 눈에 보이는 문자를 생성하지 않는 데드 키를 난독 처리하지만, 대신 키가 다음 문자 키와 결합되어 한 문자를 생성함을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-661">WPF obfuscates dead keys, which produce no visible character, but instead indicates that the key is to be combined with the next letter key to produce one character.</span></span> <span data-ttu-id="73c1f-662"><xref:System.Windows.Input.Keyboard.KeyDownEvent> 이벤트와 같은 키 입력 이벤트는 <xref:System.Windows.Input.KeyEventArgs.Key> 속성을 <xref:System.Windows.Input.Key> 값으로 설정하여 키가 데드 키일 때 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-662">The key input events, such as the <xref:System.Windows.Input.Keyboard.KeyDownEvent> event, report when a key is a dead key by setting the <xref:System.Windows.Input.KeyEventArgs.Key> property to the <xref:System.Windows.Input.Key> value.</span></span> <span data-ttu-id="73c1f-663">애플리케이션은 일반적으로 결합된 문자를 만드는 키보드 입력에 응답하지 않으므로, 이는 일반적으로 예상되는 동작입니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-663">This is usually expected behavior because applications usually do not intend to respond to keyboard input that creates a combined character.</span></span> | <span data-ttu-id="73c1f-664">결합된 문자의 일부였던 키를 읽어야 하는 애플리케이션은 <xref:System.Windows.Input.KeyEventArgs.DeadCharProcessedKey> 속성을 사용하여 현재 모호한 키를 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-664">Applications that expect to read keys that were part of combined characters can get the now obfuscated key by using the <xref:System.Windows.Input.KeyEventArgs.DeadCharProcessedKey> property.</span></span> |
| <span data-ttu-id="73c1f-665">**포커스 관리자**</span><span class="sxs-lookup"><span data-stu-id="73c1f-665">**Focus manager**</span></span> | <span data-ttu-id="73c1f-666">`true`로 설정된 [IsFocusScope](xref:System.Windows.Input.FocusManager.IsFocusScope%2A) 연결 속성이 있는 요소가 <xref:System.Windows.Input.FocusManager.GetFocusedElement(System.Windows.DependencyObject)?displayProperty=nameWithType> 메서드에 전달되면, 이 메서드는 해당 포커스 영역 내에서 마지막 키보드 포커스 요소인 요소를 반환합니다. 단, 반환된 요소가 메서드에 전달된 요소와 동일한 <xref:System.Windows.PresentationSource> 개체여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-666">When the <xref:System.Windows.Input.FocusManager.GetFocusedElement(System.Windows.DependencyObject)?displayProperty=nameWithType> method is passed an element that has the [IsFocusScope](xref:System.Windows.Input.FocusManager.IsFocusScope%2A) attached property set to `true`, the method returns an element that is the last keyboard-focused element within that focus scope if and only if the returned element belongs to the same <xref:System.Windows.PresentationSource> object as the element that is passed to the method.</span></span> | <span data-ttu-id="73c1f-667">없음</span><span class="sxs-lookup"><span data-stu-id="73c1f-667">None.</span></span> |

### <a name="ui-automation"></a><span data-ttu-id="73c1f-668">UI 자동화</span><span class="sxs-lookup"><span data-stu-id="73c1f-668">UI Automation</span></span>

<span data-ttu-id="73c1f-669">네임스페이스: <xref:System.Windows>, <xref:System.Windows.Automation.Peers>, <xref:System.Windows.Automation.Provider>, <xref:System.Windows.Controls>, <xref:System.Windows.Data>, <xref:System.Windows.Input>; 어셈블리: PresentationFramework(PresentationFramework.dll의), PresentationCore(PresentationCore.dll의), UIAutomationProvider(UIAutomationProvider.dll의), WindowsBase(WindowsBase.dll의)</span><span class="sxs-lookup"><span data-stu-id="73c1f-669">Namespace: <xref:System.Windows>, <xref:System.Windows.Automation.Peers>, <xref:System.Windows.Automation.Provider>, <xref:System.Windows.Controls>, <xref:System.Windows.Data>, <xref:System.Windows.Input>; assemblies: PresentationFramework (in PresentationFramework.dll), PresentationCore (in PresentationCore.dll), UIAutomationProvider (in UIAutomationProvider.dll), WindowsBase (in WindowsBase.dll)</span></span>

| <span data-ttu-id="73c1f-670">기능</span><span class="sxs-lookup"><span data-stu-id="73c1f-670">Feature</span></span> | <span data-ttu-id="73c1f-671">3\.5 SP1과의 차이점</span><span class="sxs-lookup"><span data-stu-id="73c1f-671">Differences from 3.5 SP1</span></span> | <span data-ttu-id="73c1f-672">권장 변경 내용</span><span class="sxs-lookup"><span data-stu-id="73c1f-672">Recommended changes</span></span> |
| ------- | ------------------------ | ------------------- |
| <span data-ttu-id="73c1f-673">**보기의 클래스 계층 구조**</span><span class="sxs-lookup"><span data-stu-id="73c1f-673">**Class hierarchy of views**</span></span> | <span data-ttu-id="73c1f-674"><xref:System.Windows.Automation.Peers.TreeViewAutomationPeer> 및 <xref:System.Windows.Automation.Peers.TreeViewItemAutomationPeer> 클래스는 <xref:System.Windows.Automation.Peers.FrameworkElementAutomationPeer> 대신 <xref:System.Windows.Automation.Peers.ItemsControlAutomationPeer>에서 상속합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-674">The <xref:System.Windows.Automation.Peers.TreeViewAutomationPeer> and <xref:System.Windows.Automation.Peers.TreeViewItemAutomationPeer> classes inherit from <xref:System.Windows.Automation.Peers.ItemsControlAutomationPeer> instead of <xref:System.Windows.Automation.Peers.FrameworkElementAutomationPeer>.</span></span> | <span data-ttu-id="73c1f-675"><xref:System.Windows.Automation.Peers.TreeViewItemAutomationPeer> 클래스에서 상속하고 <xref:System.Windows.Automation.Peers.TreeViewItemAutomationPeer.GetChildrenCore%2A> 메서드를 재정의하는 경우 새 <xref:System.Windows.Automation.Peers.TreeViewDataItemAutomationPeer> 클래스에서 상속하는 개체의 반환을 고려해 보세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-675">If you inherit from the <xref:System.Windows.Automation.Peers.TreeViewItemAutomationPeer> classes and override the <xref:System.Windows.Automation.Peers.TreeViewItemAutomationPeer.GetChildrenCore%2A> method, consider returning an object that inherits from the new <xref:System.Windows.Automation.Peers.TreeViewDataItemAutomationPeer> class.</span></span> |
| <span data-ttu-id="73c1f-676">**화면 밖 컨테이너**</span><span class="sxs-lookup"><span data-stu-id="73c1f-676">**Containers off screen**</span></span> | <span data-ttu-id="73c1f-677">잘못된 반환 값을 수정하기 위해 <xref:System.Windows.Automation.Peers.UIElementAutomationPeer.IsOffscreenCore%2A> 메서드는 보기에서 벗어나 스크롤된 항목 컨테이너에 대해 이제 `false`를 올바르게 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-677">To fix an incorrect return value, the <xref:System.Windows.Automation.Peers.UIElementAutomationPeer.IsOffscreenCore%2A> method now correctly returns `false` for item containers that are scrolled out of view.</span></span> <span data-ttu-id="73c1f-678">또한 메서드의 값은 다른 창에 의해 가려지는지 또는 요소가 특정 모니터에 표시되는지 여부에 의해 영향을 받지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-678">Also, the value of the method is not affected by occlusion by other windows, or by whether the element is visible on a specific monitor.</span></span> | <span data-ttu-id="73c1f-679">없음</span><span class="sxs-lookup"><span data-stu-id="73c1f-679">None.</span></span> |
| <span data-ttu-id="73c1f-680">**메뉴 및 자식 개체**</span><span class="sxs-lookup"><span data-stu-id="73c1f-680">**Menus and child objects**</span></span> | <span data-ttu-id="73c1f-681"><xref:System.Windows.Controls.MenuItem> 개체가 아닌 자식이 포함된 메뉴의 UI 자동화를 사용할 수 있도록, <xref:System.Windows.Automation.Peers.MenuItemAutomationPeer.GetChildrenCore%2A> 메서드는 <xref:System.Windows.Automation.Peers.MenuItemAutomationPeer> 개체 대신 자식 <xref:System.Windows.UIElement> 개체의 <xref:System.Windows.Automation.Peers.AutomationPeer> 개체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-681">To enable UI automation of menus that contain children other than <xref:System.Windows.Controls.MenuItem> objects, the <xref:System.Windows.Automation.Peers.MenuItemAutomationPeer.GetChildrenCore%2A> method now returns the <xref:System.Windows.Automation.Peers.AutomationPeer> object of a child <xref:System.Windows.UIElement> object, instead of a <xref:System.Windows.Automation.Peers.MenuItemAutomationPeer> object.</span></span> | <span data-ttu-id="73c1f-682">없음</span><span class="sxs-lookup"><span data-stu-id="73c1f-682">None.</span></span> |
| <span data-ttu-id="73c1f-683">**새 인터페이스 및 어셈블리**</span><span class="sxs-lookup"><span data-stu-id="73c1f-683">**New interfaces and assembly**</span></span> | <span data-ttu-id="73c1f-684">UI 자동화에 대한 새로운 기능을 사용할 수 있도록 다음 인터페이스가 추가되었습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-684">To enable new features for UI automation, the following interfaces were added:</span></span><br><br>* <xref:System.Windows.Automation.Provider.IItemContainerProvider><br>* <xref:System.Windows.Automation.Provider.ISynchronizedInputProvider><br>* <xref:System.Windows.Automation.Provider.IVirtualizedItemProvider> | <span data-ttu-id="73c1f-685">WPF 자동화 피어를 빌드하는 프로젝트는 UIAutomationProvider.dll에 대한 명시적 참조를 추가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-685">Any project that builds WPF automation peers must add an explicit reference to UIAutomationProvider.dll.</span></span> |
| <span data-ttu-id="73c1f-686">**Thumb**</span><span class="sxs-lookup"><span data-stu-id="73c1f-686">**Thumbs**</span></span> | <span data-ttu-id="73c1f-687"><xref:System.Windows.Automation.Peers.ThumbAutomationPeer.GetClassNameCore%2A> 메서드는 null 대신 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-687">The <xref:System.Windows.Automation.Peers.ThumbAutomationPeer.GetClassNameCore%2A> method returns a value instead of null.</span></span> <span data-ttu-id="73c1f-688">따라서 <xref:System.Windows.Controls.Primitives.Thumb> 클래스에서 상속하는 <xref:System.Windows.Controls.GridSplitter> 등의 컨트롤은 이름을 UI 자동화에 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-688">Therefore, controls such as <xref:System.Windows.Controls.GridSplitter> that inherit from the <xref:System.Windows.Controls.Primitives.Thumb> class will report a name to UI Automation.</span></span> | <span data-ttu-id="73c1f-689">없음</span><span class="sxs-lookup"><span data-stu-id="73c1f-689">None.</span></span> |
| <span data-ttu-id="73c1f-690">**가상화된 요소**</span><span class="sxs-lookup"><span data-stu-id="73c1f-690">**Virtualized elements**</span></span> | <span data-ttu-id="73c1f-691">성능 향상을 위해 <xref:System.Windows.Automation.Peers.UIElementAutomationPeer.GetChildrenCore%2A> 메서드는 가상화 여부와 관계없이 모든 자식 개체 대신 시각적 트리에 실제로 있는 자식 개체만 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-691">To improve performance, the <xref:System.Windows.Automation.Peers.UIElementAutomationPeer.GetChildrenCore%2A> method returns only the child objects that are actually in the visual tree, instead of all child objects, regardless of whether they are virtualized.</span></span> | <span data-ttu-id="73c1f-692"><xref:System.Windows.Automation.Peers.ItemsControlAutomationPeer>의 모든 항목을 반복하려면 <xref:System.Windows.Automation.ItemContainerPattern>을 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-692">Use <xref:System.Windows.Automation.ItemContainerPattern> to iterate over all items of an <xref:System.Windows.Automation.Peers.ItemsControlAutomationPeer>.</span></span> |

### <a name="xaml"></a><span data-ttu-id="73c1f-693">XAML</span><span class="sxs-lookup"><span data-stu-id="73c1f-693">XAML</span></span>

<span data-ttu-id="73c1f-694">네임스페이스: <xref:System.Windows>, <xref:System.Windows.Controls>, <xref:System.Windows.Data>, <xref:System.Windows.Input>, <xref:System.Windows.Markup>; 어셈블리: PresentationFramework(PresentationFramework.dll의), PresentationCore(PresentationCore.dll의), WindowsBase(WindowsBase.dll의)</span><span class="sxs-lookup"><span data-stu-id="73c1f-694">Namespaces: <xref:System.Windows>, <xref:System.Windows.Controls>, <xref:System.Windows.Data>, <xref:System.Windows.Input>, <xref:System.Windows.Markup>; assemblies: PresentationFramework (in PresentationFramework.dll), PresentationCore (in PresentationCore.dll), WindowsBase (in WindowsBase.dll)</span></span>

| <span data-ttu-id="73c1f-695">기능</span><span class="sxs-lookup"><span data-stu-id="73c1f-695">Feature</span></span> | <span data-ttu-id="73c1f-696">3\.5 SP1과의 차이점</span><span class="sxs-lookup"><span data-stu-id="73c1f-696">Differences from 3.5 SP1</span></span> | <span data-ttu-id="73c1f-697">권장 변경 내용</span><span class="sxs-lookup"><span data-stu-id="73c1f-697">Recommended changes</span></span> |
| ------- | ------------------------ | ------------------- |
| <span data-ttu-id="73c1f-698">**태그 확장**</span><span class="sxs-lookup"><span data-stu-id="73c1f-698">**Markup extension**</span></span> | <span data-ttu-id="73c1f-699">WPF는 이제 속성을 설정하거나 컬렉션에 항목을 만들기 위해 태그 확장을 사용할 때 경우에 따라 <xref:System.Windows.Markup.MarkupExtension> 개체를 반환하는 대신 항상 <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A> 메서드의 값을 올바르게 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-699">WPF now correctly always uses the value from the <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A> method instead of returning the <xref:System.Windows.Markup.MarkupExtension> object in certain cases when a markup extension is used to set a property or to create an item in a collection.</span></span> <span data-ttu-id="73c1f-700">경우에 따라 태그 확장은 자체를 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-700">A markup extension might return itself in some cases.</span></span> | <span data-ttu-id="73c1f-701">애플리케이션이 이전 버전에서 <xref:System.Windows.Markup.MarkupExtension> 개체를 반환한 리소스에 액세스하는 경우 <xref:System.Windows.Markup.MarkupExtension> 개체 대신 <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>에서 반환된 개체를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-701">If your application accesses a resource that returned a <xref:System.Windows.Markup.MarkupExtension> object in earlier versions, reference the object that is returned from <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>, instead of the <xref:System.Windows.Markup.MarkupExtension> object.</span></span> |
| <span data-ttu-id="73c1f-702">**특성 구문 분석**</span><span class="sxs-lookup"><span data-stu-id="73c1f-702">**Parsing attributes**</span></span> | <span data-ttu-id="73c1f-703">이제 XAML의 특성에는 마침표를 하나만 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-703">Attributes in XAML can now have only one period.</span></span> <span data-ttu-id="73c1f-704">예를 들어, 다음은 유효합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-704">For example, the following are valid:</span></span><br><br><span data-ttu-id="73c1f-705">`<Button Background="Red"/>`(마침표 없음)</span><span class="sxs-lookup"><span data-stu-id="73c1f-705">`<Button Background="Red"/>` (no periods)</span></span><br><br><span data-ttu-id="73c1f-706">`<Button Button.Background = "Red"/>`(마침표 1개)</span><span class="sxs-lookup"><span data-stu-id="73c1f-706">`<Button Button.Background = "Red"/>` (one period)</span></span><br><br><span data-ttu-id="73c1f-707">다음은 유효하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-707">The following is no longer valid:</span></span><br><br><span data-ttu-id="73c1f-708">`<Button Control.Button.Background = "Red"/>`(마침표 2개 이상)</span><span class="sxs-lookup"><span data-stu-id="73c1f-708">`<Button Control.Button.Background = "Red"/>` (more than one period)</span></span> | <span data-ttu-id="73c1f-709">마침표가 2개 이상인 XAML 특성을 수정하세요.</span><span class="sxs-lookup"><span data-stu-id="73c1f-709">Correct XAML attributes that have more than one period.</span></span> |

## <a name="xml"></a><span data-ttu-id="73c1f-710">XML</span><span class="sxs-lookup"><span data-stu-id="73c1f-710">XML</span></span>

<span data-ttu-id="73c1f-711">다음 표의 각 행에서는 이전에 제한 사항이었거나 기타 문제가 있던 기능의 개선 내용을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-711">The rows in this table describe improvements to features that previously had limitations or other issues.</span></span>

### <a name="schema-and-transforms"></a><span data-ttu-id="73c1f-712">스키마 및 변환</span><span class="sxs-lookup"><span data-stu-id="73c1f-712">Schema and transforms</span></span>

<span data-ttu-id="73c1f-713">네임스페이스: <xref:System.Xml.Linq>, <xref:System.Xml.Schema>, <xref:System.Xml.XPath>; 어셈블리: System.Xml(System.Xml.dll의), System.Xml.Linq(System.Xml.Linq.dll의)</span><span class="sxs-lookup"><span data-stu-id="73c1f-713">Namespaces: <xref:System.Xml.Linq>; <xref:System.Xml.Schema>, <xref:System.Xml.XPath>; assemblies: System.Xml (in System.Xml.dll), System.Xml.Linq (in System.Xml.Linq.dll)</span></span>

| <span data-ttu-id="73c1f-714">기능</span><span class="sxs-lookup"><span data-stu-id="73c1f-714">Feature</span></span> | <span data-ttu-id="73c1f-715">3\.5 SP1과의 차이점</span><span class="sxs-lookup"><span data-stu-id="73c1f-715">Differences from 3.5 SP1</span></span> |
| ------- | ------------------------ |
| <span data-ttu-id="73c1f-716">**카멜레온 스키마**</span><span class="sxs-lookup"><span data-stu-id="73c1f-716">**Chameleon schemas**</span></span> | <span data-ttu-id="73c1f-717">데이터 손상을 방지하기 위해 이제 카멜레온 스키마는 여러 스키마에 포함될 때 올바르게 복제됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-717">To prevent data corruption, chameleon schemas are now cloned correctly when they are included with multiple schemas.</span></span><br><br><span data-ttu-id="73c1f-718">카멜레온 스키마는 대상 네임스페이스가 없는 스키마이며, 다른 XSD에 포함될 때 가져오기 스키마의 대상 네임스페이스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-718">Chameleon schemas are schemas that do not have a target namespace, and when they are included in another XSD, they take on the target namespace of the importing schema.</span></span> <span data-ttu-id="73c1f-719">카멜레온 스키마는 스키마에 공통 형식을 포함하는 데 종종 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-719">They are often used to include common types into a schema.</span></span> |
| <span data-ttu-id="73c1f-720">**ID 함수**</span><span class="sxs-lookup"><span data-stu-id="73c1f-720">**ID functions**</span></span> | <span data-ttu-id="73c1f-721"><xref:System.Xml.XmlReader> 개체가 XLST에 전달될 때 이제 XSLT [id 함수](/sql/xquery/functions-on-sequences-id)가 null 대신 올바른 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-721">The XSLT [id function](/sql/xquery/functions-on-sequences-id) now returns the correct value instead of null when an <xref:System.Xml.XmlReader> object is passed to an XLST.</span></span><br><br><span data-ttu-id="73c1f-722">사용자가 <xref:System.Xml.Linq.XNode.CreateReader%2A> 메서드를 사용하여 LINQ to XML 클래스에서 <xref:System.Xml.XmlReader> 개체를 만들었고 이 <xref:System.Xml.XmlReader> 개체가 XSLT로 전달된 경우, XSLT의 `id` 함수 인스턴스가 전에는 null을 반환했습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-722">If the user created an <xref:System.Xml.XmlReader> object from a LINQ to XML class by using the <xref:System.Xml.Linq.XNode.CreateReader%2A> method, and this <xref:System.Xml.XmlReader> object was passed to an XSLT, any instances of the `id` function in the XSLT previously returned null.</span></span> <span data-ttu-id="73c1f-723">이것은 `id` 함수에 대해 허용된 반환 값이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-723">This is not an allowed return value for the `id` function.</span></span> |
| <span data-ttu-id="73c1f-724">**네임스페이스 특성**</span><span class="sxs-lookup"><span data-stu-id="73c1f-724">**Namespace attribute**</span></span> | <span data-ttu-id="73c1f-725">데이터 손상을 방지하기 위해 이제 <xref:System.Xml.XPath.XPathNavigator> 개체가 `x:xmlns` 특성의 로컬 이름을 올바르게 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-725">To prevent data corruption, an <xref:System.Xml.XPath.XPathNavigator> object now returns the local name of the `x:xmlns` attribute correctly.</span></span> |
| <span data-ttu-id="73c1f-726">**네임스페이스 선언**</span><span class="sxs-lookup"><span data-stu-id="73c1f-726">**Namespace declarations**</span></span> | <span data-ttu-id="73c1f-727">하위 트리의 <xref:System.Xml.XmlReader> 개체는 더 이상 하나의 XML 요소 내에 중복된 네임스페이스 선언을 만들지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-727">An <xref:System.Xml.XmlReader> object on a sub-tree no longer creates duplicate namespace declarations within one XML element.</span></span> |
| <span data-ttu-id="73c1f-728">**스키마 유효성 검사**</span><span class="sxs-lookup"><span data-stu-id="73c1f-728">**Schema validation**</span></span> | <span data-ttu-id="73c1f-729">잘못된 스키마 유효성 검사를 방지하기 위해, <xref:System.Xml.Schema.XmlSchemaSet> 클래스는 XSD 스키마가 일관성 있고 정확하게 컴파일되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-729">To prevent erroneous schema validation, the <xref:System.Xml.Schema.XmlSchemaSet> class allows for XSD schemas to be compiled correctly and consistently.</span></span> <span data-ttu-id="73c1f-730">이러한 스키마는 다른 스키마를 포함할 수 있습니다. 예를 들어 `A.xsd`는 `C.xsd`를 포함할 수 있는 `B.xsd`를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-730">These schemas can include other schemas; for example, `A.xsd` can include `B.xsd`, which can include `C.xsd`.</span></span> <span data-ttu-id="73c1f-731">이들 중 하나를 컴파일하면 이 의존성 그래프가 트래버스됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-731">Compiling any one of these causes this graph of dependencies to be traversed.</span></span> |
| <span data-ttu-id="73c1f-732">**스크립트 함수**</span><span class="sxs-lookup"><span data-stu-id="73c1f-732">**Script functions**</span></span> | <span data-ttu-id="73c1f-733">함수가 실제로 사용 가능할 때 [function-available 함수](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms256124(v=vs.100))는 더 이상 올바르지 않게 `false`를 반환하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-733">The [function-available function](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms256124(v=vs.100)) no longer incorrectly returns `false` when the function is actually available.</span></span> |
| <span data-ttu-id="73c1f-734">**URI**</span><span class="sxs-lookup"><span data-stu-id="73c1f-734">**URIs**</span></span> | <span data-ttu-id="73c1f-735"><xref:System.Xml.Linq.XElement.Load%2A> 메서드는 이제 LINQ 쿼리에서 올바른 BaseURI를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-735">The <xref:System.Xml.Linq.XElement.Load%2A> method now returns the correct BaseURI in LINQ queries.</span></span> |

### <a name="validation"></a><span data-ttu-id="73c1f-736">유효성 검사</span><span class="sxs-lookup"><span data-stu-id="73c1f-736">Validation</span></span>

<span data-ttu-id="73c1f-737">네임스페이스: <xref:System.Xml.Linq>, <xref:System.Xml.Schema>, <xref:System.Xml.XPath>; 어셈블리: System.Xml(System.Xml.dll의), System.Xml.Linq(System.Xml.Linq.dll의)</span><span class="sxs-lookup"><span data-stu-id="73c1f-737">Namespaces: <xref:System.Xml.Linq>; <xref:System.Xml.Schema>, <xref:System.Xml.XPath>; assemblies: System.Xml (in System.Xml.dll), System.Xml.Linq (in System.Xml.Linq.dll)</span></span>

| <span data-ttu-id="73c1f-738">기능</span><span class="sxs-lookup"><span data-stu-id="73c1f-738">Feature</span></span> | <span data-ttu-id="73c1f-739">3\.5 SP1과의 차이점</span><span class="sxs-lookup"><span data-stu-id="73c1f-739">Differences from 3.5 SP1</span></span> |
| ------- | ------------------------ |
| <span data-ttu-id="73c1f-740">**네임스페이스 확인자**</span><span class="sxs-lookup"><span data-stu-id="73c1f-740">**Namespace resolvers**</span></span> | <span data-ttu-id="73c1f-741"><xref:System.Xml.XmlReader.ReadContentAs%2A> 메서드는 더 이상 전달된 <xref:System.Xml.IXmlNamespaceResolver> 확인자를 무시하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-741">The <xref:System.Xml.XmlReader.ReadContentAs%2A> method no longer ignores the <xref:System.Xml.IXmlNamespaceResolver> resolver passed to it.</span></span><br><br><span data-ttu-id="73c1f-742">이전 버전에서는 지정된 네임스페이스 확인자가 무시되고 대신 <xref:System.Xml.XmlReader>가 사용되었습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-742">In previous versions, the specified namespace resolver was ignored, and the <xref:System.Xml.XmlReader> was used instead.</span></span> |
| <span data-ttu-id="73c1f-743">**공백**</span><span class="sxs-lookup"><span data-stu-id="73c1f-743">**White space**</span></span> | <span data-ttu-id="73c1f-744">판독기를 만들 때 데이터 손실을 방지하기 위해 <xref:System.Xml.XmlReader.Create%2A> 메서드는 더 이상 유효한 공백을 삭제하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-744">To prevent data loss when you are creating a reader, the <xref:System.Xml.XmlReader.Create%2A> method no longer discards significant white space.</span></span><br><br><span data-ttu-id="73c1f-745">XML 유효성 검사는 텍스트가 XML 태그와 혼합될 수 있는 혼합 콘텐츠 모드를 인식합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-745">XML validation recognizes mixed-content mode, where text can be intermixed with XML markup.</span></span> <span data-ttu-id="73c1f-746">혼합 모드에서는 모든 공백이 유효하므로 보고되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-746">In mixed mode, all white space is significant and should be reported.</span></span> |

### <a name="writing"></a><span data-ttu-id="73c1f-747">쓰기</span><span class="sxs-lookup"><span data-stu-id="73c1f-747">Writing</span></span>

<span data-ttu-id="73c1f-748">네임스페이스: <xref:System.Xml.Linq>, <xref:System.Xml.Schema>, <xref:System.Xml.XPath>; 어셈블리: System.Xml(System.Xml.dll의), System.Xml.Linq(System.Xml.Linq.dll의)</span><span class="sxs-lookup"><span data-stu-id="73c1f-748">Namespaces: <xref:System.Xml.Linq>; <xref:System.Xml.Schema>, <xref:System.Xml.XPath>; assemblies: System.Xml (in System.Xml.dll), System.Xml.Linq (in System.Xml.Linq.dll)</span></span>

| <span data-ttu-id="73c1f-749">기능</span><span class="sxs-lookup"><span data-stu-id="73c1f-749">Feature</span></span> | <span data-ttu-id="73c1f-750">3\.5 SP1과의 차이점</span><span class="sxs-lookup"><span data-stu-id="73c1f-750">Differences from 3.5 SP1</span></span> |
| ------- | ------------------------ |
| <span data-ttu-id="73c1f-751">**엔터티 참조**</span><span class="sxs-lookup"><span data-stu-id="73c1f-751">**Entity references**</span></span> | <span data-ttu-id="73c1f-752">데이터 손상을 방지하기 위해, 엔터티 참조가 더 이상 XML 특성에서 두 번 엔터티화되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-752">To prevent data corruption, entity references are no longer entitized twice in XML attributes.</span></span><br><br><span data-ttu-id="73c1f-753">사용자가 엔터티를 `xmlns` 특성에 쓰려고 하거나 <xref:System.Xml.XmlWriter.WriteEntityRef%2A> 메서드를 사용하여 `xml:lang` 또는 `xml:space` 특성에 쓰려고 하면, 엔터티가 출력에서 두 번 엔터티화되어 데이터가 손상됩니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-753">If the user tried to write an entity into an `xmlns` attribute or into an `xml:lang` or `xml:space` attribute by using the <xref:System.Xml.XmlWriter.WriteEntityRef%2A> method, the entity was entitized twice in the output, therefore corrupting the data.</span></span> |
| <span data-ttu-id="73c1f-754">**줄 바꿈 처리**</span><span class="sxs-lookup"><span data-stu-id="73c1f-754">**New line handling**</span></span> | <span data-ttu-id="73c1f-755">데이터 손상을 방지하기 위해 <xref:System.Xml.XmlWriter> 개체가 <xref:System.Xml.NewLineHandling> 옵션을 존중합니다.</span><span class="sxs-lookup"><span data-stu-id="73c1f-755">To prevent data corruption, <xref:System.Xml.XmlWriter> objects respect the <xref:System.Xml.NewLineHandling> option.</span></span> |

## <a name="see-also"></a><span data-ttu-id="73c1f-756">참조</span><span class="sxs-lookup"><span data-stu-id="73c1f-756">See also</span></span>

- [<span data-ttu-id="73c1f-757">.NET Framework 4의 새 형식 및 멤버</span><span class="sxs-lookup"><span data-stu-id="73c1f-757">New Types and Members in the .NET Framework 4</span></span>](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ff641764%28v=vs.100%29)
- [<span data-ttu-id="73c1f-758">.NET Framework 4 마이그레이션 가이드</span><span class="sxs-lookup"><span data-stu-id="73c1f-758">Migration Guide to the .NET Framework 4</span></span>](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ff657133%28v=vs.100%29)
- [<span data-ttu-id="73c1f-759">.NET Framework 4의 새로운 기능</span><span class="sxs-lookup"><span data-stu-id="73c1f-759">What's New in the .NET Framework 4</span></span>](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms171868%28v=vs.100%29)
- [<span data-ttu-id="73c1f-760">.NET Framework의 버전 호환성</span><span class="sxs-lookup"><span data-stu-id="73c1f-760">Version Compatibility in the .NET Framework</span></span>](version-compatibility.md)
- [<span data-ttu-id="73c1f-761">.NET Framework 4로 Office 솔루션 마이그레이션</span><span class="sxs-lookup"><span data-stu-id="73c1f-761">Migrating Office Solutions to the .NET Framework 4</span></span>](/visualstudio/vsto/migrating-office-solutions-to-the-dotnet-framework-4-or-later)
- [<span data-ttu-id="73c1f-762">.NET Framework 클래스 라이브러리의 사용되지 않는 기능</span><span class="sxs-lookup"><span data-stu-id="73c1f-762">What's Obsolete in the .NET Framework Class Library</span></span>](../whats-new/whats-obsolete.md)
