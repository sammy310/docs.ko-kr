---
title: Al.exe(어셈블리 링커)
description: 어셈블리 링커 도구인 AI.exe를 사용합니다. 이 도구는 모듈 또는 리소스 파일인 하나 이상의 파일에서 어셈블리 매니페스트가 있는 파일을 생성합니다.
ms.date: 03/30/2017
helpviewer_keywords:
- Al.exe
- Assembly Linker
- modules, Assembly Linker
- assembly manifest, Assembly Linker
ms.assetid: b5382965-0053-47cf-b92f-862860275a01
ms.openlocfilehash: dff7ab7ccc6543b1c13cb2b49cbdf712eba301ae
ms.sourcegitcommit: 1dbe25ff484a02025d5c34146e517c236f7161fb
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/19/2021
ms.locfileid: "104652960"
---
# <a name="alexe-assembly-linker"></a><span data-ttu-id="74aef-104">Al.exe(어셈블리 링커)</span><span class="sxs-lookup"><span data-stu-id="74aef-104">Al.exe (Assembly Linker)</span></span>

<span data-ttu-id="74aef-105">어셈블리 링커는 모듈 또는 리소스 파일인 하나 이상의 파일에서 어셈블리 매니페스트가 있는 파일을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-105">The Assembly Linker generates a file that has an assembly manifest from one or more files that are either modules or resource files.</span></span> <span data-ttu-id="74aef-106">모듈이란 어셈블리 매니페스트가 없는 IL(Intermediate Language) 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-106">A module is an intermediate language (IL) file that does not have an assembly manifest.</span></span>

> [!NOTE]
> <span data-ttu-id="74aef-107">Visual Studio 2008부터 C# 및 Visual Basic 컴파일러가 모두 Win32 매니페스트를 어셈블리에 자동으로 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-107">Starting with Visual Studio 2008, both the C# and Visual Basic compilers automatically embed a Win32 manifest into the assembly.</span></span> <span data-ttu-id="74aef-108">자세한 내용은 [-win32manifest(C# 컴파일러 옵션)](../../csharp/language-reference/compiler-options/resources.md#win32manifest)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="74aef-108">For more information, see [-win32manifest (C# Compiler Options)](../../csharp/language-reference/compiler-options/resources.md#win32manifest).</span></span>

<span data-ttu-id="74aef-109">이 도구는 자동으로 Visual Studio와 함께 설치됩니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-109">This tool is automatically installed with Visual Studio.</span></span> <span data-ttu-id="74aef-110">도구를 실행하려면 [Visual Studio 개발자 명령 프롬프트 또는 Visual Studio 개발자 PowerShell](/visualstudio/ide/reference/command-prompt-powershell)을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-110">To run the tool, use [Visual Studio Developer Command Prompt or Visual Studio Developer PowerShell](/visualstudio/ide/reference/command-prompt-powershell).</span></span>

<span data-ttu-id="74aef-111">명령 프롬프트에 다음을 입력합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-111">At the command prompt, type the following:</span></span>

## <a name="syntax"></a><span data-ttu-id="74aef-112">구문</span><span class="sxs-lookup"><span data-stu-id="74aef-112">Syntax</span></span>

```console
al sources options
```

## <a name="parameters"></a><span data-ttu-id="74aef-113">매개 변수</span><span class="sxs-lookup"><span data-stu-id="74aef-113">Parameters</span></span>

<span data-ttu-id="74aef-114">다음 `sources` 중에서 하나 이상 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-114">You can specify one or more of the following `sources`.</span></span>

| <span data-ttu-id="74aef-115">원본</span><span class="sxs-lookup"><span data-stu-id="74aef-115">Source</span></span> | <span data-ttu-id="74aef-116">설명</span><span class="sxs-lookup"><span data-stu-id="74aef-116">Description</span></span> |
| ------ | ----------- |
|<span data-ttu-id="74aef-117">`file`[,`target`]</span><span class="sxs-lookup"><span data-stu-id="74aef-117">`file`[,`target`]</span></span>|<span data-ttu-id="74aef-118">`file`(모듈)의 내용을 `target`이 지정하는 파일 이름에 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-118">Copies the contents of `file` (a module) to the file name specified by `target`.</span></span> <span data-ttu-id="74aef-119">복사한 후 *Al.exe* 가 `target`을 어셈블리로 컴파일합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-119">After copying, *Al.exe* compiles `target` into an assembly.</span></span>|
|<span data-ttu-id="74aef-120">**/embed[resource]:** `file`[,`name`[,`private`]]</span><span class="sxs-lookup"><span data-stu-id="74aef-120">**/embed[resource]:** `file`[,`name`[,`private`]]</span></span>|<span data-ttu-id="74aef-121">`file`이 지정하는 리소스를 어셈블리 매니페스트가 포함된 이미지에 포함합니다. *Al.exe* 는 `file`의 내용을 이식 가능한 실행 파일(PE) 이미지에 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-121">Embeds the resource specified by `file` in the image that contains the assembly manifest; *Al.exe* copies the contents of `file` into the portable executable (PE) image.</span></span><br /><br /> <span data-ttu-id="74aef-122">`name` 매개 변수는 리소스의 내부 식별자입니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-122">The `name` parameter is an internal identifier for the resource.</span></span> <span data-ttu-id="74aef-123">기본적으로 리소스는 어셈블리에서 공용입니다. 즉, 다른 어셈블리가 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-123">By default, resources are public in the assembly (visible to other assemblies).</span></span> <span data-ttu-id="74aef-124">`private`를 지정하면 다른 어셈블리에서 리소스를 볼 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-124">Specifying `private` makes the resource not visible to other assemblies.</span></span><br /><br /> <span data-ttu-id="74aef-125">예를 들어, `file`이 [리소스 파일 생성기(*Resgen.exe*)](resgen-exe-resource-file-generator.md)나 개발 환경에서 만들어진 .NET Framework 리소스 파일인 경우에는 <xref:System.Resources>의 멤버를 사용하여 해당 파일에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-125">If `file` is a .NET Framework resource file created, for example, by the [Resource File Generator (*Resgen.exe*)](resgen-exe-resource-file-generator.md) or in the development environment, it can be accessed with members in the <xref:System.Resources>.</span></span> <span data-ttu-id="74aef-126">자세한 내용은 <xref:System.Resources.ResourceManager>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="74aef-126">For more information, see <xref:System.Resources.ResourceManager>.</span></span> <span data-ttu-id="74aef-127">다른 모든 리소스의 경우에는 런타임에 <xref:System.Reflection.Assembly>의 `GetManifestResource*` 메서드를 사용하여 리소스에 액세스합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-127">For all other resources, use the `GetManifestResource*` methods in the <xref:System.Reflection.Assembly> to access the resource at run time.</span></span><br /><br /> <span data-ttu-id="74aef-128">리소스 파일만 *Al.exe* 에 전달되는 경우에는 출력 파일이 위성 리소스 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-128">If only resource files are passed to *Al.exe*, the output file is a satellite resource assembly.</span></span>|
|<span data-ttu-id="74aef-129">**/link[resource]:** `file`[,`name`[,`target`[,`private`]]]</span><span class="sxs-lookup"><span data-stu-id="74aef-129">**/link[resource]:** `file`[,`name`[,`target`[,`private`]]]</span></span>|<span data-ttu-id="74aef-130">리소스 파일을 어셈블리에 링크합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-130">Links a resource file to an assembly.</span></span> <span data-ttu-id="74aef-131">`file`이 지정하는 리소스가 어셈블리의 일부가 되고 파일은 복사되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-131">The resource specified by `file` becomes part of the assembly; the file is not copied.</span></span> <span data-ttu-id="74aef-132">`file` 매개 변수는 어떠한 파일 형식도 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-132">The `file` parameter can be in any file format.</span></span> <span data-ttu-id="74aef-133">예를 들어, 네이티브 DLL을 `file` 매개 변수로 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-133">For example, you can specify a native DLL as the `file` parameter.</span></span> <span data-ttu-id="74aef-134">이렇게 하면 네이티브 DLL이 어셈블리의 일부가 되므로 전역 어셈블리 캐시에 설치하고 어셈블리의 관리 코드에서 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-134">This will make the native DLL part of the assembly so that it can be installed into the global assembly cache and accessed from managed code in the assembly.</span></span> <span data-ttu-id="74aef-135">이 작업은 **/linkresource** 컴파일러 옵션을 사용하여 수행할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-135">You can also do this by using the **/linkresource** compiler option.</span></span> <span data-ttu-id="74aef-136">자세한 내용은 [-linkresource(C# 컴파일러 옵션)](../../csharp/language-reference/compiler-options/resources.md#linkresources)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="74aef-136">For more information, see [-linkresource (C# Compiler Options)](../../csharp/language-reference/compiler-options/resources.md#linkresources).</span></span><br /><br /> <span data-ttu-id="74aef-137">`name` 매개 변수는 리소스의 내부 식별자입니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-137">The `name` parameter is an internal identifier for the resource.</span></span> <span data-ttu-id="74aef-138">`target` 매개 변수는 *Al.exe* 에서 `file`*을 복사하는 경로와 파일 이름을 지정합니다.*</span><span class="sxs-lookup"><span data-stu-id="74aef-138">The `target` parameter specifies a path and file name into which *Al.exe* copies the `file`*.*</span></span> <span data-ttu-id="74aef-139">복사한 후 *Al.exe* 가 `target`을 어셈블리로 컴파일합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-139">After copying, *Al.exe* compiles `target` into an assembly.</span></span> <span data-ttu-id="74aef-140">기본적으로 리소스는 어셈블리에서 공용입니다. 즉, 다른 어셈블리가 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-140">By default, resources are public in the assembly (visible to other assemblies).</span></span> <span data-ttu-id="74aef-141">`private`를 지정하면 다른 어셈블리에서 리소스를 볼 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-141">Specifying `private` makes the resource not visible to other assemblies.</span></span><br /><br /> <span data-ttu-id="74aef-142">예를 들어, `file`이 리소스 파일 생성기 (*Resgen.exe*)나 개발 환경에서 만들어진 .NET Framework 리소스 파일인 경우에는 <xref:System.Resources> 네임스페이스의 멤버를 사용하여 해당 파일에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-142">If `file` is a .NET Framework resource file created, for example, by the Resource File Generator (*Resgen.exe*) or in the development environment, it can be accessed with members in the <xref:System.Resources> namespace.</span></span> <span data-ttu-id="74aef-143">자세한 내용은 <xref:System.Resources.ResourceManager>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="74aef-143">For more information, see <xref:System.Resources.ResourceManager>.</span></span> <span data-ttu-id="74aef-144">다른 모든 리소스의 경우에는 런타임에 `GetManifestResource*` 클래스의 <xref:System.Reflection.Assembly> 메서드를 사용하여 리소스에 액세스합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-144">For all other resources, use the `GetManifestResource*` methods in the <xref:System.Reflection.Assembly> class to access the resource at run time.</span></span><br /><br /> <span data-ttu-id="74aef-145">리소스 파일만 *Al.exe* 에 전달되는 경우에는 출력 파일이 위성 리소스 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-145">If only resource files are passed to *Al.exe*, the output file is a satellite resource assembly.</span></span>|

<span data-ttu-id="74aef-146">다음 `options`를 지정할 수 있으며, **/out** 은 반드시 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-146">You can specify the following `options`; you must specify **/out**.</span></span>

| <span data-ttu-id="74aef-147">옵션</span><span class="sxs-lookup"><span data-stu-id="74aef-147">Option</span></span> | <span data-ttu-id="74aef-148">설명</span><span class="sxs-lookup"><span data-stu-id="74aef-148">Description</span></span> |
| ------ | ----------- |
|<span data-ttu-id="74aef-149">**/algid:** `id`</span><span class="sxs-lookup"><span data-stu-id="74aef-149">**/algid:** `id`</span></span>|<span data-ttu-id="74aef-150">어셈블리 매니페스트가 포함된 파일을 제외하고 다중 파일 어셈블리에 있는 모든 파일을 해시하는 알고리즘을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-150">Specifies an algorithm to hash all files in a multifile assembly except the file that contains the assembly manifest.</span></span> <span data-ttu-id="74aef-151">기본 알고리즘은 CALG_SHA1입니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-151">The default algorithm is CALG_SHA1.</span></span> <span data-ttu-id="74aef-152">다른 알고리즘에 대해서는 Platform SDK 설명서의 ALG_ID를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="74aef-152">See ALG_ID in the Platform SDK documentation for other algorithms.</span></span> <span data-ttu-id="74aef-153">.NET Framework의 첫 릴리스에서는 CALG_SHA1과 CALG_MD5만 유효합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-153">For the first release of the .NET Framework, only CALG_SHA1 and CALG_MD5 are valid.</span></span><br /><br /> <span data-ttu-id="74aef-154">해시 값은 어셈블리 매니페스트의 파일 테이블에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-154">The hash values are stored in the file table of the assembly manifest.</span></span> <span data-ttu-id="74aef-155">설치 및 로드할 때 어셈블리의 파일을 해시와 비교하여 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-155">At installation and load time, the assembly's files are checked against their hashes.</span></span><br /><br /> <span data-ttu-id="74aef-156">모듈의 소스 코드에서 이 옵션을 사용자 지정 특성(<xref:System.Reflection.AssemblyAlgorithmIdAttribute>)으로 지정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-156">You can also specify this option as a custom attribute (<xref:System.Reflection.AssemblyAlgorithmIdAttribute>) in the source code for any module.</span></span>|
|<span data-ttu-id="74aef-157">**/base[address]:** `addr`</span><span class="sxs-lookup"><span data-stu-id="74aef-157">**/base[address]:** `addr`</span></span>|<span data-ttu-id="74aef-158">런타임에 DLL이 사용자의 컴퓨터에 로드되는 주소를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-158">Specifies the address at which a DLL will be loaded on the user's computer at run time.</span></span> <span data-ttu-id="74aef-159">운영 체제가 프로세스 공간에서 DLL을 재배치하게 하지 않고 DLL의 기본 주소를 직접 지정하면 애플리케이션의 로드 속도가 빨라집니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-159">Applications load faster if you specify the base address of the DLLs, instead of letting the operating system relocate the DLLs in the process space.</span></span>|
|<span data-ttu-id="74aef-160">**/bugreport**: `filename`</span><span class="sxs-lookup"><span data-stu-id="74aef-160">**/bugreport**: `filename`</span></span>|<span data-ttu-id="74aef-161">버그를 보고하기 위한 정보가 포함된 파일(`filename`)을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-161">Creates a file (`filename`) that contains information for reporting bugs.</span></span>|
|<span data-ttu-id="74aef-162">**/comp[any]:** `text`</span><span class="sxs-lookup"><span data-stu-id="74aef-162">**/comp[any]:** `text`</span></span>|<span data-ttu-id="74aef-163">어셈블리의 Company 필드에 대한 문자열을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-163">Specifies a string for the Company field in the assembly.</span></span> <span data-ttu-id="74aef-164">`text`에 공백이 있으면 문자열을 큰따옴표(" ")로 묶습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-164">Place the string in double quotation marks (" ") if `text` contains a space.</span></span> <span data-ttu-id="74aef-165">이 문자열은 어셈블리의 사용자 지정 속성이며 리플렉션과 함께 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-165">This string is a custom attribute on the assembly and is available for viewing with reflection.</span></span><br /><br /> <span data-ttu-id="74aef-166">**/win32res** 를 지정하지 않으면 파일 탐색기에서 `text`가 파일의 `Company` 속성으로 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-166">If you do not specify **/win32res**, `text` appears in File Explorer as the `Company` property for the file.</span></span> <span data-ttu-id="74aef-167">**/win32res** 를 지정하면 파일 탐색기에서 리소스 파일의 회사 정보가 `Company` 속성으로 파일 탐색기에 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-167">If you specify **/win32res**, the company information in the specified resource file appears as the `Company` property in File Explorer.</span></span><br /><br /> <span data-ttu-id="74aef-168">텍스트가 빈 문자열("")이면 Win32 `Company` 리소스가 단일 공백으로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-168">If text is an empty string (""), the Win32 `Company` resource appears as a single space.</span></span><br /><br /> <span data-ttu-id="74aef-169">**/win32res** 를 지정하면 **/company** 는 Win32 리소스 정보에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-169">If you specify **/win32res**, **/company** will not affect the Win32 resource information.</span></span><br /><br /> <span data-ttu-id="74aef-170">MSIL 모듈의 소스 코드에서 이 옵션을 사용자 지정 특성(<xref:System.Reflection.AssemblyCompanyAttribute>)으로 지정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-170">You can also specify this option as a custom attribute (<xref:System.Reflection.AssemblyCompanyAttribute>) in the source code for any MSIL module.</span></span>|
|<span data-ttu-id="74aef-171">**/config[uration]:** `text`</span><span class="sxs-lookup"><span data-stu-id="74aef-171">**/config[uration]:** `text`</span></span>|<span data-ttu-id="74aef-172">어셈블리의 Configuration 필드에 대한 문자열을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-172">Specifies a string for the Configuration field in the assembly.</span></span> <span data-ttu-id="74aef-173">`text`에 공백이 있으면 문자열을 큰따옴표(" ")로 묶습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-173">Place the string in double quotation marks (" ") if `text` contains a space.</span></span> <span data-ttu-id="74aef-174">이 문자열은 어셈블리의 사용자 지정 속성이며 리플렉션과 함께 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-174">This string is a custom attribute on the assembly and is available for viewing with reflection.</span></span><br /><br /> <span data-ttu-id="74aef-175">텍스트가 빈 문자열이면 Win32 Configuration 리소스가 단일 공백으로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-175">If text is an empty string, the Win32 Configuration resource appears as a single space.</span></span><br /><br /> <span data-ttu-id="74aef-176">MSIL 모듈의 소스 코드에서 이 옵션을 사용자 지정 특성(<xref:System.Reflection.AssemblyConfigurationAttribute>)으로 지정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-176">You can also specify this option as a custom attribute (<xref:System.Reflection.AssemblyConfigurationAttribute>) in the source code for any MSIL module.</span></span>|
|<span data-ttu-id="74aef-177">**/copy[right]:** `text`</span><span class="sxs-lookup"><span data-stu-id="74aef-177">**/copy[right]:** `text`</span></span>|<span data-ttu-id="74aef-178">어셈블리의 Copyright 필드에 대한 문자열을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-178">Specifies a string for the Copyright field in the assembly.</span></span> <span data-ttu-id="74aef-179">`text`에 공백이 있으면 문자열을 큰따옴표(" ")로 묶습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-179">Place the string in double quotation marks (" ") if `text` contains a space.</span></span> <span data-ttu-id="74aef-180">이 문자열은 어셈블리의 사용자 지정 속성이며 리플렉션과 함께 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-180">This string is a custom attribute on the assembly and is available for viewing with reflection.</span></span><br /><br /> <span data-ttu-id="74aef-181">**/win32res** 를 지정하지 않으면 파일 탐색기에서 **/copyright** 가 Win32 Copyright(저작권) 리소스로 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-181">If you do not specify **/win32res**, **/copyright** appears in File Explorer as the Win32 Copyright resource.</span></span><br /><br /> <span data-ttu-id="74aef-182">텍스트가 빈 문자열이면 Win32 Copyright 리소스가 단일 공백으로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-182">If text is an empty string, the Win32 Copyright resource appears as a single space.</span></span><br /><br /> <span data-ttu-id="74aef-183">**/win32res** 를 지정하면 **/copyright** 는 Win32 리소스 정보에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-183">If you specify **/win32res**, **/copyright** will not affect the Win32 resource information.</span></span><br /><br /> <span data-ttu-id="74aef-184">MSIL 모듈의 소스 코드에서 이 옵션을 사용자 지정 특성(<xref:System.Reflection.AssemblyCopyrightAttribute>)으로 지정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-184">You can also specify this option as a custom attribute (<xref:System.Reflection.AssemblyCopyrightAttribute>) in the source code for any MSIL module.</span></span>|
|<span data-ttu-id="74aef-185">**/c[ulture]:** `text`</span><span class="sxs-lookup"><span data-stu-id="74aef-185">**/c[ulture]:** `text`</span></span>|<span data-ttu-id="74aef-186">어셈블리에 연결할 문화권 문자열을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-186">Specifies the culture string to associate with the assembly.</span></span> <span data-ttu-id="74aef-187">"Tags for the Identification of Languages"라는 제목의 인터넷 RFC(Requests for Comments) 문서 1766에서 정의하는 값이 문화권의 유효한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-187">Valid values for cultures are those defined by the Internet Requests for Comments (RFC) document 1766 titled "Tags for the Identification of Languages."</span></span><br /><br /> <span data-ttu-id="74aef-188">`text`에 공백이 있으면 문자열을 큰따옴표(" ")로 묶습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-188">Place the string in double quotation marks (" ") if `text` contains a space.</span></span> <span data-ttu-id="74aef-189">기본 문화권 문자열은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-189">There is no default culture string.</span></span> <span data-ttu-id="74aef-190">이 문자열을 리플렉션과 함께 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-190">This string is available for viewing with reflection.</span></span><br /><br /> <span data-ttu-id="74aef-191">유효한 `text` 문자열에 대한 자세한 내용은 <xref:System.Globalization.CultureInfo>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="74aef-191">For information about valid `text` strings, see the <xref:System.Globalization.CultureInfo>.</span></span><br /><br /> <span data-ttu-id="74aef-192">MSIL 모듈의 소스 코드에서 이 옵션을 사용자 지정 특성(<xref:System.Reflection.AssemblyCultureAttribute>)으로 지정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-192">You can also specify this option as a custom attribute (<xref:System.Reflection.AssemblyCultureAttribute>) in the source code for any MSIL module.</span></span>|
|<span data-ttu-id="74aef-193">**/delay[sign][+&#124;-]**</span><span class="sxs-lookup"><span data-stu-id="74aef-193">**/delay[sign][+&#124;-]**</span></span>|<span data-ttu-id="74aef-194">어셈블리를 완전히 서명할지, 아니면 부분적으로 서명할지를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-194">Specifies whether the assembly will be fully or partially signed.</span></span> <span data-ttu-id="74aef-195">완전히 서명된 어셈블리가 필요하면 **/delaysign-** 를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-195">Use **/delaysign-** if you want a fully signed assembly.</span></span> <span data-ttu-id="74aef-196">어셈블리에 공개 키만 포함하려면 **/delaysign+** 를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-196">Use **/delaysign+** if you only want to include the public key in the assembly.</span></span><br /><br /> <span data-ttu-id="74aef-197">완전히 서명된 어셈블리를 요청할 경우 *Al.exe* 는 매니페스트(어셈블리 메타데이터)가 포함된 파일을 해시하고 공개 키로 해당 해시에 서명합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-197">When you request a fully signed assembly, *Al.exe* hashes the file that contains the manifest (assembly metadata) and signs that hash with the private key.</span></span> <span data-ttu-id="74aef-198">결과로 생성되는 디지털 서명은 매니페스트가 포함된 파일에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-198">The resulting digital signature is stored in the file that contains the manifest.</span></span> <span data-ttu-id="74aef-199">어셈블리 서명이 연기된 경우 *Al.exe* 는 시그니처를 컴퓨팅하거나 저장하지 않고 나중에 시그니처를 추가할 수 있도록 파일에 공간을 예약합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-199">When an assembly is delay signed, *Al.exe* does not compute and store the signature, but just reserves space in the file so the signature can be added later.</span></span><br /><br /> <span data-ttu-id="74aef-200">기본값은 **/delaysign-** 입니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-200">The default is **/delaysign-**.</span></span><br /><br /> <span data-ttu-id="74aef-201">**/delaysign** 옵션은 **/keyfile** 또는 **/keyname** 과 함께 사용하지 않으면 효과가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-201">The **/delaysign** option has no effect unless used with **/keyfile** or **/keyname**.</span></span><br /><br /> <span data-ttu-id="74aef-202">예를 들어 **/delaysign+** 를 사용하면 테스터를 통해 전역 캐시에 어셈블리를 넣을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-202">For example, using **/delaysign+** enables a tester to put the assembly in the global cache.</span></span> <span data-ttu-id="74aef-203">테스트를 마친 후 어셈블리에 프라이빗 키를 포함하여 어셈블리에 완전히 서명할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-203">After testing, you can fully sign the assembly by including the private key in the assembly.</span></span><br /><br /> <span data-ttu-id="74aef-204">참고: [*Gacutil.exe*(전역 어셈블리 캐시 도구)](gacutil-exe-gac-tool.md)를 사용하여 전역 캐시에 서명이 연기된 어셈블리를 넣으려면, 먼저 [*Sn.exe*(강력한 이름 도구)](sn-exe-strong-name-tool.md)를 사용하여 확인을 건너뛰는 어셈블리를 등록합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-204">Note: Before using the [*Gacutil.exe* (Global Assembly Cache Tool)](gacutil-exe-gac-tool.md) to put a delay-signed assembly into the global cache, use the [*Sn.exe* (Strong Name Tool)](sn-exe-strong-name-tool.md) to register the assembly for verification skipping.</span></span> <span data-ttu-id="74aef-205">예: `Sn.exe –Vr delaySignedAssembly`.</span><span class="sxs-lookup"><span data-stu-id="74aef-205">For example, `Sn.exe –Vr delaySignedAssembly`.</span></span> <span data-ttu-id="74aef-206">개발에서만 이 기능을 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="74aef-206">Use this only for development.</span></span><br /><br /> <span data-ttu-id="74aef-207">MSIL 모듈의 소스 코드에서 이 옵션을 사용자 지정 특성(<xref:System.Reflection.AssemblyDelaySignAttribute>)으로 지정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-207">You can also specify this option as a custom attribute (<xref:System.Reflection.AssemblyDelaySignAttribute>) in the source code for any MSIL module.</span></span>|
|<span data-ttu-id="74aef-208">**/descr[iption]:** `text`</span><span class="sxs-lookup"><span data-stu-id="74aef-208">**/descr[iption]:** `text`</span></span>|<span data-ttu-id="74aef-209">어셈블리의 <xref:System.Reflection.AssemblyDescriptionAttribute.Description%2A> 필드에 대한 문자열을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-209">Specifies a string for the <xref:System.Reflection.AssemblyDescriptionAttribute.Description%2A> field in the assembly.</span></span> <span data-ttu-id="74aef-210">`text`에 공백이 있으면 문자열을 큰따옴표(" ")로 묶습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-210">Place the string in double quotation marks (" ") if `text` contains a space.</span></span> <span data-ttu-id="74aef-211">이 문자열은 어셈블리의 사용자 지정 속성이며 리플렉션과 함께 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-211">This string is a custom attribute on the assembly and is available for viewing with reflection.</span></span><br /><br /> <span data-ttu-id="74aef-212">**/win32res** 를 지정하지 않으면 파일 탐색기에서 **/description** 이 Win32 **Comments**(설명) 리소스로 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-212">If you do not specify **/win32res**, **/description** appears in File Explorer as the Win32 **Comments** resource.</span></span><br /><br /> <span data-ttu-id="74aef-213">텍스트가 빈 문자열이면 Win32 **Comments** 리소스가 단일 공백으로 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-213">If text is an empty string, the Win32 **Comments** resource appears as a single space.</span></span><br /><br /> <span data-ttu-id="74aef-214">**/win32res** 를 지정하면 **/description** 은 Win32 리소스 정보에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-214">If you specify **/win32res**, **/description** will not affect the Win32 resource information.</span></span><br /><br /> <span data-ttu-id="74aef-215">MSIL 모듈의 소스 코드에서 이 옵션을 사용자 지정 특성(<xref:System.Reflection.AssemblyDescriptionAttribute.Description%2A>)으로 지정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-215">You can also specify this option as a custom attribute (<xref:System.Reflection.AssemblyDescriptionAttribute.Description%2A>) in the source code for any MSIL module.</span></span>|
|<span data-ttu-id="74aef-216">**/e[vidence]:** `file`</span><span class="sxs-lookup"><span data-stu-id="74aef-216">**/e[vidence]:** `file`</span></span>|<span data-ttu-id="74aef-217">어셈블리에 `file`을 Security.Evidence라는 리소스 이름으로 포함시킵니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-217">Embeds `file` in the assembly with the resource name of Security.Evidence.</span></span><br /><br /> <span data-ttu-id="74aef-218">기본 리소스에는 Security.Evidence를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-218">You cannot use Security.Evidence for regular resources.</span></span>|
|<span data-ttu-id="74aef-219">**/fileversion:** `version`</span><span class="sxs-lookup"><span data-stu-id="74aef-219">**/fileversion:** `version`</span></span>|<span data-ttu-id="74aef-220">어셈블리의 **File Version**(파일 버전) 필드에 대한 문자열을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-220">Specifies a string for the **File Version** field in the assembly.</span></span> <span data-ttu-id="74aef-221">이 문자열은 어셈블리의 사용자 지정 속성이며 리플렉션과 함께 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-221">This string is a custom attribute on the assembly and is available for viewing with reflection.</span></span><br /><br /> <span data-ttu-id="74aef-222">**/win32res** 를 지정하지 않으면 **/fileversion** 이 Win32 **File Version** 리소스로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-222">If you do not specify **/win32res**, **/fileversion** will be used as the Win32 **File Version** resource.</span></span> <span data-ttu-id="74aef-223">**/fileversion** 을 지정하지 않으면 Win32 **File Version** 리소스가 Win32 **Assembly Version**(어셈블리 버전) 리소스로 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-223">If you do not specify **/fileversion**, the Win32 **File Version** resource will be populated by the Win32 **Assembly Version** resource.</span></span><br /><br /> <span data-ttu-id="74aef-224">**/win32res** 를 지정하면 **/fileversion** 은 Win32 리소스에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-224">If **/win32res** is specified, **/fileversion** does not affect the Win32 resource.</span></span><br /><br /> <span data-ttu-id="74aef-225">MSIL 모듈의 소스 코드에서 이 옵션을 사용자 지정 특성(AssemblyFileVersionAttribute)으로 지정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-225">You can also specify this option as a custom attribute (AssemblyFileVersionAttribute) in the source code for any MSIL module.</span></span>|
|<span data-ttu-id="74aef-226">**/flags:** `flags`</span><span class="sxs-lookup"><span data-stu-id="74aef-226">**/flags:** `flags`</span></span>|<span data-ttu-id="74aef-227">어셈블리의 `Flags` 필드에 대한 값을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-227">Specifies a value for the `Flags` field in the assembly.</span></span> <span data-ttu-id="74aef-228">`flags`에 사용할 수 있는 값은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-228">Possible values for `flags`:</span></span><br /><br /> <span data-ttu-id="74aef-229">0x0000</span><span class="sxs-lookup"><span data-stu-id="74aef-229">0x0000</span></span><br /> <span data-ttu-id="74aef-230">어셈블리가 side-by-side로 호환됩니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-230">The assembly is side-by-side compatible.</span></span><br /><br /> <span data-ttu-id="74aef-231">0x0010</span><span class="sxs-lookup"><span data-stu-id="74aef-231">0x0010</span></span><br /> <span data-ttu-id="74aef-232">어셈블리는 같은 애플리케이션 도메인에서 실행할 경우 다른 버전과 함께 실행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-232">The assembly cannot execute with other versions if they are executing in the same application domain.</span></span><br /><br /> <span data-ttu-id="74aef-233">0x0020</span><span class="sxs-lookup"><span data-stu-id="74aef-233">0x0020</span></span><br /> <span data-ttu-id="74aef-234">어셈블리는 같은 프로세스에서 실행할 경우 다른 버전과 함께 실행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-234">The assembly cannot execute with other versions if they are executing in the same process.</span></span><br /><br /> <span data-ttu-id="74aef-235">0x0030</span><span class="sxs-lookup"><span data-stu-id="74aef-235">0x0030</span></span><br /> <span data-ttu-id="74aef-236">같은 컴퓨터에서 실행되는 경우에는 어셈블리를 다른 버전과 함께 실행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-236">The assembly cannot execute with other versions if they are executing on the same computer.</span></span><br /><br /> <span data-ttu-id="74aef-237">MSIL 모듈의 소스 코드에서 이 옵션을 사용자 지정 특성(<xref:System.Reflection.AssemblyFlagsAttribute>)으로 지정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-237">You can also specify this option as a custom attribute (<xref:System.Reflection.AssemblyFlagsAttribute>) in the source code for any MSIL module.</span></span>|
|<span data-ttu-id="74aef-238">**/fullpaths**</span><span class="sxs-lookup"><span data-stu-id="74aef-238">**/fullpaths**</span></span>|<span data-ttu-id="74aef-239">오류 메시지에 보고되는 파일에 대해 *Al.exe* 가 절대 경로를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-239">Causes *Al.exe* to use the absolute path for any files that are reported in an error message.</span></span>|
|<span data-ttu-id="74aef-240">**/help**</span><span class="sxs-lookup"><span data-stu-id="74aef-240">**/help**</span></span>|<span data-ttu-id="74aef-241">이 도구의 명령 구문 및 옵션을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-241">Displays command syntax and options for the tool.</span></span>|
|<span data-ttu-id="74aef-242">**/keyf[ile]:** `filename`</span><span class="sxs-lookup"><span data-stu-id="74aef-242">**/keyf[ile]:** `filename`</span></span>|<span data-ttu-id="74aef-243">어셈블리에 서명하기 위한 키 쌍 또는 공개 키를 포함하는 파일(`filename`)을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-243">Specifies a file (`filename`) that contains a key pair or just a public key to sign an assembly.</span></span> <span data-ttu-id="74aef-244">컴파일러는 퍼블릭 키를 어셈블리 매니페스트에 삽입한 다음 프라이빗 키를 사용하여 최종 어셈블리에 서명합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-244">The compiler inserts the public key in the assembly manifest and then signs the final assembly with the private key.</span></span> <span data-ttu-id="74aef-245">키 파일을 생성하고 키 쌍을 키 컨테이너에 설치하는 방법에 대한 자세한 내용은 [Strong Name Tool (*Sn.exe*)](sn-exe-strong-name-tool.md)(Sn.exe(강력한 이름 도구))을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="74aef-245">See the [Strong Name Tool (*Sn.exe*)](sn-exe-strong-name-tool.md) for information about generating key files and installing key pairs into key containers.</span></span><br /><br /> <span data-ttu-id="74aef-246">연기된 서명을 사용할 경우 이 파일에는 일반적으로 퍼블릭 키가 있으며 프라이빗 키는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-246">If you are using delayed signing, this file will usually have the public key but not the private key.</span></span><br /><br /> <span data-ttu-id="74aef-247">키 쌍의 공개 키 정보는 어셈블리의 .publickey 필드에 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-247">The public key (of the key pair) information appears in the .publickey field of the assembly.</span></span><br /><br /> <span data-ttu-id="74aef-248">MSIL 모듈의 소스 코드에서 이 옵션을 사용자 지정 특성(<xref:System.Reflection.AssemblyKeyFileAttribute>)으로 지정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-248">You can also specify this option as a custom attribute (<xref:System.Reflection.AssemblyKeyFileAttribute>) in the source code for any MSIL module.</span></span><br /><br /> <span data-ttu-id="74aef-249">**/keyfile** 및 **/keyname** 이 모두 동일한 컴파일에서 명령줄 옵션이나 사용자 지정 특성으로 지정되면 *Al.exe* 에서 먼저 **/keyname** 으로 지정된 컨테이너를 찾으려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-249">If both **/keyfile** and **/keyname** are specified (either by command-line option or by custom attribute) in the same compilation, *Al.exe* will first try the container specified with **/keyname**.</span></span> <span data-ttu-id="74aef-250">이 시도에 성공하면 키 컨테이너의 정보를 사용하여 어셈블리가 서명됩니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-250">If that succeeds, the assembly is signed with the information in the key container.</span></span> <span data-ttu-id="74aef-251">*Al.exe* 에서 키 컨테이너를 찾지 못하면 **/keyfile** 로 지정된 파일을 찾으려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-251">If *Al.exe* does not find the key container, it will try the file specified with **/keyfile**.</span></span> <span data-ttu-id="74aef-252">해당 파일을 찾으면 어셈블리가 키 파일의 정보로 서명되고 키 정보가 키 컨테이너에 설치됩니다([*Sn.exe*](sn-exe-strong-name-tool.md)의 -i 옵션과 비슷함). 이에 따라 다음에 컴파일할 때 **/keyname** 옵션이 유효하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-252">If that succeeds, the assembly is signed with the information in the key file and the key information will be installed in the key container (similar to the -i option in [*Sn.exe*](sn-exe-strong-name-tool.md)) so that on the next compilation, the **/keyname** option will be valid.</span></span>|
|<span data-ttu-id="74aef-253">**/keyn[ame]:** `text`</span><span class="sxs-lookup"><span data-stu-id="74aef-253">**/keyn[ame]:** `text`</span></span>|<span data-ttu-id="74aef-254">키 쌍을 보관하는 컨테이너를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-254">Specifies a container that holds a key pair.</span></span> <span data-ttu-id="74aef-255">어셈블리 매니페스트에 공개 키를 삽입하여 어셈블리에 서명(강력한 이름을 부여)합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-255">This will sign the assembly (give it a strong name) by inserting a public key into the assembly manifest.</span></span> <span data-ttu-id="74aef-256">그런 다음 *Al.exe* 가 프라이빗 키를 사용하여 최종 어셈블리에 서명합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-256">*Al.exe* will then sign the final assembly with the private key.</span></span><br /><br /> <span data-ttu-id="74aef-257">*Sn.exe* 를 사용하여 키 쌍을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-257">Use *Sn.exe* to generate a key pair.</span></span><br /><br /> <span data-ttu-id="74aef-258">어셈블리의 .publickey 필드에 키 정보가 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-258">The key information appears in the .publickey field of the assembly.</span></span><br /><br /> <span data-ttu-id="74aef-259">`text`에 공백이 있으면 큰따옴표(" ")로 묶습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-259">Place `text` in double quotation marks (" ") if there is an embedded space.</span></span><br /><br /> <span data-ttu-id="74aef-260">MSIL 모듈의 소스 코드에서 이 옵션을 사용자 지정 특성(<xref:System.Reflection.AssemblyKeyNameAttribute>)으로 지정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-260">You can also specify this option as a custom attribute (<xref:System.Reflection.AssemblyKeyNameAttribute>) in the source code for any MSIL module.</span></span>|
|<span data-ttu-id="74aef-261">**/main:** `method`</span><span class="sxs-lookup"><span data-stu-id="74aef-261">**/main:** `method`</span></span>|<span data-ttu-id="74aef-262">모듈을 실행 파일로 변환할 때 진입점으로 사용할 메서드의 정규화된 이름(`class`.`method`)을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-262">Specifies the fully qualified name (`class`.`method`) of the method to use as an entry point when converting a module to an executable file.</span></span>|
|<span data-ttu-id="74aef-263">**/nologo**</span><span class="sxs-lookup"><span data-stu-id="74aef-263">**/nologo**</span></span>|<span data-ttu-id="74aef-264">*Al.exe* 를 호출할 때 명령줄에 표시되는 배너 또는 로고를 표시하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-264">Suppresses the banner, or logo, displayed at the command line when you invoke *Al.exe*.</span></span>|
|<span data-ttu-id="74aef-265">**/out:** `filename`</span><span class="sxs-lookup"><span data-stu-id="74aef-265">**/out:** `filename`</span></span>|<span data-ttu-id="74aef-266">*Al.exe* 가 생성한 파일의 이름을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-266">Specifies the name of the file produced by *Al.exe*.</span></span> <span data-ttu-id="74aef-267">필수 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-267">This is a required option.</span></span>|
|<span data-ttu-id="74aef-268">**/platform:** `text`</span><span class="sxs-lookup"><span data-stu-id="74aef-268">**/platform:** `text`</span></span>|<span data-ttu-id="74aef-269">이 코드를 실행할 수 있는 플랫폼은 x86, Itanium, x64, anycpu(기본값) 또는 anycpu32bitpreferred로 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-269">Limits which platform this code can run on; must be one of x86, Itanium, x64, anycpu (the default), or anycpu32bitpreferred.</span></span>|
|<span data-ttu-id="74aef-270">**/prod[uct]:** `text`</span><span class="sxs-lookup"><span data-stu-id="74aef-270">**/prod[uct]:** `text`</span></span>|<span data-ttu-id="74aef-271">어셈블리의 **Product**(제품) 필드에 대한 문자열을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-271">Specifies a string for the **Product** field in the assembly.</span></span> <span data-ttu-id="74aef-272">`text`에 공백이 있으면 문자열을 큰따옴표(" ")로 묶습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-272">Place the string in double quotation marks (" ") if `text` contains a space.</span></span> <span data-ttu-id="74aef-273">이 문자열은 어셈블리의 사용자 지정 속성이며 리플렉션과 함께 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-273">This string is a custom attribute on the assembly and is available for viewing with reflection.</span></span><br /><br /> <span data-ttu-id="74aef-274">**/win32res** 를 지정하지 않으면 파일 탐색기에서 **/product** 가 Win32 **Product Name**(제품 이름) 리소스로 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-274">If you do not specify **/win32res**, **/product** appears in File Explorer as the Win32 **Product Name** resource.</span></span><br /><br /> <span data-ttu-id="74aef-275">텍스트가 빈 문자열이면 Win32 **Product Name** 리소스가 단일 공백으로 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-275">If text is an empty string, the Win32 **Product Name** resource appears as a single space.</span></span><br /><br /> <span data-ttu-id="74aef-276">**/win32res** 를 지정하면 **/product** 는 Win32 리소스 정보에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-276">If you specify **/win32res**, **/product** will not affect the Win32 resource information.</span></span><br /><br /> <span data-ttu-id="74aef-277">MSIL 모듈의 소스 코드에서 이 옵션을 사용자 지정 특성(<xref:System.Reflection.AssemblyProductAttribute>)으로 지정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-277">You can also specify this option as a custom attribute (<xref:System.Reflection.AssemblyProductAttribute>) in the source code for any MSIL module.</span></span>|
|<span data-ttu-id="74aef-278">**/productv[ersion]:** `text`</span><span class="sxs-lookup"><span data-stu-id="74aef-278">**/productv[ersion]:** `text`</span></span>|<span data-ttu-id="74aef-279">어셈블리의 **Product Version**(제품 버전) 필드에 대한 문자열을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-279">Specifies a string for the **Product Version** field in the assembly.</span></span> <span data-ttu-id="74aef-280">`text`에 공백이 있으면 문자열을 큰따옴표(" ")로 묶습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-280">Place the string in double quotation marks (" ") if `text` contains a space.</span></span> <span data-ttu-id="74aef-281">이 문자열은 어셈블리의 사용자 지정 속성이며 리플렉션과 함께 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-281">This string is a custom attribute on the assembly and is available for viewing with reflection.</span></span><br /><br /> <span data-ttu-id="74aef-282">**/win32res** 를 지정하지 않으면 **/productversion** 이 Win32 **Product Version** 리소스로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-282">If you do not specify **/win32res**, **/productversion** will be used as the Win32 **Product Version** resource.</span></span> <span data-ttu-id="74aef-283">**/productversion** 을 지정하지 않으면 Win32 **Product Version** 리소스가 Win32 **File Version** 리소스로 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-283">If you do not specify **/productversion**, the Win32 **Product Version** resource will be populated by the Win32 **File Version** resource.</span></span><br /><br /> <span data-ttu-id="74aef-284">**/win32res** 를 지정하면 **/productversion** 은 Win32 리소스 정보에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-284">If you specify **/win32res**, **/productversion** will not affect the Win32 resource information.</span></span><br /><br /> <span data-ttu-id="74aef-285">MSIL 모듈의 소스 코드에서 이 옵션을 사용자 지정 특성(<xref:System.Reflection.AssemblyInformationalVersionAttribute>)으로 지정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-285">You can also specify this option as a custom attribute (<xref:System.Reflection.AssemblyInformationalVersionAttribute>) in the source code for any MSIL module.</span></span>|
|<span data-ttu-id="74aef-286">**/t[arget]:** `lib[rary]` &#124; `exe` &#124; `win[exe]`</span><span class="sxs-lookup"><span data-stu-id="74aef-286">**/t[arget]:** `lib[rary]` &#124; `exe` &#124; `win[exe]`</span></span>|<span data-ttu-id="74aef-287">출력 파일의 파일 형식 즉, `lib[rary]`(코드 라이브러리), `exe`(콘솔 애플리케이션) 또는 `win[exe]`(Windows 기반 애플리케이션)을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-287">Specifies the file format of the output file: `lib[rary]` (code library), `exe` (console application), or `win[exe]` (Windows-based application).</span></span> <span data-ttu-id="74aef-288">기본값은 `lib[rary]`입니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-288">The default is `lib[rary]`.</span></span>|
|<span data-ttu-id="74aef-289">**/template:** `filename`</span><span class="sxs-lookup"><span data-stu-id="74aef-289">**/template:** `filename`</span></span>|<span data-ttu-id="74aef-290">culture 필드를 제외한 모든 어셈블리 메타데이터를 상속받을 상위 어셈블리, `filename`을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-290">Specifies the assembly, `filename`, from which to inherit all assembly metadata, except the culture field.</span></span><br /><br /> <span data-ttu-id="74aef-291">**/template** 으로 만든 어셈블리는 위성 어셈블리가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-291">An assembly that you create with **/template** will be a satellite assembly.</span></span>|
|<span data-ttu-id="74aef-292">**/title:** `text`</span><span class="sxs-lookup"><span data-stu-id="74aef-292">**/title:** `text`</span></span>|<span data-ttu-id="74aef-293">어셈블리의 **Title**(제목) 필드에 대한 문자열을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-293">Specifies a string for the **Title** field in the assembly.</span></span> <span data-ttu-id="74aef-294">`text`에 공백이 있으면 문자열을 큰따옴표(" ")로 묶습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-294">Place the string in double quotation marks (" ") if `text` contains a space.</span></span> <span data-ttu-id="74aef-295">이 문자열은 어셈블리의 사용자 지정 속성이며 리플렉션과 함께 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-295">This string is a custom attribute on the assembly and is available for viewing with reflection.</span></span><br /><br /> <span data-ttu-id="74aef-296">**/win32res** 를 지정하지 않으면 파일 탐색기에서 **/title** 이 셸에서 애플리케이션의 이름으로 사용되는 Win32 **Description**(설명) 리소스로 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-296">If you do not specify **/win32res**, **/title** appears in File Explorer as the Win32 **Description** resource, which is used by the shell as the friendly name of an application.</span></span> <span data-ttu-id="74aef-297">또한 여러 애플리케이션이 지원하는 파일 형식에 대한 바로 가기 메뉴의 **연결 프로그램** 하위 메뉴에도 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-297">It is also displayed on the **Open With** submenu of the shortcut menu for a file type for which there are multiple supporting applications.</span></span><br /><br /> <span data-ttu-id="74aef-298">텍스트가 빈 문자열이면 Win32 **Description** 리소스가 단일 공백으로 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-298">If text is an empty string, the Win32 **Description** resource appears as a single space.</span></span><br /><br /> <span data-ttu-id="74aef-299">**/win32res** 를 지정하면 **/title** 은 Win32 리소스 정보에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-299">If you specify **/win32res**, **/title** will not affect the Win32 resource information.</span></span><br /><br /> <span data-ttu-id="74aef-300">MSIL 모듈의 소스 코드에서 이 옵션을 사용자 지정 특성(<xref:System.Reflection.AssemblyTitleAttribute>)으로 지정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-300">You can also specify this option as a custom attribute (<xref:System.Reflection.AssemblyTitleAttribute>) in the source code for any MSIL module.</span></span>|
|<span data-ttu-id="74aef-301">**/trade[mark]:** `text`</span><span class="sxs-lookup"><span data-stu-id="74aef-301">**/trade[mark]:** `text`</span></span>|<span data-ttu-id="74aef-302">어셈블리의 **Trademark**(상표) 필드에 대한 문자열을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-302">Specifies a string for the **Trademark** field in the assembly.</span></span> <span data-ttu-id="74aef-303">`text`에 공백이 있으면 문자열을 큰따옴표(" ")로 묶습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-303">Place the string in double quotation marks (" ") if `text` contains a space.</span></span> <span data-ttu-id="74aef-304">이 문자열은 어셈블리의 사용자 지정 속성이며 리플렉션과 함께 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-304">This string is a custom attribute on the assembly and is available for viewing with reflection.</span></span><br /><br /> <span data-ttu-id="74aef-305">**/win32res** 를 지정하지 않으면 파일 탐색기에서 **/trademark** 가 Win32 **Trademark** 리소스로 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-305">If you do not specify **/win32res**, **/trademark** appears in File Explorer as the Win32 **Trademark** resource.</span></span><br /><br /> <span data-ttu-id="74aef-306">텍스트가 빈 문자열이면 Win32 **Trademark** 리소스가 단일 공백으로 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-306">If text is an empty string, the Win32 **Trademark** resource appears as a single space.</span></span><br /><br /> <span data-ttu-id="74aef-307">**/win32res** 를 지정하면 **/trademark** 는 Win32 리소스 정보에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-307">If you specify **/win32res**, **/trademark** will not affect the Win32 resource information.</span></span><br /><br /> <span data-ttu-id="74aef-308">MSIL 모듈의 소스 코드에서 이 옵션을 사용자 지정 특성(<xref:System.Reflection.AssemblyTrademarkAttribute>)으로 지정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-308">You can also specify this option as a custom attribute (<xref:System.Reflection.AssemblyTrademarkAttribute>) in the source code for any MSIL module.</span></span>|
|<span data-ttu-id="74aef-309">**/v[ersion]:** `version`</span><span class="sxs-lookup"><span data-stu-id="74aef-309">**/v[ersion]:** `version`</span></span>|<span data-ttu-id="74aef-310">이 어셈블리의 버전 정보를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-310">Specifies version information for this assembly.</span></span> <span data-ttu-id="74aef-311">버전 문자열의 형식은 `major`.`minor`.`build`.`revision`입니다. 기본값은 0입니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-311">The format of the version string is `major`.`minor`.`build`.`revision`. The default value is 0.</span></span><br /><br /> <span data-ttu-id="74aef-312">**/version** 을 지정하면 `major`도 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-312">If you do specify **/version**, you must specify `major`.</span></span> <span data-ttu-id="74aef-313">`major` 및 `minor`를 지정하면 `build`에 별표(\*)를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-313">If you specify `major` and `minor`, you can specify an asterisk (\*)for `build`.</span></span> <span data-ttu-id="74aef-314">이 경우 `build`는 현지 시간 2000년 1월 1일부터 경과된 일수와 일치하며, `revision`은 현재 날짜, 현지 시간, 자정부터 경과된 초 수를 2로 나눈 값과 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-314">This causes `build` to be equal to the number of days since January 1, 2000, local time, and `revision` to be equal to the number of seconds since midnight of the current day, local time, divided by 2.</span></span><br /><br /> <span data-ttu-id="74aef-315">`major`, `minor` 및 `build`를 지정하면 `revision`에 대해 별표를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-315">If you specify `major`, `minor`, and `build`, you can specify an asterisk for `revision`.</span></span> <span data-ttu-id="74aef-316">이 경우 `revision`은 현재 날짜, 현지 시간, 자정부터 경과된 초 수를 2로 나눈 값과 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-316">This causes `revision` to be equal to the number of seconds since midnight of the current day, local time, divided by 2.</span></span><br /><br /> <span data-ttu-id="74aef-317">유효한 버전 문자열을 요약하면 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-317">To summarize, the valid version strings are as follows:</span></span><br /><br /> <span data-ttu-id="74aef-318">X</span><span class="sxs-lookup"><span data-stu-id="74aef-318">X</span></span><br /><br /> <span data-ttu-id="74aef-319">X.X</span><span class="sxs-lookup"><span data-stu-id="74aef-319">X.X</span></span><br /><br /> <span data-ttu-id="74aef-320">X.X.\*</span><span class="sxs-lookup"><span data-stu-id="74aef-320">X.X.\*</span></span><br /><br /> <span data-ttu-id="74aef-321">X.X.X</span><span class="sxs-lookup"><span data-stu-id="74aef-321">X.X.X</span></span><br /><br /> <span data-ttu-id="74aef-322">X.X.X.\*</span><span class="sxs-lookup"><span data-stu-id="74aef-322">X.X.X.\*</span></span><br /><br /> <span data-ttu-id="74aef-323">X.X.X.X</span><span class="sxs-lookup"><span data-stu-id="74aef-323">X.X.X.X</span></span><br /><br /> <span data-ttu-id="74aef-324">여기서 X는 65535를 제외한 부호 없는 short 상수(0-65534)입니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-324">where X is any unsigned short constant except 65535 (0-65534).</span></span><br /><br /> <span data-ttu-id="74aef-325">**/win32res** 를 지정하지 않으면 **/version** 이 Win32 **Assembly Version**(어셈블리 버전) 리소스로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-325">If you do not specify **/win32res**, **/version** will be used as the Win32 **Assembly Version** resource.</span></span><br /><br /> <span data-ttu-id="74aef-326">**/win32res**, **/productversion** 및 **/fileversion** 을 지정하지 않으면 **/version** 이 Win32 **Assembly Version**, File Version 및 **Product Version** 리소스에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-326">If you do not specify **/win32res**, **/productversion**, and **/fileversion**, **/version** will be used for the **Assembly Version**, File Version, and **Product Version** Win32 resources.</span></span><br /><br /> <span data-ttu-id="74aef-327">**/win32res** 를 지정하면 **/version** 은 Win32 리소스 정보에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-327">If you specify **/win32res**, **/version** will not affect the Win32 resource information.</span></span><br /><br /> <span data-ttu-id="74aef-328">MSIL 모듈의 소스 코드에서 이 옵션을 사용자 지정 특성(<xref:System.Reflection.AssemblyVersionAttribute>)으로 지정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-328">You can also specify this option as a custom attribute (<xref:System.Reflection.AssemblyVersionAttribute>) in the source code for any MSIL module.</span></span>|
|<span data-ttu-id="74aef-329">**/win32icon:** `filename`</span><span class="sxs-lookup"><span data-stu-id="74aef-329">**/win32icon:** `filename`</span></span>|<span data-ttu-id="74aef-330">.ico 파일을 어셈블리에 삽입합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-330">Inserts an .ico file in the assembly.</span></span> <span data-ttu-id="74aef-331">.ico 파일을 사용하면 파일 탐색기에서 출력 파일을 원하는 모양으로 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-331">The .ico file gives the output file the desired appearance in File Explorer.</span></span>|
|<span data-ttu-id="74aef-332">**/win32res:** `filename`</span><span class="sxs-lookup"><span data-stu-id="74aef-332">**/win32res:** `filename`</span></span>|<span data-ttu-id="74aef-333">Win32 리소스(.res 파일)를 출력 파일에 삽입합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-333">Inserts a Win32 resource (.res file) in the output file.</span></span> <span data-ttu-id="74aef-334">Win32 리소스 파일은 리소스 컴파일러를 사용하여 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-334">A Win32 resource file can be created by using the Resource Compiler.</span></span> <span data-ttu-id="74aef-335">리소스 컴파일러는 Visual C++ 프로그램을 컴파일할 때 실행되며 .rc 파일에서 .res 파일이 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-335">The Resource Compiler is invoked when you compile a Visual C++ program; a .res file is created from the .rc file.</span></span>|
|`@filename`|<span data-ttu-id="74aef-336">*Al.exe* 명령을 포함하는 지시 파일을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-336">Specifies a response file that contains *Al.exe* commands.</span></span><br /><br /> <span data-ttu-id="74aef-337">지시 파일의 명령은 한 줄에 하나씩 나타나거나 하나 이상의 공백으로 분리되어 같은 줄에 나타날 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-337">Commands in the response file can appear one per line or on the same line, separated by one or more spaces.</span></span>|
|<span data-ttu-id="74aef-338">**/?**</span><span class="sxs-lookup"><span data-stu-id="74aef-338">**/?**</span></span>|<span data-ttu-id="74aef-339">이 도구의 명령 구문 및 옵션을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-339">Displays command syntax and options for the tool.</span></span>|

## <a name="remarks"></a><span data-ttu-id="74aef-340">설명</span><span class="sxs-lookup"><span data-stu-id="74aef-340">Remarks</span></span>

<span data-ttu-id="74aef-341">모든 Visual Studio 컴파일러는 어셈블리를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-341">All Visual Studio compilers produce assemblies.</span></span> <span data-ttu-id="74aef-342">그러나 모듈(매니페스트 없는 메타데이터)이 하나 이상 있으면 *Al.exe* 를 사용하여 별도의 파일에 매니페스트가 있는 어셈블리를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-342">However, if you have one or more modules (metadata without a manifest), you can use *Al.exe* to create an assembly with the manifest in a separate file.</span></span>

<span data-ttu-id="74aef-343">캐시에서 어셈블리를 설치하거나, 제거하거나, 캐시의 내용을 나열하려면 [*Gacutil.exe*(전역 어셈블리 캐시 도구)](gacutil-exe-gac-tool.md)를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-343">To install assemblies in the cache, remove assemblies from the cache, or list the contents of the cache, use the [Global Assembly Cache Tool (*Gacutil.exe*)](gacutil-exe-gac-tool.md).</span></span>

## <a name="errors-and-warnings"></a><span data-ttu-id="74aef-344">오류 및 경고</span><span class="sxs-lookup"><span data-stu-id="74aef-344">Errors and Warnings</span></span>

<span data-ttu-id="74aef-345">다음 표에서는 *Al.exe* 에 의해 생성된 오류를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-345">The following table lists the errors generated by *Al.exe*.</span></span>

| <span data-ttu-id="74aef-346">Error</span><span class="sxs-lookup"><span data-stu-id="74aef-346">Error</span></span> | <span data-ttu-id="74aef-347">설명</span><span class="sxs-lookup"><span data-stu-id="74aef-347">Description</span></span> |
| ----- | ----------- |
|<span data-ttu-id="74aef-348">al1001</span><span class="sxs-lookup"><span data-stu-id="74aef-348">al1001</span></span>|<span data-ttu-id="74aef-349">내부 컴파일러 오류</span><span class="sxs-lookup"><span data-stu-id="74aef-349">Internal compiler error</span></span><br /><br /> <span data-ttu-id="74aef-350">*Al.exe* 가 예기치 않은 구문을 분석할 수 없어 실패하는지 여부를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-350">Try to determine whether *Al.exe* is failing because of its inability to parse unexpected syntax.</span></span> <span data-ttu-id="74aef-351">그런 다음 Microsoft 기술 지원 서비스에 문의하세요.</span><span class="sxs-lookup"><span data-stu-id="74aef-351">Then, contact Microsoft Product Support Services.</span></span>|
|<span data-ttu-id="74aef-352">al1002</span><span class="sxs-lookup"><span data-stu-id="74aef-352">al1002</span></span>|<span data-ttu-id="74aef-353">메모리 부족</span><span class="sxs-lookup"><span data-stu-id="74aef-353">Out of memory</span></span><br /><br /> <span data-ttu-id="74aef-354">*Al.exe* 가 메모리 부족으로 중지되었습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-354">*Al.exe* ran out of memory and stopped.</span></span> <span data-ttu-id="74aef-355">사용 가능한 메모리 양을 늘립니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-355">Increase the amount of available memory.</span></span>|
|<span data-ttu-id="74aef-356">al1003</span><span class="sxs-lookup"><span data-stu-id="74aef-356">al1003</span></span>|<span data-ttu-id="74aef-357">'option' 컴파일러 옵션 다음에는 인수가 와야 합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-357">Compiler option 'option' must be followed by an argument</span></span><br /><br /> <span data-ttu-id="74aef-358">*Al.exe* 에서 명령줄 옵션에 인수가 전달될 것으로 예상했습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-358">*Al.exe* expected an argument to be passed to a command-line option.</span></span> <span data-ttu-id="74aef-359">예를 들어 **/algid:** 를 지정하는 경우 알고리즘 식별자를 전달해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-359">For example, if you specify **/algid:**, you must pass an algorithm identifier.</span></span>|
|<span data-ttu-id="74aef-360">al1004</span><span class="sxs-lookup"><span data-stu-id="74aef-360">al1004</span></span>|<span data-ttu-id="74aef-361">예기치 않은 공용 언어 런타임 초기화 오류 - 'reason'</span><span class="sxs-lookup"><span data-stu-id="74aef-361">Unexpected common language runtime initialization error — 'reason'</span></span><br /><br /> <span data-ttu-id="74aef-362">*Al.exe* 에서 지정된 이유로 Visual Studio 또는 공용 언어 런타임 설치 오류를 보고했습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-362">*Al.exe* reported an error with the installation of Visual Studio or the common language runtime for the specified reason.</span></span>|
|<span data-ttu-id="74aef-363">al1005</span><span class="sxs-lookup"><span data-stu-id="74aef-363">al1005</span></span>|<span data-ttu-id="74aef-364">'file' 파일이 너무 커서 열 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-364">File 'file' too big to open</span></span><br /><br /> <span data-ttu-id="74aef-365">*Al.exe* 에서 여는 모든 파일은 4GB(기가바이트)보다 작아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-365">All files opened by *Al.exe* must be smaller than 4 gigabytes (GB).</span></span>|
|<span data-ttu-id="74aef-366">al1006</span><span class="sxs-lookup"><span data-stu-id="74aef-366">al1006</span></span>|<span data-ttu-id="74aef-367">'file' 지시 파일이 이미 포함되었습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-367">Response file 'file' was already included</span></span><br /><br /> <span data-ttu-id="74aef-368">동일한 지시 파일이 명령줄에서 두 번 이상 지정되었습니다(`@file`).</span><span class="sxs-lookup"><span data-stu-id="74aef-368">The same response file was specified (`@file`) more than once on the command line.</span></span> <span data-ttu-id="74aef-369">지시 파일은 한 번만 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-369">The response file can only be included once.</span></span>|
|<span data-ttu-id="74aef-370">al1007</span><span class="sxs-lookup"><span data-stu-id="74aef-370">al1007</span></span>|<span data-ttu-id="74aef-371">'file' 지시 파일을 여는 동안 오류가 발생했습니다. 'reason'</span><span class="sxs-lookup"><span data-stu-id="74aef-371">Error opening response file 'file' — 'reason'</span></span><br /><br /> <span data-ttu-id="74aef-372">*Al.exe* 에서 지정된 이유로 지정된 지시 파일을 열 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-372">*Al.exe* cannot open the specified response file for the specified reason.</span></span>|
|<span data-ttu-id="74aef-373">al1008</span><span class="sxs-lookup"><span data-stu-id="74aef-373">al1008</span></span>|<span data-ttu-id="74aef-374">'option' 명령줄 옵션에 대한 파일 사양이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-374">Missing file specification for 'option' command-line option</span></span><br /><br /> <span data-ttu-id="74aef-375">*Al.exe* 에서 명령줄 옵션에 파일이 전달될 것으로 예상했습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-375">*Al.exe* expected a file to be passed to a command-line option.</span></span> <span data-ttu-id="74aef-376">예를 들어 **/out** 옵션을 지정하는 경우 파일을 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-376">For example, if you specify the **/out** option, you must specify a file.</span></span>|
|<span data-ttu-id="74aef-377">al1009</span><span class="sxs-lookup"><span data-stu-id="74aef-377">al1009</span></span>|<span data-ttu-id="74aef-378">'file'을 쓰기용으로 열 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-378">Can't open 'file' for writing</span></span><br /><br /> <span data-ttu-id="74aef-379">*Al.exe* 에서 출력 어셈블리 파일과 같은 파일에 쓸 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-379">*Al.exe* was unable to write to a file, such as the output assembly file.</span></span> <span data-ttu-id="74aef-380">디스크가 꽉 찼거나, 파일이 읽기 전용이거나, 파일에 대한 권한이 없을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-380">The disk might be full, the file might be read-only, or you might not have permissions to the file.</span></span>|
|<span data-ttu-id="74aef-381">al1010</span><span class="sxs-lookup"><span data-stu-id="74aef-381">al1010</span></span>|<span data-ttu-id="74aef-382">명령줄 구문 오류: 'option' 옵션에 ':text' 누락</span><span class="sxs-lookup"><span data-stu-id="74aef-382">Command-line syntax error: Missing ':text' for 'option' option</span></span><br /><br /> <span data-ttu-id="74aef-383">*Al.exe* 에서 명령줄 옵션에 인수가 전달될 것으로 예상했습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-383">*Al.exe* expected an argument to be passed to a command-line option.</span></span> <span data-ttu-id="74aef-384">예를 들어 **/title** 옵션을 지정하는 경우 문자열을 전달해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-384">For example, if you specify the **/title** option, you must pass a string.</span></span>|
|<span data-ttu-id="74aef-385">al1011</span><span class="sxs-lookup"><span data-stu-id="74aef-385">al1011</span></span>|<span data-ttu-id="74aef-386">'file' 파일은 실행 파일이며 텍스트 파일로 열 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-386">File 'file' is an executable file and cannot be opened as a text file</span></span><br /><br /> <span data-ttu-id="74aef-387">텍스트 파일이 필요한 위치에 이진 파일이 지정되었습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-387">A binary file was specified where a text file was expected.</span></span> <span data-ttu-id="74aef-388">예를 들어 명령줄에서 이진 파일이 지시 파일로 전달되면 이 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-388">For example, this error occurs if a binary file is passed on the command line as a response file.</span></span>|
|<span data-ttu-id="74aef-389">al1012</span><span class="sxs-lookup"><span data-stu-id="74aef-389">al1012</span></span>|<span data-ttu-id="74aef-390">'value'가 'option' 옵션에 유효한 설정이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-390">'value' is not a valid setting for option 'option'</span></span><br /><br /> <span data-ttu-id="74aef-391">예기치 않은 값이 명령줄 옵션에 전달되었습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-391">An unexpected value was passed to a command-line option.</span></span> <span data-ttu-id="74aef-392">예를 들어 **/target** 옵션에 잘못된 값을 지정하는 경우 이 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-392">For example, this error occurs if you specify an invalid value to the **/target** option.</span></span>|
|<span data-ttu-id="74aef-393">al1013</span><span class="sxs-lookup"><span data-stu-id="74aef-393">al1013</span></span>|<span data-ttu-id="74aef-394">인식할 수 없는 명령줄 옵션: 'option'</span><span class="sxs-lookup"><span data-stu-id="74aef-394">Unrecognized command-line option: 'option'</span></span><br /><br /> <span data-ttu-id="74aef-395">잘못된 명령줄 옵션을 지정했습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-395">An invalid command-line option was specified.</span></span>|
|<span data-ttu-id="74aef-396">al1014</span><span class="sxs-lookup"><span data-stu-id="74aef-396">al1014</span></span>|<span data-ttu-id="74aef-397">예기치 않은 초기화 오류 - 'reason'</span><span class="sxs-lookup"><span data-stu-id="74aef-397">Unexpected initialization error — 'reason'</span></span><br /><br /> <span data-ttu-id="74aef-398">*Al.exe* 에서 COM 초기화 오류를 발견했습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-398">*Al.exe* detected a COM initialization failure.</span></span> <span data-ttu-id="74aef-399">이 오류는 메모리 부족으로 발생할 수도 있지만 시스템 DLL 파일 때문일 가능성이 더 큽니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-399">This might be caused by a lack of memory, but a more likely cause is the system DLL files.</span></span> <span data-ttu-id="74aef-400">Microsoft Visual Studio와 같은 자동화 인식 또는 COM 인식 프로그램을 실행하면 유사한 오류가 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-400">You should see a similar error if you run any Automation-aware or COM-aware program, such as Microsoft Visual Studio.</span></span><br /><br /> <span data-ttu-id="74aef-401">운영 체제를 다시 설치합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-401">Reinstall the operating system.</span></span>|
|<span data-ttu-id="74aef-402">al1015</span><span class="sxs-lookup"><span data-stu-id="74aef-402">al1015</span></span>|<span data-ttu-id="74aef-403">'alinkui.dll' 메시지 파일을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-403">Unable to find messages file 'alinkui.dll'</span></span><br /><br /> <span data-ttu-id="74aef-404">*Al.exe* 를 사용하려면 *Alinkui.dll* 이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-404">*Al.exe* requires *Alinkui.dll*.</span></span> <span data-ttu-id="74aef-405">이 파일이 경로에 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-405">Make sure that this file is on your path.</span></span> <span data-ttu-id="74aef-406">필요한 경우 제품 CD에서 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-406">If necessary, copy it from the product CD.</span></span>|
|<span data-ttu-id="74aef-407">al1016</span><span class="sxs-lookup"><span data-stu-id="74aef-407">al1016</span></span>|<span data-ttu-id="74aef-408">유효한 입력 파일을 지정하지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-408">No valid input files were specified</span></span><br /><br /> <span data-ttu-id="74aef-409">*Al.exe* 를 사용하려면 어셈블리 정보가 없는 입력 파일이 하나 이상 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-409">*Al.exe* requires one or more input files that do not have assembly information.</span></span>|
|<span data-ttu-id="74aef-410">al1017</span><span class="sxs-lookup"><span data-stu-id="74aef-410">al1017</span></span>|<span data-ttu-id="74aef-411">대상 파일 이름을 지정하지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-411">No target file name was specified</span></span><br /><br /> <span data-ttu-id="74aef-412">대상 파일 이름을 지정하는 필수 **/out** 옵션이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-412">The required **/out** option specifying the target file name was missing.</span></span>|
|<span data-ttu-id="74aef-413">al1018</span><span class="sxs-lookup"><span data-stu-id="74aef-413">al1018</span></span>|<span data-ttu-id="74aef-414">‘file’ 필수 파일을 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-414">Required file 'file' could not be loaded</span></span><br /><br /> <span data-ttu-id="74aef-415">특정 DLL 파일을 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-415">Certain DLL files cannot be loaded.</span></span> <span data-ttu-id="74aef-416">Visual Studio 또는 Windows SDK를 다시 설치합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-416">Reinstall Visual Studio or the Windows SDK.</span></span>|
|<span data-ttu-id="74aef-417">al1019</span><span class="sxs-lookup"><span data-stu-id="74aef-417">al1019</span></span>|<span data-ttu-id="74aef-418">어셈블리를 만드는 동안 메타데이터 오류 발생 - reason</span><span class="sxs-lookup"><span data-stu-id="74aef-418">Metadata failure while creating assembly—reason</span></span><br /><br /> <span data-ttu-id="74aef-419">지정된 이유로 어셈블리 생성이 중단되었습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-419">Generation of the assembly was interrupted for the specified reason.</span></span> <span data-ttu-id="74aef-420">예를 들어 **/win32res** 옵션으로 지정한 파일을 찾을 수 없는 경우 이 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-420">For example, this error occurs if a file that you specify with the **/win32res** option is not found.</span></span>|
|<span data-ttu-id="74aef-421">al1020</span><span class="sxs-lookup"><span data-stu-id="74aef-421">al1020</span></span>|<span data-ttu-id="74aef-422">포함된 어셈블리 'file'을 무시합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-422">Ignoring included assembly 'file'</span></span><br /><br /> <span data-ttu-id="74aef-423">어셈블리를 포함하는 입력 파일을 지정했습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-423">An input file that contained an assembly was specified.</span></span> <span data-ttu-id="74aef-424">*Al.exe* 입력 파일은 어셈블리를 포함할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-424">*Al.exe* input files cannot contain assemblies.</span></span>|
|<span data-ttu-id="74aef-425">al1021</span><span class="sxs-lookup"><span data-stu-id="74aef-425">al1021</span></span>|<span data-ttu-id="74aef-426">'setting': 이전 설정 재정의</span><span class="sxs-lookup"><span data-stu-id="74aef-426">'setting' : overriding previous setting</span></span><br /><br /> <span data-ttu-id="74aef-427">모듈에 사용자 지정 특성을 통해 할당된 특정 설정 값이 있었습니다. 이 값이 *Al.exe* 명령줄 옵션을 사용하여 전달된 값으로 재정의되었습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-427">A module had a value for a particular setting, possibly assigned through custom attributes, which was overridden with a value passed using an *Al.exe* command-line option.</span></span>|
|<span data-ttu-id="74aef-428">al1022</span><span class="sxs-lookup"><span data-stu-id="74aef-428">al1022</span></span>|<span data-ttu-id="74aef-429">포함된 리소스 'file'을 읽는 동안 오류 발생 - reason</span><span class="sxs-lookup"><span data-stu-id="74aef-429">Error reading embedded resource 'file'—reason</span></span><br /><br /> <span data-ttu-id="74aef-430">*Al.exe* 에서 지정된 이유로 **/embedresource** 옵션에 전달된 파일을 읽을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-430">*Al.exe* cannot read the file passed to the **/embedresource** option for the specified reason.</span></span>|
|<span data-ttu-id="74aef-431">al1023</span><span class="sxs-lookup"><span data-stu-id="74aef-431">al1023</span></span>|<span data-ttu-id="74aef-432">리소스 'file'을 포함하는 동안 오류 발생 - reason</span><span class="sxs-lookup"><span data-stu-id="74aef-432">Error embedding resource 'file'—reason</span></span><br /><br /> <span data-ttu-id="74aef-433">운영 체제에서 지정된 이유로 어셈블리에 리소스 파일을 포함할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-433">The operating system cannot embed the resource file in the assembly for the specified reason.</span></span>|
|<span data-ttu-id="74aef-434">al1025</span><span class="sxs-lookup"><span data-stu-id="74aef-434">al1025</span></span>|<span data-ttu-id="74aef-435">ComType 레코드 'record'가 잘못 된 파일 레코드 'record'를 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-435">ComType record 'record' points to an invalid file record 'record'</span></span><br /><br /> <span data-ttu-id="74aef-436">입력 모듈의 메타데이터가 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-436">Metadata in the input module is invalid.</span></span> <span data-ttu-id="74aef-437">모듈을 생성한 도구를 수정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-437">The tool that produced the module must be fixed.</span></span>|
|<span data-ttu-id="74aef-438">al1026</span><span class="sxs-lookup"><span data-stu-id="74aef-438">al1026</span></span>|<span data-ttu-id="74aef-439">지정된 ‘version’ 버전이 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-439">The version specified 'version' is invalid</span></span><br /><br /> <span data-ttu-id="74aef-440">유효한 형식은 **/version** 옵션에 대한 정보를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="74aef-440">See information about the **/version** option for valid formats.</span></span>|
|<span data-ttu-id="74aef-441">al1028</span><span class="sxs-lookup"><span data-stu-id="74aef-441">al1028</span></span>|<span data-ttu-id="74aef-442">file' 키 파일에 서명에 필요한 프라이빗 키가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-442">Key file 'file' is missing the private key needed for signing</span></span><br /><br /> <span data-ttu-id="74aef-443">공개 키만 포함된 키 파일이 **/keyfile** 옵션에 전달되었습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-443">A key file that contains only the public key was passed to the **/keyfile** option.</span></span> <span data-ttu-id="74aef-444">다음 명령과 같이 [*Sn.exe*(강력한 이름 도구)](sn-exe-strong-name-tool.md)를 사용하여 퍼블릭 키와 프라이빗 키가 둘 다 포함된 파일을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-444">Use the [Strong Name Tool (*Sn.exe*)](sn-exe-strong-name-tool.md) to generate a file that has both a public and private key, as shown in the following command.</span></span><br /><br /> `sn -k keypair.snk.`|
|<span data-ttu-id="74aef-445">al1029</span><span class="sxs-lookup"><span data-stu-id="74aef-445">al1029</span></span>|<span data-ttu-id="74aef-446">키 컨테이너 이름 ‘container’가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-446">The key container name 'container' does not exist</span></span><br /><br /> <span data-ttu-id="74aef-447">**/keyname** 옵션에 전달된 값이 유효한 컨테이너가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-447">The value passed to the **/keyname** option is not a valid container.</span></span> <span data-ttu-id="74aef-448">[*Sn.exe*(강력한 이름 도구)](sn-exe-strong-name-tool.md)를 사용하여 컨테이너를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-448">Use the [Strong Name Tool (*Sn.exe*)](sn-exe-strong-name-tool.md) to create a container.</span></span>|
|<span data-ttu-id="74aef-449">al1030</span><span class="sxs-lookup"><span data-stu-id="74aef-449">al1030</span></span>|<span data-ttu-id="74aef-450">암호화 서비스가 제대로 설치되지 않았거나 적절한 키 공급자가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-450">The cryptographic service is not installed properly or does not have a suitable key provider</span></span><br /><br /> <span data-ttu-id="74aef-451">운영 체제를 다시 설치해야 하거나 키를 만드는 데 사용되는 일부 암호화 유틸리티를 설치해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-451">You might have to reinstall the operating system or install some cryptographic utility that was used to create the key.</span></span>|
|<span data-ttu-id="74aef-452">al1031</span><span class="sxs-lookup"><span data-stu-id="74aef-452">al1031</span></span>|<span data-ttu-id="74aef-453">'file' 아이콘을 읽는 동안 오류 발생 - reason</span><span class="sxs-lookup"><span data-stu-id="74aef-453">Error reading icon 'file'—reason</span></span><br /><br /> <span data-ttu-id="74aef-454">*Al.exe* 에서 지정된 이유로 **/win32icon** 옵션에 전달된 파일을 읽을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-454">*Al.exe* cannot read the file that was passed to the **/win32icon** option for the specified reason</span></span>|
|<span data-ttu-id="74aef-455">al1032</span><span class="sxs-lookup"><span data-stu-id="74aef-455">al1032</span></span>|<span data-ttu-id="74aef-456">'file'에 대한 리소스를 생성하는 동안 오류 발생 - reason</span><span class="sxs-lookup"><span data-stu-id="74aef-456">Error generating resources for 'file'—reason</span></span><br /><br /> <span data-ttu-id="74aef-457">디스크 공간 부족 또는 일부 다른 오류로 인해 *Al.exe* 에서 파일을 만들 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-457">*Al.exe* cannot create a file because of insufficient disk space or some other error.</span></span> <span data-ttu-id="74aef-458">**/win32icon** 옵션(.ico 파일 생성)을 지정하거나 **/win32res** 옵션(리소스 정보가 포함된 파일 생성)을 지정하지 않으면 이 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-458">This error occurs when you specify the **/win32icon** option (which generates an .ico file) or do not specify the **/win32res** option (which generates a file that has resource information).</span></span><br /><br /> <span data-ttu-id="74aef-459">파일 생성 문제를 해결할 수 없는 경우 버전 또는 비트맵(아이콘) 정보를 포함할 수 있는 파일을 지정하는 **/win32res** 를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-459">If you cannot resolve the file generation problem, use **/win32res**, which specifies a file that can contain version or bitmap (icon) information.</span></span>|
|<span data-ttu-id="74aef-460">al1033</span><span class="sxs-lookup"><span data-stu-id="74aef-460">al1033</span></span>|<span data-ttu-id="74aef-461">어셈블리 사용자 지정 특성 'attribute'가 서로 다른 값으로 여러 번 지정되었습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-461">Assembly custom attribute 'attribute' was specified multiple times with different values</span></span><br /><br /> <span data-ttu-id="74aef-462">*Al.exe* 에 대한 입력으로 지정된 소스 모듈의 동일한 사용자 지정 특성 발생 두 개에 서로 다른 값이 전달되었습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-462">Different values were passed to two occurrences of the same custom attribute in source modules that are specified as input to *Al.exe*.</span></span>|
|<span data-ttu-id="74aef-463">al1034</span><span class="sxs-lookup"><span data-stu-id="74aef-463">al1034</span></span>|<span data-ttu-id="74aef-464">'file' 어셈블리를 복사하거나 이름을 바꿀 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-464">Assembly 'file' cannot be copied or renamed</span></span><br /><br /> <span data-ttu-id="74aef-465">입력 파일을 지정하고 복사할 수 있게 해주는 *Al.exe* 구문을 사용하는 동안 이름 충돌이 발생하여 컴파일러가 중지되었습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-465">While using the *Al.exe* syntax that enables you to both specify an input file and copy it, a name conflict arose that stopped the compiler.</span></span> <span data-ttu-id="74aef-466">예를 들어 이 오류는 `input.dll,somename.dll /out:somename.dll`을 지정하는 경우 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-466">For example, this error occurs if you specify `input.dll,somename.dll /out:somename.dll`.</span></span>|
|<span data-ttu-id="74aef-467">al1035</span><span class="sxs-lookup"><span data-stu-id="74aef-467">al1035</span></span>|<span data-ttu-id="74aef-468">라이브러리는 진입점을 포함할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-468">Libraries cannot have an entry point</span></span><br /><br /> <span data-ttu-id="74aef-469">**/target:lib** 옵션(기본값) 및 **/main** 옵션을 모두 지정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-469">You cannot specify both the **/target:lib** option (the default) and the **/main** option.</span></span>|
|<span data-ttu-id="74aef-470">al1036</span><span class="sxs-lookup"><span data-stu-id="74aef-470">al1036</span></span>|<span data-ttu-id="74aef-471">실행 가능한 애플리케이션에는 진입점이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-471">Entry point required for executable applications</span></span><br /><br /> <span data-ttu-id="74aef-472">**/target:exe** 또는 **/target:win** 옵션을 사용할 때는 **/main** 옵션도 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-472">When using the **/target:exe** or **/target:win** option, you must also specify the **/main** option.</span></span>|
|<span data-ttu-id="74aef-473">al1037</span><span class="sxs-lookup"><span data-stu-id="74aef-473">al1037</span></span>|<span data-ttu-id="74aef-474">'main' 진입점 메서드를 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-474">Unable to find the entry point method 'main'</span></span><br /><br /> <span data-ttu-id="74aef-475">*Al.exe* 가 **/main** 옵션으로 지정된 위치에서 `Main` 메서드를 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-475">*Al.exe* cannot find a `Main` method at the location specified by the **/main** option.</span></span>|
|<span data-ttu-id="74aef-476">al1039</span><span class="sxs-lookup"><span data-stu-id="74aef-476">al1039</span></span>|<span data-ttu-id="74aef-477">전역 어셈블리 캐시 관리자 초기화 실패 - reason</span><span class="sxs-lookup"><span data-stu-id="74aef-477">Initialization of global assembly cache manager failed—reason</span></span><br /><br /> <span data-ttu-id="74aef-478">Visual Studio 또는 Windows SDK를 다시 설치합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-478">Reinstall Visual Studio or the Windows SDK.</span></span>|
|<span data-ttu-id="74aef-479">al1040</span><span class="sxs-lookup"><span data-stu-id="74aef-479">al1040</span></span>|<span data-ttu-id="74aef-480">캐시에 어셈블리를 설치하지 못함 - reason</span><span class="sxs-lookup"><span data-stu-id="74aef-480">Failed to install assembly into cache—reason</span></span><br /><br /> <span data-ttu-id="74aef-481">서명된 어셈블리만 캐시에 설치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-481">Only signed assemblies can be installed into the cache.</span></span> <span data-ttu-id="74aef-482">자세한 내용은 [전역 어셈블리 캐시](../app-domains/gac.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="74aef-482">For more information, see [Global Assembly Cache](../app-domains/gac.md).</span></span>|
|<span data-ttu-id="74aef-483">al1041</span><span class="sxs-lookup"><span data-stu-id="74aef-483">al1041</span></span>|<span data-ttu-id="74aef-484">'method': 서명 또는 표시 유형이 잘못되었거나 제네릭이기 때문에 진입점이 될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-484">'method': cannot be the entry point because the signature or visibility is incorrect, or it is generic</span></span><br /><br /> <span data-ttu-id="74aef-485">메서드가 **/main** 옵션으로 지정되었지만 해당 메서드가 정적이 아니거나, `int` 또는 `void`를 반환하지 않거나, 제네릭이거나, 잘못된 인수를 포함하고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-485">A method was specified with the **/main** option, but that method is not static, does not return `int` or `void`, was generic, or has invalid arguments.</span></span>|
|<span data-ttu-id="74aef-486">al1042</span><span class="sxs-lookup"><span data-stu-id="74aef-486">al1042</span></span>|<span data-ttu-id="74aef-487">'exe': EXE를 모듈로 추가할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-487">'exe': EXEs cannot be added modules</span></span><br /><br /> <span data-ttu-id="74aef-488">어셈블리가 없는 *.exe* 파일이 *Al.exe* 에 대한 입력 파일로 지정되었습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-488">An *.exe* file that does not have an assembly was specified as an input file to *Al.exe*.</span></span> <span data-ttu-id="74aef-489">*Al.exe* 는 어셈블리가 없는 *dll* 파일만 입력 파일로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-489">*Al.exe* can only take *dll* files without assemblies as input files.</span></span>|
|<span data-ttu-id="74aef-490">al1043</span><span class="sxs-lookup"><span data-stu-id="74aef-490">al1043</span></span>|<span data-ttu-id="74aef-491">'name' 매니페스트 파일 이름은 모듈과 같을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-491">Manifest file name 'name' cannot be the same as any modules</span></span><br /><br /> <span data-ttu-id="74aef-492">**/out** 옵션으로 지정된 이름은 *Al.exe* 에 대한 입력으로 지정된 파일 이름 중 하나와 같을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-492">The name specified with the **/out** option cannot be the same as any one of the file names that are specified as input to *Al.exe*.</span></span>|
|<span data-ttu-id="74aef-493">al1044</span><span class="sxs-lookup"><span data-stu-id="74aef-493">al1044</span></span>|<span data-ttu-id="74aef-494">'file' 키 파일을 읽는 동안 오류 발생 - reason</span><span class="sxs-lookup"><span data-stu-id="74aef-494">Error reading key file 'file'—reason</span></span><br /><br /> <span data-ttu-id="74aef-495">**/keyfile** 또는 <xref:System.Reflection.AssemblyKeyFileAttribute>에 지정된 파일을 열거나 읽는 동안 오류가 발생했습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-495">An error occurred while opening or reading from a file specified with **/keyfile** or the <xref:System.Reflection.AssemblyKeyFileAttribute>.</span></span>|
|<span data-ttu-id="74aef-496">al1045</span><span class="sxs-lookup"><span data-stu-id="74aef-496">al1045</span></span>|<span data-ttu-id="74aef-497">‘file’ 파일 이름이 너무 길거나 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-497">Filename 'file' is too long or invalid</span></span><br /><br /> <span data-ttu-id="74aef-498">260자보다 긴 파일 이름이 *Al.exe* 에 전달되었습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-498">A file name longer than 260 characters was passed to *Al.exe*.</span></span> <span data-ttu-id="74aef-499">더 적은 문자를 포함하거나 경로가 더 짧은 파일 이름을 선택하거나 파일 이름을 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-499">Choose a file name with fewer characters or a shorter path, or rename the file.</span></span>|
|<span data-ttu-id="74aef-500">al1046</span><span class="sxs-lookup"><span data-stu-id="74aef-500">al1046</span></span>|<span data-ttu-id="74aef-501">'ID' 리소스 식별자가 이 어셈블리에서 이미 사용되었습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-501">Resource identifier 'ID' has already been used in this assembly</span></span><br /><br /> <span data-ttu-id="74aef-502">포함 또는 연결된 두 리소스에 동일한 식별자 또는 이름(두 번째 인수)이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-502">Two resources, embedded or linked, have the same identifier or name (the second argument).</span></span> <span data-ttu-id="74aef-503">충돌하는 리소스 중 하나를 제거하거나 이름을 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-503">Remove or rename one of the conflicting resources.</span></span>|
|<span data-ttu-id="74aef-504">al1047</span><span class="sxs-lookup"><span data-stu-id="74aef-504">al1047</span></span>|<span data-ttu-id="74aef-505">'file' 파일을 가져오는 동안 오류 발생 - reason</span><span class="sxs-lookup"><span data-stu-id="74aef-505">Error importing file 'file'—reason</span></span><br /><br /> <span data-ttu-id="74aef-506">지정된 이유로 모듈 파일을 열 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-506">A module file cannot be opened for the specified reason.</span></span>|
|<span data-ttu-id="74aef-507">al1048</span><span class="sxs-lookup"><span data-stu-id="74aef-507">al1048</span></span>|<span data-ttu-id="74aef-508">'assembly' 어셈블리의 'module' 모듈을 가져오는 동안 오류 발생 - reason</span><span class="sxs-lookup"><span data-stu-id="74aef-508">Error importing module 'module' of assembly 'assembly'—reason</span></span><br /><br /> <span data-ttu-id="74aef-509">다중 파일 어셈블리의 비매니페스트 파일을 열 때 오류가 발생했습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-509">An error occurred when opening a nonmanifest file of a multifile assembly.</span></span> <span data-ttu-id="74aef-510">이 오류는 *Al.exe* 에서 직접 내보내지 않고 *Al.exe* 를 사용하는 프로세스에 프로그래밍 방식으로 전달될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-510">This error is not emitted directly by *Al.exe*, but can be passed programmatically to a process that uses *Al.exe*.</span></span>|
|<span data-ttu-id="74aef-511">al1049</span><span class="sxs-lookup"><span data-stu-id="74aef-511">al1049</span></span>|<span data-ttu-id="74aef-512">2000년 1월 1일 이전 날짜에 대한 빌드 및 수정 버전 번호를 자동으로 생성할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-512">Cannot auto-generate build and revision version numbers for dates before January 1, 2000</span></span><br /><br /> <span data-ttu-id="74aef-513">컴퓨터의 시스템 시계가 2000년 1월 1일 이전 날짜로 설정되었습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-513">The system clock on your computer is set to a date earlier than January 1, 2000.</span></span>|
|<span data-ttu-id="74aef-514">al1050</span><span class="sxs-lookup"><span data-stu-id="74aef-514">al1050</span></span>|<span data-ttu-id="74aef-515">'old feature'를 사용하는 기능은 더 이상 지원되지 않습니다. 'new feature'를 대신 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="74aef-515">The feature you are using 'old feature' is no longer supported; please use 'new feature' instead</span></span><br /><br /> <span data-ttu-id="74aef-516">이전에 *Al.exe* 에서 지원한 기능이 이제 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-516">A feature previously supported by *Al.exe* is now obsolete.</span></span> <span data-ttu-id="74aef-517">권장 기능을 대신 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-517">Use the recommended feature instead.</span></span>|
|<span data-ttu-id="74aef-518">al1051</span><span class="sxs-lookup"><span data-stu-id="74aef-518">al1051</span></span>|<span data-ttu-id="74aef-519">'attribute' 특성을 내보내는 동안 오류 발생 - reason</span><span class="sxs-lookup"><span data-stu-id="74aef-519">Error emitting 'attribute' attribute—reason</span></span><br /><br /> <span data-ttu-id="74aef-520">지정된 이유로 어셈블리 사용자 지정 특성이 *Al.exe* 에서 처리되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-520">An assembly custom attribute was not processed by *Al.exe* for the specified reason.</span></span>|
|<span data-ttu-id="74aef-521">al1052</span><span class="sxs-lookup"><span data-stu-id="74aef-521">al1052</span></span>|<span data-ttu-id="74aef-522">‘filename’ 파일은 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-522">File 'filename' is not an assembly</span></span><br /><br /> <span data-ttu-id="74aef-523">**/template** 으로 지정된 파일은 어셈블리 메타데이터를 포함해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-523">The file specified with **/template** must contain assembly metadata.</span></span> <span data-ttu-id="74aef-524">이 오류는 **/template** 으로 지정된 파일에 어셈블리가 포함되지 않았음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-524">This error indicates that the file specified by **/template** did not contain an assembly.</span></span>|
|<span data-ttu-id="74aef-525">al1053</span><span class="sxs-lookup"><span data-stu-id="74aef-525">al1053</span></span>|<span data-ttu-id="74aef-526">'옵션'에 대해 지정된 'version' 버전은 일반적인 'major.minor.build.revision' 형식이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-526">The version 'version' specified for the 'option' is not in the normal 'major.minor.build.revision' format</span></span><br /><br /> <span data-ttu-id="74aef-527">*Al.exe* 에서 **/fileversion** 또는 **/productversion** 옵션으로 지정된 형식이 아닌 버전 정보를 발견했습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-527">*Al.exe* detected ill-formed version information specified with the **/fileversion** or **/productversion** options.</span></span>|
|<span data-ttu-id="74aef-528">al1054</span><span class="sxs-lookup"><span data-stu-id="74aef-528">al1054</span></span>|<span data-ttu-id="74aef-529">'옵션'에 대해 지정된 'version' 버전은 일반적인 'major.minor.build.revision' 형식이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-529">The version 'version' specified for the 'option' is not in the normal 'major.minor.build.revision' format</span></span><br /><br /> <span data-ttu-id="74aef-530">*Al.exe* 에서 <xref:System.Resources.SatelliteContractVersionAttribute>에 잘못된 형식의 버전 정보가 지정된 것을 발견했습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-530">*Al.exe* detected ill-formed version information specified with the <xref:System.Resources.SatelliteContractVersionAttribute>.</span></span>|
|<span data-ttu-id="74aef-531">al1055</span><span class="sxs-lookup"><span data-stu-id="74aef-531">al1055</span></span>|<span data-ttu-id="74aef-532">참조된 ‘filename’ 어셈블리에 강력한 이름이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-532">Referenced assembly 'filename' does not have a strong name</span></span><br /><br /> <span data-ttu-id="74aef-533">이 오류는 강력한 이름의 어셈블리를 빌드하고 강력한 이름이 없는 어셈블리를 참조하는 경우에 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-533">This error is issued when you are building an assembly with a strong name and reference an assembly that does not have a strong name.</span></span> <span data-ttu-id="74aef-534">이 오류를 수정하려면 강력한 이름으로 어셈블리를 다시 생성하거나 *sn.exe* 를 사용하여 어셈블리에 강력한 이름을 연결해야 합니다([*sn.exe*](sn-exe-strong-name-tool.md)에 대한 설명서 참조).</span><span class="sxs-lookup"><span data-stu-id="74aef-534">To fix this, you must either regenerate your assembly with a strong name, or attach a strong name to the assembly by using *Sn.exe* (see the documentation for [*Sn.exe*](sn-exe-strong-name-tool.md)).</span></span><br /><br /> <span data-ttu-id="74aef-535">일반적으로 이 오류는 Visual Studio IDE를 통해 C# 프로젝트에 COM 모듈 참조를 추가하는 경우와 같이 래퍼 어셈블리를 통해 COM 개체를 사용하는 경우에 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-535">A common occurrence of this error is when you are using COM objects by way of wrapper assemblies, such as when you add a reference to a COM module to a C# project by way of the Visual Studio IDE.</span></span> <span data-ttu-id="74aef-536">오류를 방지하려면 "래퍼 어셈블리 키 파일/이름" 프로젝트 속성에서 COM 래퍼 어셈블리에 대한 강력한 이름 키 파일을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-536">To avoid the error, you can specify the strong name key file for COM wrapper assemblies in the Project Property "Wrapper Assembly Key File/Name"</span></span><br /><br /> <span data-ttu-id="74aef-537">tlbimp를 통해 래퍼 어셈블리를 만드는 경우 래퍼 어셈블리에 강력한 이름을 할당하는 방법에 대한 자세한 내용은 [tlbimp](tlbimp-exe-type-library-importer.md) 설명서를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="74aef-537">If you are creating the wrapper assembly through tlbimp, see the [tlbimp](tlbimp-exe-type-library-importer.md) documentation for information about how to assign a strong name to the wrapper assembly.</span></span><br /><br /> <span data-ttu-id="74aef-538">어셈블리에 강력한 이름이 있는 경우 전역 어셈블리 캐시에 설치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-538">If an assembly has a strong name, it can be installed in the global assembly cache.</span></span> <span data-ttu-id="74aef-539">결과적으로, 참조된 어셈블리도 전역 어셈블리 캐시로 이동됩니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-539">Consequently, referenced assemblies would also go into the global assembly cache.</span></span> <span data-ttu-id="74aef-540">강력한 이름을 가진 어셈블리만 전역 어셈블리 캐시로 이동될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-540">Only assemblies with strong names can go into the global assembly cache.</span></span>|
|<span data-ttu-id="74aef-541">al1056</span><span class="sxs-lookup"><span data-stu-id="74aef-541">al1056</span></span>|<span data-ttu-id="74aef-542">참조된 'filename' 어셈블리는 지역화된 위성 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-542">Referenced assembly 'filename' is a localized satellite assembly</span></span><br /><br /> <span data-ttu-id="74aef-543"><xref:System.Reflection.AssemblyCultureAttribute> 특성을 사용하여 만든 어셈블리가 현재 어셈블리를 만들 때 참조되었습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-543">An assembly created by using the <xref:System.Reflection.AssemblyCultureAttribute> attribute was referenced in creating the current assembly.</span></span> <span data-ttu-id="74aef-544"><xref:System.Reflection.AssemblyCultureAttribute> 특성은 파일이 지역화된 위성 어셈블리이며 위성 어셈블리를 참조하는 데 적합하지 않음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-544">The <xref:System.Reflection.AssemblyCultureAttribute> attribute indicates the file is a localized satellite assembly and it is not appropriate to reference a satellite assembly.</span></span> <span data-ttu-id="74aef-545">기본 부모 어셈블리를 대신 참조합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-545">Reference the main parent assembly instead.</span></span>|
|<span data-ttu-id="74aef-546">al1057</span><span class="sxs-lookup"><span data-stu-id="74aef-546">al1057</span></span>|<span data-ttu-id="74aef-547">실행 파일을 지역화할 수 없습니다. 문화권은 항상 비어 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-547">Executables cannot be localized, Culture should always be empty</span></span><br /><br /> <span data-ttu-id="74aef-548">**/target:exe** 를 사용하여 어셈블리를 만들고 있지만 **/culture** 를 지정했습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-548">An assembly is being created by using **/target:exe** but **/culture** was specified.</span></span> <span data-ttu-id="74aef-549">*.exe* 의 어셈블리는 Culture 필드에 정보를 포함할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-549">Assemblies in the *.exe* cannot have information in the Culture field.</span></span>|
|<span data-ttu-id="74aef-550">al1058</span><span class="sxs-lookup"><span data-stu-id="74aef-550">al1058</span></span>|<span data-ttu-id="74aef-551">'file'은 어셈블리이며 모듈로 추가할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-551">'file' is an assembly and cannot be added as a module</span></span><br /><br /> <span data-ttu-id="74aef-552">C++ 컴파일에서 **/assemblymodule**(링커 옵션)에 어셈블리가 포함된 파일이 전달되었습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-552">In a C++ compilation, **/assemblymodule** (linker option) was passed a file that contained an assembly.</span></span>|
|<span data-ttu-id="74aef-553">al1059</span><span class="sxs-lookup"><span data-stu-id="74aef-553">al1059</span></span>|<span data-ttu-id="74aef-554">알 수 없는 오류(code)</span><span class="sxs-lookup"><span data-stu-id="74aef-554">Unknown error (code)</span></span><br /><br /> <span data-ttu-id="74aef-555">*Al.exe* 가 알 수 없는 오류 코드(`code`)를 받았습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-555">*Al.exe* received an unknown error code (`code`).</span></span><br /><br /> <span data-ttu-id="74aef-556">가능한 해결 방법은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-556">Possible solutions include the following:</span></span><br /><br /> <span data-ttu-id="74aef-557">Visual Studio를 다시 설치합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-557">Reinstall Visual Studio.</span></span><br /><br /> <span data-ttu-id="74aef-558">Windows SDK를 다시 설치합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-558">Reinstall the Windows SDK.</span></span><br /><br /> <span data-ttu-id="74aef-559">누락된 파일이 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-559">Check for missing files.</span></span><br /><br /> <span data-ttu-id="74aef-560">디스크 공간이 충분한지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-560">Check for adequate disk space.</span></span><br /><br /> <span data-ttu-id="74aef-561">메모리가 충분한지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-561">Check for adequate memory.</span></span><br /><br /> <span data-ttu-id="74aef-562">파일에 액세스할 수 있는 다른 프로세스를 중지합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-562">Stop other processes that might be accessing the files.</span></span><br /><br /> <span data-ttu-id="74aef-563">컴퓨터를 다시 부팅합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-563">Reboot your computer.</span></span>|
|<span data-ttu-id="74aef-564">al1060</span><span class="sxs-lookup"><span data-stu-id="74aef-564">al1060</span></span>|<span data-ttu-id="74aef-565">해시를 만드는 동안 암호화 오류 발생 - reason</span><span class="sxs-lookup"><span data-stu-id="74aef-565">Cryptographic failure while creating hashes—reason</span></span><br /><br /> <span data-ttu-id="74aef-566">다중 파일 어셈블리에 대한 파일 해시를 만드는 동안 오류가 발생했습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-566">An error occurred while creating the file hashes for a multifile assembly.</span></span>|
|<span data-ttu-id="74aef-567">al1061</span><span class="sxs-lookup"><span data-stu-id="74aef-567">al1061</span></span>|<span data-ttu-id="74aef-568">'reason' 때문에 'option' 옵션을 설정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-568">Cannot set option 'option' because 'reason'</span></span><br /><br /> <span data-ttu-id="74aef-569">지정된 이유로 이 옵션에 대해 지정된 값이 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-569">The value specified for this option is invalid for the specified reason.</span></span>|
|<span data-ttu-id="74aef-570">al1062</span><span class="sxs-lookup"><span data-stu-id="74aef-570">al1062</span></span>|<span data-ttu-id="74aef-571">'module' 모듈이 여러 번 지정되었습니다. 한 번만 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-571">Module 'module' was specified multiple times; it will only be included once</span></span><br /><br /> <span data-ttu-id="74aef-572">이 경고는 동일한 소스, 입력 또는 모듈 파일이 명령줄에서 여러 번 지정될 때 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-572">This warning is generated when the same source, input, or module file is specified multiple times on the command line.</span></span> <span data-ttu-id="74aef-573">파일 이름을 한 번만 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-573">Make sure that you specify the file name only once.</span></span>|
|<span data-ttu-id="74aef-574">al1063</span><span class="sxs-lookup"><span data-stu-id="74aef-574">al1063</span></span>|<span data-ttu-id="74aef-575">이 어셈블리의 여러 위치에서 'type' 공용 형식이 정의되었습니다. 'file1' 및 'file2'</span><span class="sxs-lookup"><span data-stu-id="74aef-575">Public type 'type' is defined in multiple locations in this assembly: 'file1' and 'file2'</span></span><br /><br /> <span data-ttu-id="74aef-576">어셈블리의 둘 이상 모듈에서 동일한 형식이 발견되었습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-576">The same type was found in more than one module in the assembly.</span></span> <span data-ttu-id="74aef-577">각 형식의 버전이 어셈블리에 하나씩만 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-577">Only one version of each type may be present in an assembly.</span></span>|
|<span data-ttu-id="74aef-578">al1064</span><span class="sxs-lookup"><span data-stu-id="74aef-578">al1064</span></span>|<span data-ttu-id="74aef-579">/bugreport 옵션을 여러 개 지정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-579">Cannot specify multiple /bugreport options.</span></span><br /><br /> <span data-ttu-id="74aef-580">**/bugreport** 옵션은 하나만 허용됩니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-580">Only one **/bugreport** option is allowed.</span></span>|
|<span data-ttu-id="74aef-581">al1065</span><span class="sxs-lookup"><span data-stu-id="74aef-581">al1065</span></span>|<span data-ttu-id="74aef-582">‘File Name’ 파일 이름이 너무 길거나 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-582">File name 'File Name' is too long or invalid</span></span><br /><br /> <span data-ttu-id="74aef-583">지정된 파일 이름이 허용되는 최대값보다 깁니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-583">The specified file name is longer than the maximum allowed.</span></span>|
|<span data-ttu-id="74aef-584">al1066</span><span class="sxs-lookup"><span data-stu-id="74aef-584">al1066</span></span>|<span data-ttu-id="74aef-585">'character' 문자는 명령줄 또는 지시 파일에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-585">Character 'character' is not allowed on the command line or in response files</span></span><br /><br /> <span data-ttu-id="74aef-586">명령줄 또는 파일에서 잘못된 문자가 발견되었습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-586">An invalid character was found, either on the command line or in a file.</span></span>|
|<span data-ttu-id="74aef-587">al1067</span><span class="sxs-lookup"><span data-stu-id="74aef-587">al1067</span></span>|<span data-ttu-id="74aef-588">'filename'은 텍스트 파일이 아니라 이진 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-588">'filename' is a binary file instead of a text file</span></span><br /><br /> <span data-ttu-id="74aef-589">파일이 텍스트가 아니라 이진 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-589">The file is in binary format instead of text.</span></span>|
|<span data-ttu-id="74aef-590">al1068</span><span class="sxs-lookup"><span data-stu-id="74aef-590">al1068</span></span>|<span data-ttu-id="74aef-591">'ModuleName' 모듈은 이 어셈블리에서 이미 정의되었습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-591">Module 'ModuleName' is already defined in this assembly.</span></span> <span data-ttu-id="74aef-592">연결된 각 리소스 및 모듈에 고유한 파일 이름이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-592">Each linked resource and module must have a unique file name.</span></span><br /><br /> <span data-ttu-id="74aef-593">이 어셈블리에서 모듈이 두 번 이상 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-593">The module occurs more than once in this assembly.</span></span>|
|<span data-ttu-id="74aef-594">al1069</span><span class="sxs-lookup"><span data-stu-id="74aef-594">al1069</span></span>|<span data-ttu-id="74aef-595">동일한 약식 파일 이름을 가진 긴 파일 이름이 이미 있을 경우 'filename' 약식 파일 이름을 만들 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-595">Cannot create short file name 'filename' when a long file name with the same short file name already exists</span></span><br /><br /> <span data-ttu-id="74aef-596">현재 파일 이름의 약식 버전이 이미 존재합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-596">The current file has a name that is the short version of a file name that already exists.</span></span> <span data-ttu-id="74aef-597">예를 들어 LongFileName.cs를 컴파일한 다음 LongFi~1.cs 이름으로 다시 컴파일하면 다음과 비슷한 컴파일러 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-597">For example, compiling LongFileName.cs and then recompiling with the name LongFi~1.cs will cause a compiler error similar to this.</span></span> <span data-ttu-id="74aef-598">긴 이름을 가진 컴파일러 출력 파일이 삭제되었지만 유사한 링커 파일이 남아 있는 경우 이 오류가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-598">If the compiler output files that have long names were deleted, but the analogous linker files remained, this error might occur.</span></span>|
|<span data-ttu-id="74aef-599">al1070</span><span class="sxs-lookup"><span data-stu-id="74aef-599">al1070</span></span>|<span data-ttu-id="74aef-600">알 수 없는 어셈블리는 프로세서의 특정 모듈('Module Name')을 포함할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-600">Agnostic assembly cannot have a processor-specific module 'Module Name'</span></span><br /><br /> <span data-ttu-id="74aef-601">**/platform:agnostic** 을 사용하여 빌드하는 경우(또는 **/platform** 을 지정하지 않은 경우), **/addmodule** 을 사용하여 agnostic이 아닌 모듈을 추가하려고 하면 오류가 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-601">If you are building using **/platform:agnostic** (or you don't specify **/platform**), an error will be generated if you try to add a module (using **/addmodule**) that is not agnostic.</span></span> <span data-ttu-id="74aef-602">이는 ia64 obj에 i386 obj 파일을 연결하려는 것과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-602">This is like trying to link an i386 obj file to an ia64 obj.</span></span><br /><br /> <span data-ttu-id="74aef-603">특정 모듈의 기본 소스는 C++입니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-603">The main source of non-agnostic modules is C++.</span></span> <span data-ttu-id="74aef-604">**/addmodule** 을 C++ 모듈과 함께 사용하는 경우 빌드 스크립트를 수정하여 적절한 **/platform** 설정을 지정해야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-604">If you are using **/addmodule** with a C++ module, you may have to modify your build scripts to specify the appropriate **/platform** setting.</span></span>|
|<span data-ttu-id="74aef-605">al1072</span><span class="sxs-lookup"><span data-stu-id="74aef-605">al1072</span></span>|<span data-ttu-id="74aef-606">어셈블리 및 'Module Name' 모듈은 다른 프로세서를 대상으로 할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-606">Assembly and module 'Module Name' cannot target different processors</span></span><br /><br /> <span data-ttu-id="74aef-607">결과를 단일 프로세서에서 실행해야 하므로 서로 다른 프로세서를 대상으로 하는 어셈블리와 모듈을 연결할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-607">You cannot link an assembly and a module that are targeted for different processors, because the result has to run on a single processor.</span></span>|
|<span data-ttu-id="74aef-608">al1073</span><span class="sxs-lookup"><span data-stu-id="74aef-608">al1073</span></span>|<span data-ttu-id="74aef-609">참조된 ‘assembly’ 어셈블리가 다른 프로세서를 대상으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-609">Referenced assembly 'assembly' targets a different processor</span></span><br /><br /> <span data-ttu-id="74aef-610">결과를 단일 프로세서에서 실행해야 하므로 서로 다른 프로세서를 대상으로 하는 어셈블리를 연결할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-610">You cannot link assemblies that are targeted for different processors, because the result has to run on a single processor.</span></span>|
|<span data-ttu-id="74aef-611">al1074</span><span class="sxs-lookup"><span data-stu-id="74aef-611">al1074</span></span>|<span data-ttu-id="74aef-612">'File Name'에 저장된 'Module Name' 모듈 이름은 해당 파일 이름과 일치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-612">Module name 'Module Name' stored in 'File Name' must match its file name</span></span><br /><br /> <span data-ttu-id="74aef-613">이는 링커에 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-613">This is required of the linker.</span></span> <span data-ttu-id="74aef-614">이 문제를 해결하려면 두 이름이 일치하도록 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-614">To resolve this problem, make the two names match.</span></span>|
|<span data-ttu-id="74aef-615">al1075</span><span class="sxs-lookup"><span data-stu-id="74aef-615">al1075</span></span>|<span data-ttu-id="74aef-616">서명 연기가 요청되었지만 키가 지정되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-616">Delay signing was requested, but no key was given</span></span><br /><br /> <span data-ttu-id="74aef-617">어셈블리 서명이 연기된 경우 컴파일러는 서명을 컴퓨팅하거나 저장하지 않고 나중에 서명을 추가할 수 있도록 파일에 공간을 예약합니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-617">When an assembly is delay signed, the compiler does not compute and store the signature, but reserves space in the file so the signature can be added later.</span></span><br /><br /> <span data-ttu-id="74aef-618">예를 들어 **/delaysign+** 를 사용하면 테스터를 통해 전역 캐시에 어셈블리를 넣을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-618">For example, using **/delaysign+** enables a tester to put the assembly in the global cache.</span></span> <span data-ttu-id="74aef-619">테스트를 마친 후 어셈블리 링커 유틸리티를 통해 어셈블리에 프라이빗 키를 추가하여 어셈블리에 완전히 서명할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-619">After testing, you can fully sign the assembly by adding the private key to the assembly by using the Assembly Linker utility.</span></span>|
|<span data-ttu-id="74aef-620">al1076</span><span class="sxs-lookup"><span data-stu-id="74aef-620">al1076</span></span>|<span data-ttu-id="74aef-621">'type' 형식이 여러 어셈블리에 전달되었습니다. 'assembly' 및 'assembly'.</span><span class="sxs-lookup"><span data-stu-id="74aef-621">Type 'type' is forwarded to multiple assemblies: 'assembly' and 'assembly'.</span></span><br /><br /> <span data-ttu-id="74aef-622">각 형식을 하나의 어셈블리에만 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-622">A type can only be forwarded to one assembly.</span></span>|
|<span data-ttu-id="74aef-623">al1077</span><span class="sxs-lookup"><span data-stu-id="74aef-623">al1077</span></span>|<span data-ttu-id="74aef-624">'type' public 형식이 'assembly'에서 정의되고 'assembly'로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-624">Public type 'type' is defined in 'assembly' and forwarded to 'assembly'.</span></span><br /><br /> <span data-ttu-id="74aef-625">생성되는 어셈블리에 중복된 public 형식이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-625">There is a duplicate public type in the assembly being generated.</span></span> <span data-ttu-id="74aef-626">하나는 유효한 형식 정의이고 다른 하나는 형식 전달자입니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-626">One is a valid type definition and the other is a type forwarder.</span></span>|

## <a name="example"></a><span data-ttu-id="74aef-627">예제</span><span class="sxs-lookup"><span data-stu-id="74aef-627">Example</span></span>

<span data-ttu-id="74aef-628">다음 명령은 `t2.netmodule` 모듈의 어셈블리를 사용하여 실행 파일 *t2a.exe* 를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-628">The following command creates an executable file *t2a.exe* with an assembly from the `t2.netmodule` module.</span></span> <span data-ttu-id="74aef-629">진입점은 `Main`의 `MyClass` 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="74aef-629">The entry point is the `Main` method in `MyClass`.</span></span>

```console
al t2.netmodule /target:exe /out:t2a.exe /main:MyClass.Main
```

## <a name="see-also"></a><span data-ttu-id="74aef-630">참조</span><span class="sxs-lookup"><span data-stu-id="74aef-630">See also</span></span>

- [<span data-ttu-id="74aef-631">도구</span><span class="sxs-lookup"><span data-stu-id="74aef-631">Tools</span></span>](index.md)
- [<span data-ttu-id="74aef-632">*Sn.exe* (강력한 이름 도구)</span><span class="sxs-lookup"><span data-stu-id="74aef-632">*Sn.exe* (Strong Name Tool)</span></span>](sn-exe-strong-name-tool.md)
- [<span data-ttu-id="74aef-633">*Gacutil.exe*(전역 어셈블리 캐시 도구)</span><span class="sxs-lookup"><span data-stu-id="74aef-633">*Gacutil.exe* (Global Assembly Cache Tool)</span></span>](gacutil-exe-gac-tool.md)
- [<span data-ttu-id="74aef-634">어셈블리를 사용한 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="74aef-634">Programming with Assemblies</span></span>](../../standard/assembly/index.md)
- [<span data-ttu-id="74aef-635">개발자 명령줄 셸</span><span class="sxs-lookup"><span data-stu-id="74aef-635">Developer command-line shells</span></span>](/visualstudio/ide/reference/command-prompt-powershell)
