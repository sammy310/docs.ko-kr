---
title: 스타일 및 템플릿
description: .NET Core용 WPF(Windows Presentation Foundation)의 XAML 리소스에 대해 알아봅니다. 스타일 및 테마와 관련된 XAML 리소스의 형식을 이해합니다.
author: thraka
ms.author: adegeo
ms.date: 09/09/2019
dev_langs:
- csharp
- vb
ms.openlocfilehash: f845e739ec3cae502d1e4fd6631f987c5364a42e
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/12/2020
ms.locfileid: "81433099"
---
# <a name="styles-and-templates-in-wpf"></a><span data-ttu-id="ee4a9-104">WPF의 스타일 및 템플릿</span><span class="sxs-lookup"><span data-stu-id="ee4a9-104">Styles and templates in WPF</span></span>

<span data-ttu-id="ee4a9-105">WPF(Windows Presentation Foundation) 스타일 지정 및 템플릿은 개발자와 디자이너가 제품에 대해 시각적으로 매력적인 효과와 일관된 모양을 만들 수 있는 기능 집합을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-105">Windows Presentation Foundation (WPF) styling and templating refer to a suite of features that let developers and designers create visually compelling effects and a consistent appearance for their product.</span></span> <span data-ttu-id="ee4a9-106">앱의 모양을 사용자 지정할 때 앱 내에서 또는 앱 간에 모양을 유지 관리하고 공유할 수 있는 강력한 스타일 지정 및 템플릿 모델이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-106">When customizing the appearance of an app, you want a strong styling and templating model that enables maintenance and sharing of appearance within and among apps.</span></span> <span data-ttu-id="ee4a9-107">WPF에서 이 모델을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-107">WPF provides that model.</span></span>

<span data-ttu-id="ee4a9-108">WPF 스타일 지정 모델의 또 다른 기능은 프레젠테이션과 논리의 분리입니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-108">Another feature of the WPF styling model is the separation of presentation and logic.</span></span> <span data-ttu-id="ee4a9-109">개발자가 C# 또는 Visual Basic을 사용하여 프로그래밍 논리 작업을 수행할 때 동시에 디자이너가 XAML만 사용하여 앱 모양 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-109">Designers can work on the appearance of an app by using only XAML at the same time that developers work on the programming logic by using C# or Visual Basic.</span></span>

<span data-ttu-id="ee4a9-110">이 개요에서는 앱의 스타일 지정 및 템플릿 측면을 집중적으로 살펴보고 데이터 바인딩 개념은 설명하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-110">This overview focuses on the styling and templating aspects of the app and doesn't discuss any data-binding concepts.</span></span> <span data-ttu-id="ee4a9-111">데이터 바인딩에 대한 자세한 내용은 [데이터 바인딩 개요](../data/data-binding-overview.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-111">For information about data binding, see [Data Binding Overview](../data/data-binding-overview.md).</span></span>

<span data-ttu-id="ee4a9-112">스타일 및 템플릿을 재사용할 수 있게 해주는 리소스를 이해해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-112">It's important to understand resources, which are what enable styles and templates to be reused.</span></span> <span data-ttu-id="ee4a9-113">리소스에 대한 자세한 내용은 [XAML 리소스](xaml-resources-define.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-113">For more information about resources, see [XAML Resources](xaml-resources-define.md).</span></span>

[!INCLUDE [desktop guide under construction](../../../includes/desktop-guide-preview-note.md)]

## <a name="sample"></a><span data-ttu-id="ee4a9-114">예제</span><span class="sxs-lookup"><span data-stu-id="ee4a9-114">Sample</span></span>

<span data-ttu-id="ee4a9-115">이 개요에서 제공하는 샘플 코드는 다음 그림에 표시된 [간단한 사진 검색 애플리케이션](https://github.com/Microsoft/WPF-Samples/tree/master/Styles%20&%20Templates/IntroToStylingAndTemplating)을 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-115">The sample code provided in this overview is based on a [simple photo browsing application](https://github.com/Microsoft/WPF-Samples/tree/master/Styles%20&%20Templates/IntroToStylingAndTemplating) shown in the following illustration.</span></span>

<span data-ttu-id="ee4a9-116">![스타일 지정된 ListView](./media/styles-and-templates-overview/stylingintro-triggers.png "StylingIntro_triggers")</span><span class="sxs-lookup"><span data-stu-id="ee4a9-116">![Styled ListView](./media/styles-and-templates-overview/stylingintro-triggers.png "StylingIntro_triggers")</span></span>

<span data-ttu-id="ee4a9-117">이 간단한 사진 샘플에서는 스타일 지정 및 템플릿을 사용하여 시각적으로 눈에 띄는 사용자 환경을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-117">This simple photo sample uses styling and templating to create a visually compelling user experience.</span></span> <span data-ttu-id="ee4a9-118">이 샘플에는 두 개의 <xref:System.Windows.Controls.TextBlock> 요소와 이미지 목록에 바인딩된 <xref:System.Windows.Controls.ListBox> 컨트롤이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-118">The sample has two <xref:System.Windows.Controls.TextBlock> elements and a <xref:System.Windows.Controls.ListBox> control that is bound to a list of images.</span></span>

<span data-ttu-id="ee4a9-119">전체 샘플을 보려면 [Introduction to Styling and Templating Sample](https://github.com/Microsoft/WPF-Samples/tree/master/Styles%20&%20Templates/IntroToStylingAndTemplating)(스타일 지정 및 템플릿 샘플 소개)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-119">For the complete sample, see [Introduction to Styling and Templating Sample](https://github.com/Microsoft/WPF-Samples/tree/master/Styles%20&%20Templates/IntroToStylingAndTemplating).</span></span>

## <a name="styles"></a><span data-ttu-id="ee4a9-120">스타일</span><span class="sxs-lookup"><span data-stu-id="ee4a9-120">Styles</span></span>

<span data-ttu-id="ee4a9-121"><xref:System.Windows.Style>를 여러 요소에 속성 값 집합을 적용하는 편리한 방법으로 생각할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-121">You can think of a <xref:System.Windows.Style> as a convenient way to apply a set of property values to multiple elements.</span></span> <span data-ttu-id="ee4a9-122"><xref:System.Windows.FrameworkElement> 또는 <xref:System.Windows.FrameworkContentElement>에서 파생되는 모든 요소(예: <xref:System.Windows.Window> 또는 <xref:System.Windows.Controls.Button>)에 스타일을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-122">You can use a style on any element that derives from <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> such as a <xref:System.Windows.Window> or a <xref:System.Windows.Controls.Button>.</span></span>

<span data-ttu-id="ee4a9-123">스타일을 선언하는 가장 일반적인 방법은 XAML 파일의 `Resources` 섹션에 있는 리소스입니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-123">The most common way to declare a style is as a resource in the `Resources` section in a XAML file.</span></span> <span data-ttu-id="ee4a9-124">스타일은 리소스이므로 모든 리소스에 적용되는 동일한 범위 지정 규칙을 따릅니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-124">Because styles are resources, they obey the same scoping rules that apply to all resources.</span></span> <span data-ttu-id="ee4a9-125">간단히 말해서 스타일을 선언하는 경우 스타일을 적용할 수 있는 위치에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-125">Put simply, where you declare a style affects where the style can be applied.</span></span> <span data-ttu-id="ee4a9-126">예를 들어 스타일을 앱 정의 XAML 파일의 루트 요소에서 선언하면 앱의 모든 곳에서 스타일을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-126">For example, if you declare the style in the root element of your app definition XAML file, the style can be used anywhere in your app.</span></span>

<span data-ttu-id="ee4a9-127">예를 들어, 다음 XAML 코드는 `TextBlock`에 대해 두 개의 스타일을 선언합니다. 하나는 모든 `TextBlock` 요소에 자동으로 적용되고 다른 하나는 명시적으로 참조되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-127">For example, the following XAML code declares two styles for a `TextBlock`, one automatically applied to all `TextBlock` elements, and another that must be explicitly referenced.</span></span>

[!code-xaml[SnippetDefaultTextBlockStyleBasedOn](~/samples/snippets/desktop-guide/wpf/styles-and-templates-intro/csharp/Window2.xaml#SnippetDefaultTextBlockStyleBasedOn)]

<span data-ttu-id="ee4a9-128">위에 선언된 스타일이 사용되는 예는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-128">Here is an example of the styles declared above being used.</span></span>

[!code-xaml[SnippetTextBlocksExplicit](~/samples/snippets/desktop-guide/wpf/styles-and-templates-intro/csharp/Window2.xaml#SnippetTextBlocksExplicit)]

![스타일 적용된 TextBlock](./media/styles-and-templates-overview/stylingintro-textblocks.png)

<span data-ttu-id="ee4a9-130">자세한 내용은 [컨트롤의 스타일 만들기](styles-templates-create-apply-style.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-130">For more information, see [Create a style for a control](styles-templates-create-apply-style.md).</span></span>

## <a name="controltemplates"></a><span data-ttu-id="ee4a9-131">ControlTemplates</span><span class="sxs-lookup"><span data-stu-id="ee4a9-131">ControlTemplates</span></span>

<span data-ttu-id="ee4a9-132">WPF에서 컨트롤의 <xref:System.Windows.Controls.ControlTemplate>은 컨트롤의 모양을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-132">In WPF, the <xref:System.Windows.Controls.ControlTemplate> of a control defines the appearance of the control.</span></span> <span data-ttu-id="ee4a9-133">새 <xref:System.Windows.Controls.ControlTemplate>을 정의하고 컨트롤에 할당하여 컨트롤의 구조와 모양을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-133">You can change the structure and appearance of a control by defining a new <xref:System.Windows.Controls.ControlTemplate> and assigning it to a control.</span></span> <span data-ttu-id="ee4a9-134">대부분의 경우 템플릿을 사용하면 충분하므로 사용자 지정 컨트롤을 작성할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-134">In many cases, templates give you enough flexibility so that you do not have to write your own custom controls.</span></span>

<span data-ttu-id="ee4a9-135">각 컨트롤에는 [Control.Template](xref:System.Windows.Controls.Control.Template) 속성에 할당된 기본 템플릿이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-135">Each control has a default template assigned to the [Control.Template](xref:System.Windows.Controls.Control.Template) property.</span></span> <span data-ttu-id="ee4a9-136">템플릿은 컨트롤의 시각적 표시를 컨트롤의 기능과 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-136">The template connects the visual presentation of the control with the control's capabilities.</span></span> <span data-ttu-id="ee4a9-137">XAML에서 템플릿을 정의하므로 코드를 작성하지 않고도 컨트롤의 모양을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-137">Because you define a template in XAML, you can change the control's appearance without writing any code.</span></span> <span data-ttu-id="ee4a9-138">각 템플릿은 <xref:System.Windows.Controls.Button> 같은 특정 컨트롤을 위해 디자인되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-138">Each template is designed for a specific control, such as a <xref:System.Windows.Controls.Button>.</span></span>

<span data-ttu-id="ee4a9-139">일반적으로 XAML 파일의 `Resources` 섹션에서 템플릿을 리소스로 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-139">Commonly you declare a template as a resource on the `Resources` section of a XAML file.</span></span> <span data-ttu-id="ee4a9-140">모든 리소스와 마찬가지로 범위 지정 규칙이 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-140">As with all resources, scoping rules apply.</span></span>

<span data-ttu-id="ee4a9-141">컨트롤 템플릿에는 스타일보다 훨씬 더 많은 것이 관련됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-141">Control templates are a lot more involved than a style.</span></span> <span data-ttu-id="ee4a9-142">컨트롤 템플릿은 전체 컨트롤의 시각적 모양을 다시 작성하는 반면 스타일은 단순히 기존 컨트롤에 속성 변경 내용을 적용하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-142">This is because the control template rewrites the visual appearance of the entire control, while a style simply applies property changes to the existing control.</span></span> <span data-ttu-id="ee4a9-143">그러나 [Control.Template](xref:System.Windows.Controls.Control.Template) 속성을 설정하여 컨트롤 템플릿을 적용하므로 템플릿을 정의하거나 설정하는 데 스타일을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-143">However, since the template of a control is applied by setting the [Control.Template](xref:System.Windows.Controls.Control.Template) property, you can use a style to define or set a template.</span></span>

<span data-ttu-id="ee4a9-144">일반적으로 디자이너를 사용하면 기존 템플릿의 복사본을 만들고 수정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-144">Designers generally allow you to create a copy of an existing template and modify it.</span></span> <span data-ttu-id="ee4a9-145">예를 들어 Visual Studio WPF 디자이너에서 `CheckBox` 컨트롤을 선택하고 마우스 오른쪽 단추를 클릭한 다음 **템플릿 편집** > **복사본 만들기**를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-145">For example, in the Visual Studio WPF designer, select a `CheckBox` control, and then right-click and select **Edit template** > **Create a copy**.</span></span> <span data-ttu-id="ee4a9-146">이 명령은 *템플릿을 정의하는 스타일*을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-146">This command generates a *style that defines a template*.</span></span>

```xaml
<Style x:Key="CheckBoxStyle1" TargetType="{x:Type CheckBox}">
    <Setter Property="FocusVisualStyle" Value="{StaticResource FocusVisual1}"/>
    <Setter Property="Background" Value="{StaticResource OptionMark.Static.Background1}"/>
    <Setter Property="BorderBrush" Value="{StaticResource OptionMark.Static.Border1}"/>
    <Setter Property="Foreground" Value="{DynamicResource {x:Static SystemColors.ControlTextBrushKey}}"/>
    <Setter Property="BorderThickness" Value="1"/>
    <Setter Property="Template">
        <Setter.Value>
            <ControlTemplate TargetType="{x:Type CheckBox}">
                <Grid x:Name="templateRoot" Background="Transparent" SnapsToDevicePixels="True">
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="Auto"/>
                        <ColumnDefinition Width="*"/>
                    </Grid.ColumnDefinitions>
                    <Border x:Name="checkBoxBorder" Background="{TemplateBinding Background}" BorderThickness="{TemplateBinding BorderThickness}" BorderBrush="{TemplateBinding BorderBrush}" HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}" Margin="1" VerticalAlignment="{TemplateBinding VerticalContentAlignment}">
                        <Grid x:Name="markGrid">
                            <Path x:Name="optionMark" Data="F1 M 9.97498,1.22334L 4.6983,9.09834L 4.52164,9.09834L 0,5.19331L 1.27664,3.52165L 4.255,6.08833L 8.33331,1.52588e-005L 9.97498,1.22334 Z " Fill="{StaticResource OptionMark.Static.Glyph1}" Margin="1" Opacity="0" Stretch="None"/>
                            <Rectangle x:Name="indeterminateMark" Fill="{StaticResource OptionMark.Static.Glyph1}" Margin="2" Opacity="0"/>
                        </Grid>
                    </Border>
                    <ContentPresenter x:Name="contentPresenter" Grid.Column="1" Focusable="False" HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}" Margin="{TemplateBinding Padding}" RecognizesAccessKey="True" SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}" VerticalAlignment="{TemplateBinding VerticalContentAlignment}"/>
                </Grid>
                <ControlTemplate.Triggers>
                    <Trigger Property="HasContent" Value="true">
                        <Setter Property="FocusVisualStyle" Value="{StaticResource OptionMarkFocusVisual1}"/>
                        <Setter Property="Padding" Value="4,-1,0,0"/>

... content removed to save space ...
```

<span data-ttu-id="ee4a9-147">템플릿의 복사본을 편집하는 것은 템플릿이 작동하는 방식을 배우는 좋은 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-147">Editing a copy of a template is a great way to learn how templates work.</span></span> <span data-ttu-id="ee4a9-148">비어 있는 새 템플릿을 만드는 대신, 복사본을 편집하고 시각적 표현의 몇 가지 측면을 변경하는 것이 더 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-148">Instead of creating a new blank template, it's easier to edit a copy and change a few aspects of the visual presentation.</span></span>

<span data-ttu-id="ee4a9-149">예제는 [컨트롤의 템플릿 만들기](../themes/how-to-create-apply-template.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-149">For an example, see [Create a template for a control](../themes/how-to-create-apply-template.md).</span></span>

### <a name="templatebinding"></a><span data-ttu-id="ee4a9-150">TemplateBinding</span><span class="sxs-lookup"><span data-stu-id="ee4a9-150">TemplateBinding</span></span>

<span data-ttu-id="ee4a9-151">이전 섹션에서 정의된 템플릿 리소스가 [TemplateBinding 태그 확장](../../framework/wpf/advanced/templatebinding-markup-extension.md)을 사용한다는 것을 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-151">You may have noticed that the template resource defined in the previous section uses the [TemplateBinding Markup Extension](../../framework/wpf/advanced/templatebinding-markup-extension.md).</span></span> <span data-ttu-id="ee4a9-152">`TemplateBinding`은 템플릿 시나리오에 대한 바인딩의 최적화된 형태이며 `{Binding RelativeSource={RelativeSource TemplatedParent}}`를 사용하여 생성된 바인딩과 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-152">A `TemplateBinding` is an optimized form of a binding for template scenarios, analogous to a binding constructed with `{Binding RelativeSource={RelativeSource TemplatedParent}}`.</span></span> <span data-ttu-id="ee4a9-153">`TemplateBinding`은 템플릿의 일부를 컨트롤의 속성에 바인딩하는 데 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-153">`TemplateBinding` is useful for binding parts of the template to properties of the control.</span></span> <span data-ttu-id="ee4a9-154">예를 들어 각 컨트롤에는 <xref:System.Windows.Controls.Control.BorderThickness> 속성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-154">For example, each control has a <xref:System.Windows.Controls.Control.BorderThickness> property.</span></span> <span data-ttu-id="ee4a9-155">`TemplateBinding`을 사용하여 템플릿에서 이 컨트롤 설정의 영향을 받는 요소를 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-155">Use a `TemplateBinding` to manage which element in the template is affected by this control setting.</span></span>

### <a name="contentcontrol-and-itemscontrol"></a><span data-ttu-id="ee4a9-156">ContentControl 및 ItemsControl</span><span class="sxs-lookup"><span data-stu-id="ee4a9-156">ContentControl and ItemsControl</span></span>

<span data-ttu-id="ee4a9-157"><xref:System.Windows.Controls.ContentPresenter>가 <xref:System.Windows.Controls.ContentControl>의 <xref:System.Windows.Controls.ControlTemplate>에 선언된 경우 <xref:System.Windows.Controls.ContentPresenter>는 자동으로 <xref:System.Windows.Controls.ContentControl.ContentTemplate%2A> 및 <xref:System.Windows.Controls.ContentControl.Content%2A> 속성에 바인딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-157">If a <xref:System.Windows.Controls.ContentPresenter> is declared in the <xref:System.Windows.Controls.ControlTemplate> of a <xref:System.Windows.Controls.ContentControl>, the <xref:System.Windows.Controls.ContentPresenter> will automatically bind to the <xref:System.Windows.Controls.ContentControl.ContentTemplate%2A> and <xref:System.Windows.Controls.ContentControl.Content%2A> properties.</span></span> <span data-ttu-id="ee4a9-158">마찬가지로 <xref:System.Windows.Controls.ItemsControl>의 <xref:System.Windows.Controls.ControlTemplate>에 있는 <xref:System.Windows.Controls.ItemsPresenter>는 자동으로 <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A> 및 <xref:System.Windows.Controls.ItemsControl.Items%2A> 속성에 바인딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-158">Likewise, an <xref:System.Windows.Controls.ItemsPresenter> that is in the <xref:System.Windows.Controls.ControlTemplate> of an <xref:System.Windows.Controls.ItemsControl> will automatically bind to the <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A> and <xref:System.Windows.Controls.ItemsControl.Items%2A> properties.</span></span>

## <a name="datatemplates"></a><span data-ttu-id="ee4a9-159">DataTemplates</span><span class="sxs-lookup"><span data-stu-id="ee4a9-159">DataTemplates</span></span>

<span data-ttu-id="ee4a9-160">이 샘플 앱에는 사진 목록에 바인딩된 <xref:System.Windows.Controls.ListBox> 컨트롤이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-160">In this sample app, there is a <xref:System.Windows.Controls.ListBox> control that is bound to a list of photos.</span></span>

[!code-xaml[ListBox](~/samples/snippets/desktop-guide/wpf/styles-and-templates-intro/csharp/Window3.xaml#SnippetListBox)]

<span data-ttu-id="ee4a9-161">이 <xref:System.Windows.Controls.ListBox>는 현재 다음과 같이 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-161">This <xref:System.Windows.Controls.ListBox> currently looks like the following.</span></span>

<span data-ttu-id="ee4a9-162">![템플릿 적용 전의 ListBox](./media/styles-and-templates-overview/stylingintro-listboxbefore.png "StylingIntro_ListBoxBefore")</span><span class="sxs-lookup"><span data-stu-id="ee4a9-162">![ListBox before applying template](./media/styles-and-templates-overview/stylingintro-listboxbefore.png "StylingIntro_ListBoxBefore")</span></span>

<span data-ttu-id="ee4a9-163">대부분 컨트롤에는 몇 가지 콘텐츠 형식이 있고 해당 콘텐츠는 보통 바인딩할 데이터에서 나옵니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-163">Most controls have some type of content, and that content often comes from data that you are binding to.</span></span> <span data-ttu-id="ee4a9-164">이 샘플에서 데이터는 사진 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-164">In this sample, the data is the list of photos.</span></span> <span data-ttu-id="ee4a9-165">WPF에서는 <xref:System.Windows.DataTemplate>를 사용하여 데이터의 시각적 표시를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-165">In WPF, you use a <xref:System.Windows.DataTemplate> to define the visual representation of data.</span></span> <span data-ttu-id="ee4a9-166">기본적으로 <xref:System.Windows.DataTemplate>에 배치하면 렌더링된 앱에서 데이터가 표시되는 모양이 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-166">Basically, what you put into a <xref:System.Windows.DataTemplate> determines what the data looks like in the rendered app.</span></span>

<span data-ttu-id="ee4a9-167">샘플 앱에서 각 사용자 지정 `Photo` 개체에는 이미지의 파일 경로를 지정하는 string 형식의 `Source` 속성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-167">In our sample app, each custom `Photo` object has a `Source` property of type string that specifies the file path of the image.</span></span> <span data-ttu-id="ee4a9-168">현재 사진 개체는 파일 경로로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-168">Currently, the photo objects appear as file paths.</span></span>

[!code-csharp[PhotoClass](~/samples/snippets/desktop-guide/wpf/styles-and-templates-intro/csharp/Photo.cs#PhotoClass)]
[!code-vb[PhotoClass](~/samples/snippets/desktop-guide/wpf/styles-and-templates-intro/vb/Photo.vb#PhotoClass)]

<span data-ttu-id="ee4a9-169">사진이 이미지로 표시되도록 <xref:System.Windows.DataTemplate>을 리소스로 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-169">For the photos to appear as images, you create a <xref:System.Windows.DataTemplate> as a resource.</span></span>

[!code-xaml[DataTemplate](~/samples/snippets/desktop-guide/wpf/styles-and-templates-intro/csharp/Window4.xaml#SnippetDataTemplate)]

<span data-ttu-id="ee4a9-170"><xref:System.Windows.DataTemplate.DataType%2A> 속성은 <xref:System.Windows.Style>의 <xref:System.Windows.Style.TargetType%2A> 속성과 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-170">Notice that the <xref:System.Windows.DataTemplate.DataType%2A> property is similar to the <xref:System.Windows.Style.TargetType%2A> property of the <xref:System.Windows.Style>.</span></span> <span data-ttu-id="ee4a9-171"><xref:System.Windows.DataTemplate>이 리소스 섹션에 있는 경우 <xref:System.Windows.DataTemplate.DataType%2A> 속성을 형식으로 지정하고 `x:Key`를 생략하면 해당 형식이 나타날 때마다 <xref:System.Windows.DataTemplate>이 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-171">If your <xref:System.Windows.DataTemplate> is in the resources section, when you specify the <xref:System.Windows.DataTemplate.DataType%2A> property to a type and omit an `x:Key`, the <xref:System.Windows.DataTemplate> is applied whenever that type appears.</span></span> <span data-ttu-id="ee4a9-172">언제나 `x:Key`를 사용하여 <xref:System.Windows.DataTemplate>을 할당한 다음 <xref:System.Windows.DataTemplate> 형식을 사용하는 속성(예: <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A> 속성 또는 <xref:System.Windows.Controls.ContentControl.ContentTemplate%2A> 속성)에 대한 `StaticResource`로 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-172">You always have the option to assign the <xref:System.Windows.DataTemplate> with an `x:Key` and then set it as a `StaticResource` for properties that take <xref:System.Windows.DataTemplate> types, such as the <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A> property or the <xref:System.Windows.Controls.ContentControl.ContentTemplate%2A> property.</span></span>

<span data-ttu-id="ee4a9-173">기본적으로 위의 예제에서 <xref:System.Windows.DataTemplate>은 `Photo` 개체가 있을 때마다 <xref:System.Windows.Controls.Border> 내에 <xref:System.Windows.Controls.Image>로 표시되도록 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-173">Essentially, the <xref:System.Windows.DataTemplate> in the above example defines that whenever there is a `Photo` object, it should appear as an <xref:System.Windows.Controls.Image> within a <xref:System.Windows.Controls.Border>.</span></span> <span data-ttu-id="ee4a9-174">이 <xref:System.Windows.DataTemplate>으로 이제 앱이 다음과 같이 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-174">With this <xref:System.Windows.DataTemplate>, our app now looks like this.</span></span>

<span data-ttu-id="ee4a9-175">![사진 이미지](./media/styles-and-templates-overview/stylingintro-photosasimages.png "StylingIntro_PhotosAsImages")</span><span class="sxs-lookup"><span data-stu-id="ee4a9-175">![Photo image](./media/styles-and-templates-overview/stylingintro-photosasimages.png "StylingIntro_PhotosAsImages")</span></span>

<span data-ttu-id="ee4a9-176">데이터 템플릿 모델은 다른 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-176">The data templating model provides other features.</span></span> <span data-ttu-id="ee4a9-177">예를 들어 <xref:System.Windows.Controls.Menu> 또는 <xref:System.Windows.Controls.TreeView>와 같은 <xref:System.Windows.Controls.HeaderedItemsControl> 유형을 사용하여 다른 컬렉션을 포함하는 컬렉션 데이터를 표시하는 경우 <xref:System.Windows.HierarchicalDataTemplate>이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-177">For example, if you are displaying collection data that contains other collections using a <xref:System.Windows.Controls.HeaderedItemsControl> type such as a <xref:System.Windows.Controls.Menu> or a <xref:System.Windows.Controls.TreeView>, there is the <xref:System.Windows.HierarchicalDataTemplate>.</span></span> <span data-ttu-id="ee4a9-178">다른 데이터 템플릿 기능은 사용자 지정 논리에 따라 사용할 <xref:System.Windows.DataTemplate>을 선택할 수 있는 <xref:System.Windows.Controls.DataTemplateSelector>입니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-178">Another data templating feature is the <xref:System.Windows.Controls.DataTemplateSelector>, which allows you to choose a <xref:System.Windows.DataTemplate> to use based on custom logic.</span></span> <span data-ttu-id="ee4a9-179">자세한 내용은 다양한 데이터 템플릿 기능을 자세히 설명하는 [템플릿 개요](../../framework/wpf/data/data-templating-overview.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-179">For more information, see [Data Templating Overview](../../framework/wpf/data/data-templating-overview.md), which provides a more in-depth discussion of the different data templating features.</span></span>

## <a name="triggers"></a><span data-ttu-id="ee4a9-180">트리거</span><span class="sxs-lookup"><span data-stu-id="ee4a9-180">Triggers</span></span>

<span data-ttu-id="ee4a9-181">트리거는 속성 값이 변경되거나 이벤트가 발생할 때 속성을 설정하거나 애니메이션 등의 작업을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-181">A trigger sets properties or starts actions, such as an animation, when a property value changes or when an event is raised.</span></span> <span data-ttu-id="ee4a9-182"><xref:System.Windows.Style>, <xref:System.Windows.Controls.ControlTemplate> 및 <xref:System.Windows.DataTemplate>에는 모두 트리거 집합을 포함할 수 있는 `Triggers` 속성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-182"><xref:System.Windows.Style>, <xref:System.Windows.Controls.ControlTemplate>, and <xref:System.Windows.DataTemplate> all have a `Triggers` property that can contain a set of triggers.</span></span> <span data-ttu-id="ee4a9-183">다음과 같은 여러 가지 유형의 트리거가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-183">There are several types of triggers.</span></span>

### <a name="propertytriggers"></a><span data-ttu-id="ee4a9-184">PropertyTriggers</span><span class="sxs-lookup"><span data-stu-id="ee4a9-184">PropertyTriggers</span></span>

<span data-ttu-id="ee4a9-185">속성 값을 설정하거나 속성 값에 따라 작업을 시작하는 <xref:System.Windows.Trigger>를 속성 트리거라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-185">A <xref:System.Windows.Trigger> that sets property values or starts actions based on the value of a property is called a property trigger.</span></span>

<span data-ttu-id="ee4a9-186">속성 트리거를 사용하는 방법을 보여 주기 위해 선택하지 않는 한 각 <xref:System.Windows.Controls.ListBoxItem>을 부분적으로 투명하게 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-186">To demonstrate how to use property triggers, you can make each <xref:System.Windows.Controls.ListBoxItem> partially transparent unless it is selected.</span></span> <span data-ttu-id="ee4a9-187">다음 스타일은 <xref:System.Windows.Controls.ListBoxItem>의 <xref:System.Windows.UIElement.Opacity%2A> 값을 `0.5`로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-187">The following style sets the <xref:System.Windows.UIElement.Opacity%2A> value of a <xref:System.Windows.Controls.ListBoxItem> to `0.5`.</span></span> <span data-ttu-id="ee4a9-188">그러나 <xref:System.Windows.Controls.ListBoxItem.IsSelected%2A> 속성이 `true`인 경우 <xref:System.Windows.UIElement.Opacity%2A>가 `1.0`로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-188">When the <xref:System.Windows.Controls.ListBoxItem.IsSelected%2A> property is `true`, however, the <xref:System.Windows.UIElement.Opacity%2A> is set to `1.0`.</span></span>

[!code-xaml[PropertyTrigger](~/samples/snippets/desktop-guide/wpf/styles-and-templates-intro/csharp/Window5.xaml#SnippetPropertyTrigger)]

<span data-ttu-id="ee4a9-189">이 예제에서는 <xref:System.Windows.Trigger>를 사용하여 속성 값을 설정하지만 <xref:System.Windows.Trigger> 클래스에도 트리거를 사용하여 작업을 수행할 수 있는 <xref:System.Windows.TriggerBase.EnterActions%2A> 및 <xref:System.Windows.TriggerBase.ExitActions%2A> 속성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-189">This example uses a <xref:System.Windows.Trigger> to set a property value, but note that the <xref:System.Windows.Trigger> class also has the <xref:System.Windows.TriggerBase.EnterActions%2A> and <xref:System.Windows.TriggerBase.ExitActions%2A> properties that enable a trigger to perform actions.</span></span>

<span data-ttu-id="ee4a9-190"><xref:System.Windows.Controls.ListBoxItem>의 <xref:System.Windows.FrameworkElement.MaxHeight%2A> 속성이 `75`로 설정된 것에 유의합니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-190">Notice that the <xref:System.Windows.FrameworkElement.MaxHeight%2A> property of the <xref:System.Windows.Controls.ListBoxItem> is set to `75`.</span></span> <span data-ttu-id="ee4a9-191">다음 그림에서 세 번째 항목이 선택된 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-191">In the following illustration, the third item is the selected item.</span></span>

<span data-ttu-id="ee4a9-192">![스타일 지정된 ListView](./media/styles-and-templates-overview/stylingintro-triggers.png "StylingIntro_triggers")</span><span class="sxs-lookup"><span data-stu-id="ee4a9-192">![Styled ListView](./media/styles-and-templates-overview/stylingintro-triggers.png "StylingIntro_triggers")</span></span>

### <a name="eventtriggers-and-storyboards"></a><span data-ttu-id="ee4a9-193">EventTrigger 및 and Storyboard</span><span class="sxs-lookup"><span data-stu-id="ee4a9-193">EventTriggers and Storyboards</span></span>

<span data-ttu-id="ee4a9-194">또 다른 트리거 유형은 이벤트 발생에 따라 일련의 작업을 시작하는 <xref:System.Windows.EventTrigger>입니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-194">Another type of trigger is the <xref:System.Windows.EventTrigger>, which starts a set of actions based on the occurrence of an event.</span></span> <span data-ttu-id="ee4a9-195">예를 들어 다음 <xref:System.Windows.EventTrigger> 개체는 마우스 포인터가 <xref:System.Windows.Controls.ListBoxItem> 안으로 들어가면 <xref:System.Windows.FrameworkElement.MaxHeight%2A> 속성이 `0.2`초 동안 `90` 값으로 애니메이션 효과를 적용하도록 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-195">For example, the following <xref:System.Windows.EventTrigger> objects specify that when the mouse pointer enters the <xref:System.Windows.Controls.ListBoxItem>, the <xref:System.Windows.FrameworkElement.MaxHeight%2A> property animates to a value of `90` over a `0.2` second period.</span></span> <span data-ttu-id="ee4a9-196">마우스가 항목을 떠나면 속성은 `1`초 기간에 걸쳐 원래 값으로 돌아갑니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-196">When the mouse moves away from the item, the property returns to the original value over a period of `1` second.</span></span> <span data-ttu-id="ee4a9-197"><xref:System.Windows.ContentElement.MouseLeave> 애니메이션에 <xref:System.Windows.Media.Animation.DoubleAnimation.To%2A> 값을 지정할 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-197">Note how it is not necessary to specify a <xref:System.Windows.Media.Animation.DoubleAnimation.To%2A> value for the <xref:System.Windows.ContentElement.MouseLeave> animation.</span></span> <span data-ttu-id="ee4a9-198">이는 애니메이션은 원래 값을 추적할 수 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-198">This is because the animation is able to keep track of the original value.</span></span>

[!code-xaml[StyleEventTriggers](~/samples/snippets/desktop-guide/wpf/styles-and-templates-intro/csharp/Window6.xaml#SnippetStyleEventTriggers)]

<span data-ttu-id="ee4a9-199">자세한 내용은 [스토리보드 개요](../../framework/wpf/graphics-multimedia/storyboards-overview.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-199">For more information, see the [Storyboards overview](../../framework/wpf/graphics-multimedia/storyboards-overview.md).</span></span>

<span data-ttu-id="ee4a9-200">다음 그림에서 마우스가 세 번째 항목을 가리키고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-200">In the following illustration, the mouse is pointing to the third item.</span></span>

<span data-ttu-id="ee4a9-201">![스타일 지정 샘플 스크린샷](./media/styles-and-templates-overview/stylingintro-eventtriggers.png "StylingIntro_EventTriggers")</span><span class="sxs-lookup"><span data-stu-id="ee4a9-201">![Styling sample screenshot](./media/styles-and-templates-overview/stylingintro-eventtriggers.png "StylingIntro_EventTriggers")</span></span>

### <a name="multitriggers-datatriggers-and-multidatatriggers"></a><span data-ttu-id="ee4a9-202">MultiTrigger, DataTrigger 및 MultiDataTrigger</span><span class="sxs-lookup"><span data-stu-id="ee4a9-202">MultiTriggers, DataTriggers, and MultiDataTriggers</span></span>

<span data-ttu-id="ee4a9-203"><xref:System.Windows.Trigger> 및 <xref:System.Windows.EventTrigger> 외에 다른 유형의 트리거도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-203">In addition to <xref:System.Windows.Trigger> and <xref:System.Windows.EventTrigger>, there are other types of triggers.</span></span> <span data-ttu-id="ee4a9-204"><xref:System.Windows.MultiTrigger>를 사용하면 여러 조건에 따라 속성 값을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-204"><xref:System.Windows.MultiTrigger> allows you to set property values based on multiple conditions.</span></span> <span data-ttu-id="ee4a9-205">조건의 속성이 데이터 바인딩된 경우 <xref:System.Windows.DataTrigger> 및 <xref:System.Windows.MultiDataTrigger>를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-205">You use <xref:System.Windows.DataTrigger> and <xref:System.Windows.MultiDataTrigger> when the property of your condition is data-bound.</span></span>

## <a name="visual-states"></a><span data-ttu-id="ee4a9-206">시각적 상태</span><span class="sxs-lookup"><span data-stu-id="ee4a9-206">Visual States</span></span>

<span data-ttu-id="ee4a9-207">컨트롤은 항상 특정 **상태**에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-207">Controls are always in a specific **state**.</span></span> <span data-ttu-id="ee4a9-208">예를 들어 마우스를 컨트롤의 노출 영역 위로 움직이면 컨트롤이 일반 `MouseOver` 상태에 있는 것으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-208">For example, when the mouse moves over the surface of a control, the control is considered to be in a common state of `MouseOver`.</span></span> <span data-ttu-id="ee4a9-209">특정 상태가 없는 컨트롤은 일반 `Normal` 상태에 있는 것으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-209">A control without a specific state is considered to be in the common `Normal` state.</span></span> <span data-ttu-id="ee4a9-210">상태는 그룹으로 구분되며 앞서 언급한 상태는 `CommonStates` 상태 그룹의 일부입니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-210">States are broken into groups, and the previously mentioned states are part of the state group `CommonStates`.</span></span> <span data-ttu-id="ee4a9-211">대부분의 컨트롤에는 두 개의 상태 그룹 `CommonStates`와 `FocusStates`가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-211">Most controls have two state groups: `CommonStates` and `FocusStates`.</span></span> <span data-ttu-id="ee4a9-212">컨트롤에 적용되는 각 상태 그룹의 컨트롤은 항상 각 그룹의 한 상태(예: `CommonStates.MouseOver` 및 `FocusStates.Unfocused`)에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-212">Of each state group applied to a control, a control is always in one state of each group, such as `CommonStates.MouseOver` and `FocusStates.Unfocused`.</span></span> <span data-ttu-id="ee4a9-213">그러나 컨트롤은 동일한 그룹 내에서 서로 다른 두 가지 상태(예: `CommonStates.Normal` 및 `CommonStates.Disabled`)에 있을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-213">However, a control can't be in two different states within the same group, such as `CommonStates.Normal` and `CommonStates.Disabled`.</span></span> <span data-ttu-id="ee4a9-214">다음 표는 대부분의 컨트롤이 인식하고 사용하는 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-214">Here is a table of states most controls recognize and use.</span></span>

| <span data-ttu-id="ee4a9-215">VisualState 이름</span><span class="sxs-lookup"><span data-stu-id="ee4a9-215">VisualState Name</span></span> | <span data-ttu-id="ee4a9-216">VisualStateGroup 이름</span><span class="sxs-lookup"><span data-stu-id="ee4a9-216">VisualStateGroup Name</span></span> | <span data-ttu-id="ee4a9-217">설명</span><span class="sxs-lookup"><span data-stu-id="ee4a9-217">Description</span></span> |
| ---------------- | --------------------- | ----------- |
| <span data-ttu-id="ee4a9-218">보통</span><span class="sxs-lookup"><span data-stu-id="ee4a9-218">Normal</span></span>           | <span data-ttu-id="ee4a9-219">CommonStates</span><span class="sxs-lookup"><span data-stu-id="ee4a9-219">CommonStates</span></span>          | <span data-ttu-id="ee4a9-220">기본 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-220">The default state.</span></span> |
| <span data-ttu-id="ee4a9-221">MouseOver</span><span class="sxs-lookup"><span data-stu-id="ee4a9-221">MouseOver</span></span>        | <span data-ttu-id="ee4a9-222">CommonStates</span><span class="sxs-lookup"><span data-stu-id="ee4a9-222">CommonStates</span></span>          | <span data-ttu-id="ee4a9-223">마우스 포인터가 컨트롤 위에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-223">The mouse pointer is positioned over the control.</span></span> |
| <span data-ttu-id="ee4a9-224">누름</span><span class="sxs-lookup"><span data-stu-id="ee4a9-224">Pressed</span></span>          | <span data-ttu-id="ee4a9-225">CommonStates</span><span class="sxs-lookup"><span data-stu-id="ee4a9-225">CommonStates</span></span>          | <span data-ttu-id="ee4a9-226">컨트롤을 눌렀습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-226">The control is pressed.</span></span> |
| <span data-ttu-id="ee4a9-227">사용 안 함</span><span class="sxs-lookup"><span data-stu-id="ee4a9-227">Disabled</span></span>         | <span data-ttu-id="ee4a9-228">CommonStates</span><span class="sxs-lookup"><span data-stu-id="ee4a9-228">CommonStates</span></span>          | <span data-ttu-id="ee4a9-229">컨트롤이 비활성화되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-229">The control is disabled.</span></span> |
| <span data-ttu-id="ee4a9-230">포커스 있음</span><span class="sxs-lookup"><span data-stu-id="ee4a9-230">Focused</span></span>          | <span data-ttu-id="ee4a9-231">FocusStates</span><span class="sxs-lookup"><span data-stu-id="ee4a9-231">FocusStates</span></span>           | <span data-ttu-id="ee4a9-232">컨트롤에 포커스가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-232">The control has focus.</span></span> |
| <span data-ttu-id="ee4a9-233">포커스 없음</span><span class="sxs-lookup"><span data-stu-id="ee4a9-233">Unfocused</span></span>        | <span data-ttu-id="ee4a9-234">FocusStates</span><span class="sxs-lookup"><span data-stu-id="ee4a9-234">FocusStates</span></span>           | <span data-ttu-id="ee4a9-235">컨트롤에 포커스가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-235">The control does not have focus.</span></span> |

<span data-ttu-id="ee4a9-236">컨트롤 템플릿의 루트 요소에 <xref:System.Windows.VisualStateManager?displayProperty=fullName>을 정의하여 컨트롤이 특정 상태로 전환될 때 애니메이션을 트리거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-236">By defining a <xref:System.Windows.VisualStateManager?displayProperty=fullName> on the root element of a control template, you can trigger animations when a control enters a specific state.</span></span> <span data-ttu-id="ee4a9-237">`VisualStateManager`는 감시할 <xref:System.Windows.VisualStateGroup> 및 <xref:System.Windows.VisualState>의 조합을 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-237">The `VisualStateManager` declares which combinations of <xref:System.Windows.VisualStateGroup> and <xref:System.Windows.VisualState> to watch.</span></span> <span data-ttu-id="ee4a9-238">컨트롤이 감시되는 상태로 들어가면 `VisaulStateManager`에서 정의한 애니메이션이 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-238">When the control enters a watched state, the animation defined by the `VisaulStateManager` is started.</span></span>

<span data-ttu-id="ee4a9-239">예를 들어 다음 XAML 코드는 `CommonStates.MouseOver` 상태를 감시하여 `backgroundElement`라는 요소의 채우기 색에 애니메이션 효과를 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-239">For example, the following XAML code watches the `CommonStates.MouseOver` state to animate the fill color of the element named `backgroundElement`.</span></span> <span data-ttu-id="ee4a9-240">컨트롤이 `CommonStates.Normal` 상태로 돌아갈 때 `backgroundElement`라는 요소의 채우기 색이 복원됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-240">When the control returns to the `CommonStates.Normal` state, the fill color of the element named `backgroundElement` is restored.</span></span>

```xaml
<ControlTemplate x:Key="roundbutton" TargetType="Button">
    <Grid>
        <VisualStateManager.VisualStateGroups>
            <VisualStateGroup Name="CommonStates">
                <VisualState Name="Normal">
                    <ColorAnimation Storyboard.TargetName="backgroundElement"
                                    Storyboard.TargetProperty="(Shape.Fill).(SolidColorBrush.Color)"
                                    To="{TemplateBinding Background}"
                                    Duration="0:0:0.3"/>
                </VisualState>
                <VisualState Name="MouseOver">
                    <ColorAnimation Storyboard.TargetName="backgroundElement"
                                    Storyboard.TargetProperty="(Shape.Fill).(SolidColorBrush.Color)"
                                    To="Yellow"
                                    Duration="0:0:0.3"/>
                </VisualState>
            </VisualStateGroup>
        </VisualStateManager.VisualStateGroups>

        ...
```

<span data-ttu-id="ee4a9-241">스토리보드에 대한 자세한 내용은 [스토리보드 개요](../../framework/wpf/graphics-multimedia/storyboards-overview.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-241">For more information about storyboards, see [Storyboards Overview](../../framework/wpf/graphics-multimedia/storyboards-overview.md).</span></span>

## <a name="shared-resources-and-themes"></a><span data-ttu-id="ee4a9-242">공유 리소스 및 테마</span><span class="sxs-lookup"><span data-stu-id="ee4a9-242">Shared resources and themes</span></span>

<span data-ttu-id="ee4a9-243">일반적인 WPF 앱에는 앱 전체에 적용되는 여러 UI 리소스가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-243">A typical WPF app might have multiple UI resources that are applied throughout the app.</span></span> <span data-ttu-id="ee4a9-244">전체적으로 이 리소스 집합을 앱에 대한 테마로 간주할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-244">Collectively, this set of resources can be considered the theme for the app.</span></span> <span data-ttu-id="ee4a9-245">WPF는 <xref:System.Windows.ResourceDictionary> 클래스로 캡슐화된 리소스 사전을 사용하여 UI 리소스를 테마로 패키징할 수 있도록 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-245">WPF provides support for packaging UI resources as a theme by using a resource dictionary that is encapsulated as the <xref:System.Windows.ResourceDictionary> class.</span></span>

<span data-ttu-id="ee4a9-246">WPF 테마는 WPF가 요소의 시각 효과를 사용자 지정하기 위해 표시하는 스타일 지정 및 템플릿 메커니즘을 통해 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-246">WPF themes are defined by using the styling and templating mechanism that WPF exposes for customizing the visuals of any element.</span></span>

<span data-ttu-id="ee4a9-247">WPF 테마 리소스는 포함된 리소스 사전에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-247">WPF theme resources are stored in embedded resource dictionaries.</span></span> <span data-ttu-id="ee4a9-248">이러한 리소스 사전은 서명된 어셈블리에 포함되어야 하고 같은 어셈블리에 코드 자체로 포함되거나 side-by-side 어셈블리에 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-248">These resource dictionaries must be embedded within a signed assembly, and can either be embedded in the same assembly as the code itself or in a side-by-side assembly.</span></span> <span data-ttu-id="ee4a9-249">WPF 컨트롤이 포함된 어셈블리인 PresentationFramework.dll의 경우 테마 리소스는 일련의 side-by-side 어셈블리에 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-249">For PresentationFramework.dll, the assembly that contains WPF controls, theme resources are in a series of side-by-side assemblies.</span></span>

<span data-ttu-id="ee4a9-250">테마는 요소의 스타일을 검색할 때 보이는 마지막 위치가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-250">The theme becomes the last place to look when searching for the style of an element.</span></span> <span data-ttu-id="ee4a9-251">일반적으로 적절한 리소스를 검색할 때 요소 트리에서 위로 이동하면 검색이 시작되고 앱 리소스 컬렉션을 확인하고 마지막으로 시스템을 쿼리합니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-251">Typically, the search will begin by walking up the element tree searching for an appropriate resource, then look in the app resource collection and finally query the system.</span></span> <span data-ttu-id="ee4a9-252">이를 통해 앱 개발자는 테마에 도달하기 전에 트리 또는 앱 수준에서 개체에 대한 스타일을 다시 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-252">This gives app developers a chance to redefine the style for any object at the tree or app level before reaching the theme.</span></span>

<span data-ttu-id="ee4a9-253">리소스 사전을 여러 앱에 걸쳐 테마를 다시 사용할 수 있는 개별 파일로 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-253">You can define resource dictionaries as individual files that enable you to reuse a theme across multiple apps.</span></span> <span data-ttu-id="ee4a9-254">또한 같은 형식의 리소스를 제공하지만 값이 서로 다른 여러 리소스 사전을 정의하여 전환 가능한 테마를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-254">You can also create swappable themes by defining multiple resource dictionaries that provide the same types of resources but with different values.</span></span> <span data-ttu-id="ee4a9-255">앱에 스킨을 지정하려면 앱 수준에서 이러한 스타일이나 다른 리소스를 다시 정의하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-255">Redefining these styles or other resources at the app level is the recommended approach for skinning an app.</span></span>

<span data-ttu-id="ee4a9-256">앱 전체에서 스타일 및 템플릿을 비롯한 리소스 집합을 공유하려면 XAML 파일을 만들고 `shared.xaml` 파일에 대한 참조를 포함하는 <xref:System.Windows.ResourceDictionary>를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-256">To share a set of resources, including styles and templates, across apps, you can create a XAML file and define a <xref:System.Windows.ResourceDictionary> that includes reference to a `shared.xaml` file.</span></span>

```xaml
<ResourceDictionary.MergedDictionaries>
  <ResourceDictionary Source="Shared.xaml" />
</ResourceDictionary.MergedDictionaries>
```

<span data-ttu-id="ee4a9-257">`shared.xaml` 공유 자체가 앱의 컨트롤이 일관된 모양을 갖도록 하는 스타일 및 브러시 리소스 집합을 포함하는 <xref:System.Windows.ResourceDictionary>를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-257">It is the sharing of `shared.xaml`, which itself defines a <xref:System.Windows.ResourceDictionary> that contains a set of style and brush resources, that enables the controls in an app to have a consistent look.</span></span>

<span data-ttu-id="ee4a9-258">자세한 내용은 [병합된 리소스 사전](../../framework/wpf/advanced/merged-resource-dictionaries.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-258">For more information, see [Merged resource dictionaries](../../framework/wpf/advanced/merged-resource-dictionaries.md).</span></span>

<span data-ttu-id="ee4a9-259">사용자 지정 컨트롤에 대한 테마를 만드는 경우 [컨트롤 제작 개요](../../framework/wpf/controls/control-authoring-overview.md#defining-resources-at-the-theme-level)의 **테마 수준에서 리소스 정의** 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ee4a9-259">If you are creating a theme for your custom control, see the **Defining resources at the theme level** section of the [Control authoring overview](../../framework/wpf/controls/control-authoring-overview.md#defining-resources-at-the-theme-level).</span></span>

## <a name="see-also"></a><span data-ttu-id="ee4a9-260">참조</span><span class="sxs-lookup"><span data-stu-id="ee4a9-260">See also</span></span>

- [<span data-ttu-id="ee4a9-261">WPF의 Pack URI</span><span class="sxs-lookup"><span data-stu-id="ee4a9-261">Pack URIs in WPF</span></span>](../../framework/wpf/app-development/pack-uris-in-wpf.md)
- [<span data-ttu-id="ee4a9-262">방법: ControlTemplate에서 생성된 요소 찾기</span><span class="sxs-lookup"><span data-stu-id="ee4a9-262">How to: Find ControlTemplate-Generated Elements</span></span>](../../framework/wpf/controls/how-to-find-controltemplate-generated-elements.md)
- [<span data-ttu-id="ee4a9-263">DataTemplate에서 생성된 요소 찾기</span><span class="sxs-lookup"><span data-stu-id="ee4a9-263">Find DataTemplate-Generated Elements</span></span>](../../framework/wpf/data/how-to-find-datatemplate-generated-elements.md)
