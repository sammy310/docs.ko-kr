---
title: 디자인 규칙 (코드 분석)
description: 코드 분석 디자인 규칙에 대해 알아봅니다.
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.designrules
helpviewer_keywords:
- design rules
- managed code analysis rules, design rules
- rules, design
author: gewarren
ms.author: gewarren
ms.openlocfilehash: 7b49403b1aa3d48008e6f7448ab0ed5a84468373
ms.sourcegitcommit: 45c7148f2483db2501c1aa696ab6ed2ed8cb71b2
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 12/08/2020
ms.locfileid: "96851531"
---
# <a name="design-rules"></a><span data-ttu-id="af918-103">디자인 규칙</span><span class="sxs-lookup"><span data-stu-id="af918-103">Design rules</span></span>

<span data-ttu-id="af918-104">디자인 규칙은 [.NET Framework 디자인 지침](../../../standard/design-guidelines/index.md)을 준수 하도록 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-104">Design rules support adherence to the [.NET Framework Design Guidelines](../../../standard/design-guidelines/index.md).</span></span>

## <a name="in-this-section"></a><span data-ttu-id="af918-105">섹션 내용</span><span class="sxs-lookup"><span data-stu-id="af918-105">In this section</span></span>

| <span data-ttu-id="af918-106">규칙</span><span class="sxs-lookup"><span data-stu-id="af918-106">Rule</span></span> | <span data-ttu-id="af918-107">설명</span><span class="sxs-lookup"><span data-stu-id="af918-107">Description</span></span> |
| - | - |
| [<span data-ttu-id="af918-108">CA1000: 정적 멤버를 제네릭 형식으로 선언하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="af918-108">CA1000: Do not declare static members on generic types</span></span>](ca1000.md) | <span data-ttu-id="af918-109">제네릭 형식의 정적 멤버를 호출할 때는 형식에 형식 인수를 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-109">When a static member of a generic type is called, the type argument must be specified for the type.</span></span> <span data-ttu-id="af918-110">유추를 지원하지 않는 제네릭 인스턴스 멤버를 호출할 때는 멤버에 형식 인수를 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-110">When a generic instance member that does not support inference is called, the type argument must be specified for the member.</span></span> <span data-ttu-id="af918-111">이 두 가지 경우에 형식 인수를 지정하기 위한 구문은 서로 다르며 혼동되기 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="af918-111">In these two cases, the syntax for specifying the type argument is different and easily confused.</span></span> |
| [<span data-ttu-id="af918-112">CA1001: 삭제 가능한 필드가 있는 형식은 삭제 가능해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-112">CA1001: Types that own disposable fields should be disposable</span></span>](ca1001.md) | <span data-ttu-id="af918-113">클래스는 system.string 형식이 고 클래스에서 IDisposable을 구현 하지 않는 인스턴스 필드를 선언 하 고 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-113">A class declares and implements an instance field that is a System.IDisposable type and the class does not implement IDisposable.</span></span> <span data-ttu-id="af918-114">IDisposable 필드를 선언하는 클래스는 관리되지 않는 리소스를 간접적으로 소유하며 IDisposable 인터페이스를 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-114">A class that declares an IDisposable field indirectly owns an unmanaged resource and should implement the IDisposable interface.</span></span> |
| [<span data-ttu-id="af918-115">CA1002: 제네릭 목록을 노출하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="af918-115">CA1002: Do not expose generic lists</span></span>](ca1002.md) | <span data-ttu-id="af918-116">< (Of \<(T> ) >)는 상속이 아닌 성능을 위해 디자인 된 제네릭 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="af918-116">System.Collections.Generic.List<(Of \<(T>)>) is a generic collection that is designed for performance, not inheritance.</span></span> <span data-ttu-id="af918-117">따라서 List에는 가상 멤버가 포함되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="af918-117">Therefore, List does not contain any virtual members.</span></span> <span data-ttu-id="af918-118">상속을 위해 디자인된 제네릭 컬렉션이 대신 노출되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-118">The generic collections that are designed for inheritance should be exposed instead.</span></span> |
| [<span data-ttu-id="af918-119">CA1003: 제네릭 이벤트 처리기 인스턴스를 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="af918-119">CA1003: Use generic event handler instances</span></span>](ca1003.md) | <span data-ttu-id="af918-120">형식에 void를 반환 하는 대리자가 포함 되어 있습니다. 해당 시그니처에는 두 개의 매개 변수 (첫 번째 개체와 EventArgs에 할당할 수 있는 두 번째 형식)가 포함 되 고, 포함 하는 어셈블리 대상은 2.0 .NET Framework 합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-120">A type contains a delegate that returns void, whose signature contains two parameters (the first an object and the second a type that is assignable to EventArgs), and the containing assembly targets .NET Framework 2.0.</span></span> |
| [<span data-ttu-id="af918-121">CA1005: 제네릭 형식에 매개 변수를 너무 많이 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="af918-121">CA1005: Avoid excessive parameters on generic types</span></span>](ca1005.md) | <span data-ttu-id="af918-122">제네릭 형식에 포함된 형식 매개 변수가 많을수록 각 형식 매개 변수가 무엇을 나타내는지를 파악하거나 기억하기가 더 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="af918-122">The more type parameters a generic type contains, the more difficult it is to know and remember what each type parameter represents.</span></span> <span data-ttu-id="af918-123">일반적으로 목록에서와 같이 하나의 형식 매개 변수를 사용 하 \<T> 고 사전에서와 같이 두 개의 형식 매개 변수를 사용 하는 것이 명확 \<TKey, TValue> 합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-123">It is usually obvious with one type parameter, as in List\<T>, and in certain cases with two type parameters, as in Dictionary\<TKey, TValue>.</span></span> <span data-ttu-id="af918-124">그러나 형식 매개 변수가 세 개 이상이면 대부분의 사용자가 사용하기에 너무 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="af918-124">However, if more than two type parameters exist, the difficulty becomes too great for most users.</span></span> |
| [<span data-ttu-id="af918-125">CA1008: 열거형에는 0 값이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-125">CA1008: Enums should have zero value</span></span>](ca1008.md) | <span data-ttu-id="af918-126">초기화되지 않은 열거형의 기본값은 다른 값 형식과 마찬가지로 0입니다.</span><span class="sxs-lookup"><span data-stu-id="af918-126">The default value of an uninitialized enumeration, just as other value types, is zero.</span></span> <span data-ttu-id="af918-127">플래그가 지정 되지 않은 특성 사용 열거형은 기본값이 열거형의 유효한 값이 되도록 0 값을 사용 하 여 멤버를 정의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-127">A nonflags attributed enumeration should define a member by using the value of zero so that the default value is a valid value of the enumeration.</span></span> <span data-ttu-id="af918-128">FlagsAttribute 특성이 적용된 열거형에서 0 값을 가진 멤버를 정의하는 경우에는 열거형에 값이 설정되지 않았음을 나타낼 수 있도록 해당 멤버 이름이 "None"이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-128">If an enumeration that has the FlagsAttribute attribute applied defines a zero-valued member, its name should be "None" to indicate that no values have been set in the enumeration.</span></span> |
| [<span data-ttu-id="af918-129">CA1010: 컬렉션은 제네릭 인터페이스를 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-129">CA1010: Collections should implement generic interface</span></span>](ca1010.md) | <span data-ttu-id="af918-130">컬렉션의 유용성을 높이려면 제네릭 컬렉션 인터페이스 중 하나를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-130">To broaden the usability of a collection, implement one of the generic collection interfaces.</span></span> <span data-ttu-id="af918-131">그러면 컬렉션을 사용하여 제네릭 컬렉션 형식을 채울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="af918-131">Then the collection can be used to populate generic collection types.</span></span> |
| [<span data-ttu-id="af918-132">CA1012: 추상 형식에는 생성자를 사용하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="af918-132">CA1012: Abstract types should not have constructors</span></span>](ca1012.md) | <span data-ttu-id="af918-133">추상 형식에 대한 생성자는 파생된 형식에서만 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="af918-133">Constructors on abstract types can be called only by derived types.</span></span> <span data-ttu-id="af918-134">public 생성자에서 형식의 인스턴스를 만들고 사용자는 추상 형식의 인스턴스를 만들 수 없기 때문에 public 생성자가 있는 추상 형식은 잘못 디자인된 것입니다.</span><span class="sxs-lookup"><span data-stu-id="af918-134">Because public constructors create instances of a type, and you cannot create instances of an abstract type, an abstract type that has a public constructor is incorrectly designed.</span></span> |
| [<span data-ttu-id="af918-135">CA1014: CLSCompliantAttribute로 어셈블리를 표시하세요.</span><span class="sxs-lookup"><span data-stu-id="af918-135">CA1014: Mark assemblies with CLSCompliantAttribute</span></span>](ca1014.md) | <span data-ttu-id="af918-136">CLS(공용 언어 사양)는 어셈블리가 여러 프로그래밍 언어에 사용될 경우 준수해야 하는 명명 제한, 데이터 형식 및 규칙을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-136">The Common Language Specification (CLS) defines naming restrictions, data types, and rules to which assemblies must conform if they will be used across programming languages.</span></span> <span data-ttu-id="af918-137">바람직한 디자인은 모든 어셈블리가 CLSCompliantAttribute를 사용 하 여 CLS 규격을 명시적으로 표시 하도록 지시 합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-137">Good design dictates that all assemblies explicitly indicate CLS compliance by using CLSCompliantAttribute.</span></span> <span data-ttu-id="af918-138">어셈블리에 이 특성이 없으면 해당 어셈블리는 규격을 따르지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="af918-138">If this attribute is not present on an assembly, the assembly is not compliant.</span></span> |
| [<span data-ttu-id="af918-139">CA1016: AssemblyVersionAttribute로 어셈블리 표시</span><span class="sxs-lookup"><span data-stu-id="af918-139">CA1016: Mark assemblies with AssemblyVersionAttribute</span></span>](ca1016.md) | <span data-ttu-id="af918-140">.NET에서는 버전 번호를 사용 하 여 어셈블리를 고유 하 게 식별 하 고 강력한 이름의 어셈블리에 있는 형식에 바인딩합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-140">.NET uses the version number to uniquely identify an assembly, and to bind to types in strongly named assemblies.</span></span> <span data-ttu-id="af918-141">버전 번호는 버전 및 게시자 정책과 함께 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="af918-141">The version number is used together with version and publisher policy.</span></span> <span data-ttu-id="af918-142">기본적으로 애플리케이션은 해당 애플리케이션이 빌드될 때 사용된 어셈블리 버전으로만 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="af918-142">By default, applications run only with the assembly version with which they were built.</span></span> |
| [<span data-ttu-id="af918-143">CA1017: ComVisibleAttribute로 어셈블리를 표시하세요.</span><span class="sxs-lookup"><span data-stu-id="af918-143">CA1017: Mark assemblies with ComVisibleAttribute</span></span>](ca1017.md) | <span data-ttu-id="af918-144">ComVisibleAttribute는 COM 클라이언트에서 관리 코드에 액세스하는 방식을 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-144">ComVisibleAttribute determines how COM clients access managed code.</span></span> <span data-ttu-id="af918-145">어셈블리에서 COM에 노출할지 여부를 명시적으로 나타내는 것이 좋은 디자인입니다.</span><span class="sxs-lookup"><span data-stu-id="af918-145">Good design dictates that assemblies explicitly indicate COM visibility.</span></span> <span data-ttu-id="af918-146">전체 어셈블리에 대해 COM 노출 여부를 설정한 다음 개별 형식 및 형식 멤버에 대해 이를 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="af918-146">COM visibility can be set for the whole assembly and then overridden for individual types and type members.</span></span> <span data-ttu-id="af918-147">이 특성이 없으면 COM 클라이언트에서 어셈블리의 내용을 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="af918-147">If this attribute is not present, the contents of the assembly are visible to COM clients.</span></span> |
| [<span data-ttu-id="af918-148">CA1018: AttributeUsageAttribute로 특성을 표시하세요.</span><span class="sxs-lookup"><span data-stu-id="af918-148">CA1018: Mark attributes with AttributeUsageAttribute</span></span>](ca1018.md) | <span data-ttu-id="af918-149">사용자 지정 특성을 정의할 때는 해당 특성을 AttributeUsageAttribute로 표시하여 사용자 지정 특성을 적용할 수 있는 소스 코드의 위치를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="af918-149">When you define a custom attribute, mark it by using AttributeUsageAttribute to indicate where in the source code the custom attribute can be applied.</span></span> <span data-ttu-id="af918-150">특성의 의미 및 용도에 따라 코드에서의 유효한 위치가 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="af918-150">The meaning and intended usage of an attribute will determine its valid locations in code.</span></span> |
| [<span data-ttu-id="af918-151">CA1019: 특성 인수의 접근자를 정의하세요.</span><span class="sxs-lookup"><span data-stu-id="af918-151">CA1019: Define accessors for attribute arguments</span></span>](ca1019.md) | <span data-ttu-id="af918-152">특성에서는 대상에 특성을 적용할 때 지정해야 하는 필수 인수를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="af918-152">Attributes can define mandatory arguments that must be specified when you apply the attribute to a target.</span></span> <span data-ttu-id="af918-153">이러한 인수는 특성 생성자에 위치 매개 변수로 제공되기 때문에 이러한 인수를 위치 인수라고도 합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-153">These are also known as positional arguments because they are supplied to attribute constructors as positional parameters.</span></span> <span data-ttu-id="af918-154">모든 필수 인수에 대해 특성은 실행 시간에 인수의 값을 검색할 수 있도록 해당하는 읽기 전용 속성도 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-154">For every mandatory argument, the attribute should also provide a corresponding read-only property so that the value of the argument can be retrieved at execution time.</span></span> <span data-ttu-id="af918-155">특성에서는 명명된 인수라고 하는 선택적 인수도 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="af918-155">Attributes can also define optional arguments, which are also known as named arguments.</span></span> <span data-ttu-id="af918-156">이들 인수는 이름으로 특성 생성자에 제공되며 해당하는 읽기/쓰기 특성이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-156">These arguments are supplied to attribute constructors by name and should have a corresponding read/write property.</span></span> |
| [<span data-ttu-id="af918-157">CA1021: out 매개 변수를 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="af918-157">CA1021: Avoid out parameters</span></span>](ca1021.md) | <span data-ttu-id="af918-158">out 또는 ref를 사용하여 참조로 형식을 전달하려면 포인터 사용 방법을 알고 있어야 하고, 값 형식과 참조 형식이 어떻게 다른지 알고 있어야 하며, 반환 값이 여러 개인 메서드를 처리할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-158">Passing types by reference (using out or ref) requires experience with pointers, understanding how value types and reference types differ, and handling methods with multiple return values.</span></span> <span data-ttu-id="af918-159">또한 out 매개 변수와 ref 매개 변수의 차이점은 잘 알려져 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="af918-159">Also, the difference between out and ref parameters is not widely understood.</span></span> |
| [<span data-ttu-id="af918-160">CA1024: 적합한 속성을 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="af918-160">CA1024: Use properties where appropriate</span></span>](ca1024.md) | <span data-ttu-id="af918-161">public 또는 protected 메서드가 "Get"으로 시작하는 이름을 사용하고, 매개 변수를 사용하지 않으며, 배열이 아닌 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-161">A public or protected method has a name that starts with "Get", takes no parameters, and returns a value that is not an array.</span></span> <span data-ttu-id="af918-162">이 메서드는 속성이 될 수 있는 좋은 예일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="af918-162">The method might be a good candidate to become a property.</span></span> |
| [<span data-ttu-id="af918-163">CA1027: 열거형을 FlagsAttribute로 표시하세요.</span><span class="sxs-lookup"><span data-stu-id="af918-163">CA1027: Mark enums with FlagsAttribute</span></span>](ca1027.md) | <span data-ttu-id="af918-164">열거형은 서로 관련 있는 명명된 상수 집합을 정의하는 값 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="af918-164">An enumeration is a value type that defines a set of related named constants.</span></span> <span data-ttu-id="af918-165">명명된 상수를 의미 있게 조합할 수 있는 경우 열거형에 FlagsAttribute를 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-165">Apply FlagsAttribute to an enumeration when its named constants can be meaningfully combined.</span></span> |
| [<span data-ttu-id="af918-166">CA1028: 열거형 스토리지는 Int32여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-166">CA1028: Enum storage should be Int32</span></span>](ca1028.md) | <span data-ttu-id="af918-167">열거형은 서로 관련 있는 명명된 상수 집합을 정의하는 값 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="af918-167">An enumeration is a value type that defines a set of related named constants.</span></span> <span data-ttu-id="af918-168">기본적으로 System.Int32 데이터 형식은 상수 값을 저장하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="af918-168">By default, the System.Int32 data type is used to store the constant value.</span></span> <span data-ttu-id="af918-169">이 기본 형식을 변경할 수 있지만 대부분의 시나리오에서는 필요 하지 않거나 권장 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="af918-169">Even though you can change this underlying type, it is not required or recommended for most scenarios.</span></span> |
| [<span data-ttu-id="af918-170">CA1030: 적절한 경우 이벤트를 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="af918-170">CA1030: Use events where appropriate</span></span>](ca1030.md) | <span data-ttu-id="af918-171">이 규칙에서는 보통 이벤트에 사용되는 이름을 갖는 메서드를 찾아냅니다.</span><span class="sxs-lookup"><span data-stu-id="af918-171">This rule detects methods that have names that ordinarily would be used for events.</span></span> <span data-ttu-id="af918-172">명확하게 정의된 상태 변경에 대한 응답으로 메서드를 호출할 경우 이 메서드는 이벤트 처리기에서 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-172">If a method is called in response to a clearly defined state change, the method should be invoked by an event handler.</span></span> <span data-ttu-id="af918-173">메서드를 호출하는 개체는 메서드를 직접 호출하는 대신 이벤트를 발생시켜야 합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-173">Objects that call the method should raise events instead of calling the method directly.</span></span> |
| [<span data-ttu-id="af918-174">CA1031: 일반적인 예외 형식을 catch하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="af918-174">CA1031: Do not catch general exception types</span></span>](ca1031.md) | <span data-ttu-id="af918-175">일반 예외는 catch하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="af918-175">General exceptions should not be caught.</span></span> <span data-ttu-id="af918-176">더 구체적인 예외를 catch 하거나 catch 블록의 마지막 문으로 일반 예외를 다시 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-176">Catch a more-specific exception, or rethrow the general exception as the last statement in the catch block.</span></span> |
| [<span data-ttu-id="af918-177">CA1032: 표준 예외 생성자를 구현하세요.</span><span class="sxs-lookup"><span data-stu-id="af918-177">CA1032: Implement standard exception constructors</span></span>](ca1032.md) | <span data-ttu-id="af918-178">이들 생성자 집합을 전부 제공하지 못하면 예외를 제대로 처리하기 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="af918-178">Failure to provide the full set of constructors can make it difficult to correctly handle exceptions.</span></span> |
| [<span data-ttu-id="af918-179">CA1033: 인터페이스 메서드는 자식 형식에서 호출할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-179">CA1033: Interface methods should be callable by child types</span></span>](ca1033.md) | <span data-ttu-id="af918-180">외부에서 볼 수 있는 unsealed 형식이 public 인터페이스의 명시적 메서드 구현을 제공하면서 외부에서 볼 수 있는 같은 이름의 대체 메서드를 제공하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="af918-180">An unsealed externally visible type provides an explicit method implementation of a public interface and does not provide an alternative externally visible method that has the same name.</span></span> |
| [<span data-ttu-id="af918-181">CA1034: 중첩 형식은 노출되면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="af918-181">CA1034: Nested types should not be visible</span></span>](ca1034.md) | <span data-ttu-id="af918-182">중첩 형식은 다른 형식의 범위 내에 선언된 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="af918-182">A nested type is a type that is declared in the scope of another type.</span></span> <span data-ttu-id="af918-183">중첩 형식은 포함하는 형식의 private 구현 정보를 캡슐화하는 데 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-183">Nested types are useful to encapsulate private implementation details of the containing type.</span></span> <span data-ttu-id="af918-184">이 용도로 사용할 경우 중첩 형식은 외부에 노출되면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="af918-184">Used for this purpose, nested types should not be externally visible.</span></span> |
| [<span data-ttu-id="af918-185">CA1036: 비교 가능한 형식에 메서드를 재정의하세요.</span><span class="sxs-lookup"><span data-stu-id="af918-185">CA1036: Override methods on comparable types</span></span>](ca1036.md) | <span data-ttu-id="af918-186">public 또는 protected 형식이 System.IComparable 인터페이스를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-186">A public or protected type implements the System.IComparable interface.</span></span> <span data-ttu-id="af918-187">이 형식은 Object.Equals를 재정의하지 않으며 같음, 같지 않음, 보다 작음 또는 보다 큼에 대한 언어별 연산자를 오버로드하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="af918-187">It does not override Object.Equals nor does it overload the language-specific operator for equality, inequality, less than, or greater than.</span></span> |
| [<span data-ttu-id="af918-188">CA1040: 빈 인터페이스를 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="af918-188">CA1040: Avoid empty interfaces</span></span>](ca1040.md) | <span data-ttu-id="af918-189">인터페이스에서는 동작이나 사용 계약을 제공하는 멤버를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-189">Interfaces define members that provide a behavior or usage contract.</span></span> <span data-ttu-id="af918-190">인터페이스에 의해 설명되는 기능은 상속 계층 구조에서 형식이 나타나는 위치에 관계없이 모든 형식에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="af918-190">The functionality that is described by the interface can be adopted by any type, regardless of where the type appears in the inheritance hierarchy.</span></span> <span data-ttu-id="af918-191">형식에서는 인터페이스의 멤버에 대한 구현을 제공하여 인터페이스를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-191">A type implements an interface by providing implementations for the members of the interface.</span></span> <span data-ttu-id="af918-192">빈 인터페이스는 멤버를 정의하지 않으므로 구현 가능한 계약을 정의하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="af918-192">An empty interface does not define any members; therefore, it does not define a contract that can be implemented.</span></span> |
| [<span data-ttu-id="af918-193">CA1041: ObsoleteAttribute 메시지를 제공하세요.</span><span class="sxs-lookup"><span data-stu-id="af918-193">CA1041: Provide ObsoleteAttribute message</span></span>](ca1041.md) | <span data-ttu-id="af918-194">형식 또는 멤버가 ObsoleteAttribute.Message 속성이 지정되지 않은 System.ObsoleteAttribute 특성으로 표시되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="af918-194">A type or member is marked by using a System.ObsoleteAttribute attribute that does not have its ObsoleteAttribute.Message property specified.</span></span> <span data-ttu-id="af918-195">ObsoleteAttribute를 사용 하 여 표시 된 형식 또는 멤버를 컴파일하면 특성의 메시지 속성이 표시 되어 사용 되지 않는 형식 또는 멤버에 대 한 정보를 사용자에 게 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-195">When a type or member that is marked by using ObsoleteAttribute is compiled, the Message property of the attribute is displayed, which gives the user information about the obsolete type or member.</span></span> |
| [<span data-ttu-id="af918-196">CA1043: 인덱서에 정수 또는 문자열 인수를 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="af918-196">CA1043: Use integral or string argument for indexers</span></span>](ca1043.md) | <span data-ttu-id="af918-197">인덱서, 즉 인덱싱된 속성은 인덱스에 정수 계열 형식이나 문자열 형식을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-197">Indexers (that is, indexed properties) should use integral or string types for the index.</span></span> <span data-ttu-id="af918-198">이러한 형식은 대개 데이터 구조를 인덱싱하는 데 사용되며 라이브러리의 유용성을 증가시킵니다.</span><span class="sxs-lookup"><span data-stu-id="af918-198">These types are typically used for indexing data structures and they increase the usability of the library.</span></span> <span data-ttu-id="af918-199">Object 형식은 디자인 타임에 특정 정수 계열 형식이나 문자열 형식을 지정할 수 없는 경우에만 제한적으로 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-199">Use of the Object type should be restricted to those cases where the specific integral or string type cannot be specified at design time.</span></span> |
| [<span data-ttu-id="af918-200">CA1044: 속성은 쓰기 전용이면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="af918-200">CA1044: Properties should not be write only</span></span>](ca1044.md) | <span data-ttu-id="af918-201">읽기 전용 속성을 사용하는 것은 가능하고 종종 필요하기도 하지만 쓰기 전용 속성의 사용은 금지되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="af918-201">Although it is acceptable and often necessary to have a read-only property, the design guidelines prohibit the use of write-only properties.</span></span> <span data-ttu-id="af918-202">사용자에게 값을 설정하도록 허용한 다음 해당 값을 볼 수 없도록 하면 보안상 문제가 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="af918-202">This is because letting a user set a value, and then preventing the user from viewing that value, does not provide any security.</span></span> <span data-ttu-id="af918-203">또한 읽기 권한이 없으면 공유 개체의 상태를 볼 수 없으므로 사용하는 데 제한을 받습니다.</span><span class="sxs-lookup"><span data-stu-id="af918-203">Also, without read access, the state of shared objects cannot be viewed, which limits their usefulness.</span></span> |
| [<span data-ttu-id="af918-204">CA1045: 참조로 형식을 전달하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="af918-204">CA1045: Do not pass types by reference</span></span>](ca1045.md) | <span data-ttu-id="af918-205">out 또는 ref를 사용하여 참조로 형식을 전달하려면 포인터 사용 방법을 알고 있어야 하고, 값 형식과 참조 형식이 어떻게 다른지 알고 있어야 하며, 반환 값이 여러 개인 메서드를 처리할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-205">Passing types by reference (using out or ref) requires experience with pointers, understanding how value types and reference types differ, and handling methods with multiple return values.</span></span> <span data-ttu-id="af918-206">일반 사용자를 대상으로 디자인하는 라이브러리 설계자는 사용자가 out 또는 ref 매개 변수를 사용하는 작업에 능숙할 것이라고 기대해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="af918-206">Library architects who design for a general audience should not expect users to master working with out or ref parameters.</span></span> |
| [<span data-ttu-id="af918-207">CA1046: 참조 형식에 같음 연산자를 오버로드하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="af918-207">CA1046: Do not overload operator equals on reference types</span></span>](ca1046.md) | <span data-ttu-id="af918-208">참조 형식의 경우 같음 연산자의 기본 구현은 대부분 항상 올바릅니다.</span><span class="sxs-lookup"><span data-stu-id="af918-208">For reference types, the default implementation of the equality operator is almost always correct.</span></span> <span data-ttu-id="af918-209">기본적으로 두 참조는 같은 개체를 가리킬 경우에만 같습니다.</span><span class="sxs-lookup"><span data-stu-id="af918-209">By default, two references are equal only if they point to the same object.</span></span> |
| [<span data-ttu-id="af918-210">CA1047: protected 멤버를 sealed 형식으로 선언하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="af918-210">CA1047: Do not declare protected members in sealed types</span></span>](ca1047.md) | <span data-ttu-id="af918-211">형식에서는 상속하는 형식에서 멤버에 액세스하거나 멤버를 재정의할 수 있도록 하기 위해 protected 멤버를 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-211">Types declare protected members so that inheriting types can access or override the member.</span></span> <span data-ttu-id="af918-212">정의에 따라 sealed 형식은 상속할 수 없으므로 sealed 형식에 대해 protected 메서드를 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="af918-212">By definition, sealed types cannot be inherited, which means that protected methods on sealed types cannot be called.</span></span> |
| [<span data-ttu-id="af918-213">CA1050: 네임스페이스에 형식을 선언하세요.</span><span class="sxs-lookup"><span data-stu-id="af918-213">CA1050: Declare types in namespaces</span></span>](ca1050.md) | <span data-ttu-id="af918-214">이름 충돌을 방지하고 관련된 형식을 개체 계층 구조로 구성하기 위해 형식은 네임스페이스 안에 선언됩니다.</span><span class="sxs-lookup"><span data-stu-id="af918-214">Types are declared in namespaces to prevent name collisions and as a way to organize related types in an object hierarchy.</span></span> |
| [<span data-ttu-id="af918-215">CA1051: 표시되는 인스턴스 필드를 선언하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="af918-215">CA1051: Do not declare visible instance fields</span></span>](ca1051.md) | <span data-ttu-id="af918-216">필드의 주된 용도는 구현을 세부적으로 설명하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="af918-216">The primary use of a field should be as an implementation detail.</span></span> <span data-ttu-id="af918-217">필드는 private 또는 internal이어야 하고 속성을 통해 노출되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-217">Fields should be private or internal and should be exposed by using properties.</span></span> |
| [<span data-ttu-id="af918-218">CA1052: 정적 소유자 형식은 sealed여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-218">CA1052: Static holder types should be sealed</span></span>](ca1052.md) | <span data-ttu-id="af918-219">Public 또는 protected 형식이 정적 멤버만 포함 하며 sealed (c #) 또는 NotInheritable (Visual Basic) 한정자를 사용 하 여 선언 되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="af918-219">A public or protected type contains only static members and is not declared by using the sealed (C#) or NotInheritable (Visual Basic) modifier.</span></span> <span data-ttu-id="af918-220">상속을 고려하지 않은 형식은 sealed 한정자로 표시하여 기본 형식으로 사용되지 않도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-220">A type that is not meant to be inherited should be marked by using the sealed modifier to prevent its use as a base type.</span></span> |
| [<span data-ttu-id="af918-221">CA1053: 정적 소유자 형식에는 생성자를 사용하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="af918-221">CA1053: Static holder types should not have constructors</span></span>](ca1053.md) | <span data-ttu-id="af918-222">public 또는 중첩된 public 형식에서 정적 멤버만 선언하며 public 또는 protected 기본 생성자를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-222">A public or nested public type declares only static members and has a public or protected default constructor.</span></span> <span data-ttu-id="af918-223">호출하는 정적 멤버에 형식의 인스턴스가 필요하지 않기 때문에 생성자가 필요 없습니다.</span><span class="sxs-lookup"><span data-stu-id="af918-223">The constructor is unnecessary because calling static members does not require an instance of the type.</span></span> <span data-ttu-id="af918-224">문자열 오버로드는 안전과 보안을 위해 문자열 인수를 사용하여 URI(Uniform Resource Identifier) 오버로드를 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-224">The string overload should call the uniform resource identifier (URI) overload by using the string argument for safety and security.</span></span> |
| [<span data-ttu-id="af918-225">CA1054: URI 매개 변수는 문자열이면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="af918-225">CA1054: URI parameters should not be strings</span></span>](ca1054.md) | <span data-ttu-id="af918-226">메서드가 URI의 문자열 표현을 사용하면 URI 클래스의 인스턴스를 사용하는 해당 오버로드를 제공해야 합니다. 이렇게 하면 서비스가 안전한 방식으로 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="af918-226">If a method takes a string representation of a URI, a corresponding overload should be provided that takes an instance of the URI class, which provides these services in a safe and secure manner.</span></span> |
| [<span data-ttu-id="af918-227">CA1055: URI 반환 값은 문자열이면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="af918-227">CA1055: URI return values should not be strings</span></span>](ca1055.md) | <span data-ttu-id="af918-228">이 규칙에서는 메서드가 URI를 반환한다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-228">This rule assumes that the method returns a URI.</span></span> <span data-ttu-id="af918-229">URI의 문자열 표현은 구문 분석 및 인코딩 오류를 발생시키기 쉬우며 보안 문제를 일으킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="af918-229">A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities.</span></span> <span data-ttu-id="af918-230">System.Uri 클래스는 이러한 서비스를 안전한 방식으로 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-230">The System.Uri class provides these services in a safe and secure manner.</span></span> |
| [<span data-ttu-id="af918-231">CA1056: URI 속성은 문자열이면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="af918-231">CA1056: URI properties should not be strings</span></span>](ca1056.md) | <span data-ttu-id="af918-232">이 규칙은 속성이 URI를 나타내는 것으로 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-232">This rule assumes that the property represents a URI.</span></span> <span data-ttu-id="af918-233">URI의 문자열 표현은 구문 분석 및 인코딩 오류를 발생시키기 쉬우며 보안 문제를 일으킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="af918-233">A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities.</span></span> <span data-ttu-id="af918-234">System.Uri 클래스는 이러한 서비스를 안전한 방식으로 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-234">The System.Uri class provides these services in a safe and secure manner.</span></span> |
| [<span data-ttu-id="af918-235">CA1058: 형식은 특정 기본 형식을 확장하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="af918-235">CA1058: Types should not extend certain base types</span></span>](ca1058.md) | <span data-ttu-id="af918-236">외부에서 볼 수 있는 형식이 특정 기본 형식을 확장합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-236">An externally visible type extends certain base types.</span></span> <span data-ttu-id="af918-237">다음 방법 중 하나를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-237">Use one of the alternatives.</span></span> |
| [<span data-ttu-id="af918-238">CA1060: P/Invoke를 NativeMethods 클래스로 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-238">CA1060: Move P/Invokes to NativeMethods class</span></span>](ca1060.md) | <span data-ttu-id="af918-239">Visual Basic에서 Declare 키워드를 사용 하 여 정의 된 또는 메서드로 표시 된 것과 같은 플랫폼 호출 메서드는 <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=fullName> 비관리 코드에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-239">Platform Invocation methods, such as those marked with the <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=fullName> or methods defined by using the Declare keyword in Visual Basic, access unmanaged code.</span></span> <span data-ttu-id="af918-240">이러한 메서드는 NativeMethods, SafeNativeMethods 또는 UnsafeNativeMethods 클래스에 속해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-240">These methods should be of the NativeMethods, SafeNativeMethods, or UnsafeNativeMethods class.</span></span> |
| [<span data-ttu-id="af918-241">CA1061: 기본 클래스 메서드를 숨기지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="af918-241">CA1061: Do not hide base class methods</span></span>](ca1061.md) | <span data-ttu-id="af918-242">파생된 메서드의 매개 변수 시그니처가 기본 메서드의 매개 변수 시그니처에 있는 해당 형식보다 더 약하게 파생된 형식이라는 점만 다른 경우 기본 형식의 메서드는 파생된 형식에 있는 동일한 이름의 메서드에 의해 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="af918-242">A method in a base type is hidden by an identically named method in a derived type, when the parameter signature of the derived method differs only by types that are more weakly derived than the corresponding types in the parameter signature of the base method.</span></span> |
| [<span data-ttu-id="af918-243">CA1062: public 메서드의 인수에 대한 유효성을 검사하세요.</span><span class="sxs-lookup"><span data-stu-id="af918-243">CA1062: Validate arguments of public methods</span></span>](ca1062.md) | <span data-ttu-id="af918-244">외부에서 볼 수 있는 메서드에 전달되는 모든 참조 인수는 null인지 여부를 검사해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-244">All reference arguments that are passed to externally visible methods should be checked against null.</span></span> |
| [<span data-ttu-id="af918-245">CA1063: IDisposable을 올바르게 구현하십시오.</span><span class="sxs-lookup"><span data-stu-id="af918-245">CA1063: Implement IDisposable correctly</span></span>](ca1063.md) | <span data-ttu-id="af918-246">모든 IDisposable 형식은 Dispose 패턴을 올바르게 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-246">All IDisposable types should implement the Dispose pattern correctly.</span></span> |
| [<span data-ttu-id="af918-247">CA1064: 예외는 public이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-247">CA1064: Exceptions should be public</span></span>](ca1064.md) | <span data-ttu-id="af918-248">내부 예외는 내부 범위 내에만 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="af918-248">An internal exception is visible only inside its own internal scope.</span></span> <span data-ttu-id="af918-249">예외가 내부 범위 밖에 놓이게 되면 예외를 catch하는 데 기본 예외만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="af918-249">After the exception falls outside the internal scope, only the base exception can be used to catch the exception.</span></span> <span data-ttu-id="af918-250">내부 예외에서 상속 되 면 <xref:System.Exception?displayProperty=fullName>, <xref:System.SystemException?displayProperty=fullName>, 또는 <xref:System.ApplicationException?displayProperty=fullName>, 외부 코드에 예외를 사용 하 여 수행할 작업을 알고에 충분 한 정보가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="af918-250">If the internal exception is inherited from <xref:System.Exception?displayProperty=fullName>, <xref:System.SystemException?displayProperty=fullName>, or <xref:System.ApplicationException?displayProperty=fullName>, the external code will not have sufficient information to know what to do with the exception.</span></span> |
| [<span data-ttu-id="af918-251">CA1065: 예기치 않은 위치에서 예외를 발생시키지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="af918-251">CA1065: Do not raise exceptions in unexpected locations</span></span>](ca1065.md) | <span data-ttu-id="af918-252">예외를 throw하지 않아야 하는 메서드가 예외를 throw했습니다.</span><span class="sxs-lookup"><span data-stu-id="af918-252">A method that is not expected to throw exceptions throws an exception.</span></span> |
| [<span data-ttu-id="af918-253">CA1066: Equals를 재정의할 때 IEquatable을 구현하세요.</span><span class="sxs-lookup"><span data-stu-id="af918-253">CA1066: Implement IEquatable when overriding Equals</span></span>](ca1066.md) | <span data-ttu-id="af918-254">값 형식은 <xref:System.Object.Equals%2A> 메서드를 재정의 하지만는 구현 하지 않습니다 <xref:System.IEquatable%601> .</span><span class="sxs-lookup"><span data-stu-id="af918-254">A value type overrides <xref:System.Object.Equals%2A> method, but does not implement <xref:System.IEquatable%601>.</span></span> |
| [<span data-ttu-id="af918-255">CA1067: IEquatable을 구현할 때 Equals를 재정의하세요.</span><span class="sxs-lookup"><span data-stu-id="af918-255">CA1067: Override Equals when implementing IEquatable</span></span>](ca1067.md) | <span data-ttu-id="af918-256">형식은를 구현 <xref:System.IEquatable%601> 하지만 메서드를 재정의 하지 않습니다 <xref:System.Object.Equals%2A> .</span><span class="sxs-lookup"><span data-stu-id="af918-256">A type implements <xref:System.IEquatable%601>, but does not override <xref:System.Object.Equals%2A> method.</span></span> |
| [<span data-ttu-id="af918-257">CA1068: CancellationToken 매개 변수는 마지막에 위치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-257">CA1068: CancellationToken parameters must come last</span></span>](ca1068.md) | <span data-ttu-id="af918-258">메서드에 마지막 매개 변수가 아닌 CancellationToken 매개 변수가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="af918-258">A method has a CancellationToken parameter that is not the last parameter.</span></span> |
| [<span data-ttu-id="af918-259">CA1069: 열거형에 중복 값이 없어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="af918-259">CA1069: Enums should not have duplicate values</span></span>](ca1069.md) | <span data-ttu-id="af918-260">열거형에는 동일한 상수 값을 명시적으로 할당 하는 여러 멤버가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="af918-260">An enumeration has multiple members which are explicitly assigned the same constant value.</span></span> |
| [<span data-ttu-id="af918-261">CA1070: 이벤트 필드를 가상으로 선언하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="af918-261">CA1070: Do not declare event fields as virtual</span></span>](ca1070.md) | <span data-ttu-id="af918-262">[필드와 유사한 이벤트가](../../../csharp/event-pattern.md#defining-and-raising-field-like-events) 가상으로 선언 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="af918-262">A [field-like event](../../../csharp/event-pattern.md#defining-and-raising-field-like-events) was declared as virtual.</span></span> |
| [<span data-ttu-id="af918-263">CA1071: Override base. IEquatable 구현 시 같음</span><span class="sxs-lookup"><span data-stu-id="af918-263">CA1071: Override base.Equals when implementing IEquatable</span></span>](ca1071.md) | <span data-ttu-id="af918-264">파생 된 형식은 <xref:System.IEquatable%601> 를 구현 하지만 기본 클래스 메서드를 재정의 하지 않습니다 <xref:System.IEquatable%601.Equals%2A> .</span><span class="sxs-lookup"><span data-stu-id="af918-264">A derived type implements <xref:System.IEquatable%601>, but does not override the base class <xref:System.IEquatable%601.Equals%2A> method.</span></span> |
