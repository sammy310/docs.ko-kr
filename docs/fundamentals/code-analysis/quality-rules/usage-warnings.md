---
title: 사용 규칙 (코드 분석)
description: 코드 분석 사용 규칙에 대해 알아봅니다.
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.usagerules
helpviewer_keywords:
- rules, usage
- managed code analysis rules, usage rules
- usage rules
author: gewarren
ms.author: gewarren
ms.openlocfilehash: c8b14d2f92502d5a82e41a322e599745bdcf8b85
ms.sourcegitcommit: a6bd4cad438fe479cbd112eae10f2cd449f06e40
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/08/2020
ms.locfileid: "96593529"
---
# <a name="usage-rules"></a><span data-ttu-id="547ac-103">사용 규칙</span><span class="sxs-lookup"><span data-stu-id="547ac-103">Usage rules</span></span>

<span data-ttu-id="547ac-104">사용 규칙은 .NET의 적절 한 사용을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-104">Usage rules support proper usage of .NET.</span></span>

## <a name="in-this-section"></a><span data-ttu-id="547ac-105">섹션 내용</span><span class="sxs-lookup"><span data-stu-id="547ac-105">In this section</span></span>

|<span data-ttu-id="547ac-106">규칙</span><span class="sxs-lookup"><span data-stu-id="547ac-106">Rule</span></span>|<span data-ttu-id="547ac-107">설명</span><span class="sxs-lookup"><span data-stu-id="547ac-107">Description</span></span>|
|----------|-----------------|
|[<span data-ttu-id="547ac-108">CA1801: 사용되지 않은 매개 변수를 검토하세요.</span><span class="sxs-lookup"><span data-stu-id="547ac-108">CA1801: Review unused parameters</span></span>](ca1801.md)|<span data-ttu-id="547ac-109">메서드 시그니처에 메서드 본문에서 사용되지 않는 매개 변수가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-109">A method signature includes a parameter that is not used in the method body.</span></span>|
|[<span data-ttu-id="547ac-110">CA1816: GC.SuppressFinalize를 올바르게 호출하세요.</span><span class="sxs-lookup"><span data-stu-id="547ac-110">CA1816: Call GC.SuppressFinalize correctly</span></span>](ca1816.md)|<span data-ttu-id="547ac-111">Dispose의 구현인 메서드는를 호출 하지 않고, `GC.SuppressFinalize` 호출의 구현이 아닌 메서드를 호출 하거나, 메서드를 `Dispose` `GC.SuppressFinalize` 호출 `GC.SuppressFinalize` 하 고 Visual Basic의 이외의 항목을 전달 `this` `Me` 합니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-111">A method that is an implementation of Dispose does not call `GC.SuppressFinalize`; or a method that is not an implementation of `Dispose` calls `GC.SuppressFinalize`; or a method calls `GC.SuppressFinalize` and passes something other than `this` (`Me` in Visual Basic).</span></span>|
|[<span data-ttu-id="547ac-112">CA2200: 스택 정보를 유지하도록 다시 throw하십시오.</span><span class="sxs-lookup"><span data-stu-id="547ac-112">CA2200: Rethrow to preserve stack details</span></span>](ca2200.md)|<span data-ttu-id="547ac-113">예외가 다시 throw되며 예외가 throw 문에 명시적으로 지정되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-113">An exception is rethrown and the exception is explicitly specified in the throw statement.</span></span> <span data-ttu-id="547ac-114">throw 문에 예외를 지정하여 예외가 다시 throw되면 예외를 throw한 원래 메서드와 현재 메서드 간의 메서드 호출 목록이 손실됩니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-114">If an exception is rethrown by specifying the exception in the throw statement, the list of method calls between the original method that threw the exception and the current method is lost.</span></span>|
|[<span data-ttu-id="547ac-115">CA2201: 예약된 예외 형식을 발생시키지 마세요.</span><span class="sxs-lookup"><span data-stu-id="547ac-115">CA2201: Do not raise reserved exception types</span></span>](ca2201.md)|<span data-ttu-id="547ac-116">이렇게 하면 원래 오류를 검색 하 고 디버그 하기가 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-116">This makes the original error hard to detect and debug.</span></span>|
|[<span data-ttu-id="547ac-117">CA2207: 값 형식 정적 필드 인라인을 초기화하십시오.</span><span class="sxs-lookup"><span data-stu-id="547ac-117">CA2207: Initialize value type static fields inline</span></span>](ca2207.md)|<span data-ttu-id="547ac-118">값 형식에서 명시적인 정적 생성자를 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-118">A value type declares an explicit static constructor.</span></span> <span data-ttu-id="547ac-119">이 규칙 위반 문제를 해결하려면 모든 정적 데이터를 선언할 때 초기화하고 정적 생성자를 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-119">To fix a violation of this rule, initialize all static data when it is declared and remove the static constructor.</span></span>|
|[<span data-ttu-id="547ac-120">CA2208: 인수 예외를 올바르게 인스턴스화하세요.</span><span class="sxs-lookup"><span data-stu-id="547ac-120">CA2208: Instantiate argument exceptions correctly</span></span>](ca2208.md)|<span data-ttu-id="547ac-121">ArgumentException 또는 ArgumentException에서 파생된 예외 형식의 기본(매개 변수가 없는) 생성자를 호출했거나, ArgumentException 또는 ArgumentException에서 파생된 예외 형식의 매개 변수가 있는 생성자에 잘못된 문자열 인수가 전달되었습니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-121">A call is made to the default (parameterless) constructor of an exception type that is or derives from ArgumentException, or an incorrect string argument is passed to a parameterized constructor of an exception type that is or derives from ArgumentException.</span></span>|
|[<span data-ttu-id="547ac-122">CA2211: 비상수 필드는 노출되면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-122">CA2211: Non-constant fields should not be visible</span></span>](ca2211.md)|<span data-ttu-id="547ac-123">상수 또는 읽기 전용 정적 필드는 스레드로부터 안전 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-123">Static fields that are not constants or read-only are not thread-safe.</span></span> <span data-ttu-id="547ac-124">이러한 필드에 대 한 액세스는 신중 하 게 제어 해야 하며 클래스 개체에 대 한 액세스를 동기화 하기 위한 고급 프로그래밍 기술이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-124">Access to such a field must be carefully controlled and requires advanced programming techniques for synchronizing access to the class object.</span></span>|
|[<span data-ttu-id="547ac-125">CA2213: 삭제 가능한 필드는 삭제해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-125">CA2213: Disposable fields should be disposed</span></span>](ca2213.md)|<span data-ttu-id="547ac-126">을 구현 하는 형식은 <xref:System.IDisposable?displayProperty=fullName> 도 구현 하는 형식의 필드를 선언 `IDisposable` 합니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-126">A type that implements <xref:System.IDisposable?displayProperty=fullName> declares fields that are of types that also implement `IDisposable`.</span></span> <span data-ttu-id="547ac-127">`Dispose`필드의 메서드는 선언 형식의 메서드에서 호출 되지 않습니다 `Dispose` .</span><span class="sxs-lookup"><span data-stu-id="547ac-127">The `Dispose` method of the field is not called by the `Dispose` method of the declaring type.</span></span>|
|[<span data-ttu-id="547ac-128">CA2214: 재정의 가능한 메서드를 생성자에서 호출하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="547ac-128">CA2214: Do not call overridable methods in constructors</span></span>](ca2214.md)|<span data-ttu-id="547ac-129">생성자가 가상 메서드를 호출 하는 경우 메서드를 호출 하는 인스턴스에 대 한 생성자가 실행 되지 않았을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-129">When a constructor calls a virtual method, it is possible that the constructor for the instance that invokes the method has not executed.</span></span>|
|[<span data-ttu-id="547ac-130">CA2215: Dispose 메서드는 기본 클래스 Dispose를 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-130">CA2215: Dispose methods should call base class dispose</span></span>](ca2215.md)|<span data-ttu-id="547ac-131">형식이 삭제 가능한 형식에서 상속 되는 경우 `Dispose` 자체 메서드에서 기본 형식의 메서드를 호출 해야 합니다 `Dispose` .</span><span class="sxs-lookup"><span data-stu-id="547ac-131">If a type inherits from a disposable type, it must call the `Dispose` method of the base type from its own `Dispose` method.</span></span>|
|[<span data-ttu-id="547ac-132">CA2216: 삭제 가능한 형식은 종료자를 선언해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-132">CA2216: Disposable types should declare finalizer</span></span>](ca2216.md)|<span data-ttu-id="547ac-133">을 구현 하 <xref:System.IDisposable?displayProperty=fullName> 고 관리 되지 않는 리소스의 사용을 제안 하는 필드를 포함 하는 형식에서는에 설명 된 대로 종료자를 구현 하지 않습니다 `Object.Finalize` .</span><span class="sxs-lookup"><span data-stu-id="547ac-133">A type that implements <xref:System.IDisposable?displayProperty=fullName>, and has fields that suggest the use of unmanaged resources, does not implement a finalizer as described by `Object.Finalize`.</span></span>|
|[<span data-ttu-id="547ac-134">CA2217: 열거형을 FlagsAttribute로 표시하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="547ac-134">CA2217: Do not mark enums with FlagsAttribute</span></span>](ca2217.md)|<span data-ttu-id="547ac-135">외부에서 볼 수 있는 열거형은로 표시 되 `FlagsAttribute` 고, 두의 거듭제곱이 아닌 하나 이상의 값 또는 열거형에 정의 된 다른 값의 조합이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-135">An externally visible enumeration is marked with `FlagsAttribute`, and it has one or more values that are not powers of two or a combination of the other defined values on the enumeration.</span></span>|
|[<span data-ttu-id="547ac-136">CA2218: Equals를 재정할 때 GetHashCode를 재정의하세요.</span><span class="sxs-lookup"><span data-stu-id="547ac-136">CA2218: Override GetHashCode on overriding Equals</span></span>](ca2218.md)|<span data-ttu-id="547ac-137">Public 형식은를 재정의 <xref:System.Object.Equals%2A?displayProperty=fullName> 하지만는 재정의 하지 않습니다 <xref:System.Object.GetHashCode%2A?displayProperty=fullName> .</span><span class="sxs-lookup"><span data-stu-id="547ac-137">A public type overrides <xref:System.Object.Equals%2A?displayProperty=fullName> but does not override <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</span></span>|
|[<span data-ttu-id="547ac-138">CA2219: exception 절에서 예외를 발생시키지 마세요.</span><span class="sxs-lookup"><span data-stu-id="547ac-138">CA2219: Do not raise exceptions in exception clauses</span></span>](ca2219.md)|<span data-ttu-id="547ac-139">finally 또는 fault 절에서 예외가 발생하는 경우 새 예외가 활성 예외를 숨깁니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-139">When an exception is raised in a finally or fault clause, the new exception hides the active exception.</span></span> <span data-ttu-id="547ac-140">filter 절에서 예외가 발생하는 경우 런타임이 자동으로 예외를 catch합니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-140">When an exception is raised in a filter clause, the run time silently catches the exception.</span></span> <span data-ttu-id="547ac-141">이렇게 하면 원래 오류를 검색 하 고 디버그 하기가 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-141">This makes the original error hard to detect and debug.</span></span>|
|[<span data-ttu-id="547ac-142">CA2224: 같음 연산자를 오버로드할 때 Equals를 재정의하세요.</span><span class="sxs-lookup"><span data-stu-id="547ac-142">CA2224: Override equals on overloading operator equals</span></span>](ca2224.md)|<span data-ttu-id="547ac-143">Public 형식은 같음 연산자를 구현 하지만는 재정의 하지 않습니다 <xref:System.Object.Equals%2A?displayProperty=fullName> .</span><span class="sxs-lookup"><span data-stu-id="547ac-143">A public type implements the equality operator but doesn't override <xref:System.Object.Equals%2A?displayProperty=fullName>.</span></span>|
|[<span data-ttu-id="547ac-144">CA2225: 연산자 오버로드에는 명명된 대체 항목이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-144">CA2225: Operator overloads have named alternates</span></span>](ca2225.md)|<span data-ttu-id="547ac-145">연산자 오버로드가 감지되었으며 예상되는 이름의 대체 메서드를 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-145">An operator overload was detected, and the expected named alternative method was not found.</span></span> <span data-ttu-id="547ac-146">명명 된 대체 멤버는 연산자와 같은 기능에 대 한 액세스를 제공 하며 오버 로드 된 연산자를 지원 하지 않는 언어로 프로그래밍 하는 개발자를 위해 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-146">The named alternative member provides access to the same functionality as the operator, and is provided for developers who program in languages that do not support overloaded operators.</span></span>|
|[<span data-ttu-id="547ac-147">CA2226: 연산자에는 대칭 오버로드가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-147">CA2226: Operators should have symmetrical overloads</span></span>](ca2226.md)|<span data-ttu-id="547ac-148">형식은 같음 또는 같지 않음 연산자를 구현 하며, 반대 연산자를 구현 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-148">A type implements the equality or inequality operator, and does not implement the opposite operator.</span></span>|
|[<span data-ttu-id="547ac-149">CA2227: 컬렉션 속성은 읽기 전용이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-149">CA2227: Collection properties should be read only</span></span>](ca2227.md)|<span data-ttu-id="547ac-150">쓰기 가능한 컬렉션 속성을 통해 사용자는 컬렉션을 다른 컬렉션으로 바꿀 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-150">A writable collection property allows a user to replace the collection with a different collection.</span></span> <span data-ttu-id="547ac-151">읽기 전용 속성은 컬렉션을 바꾸지 못하도록 하지만 개별 멤버를 설정하는 것은 여전히 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-151">A read-only property stops the collection from being replaced but still allows the individual members to be set.</span></span>|
|[<span data-ttu-id="547ac-152">CA2229: serialization 생성자를 구현하십시오.</span><span class="sxs-lookup"><span data-stu-id="547ac-152">CA2229: Implement serialization constructors</span></span>](ca2229.md)|<span data-ttu-id="547ac-153">이 규칙 위반 문제를 해결하려면 serialization 생성자를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-153">To fix a violation of this rule, implement the serialization constructor.</span></span> <span data-ttu-id="547ac-154">봉인 클래스의 경우에는 생성자를 private으로 만들고, 그 밖의 경우에는 protected로 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-154">For a sealed class, make the constructor private; otherwise, make it protected.</span></span>|
|[<span data-ttu-id="547ac-155">CA2231: ValueType.Equals를 재정의할 때 같음 연산자를 오버로드하십시오.</span><span class="sxs-lookup"><span data-stu-id="547ac-155">CA2231: Overload operator equals on overriding ValueType.Equals</span></span>](ca2231.md)|<span data-ttu-id="547ac-156">값 형식이를 재정의 `Object.Equals` 하지만 같음 연산자를 구현 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-156">A value type overrides `Object.Equals` but does not implement the equality operator.</span></span>|
|[<span data-ttu-id="547ac-157">CA2234: 문자열 대신 System.Uri 개체를 전달하세요.</span><span class="sxs-lookup"><span data-stu-id="547ac-157">CA2234: Pass System.Uri objects instead of strings</span></span>](ca2234.md)|<span data-ttu-id="547ac-158">이름에 "uri", "URI", "urn", "URN", "url" 또는 "URL"이 포함된 문자열 매개 변수가 있는 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-158">A call is made to a method that has a string parameter whose name contains "uri", "URI", "urn", "URN", "url", or "URL".</span></span>  <span data-ttu-id="547ac-159">메서드의 선언 형식에는 매개 변수가 있는 해당 메서드 오버 로드가 포함 <xref:System.Uri?displayProperty=fullName> 됩니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-159">The declaring type of the method contains a corresponding method overload that has a <xref:System.Uri?displayProperty=fullName> parameter.</span></span>|
|[<span data-ttu-id="547ac-160">CA2235: 모두 serialize할 수 없는 필드로 표시하십시오.</span><span class="sxs-lookup"><span data-stu-id="547ac-160">CA2235: Mark all non-serializable fields</span></span>](ca2235.md)|<span data-ttu-id="547ac-161">serialize할 수 없는 형식의 인스턴스 필드가 serialize할 수 있는 형식에 정의되었습니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-161">An instance field of a type that is not serializable is declared in a type that is serializable.</span></span>|
|[<span data-ttu-id="547ac-162">CA2237: SerializableAttribute로 ISerializable 형식 표시</span><span class="sxs-lookup"><span data-stu-id="547ac-162">CA2237: Mark ISerializable types with SerializableAttribute</span></span>](ca2237.md)|<span data-ttu-id="547ac-163">공용 언어 런타임에서 serializable로 인식 되려면 형식에서 인터페이스 구현을 통해 사용자 지정 serialization 루틴을 사용 하는 경우에도 형식을 SerializableAttribute 특성으로 표시 해야 합니다 `ISerializable` .</span><span class="sxs-lookup"><span data-stu-id="547ac-163">To be recognized by the common language runtime as serializable, types must be marked with the SerializableAttribute attribute even if the type uses a custom serialization routine through implementation of the `ISerializable` interface.</span></span>|
|[<span data-ttu-id="547ac-164">CA2241: 서식 지정 메서드에 올바른 인수를 제공하십시오.</span><span class="sxs-lookup"><span data-stu-id="547ac-164">CA2241: Provide correct arguments to formatting methods</span></span>](ca2241.md)|<span data-ttu-id="547ac-165">에 전달 된 형식 인수에 <xref:System.String.Format%2A?displayProperty=nameWithType> 각 개체 인수에 해당 하는 형식 항목이 포함 되어 있지 않거나 그 반대의 경우도 마찬가지입니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-165">The format argument passed to <xref:System.String.Format%2A?displayProperty=nameWithType> does not contain a format item that corresponds to each object argument, or vice versa.</span></span>|
|[<span data-ttu-id="547ac-166">CA2242: NaN에 대해 정확하게 테스트하십시오.</span><span class="sxs-lookup"><span data-stu-id="547ac-166">CA2242: Test for NaN correctly</span></span>](ca2242.md)|<span data-ttu-id="547ac-167">이 식은 또는에 대해 값을 테스트 `Single.Nan` `Double.Nan` 합니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-167">This expression tests a value against `Single.Nan` or `Double.Nan`.</span></span> <span data-ttu-id="547ac-168">`Single.IsNan(Single)`또는 `Double.IsNan(Double)` 를 사용 하 여 값을 테스트 합니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-168">Use `Single.IsNan(Single)` or `Double.IsNan(Double)` to test the value.</span></span>|
|[<span data-ttu-id="547ac-169">CA2243: 특성 문자열 리터럴이 올바르게 구문 분석되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-169">CA2243: Attribute string literals should parse correctly</span></span>](ca2243.md)|<span data-ttu-id="547ac-170">특성의 문자열 리터럴 매개 변수는 URL, GUID 또는 버전에 대해 올바르게 구문 분석 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-170">An attribute's string literal parameter does not parse correctly for a URL, a GUID, or a version.</span></span>|
|[<span data-ttu-id="547ac-171">CA2244: 인덱싱된 요소의 초기화는 복제하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-171">CA2244: Do not duplicate indexed element initializations</span></span>](ca2244.md)|<span data-ttu-id="547ac-172">개체 이니셜라이저에 동일한 상수 인덱스를 사용 하는 두 개 이상의 인덱싱된 요소 이니셜라이저가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-172">An object initializer has more than one indexed element initializer with the same constant index.</span></span> <span data-ttu-id="547ac-173">마지막 이니셜라이저가 아닌 모두 중복 됩니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-173">All but the last initializer are redundant.</span></span>|
|[<span data-ttu-id="547ac-174">CA2245: 속성을 자체에 할당하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="547ac-174">CA2245: Do not assign a property to itself</span></span>](ca2245.md)|<span data-ttu-id="547ac-175">속성이 실수로 자신에 게 할당 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-175">A property was accidentally assigned to itself.</span></span>|
|[<span data-ttu-id="547ac-176">CA2246: 동일한 문에 기호 및 해당 멤버를 할당하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="547ac-176">CA2246: Do not assign a symbol and its member in the same statement</span></span>](ca2246.md)|<span data-ttu-id="547ac-177">동일한 문에서 기호와 해당 멤버, 즉 필드 또는 속성을 할당 하는 것은 권장 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-177">Assigning a symbol and its member, that is, a field or a property, in the same statement is not recommended.</span></span> <span data-ttu-id="547ac-178">멤버 액세스에서 할당 전 기호의 이전 값을 사용 하거나이 문의 할당에서 새 값을 사용 하기 위한 것은 분명 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-178">It is not clear if the member access was intended to use the symbol's old value prior to the assignment or the new value from the assignment in this statement.</span></span>|
|[<span data-ttu-id="547ac-179">CA2247: TaskCompletionSource 생성자로 전달된 인수는 TaskContinuationOptions 열거형이 아닌 TaskCreationOptions 열거형이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-179">CA2247: Argument passed to TaskCompletionSource constructor should be TaskCreationOptions enum instead of TaskContinuationOptions enum</span></span>](ca2246.md)|<span data-ttu-id="547ac-180">TaskTaskCreationOptions Source에는 기본 작업을 제어 하는 생성자와 작업에 저장 된 개체 상태를 사용 하는 생성자가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-180">TaskCompletionSource has constructors that take TaskCreationOptions that control the underlying Task, and constructors that take object state that's stored in the task.</span></span>  <span data-ttu-id="547ac-181">실수로 TaskCreationOptions 대신 System.threading.tasks.taskcontinuationoptions를 전달 하면 호출은 옵션을 state로 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-181">Accidentally passing a TaskContinuationOptions instead of a TaskCreationOptions will result in the call treating the options as state.</span></span>|
|[<span data-ttu-id="547ac-182">CA2248: ' Enum. HasFlag '에 올바른 ' enum ' 인수를 제공 하십시오.</span><span class="sxs-lookup"><span data-stu-id="547ac-182">CA2248: Provide correct 'enum' argument to 'Enum.HasFlag'</span></span>](ca2248.md)|<span data-ttu-id="547ac-183">메서드 호출에 인수로 전달 된 열거형 형식이 호출 하는 `HasFlag` 열거형 형식과 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="547ac-183">The enum type passed as an argument to the `HasFlag` method call is different from the calling enum type.</span></span>|
|[<span data-ttu-id="547ac-184">CA2249: ‘String.IndexOf’ 대신 ‘String.Contains’ 사용 고려</span><span class="sxs-lookup"><span data-stu-id="547ac-184">CA2249: Consider using String.Contains instead of String.IndexOf</span></span>](ca2249.md)|<span data-ttu-id="547ac-185">결과를 `string.IndexOf` 사용 하 여 부분 문자열의 존재 여부를 확인 하는 호출을로 바꿀 수 있습니다 `string.Contains` .</span><span class="sxs-lookup"><span data-stu-id="547ac-185">Calls to `string.IndexOf` where the result is used to check for the presence or absence of a substring can be replaced by `string.Contains`.</span></span>|
