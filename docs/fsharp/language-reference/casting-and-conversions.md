---
title: 캐스팅 및 변환
description: 프로그래밍 언어에서 F# 다양 한 기본 형식 간의 산술 변환에 대 한 변환 연산자를 제공 하는 방법에 대해 알아봅니다.
ms.date: 02/20/2020
ms.openlocfilehash: 5f9727d14a7ae070e0f0f71fa0a0abe04f662071
ms.sourcegitcommit: 771c554c84ba38cbd4ac0578324ec4cfc979cf2e
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/21/2020
ms.locfileid: "77543588"
---
# <a name="casting-and-conversions-f"></a>캐스팅 및 변환(F#)

이 항목에서는의 F#형식 변환에 대 한 지원에 대해 설명 합니다.

## <a name="arithmetic-types"></a>산술 형식

F#정수 및 부동 소수점 형식 등 다양 한 기본 형식 간의 산술 변환을 위한 변환 연산자를 제공 합니다. 정수 및 문자 변환 연산자에는 checked 및 unchecked 형식이 있습니다. 부동 소수점 연산자와 `enum` 변환 연산자는 그렇지 않습니다. 선택 하지 않은 폼은 `Microsoft.FSharp.Core.Operators`에 정의 되 고 선택 된 양식은 `Microsoft.FSharp.Core.Operators.Checked`에 정의 됩니다. 결과 값이 대상 형식의 제한을 초과 하는 경우 확인 된 폼에서 오버플로를 확인 하 고 런타임 예외를 생성 합니다.

이러한 각 연산자는 대상 형식의 이름과 동일한 이름을 갖습니다. 예를 들어 형식에 명시적으로 주석을 추가 하는 다음 코드에서는 두 가지 의미를 가진 `byte` 표시 됩니다. 첫 번째 항목은 형식이 고 두 번째 항목은 변환 연산자입니다.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet4401.fs)]

다음 표에서는에 F#정의 된 변환 연산자를 보여 줍니다.

|연산자|설명|
|--------|-----------|
|`byte`|부호 없는 8 비트 형식인 바이트로 변환 합니다.|
|`sbyte`|부호 있는 바이트로 변환 합니다.|
|`int16`|부호 있는 16 비트 정수로 변환 합니다.|
|`uint16`|부호 없는 16 비트 정수로 변환 합니다.|
|`int32, int`|32 비트 부호 있는 정수로 변환 합니다.|
|`uint32`|32 비트 부호 없는 정수로 변환 합니다.|
|`int64`|64 비트 부호 있는 정수로 변환 합니다.|
|`uint64`|64 비트 부호 없는 정수로 변환 합니다.|
|`nativeint`|네이티브 정수로 변환 합니다.|
|`unativeint`|부호 없는 네이티브 정수로 변환 합니다.|
|`float, double`|64 비트 배정밀도 IEEE 부동 소수점 숫자로 변환 합니다.|
|`float32, single`|32 비트 단 정밀도 IEEE 부동 소수점 숫자로 변환 합니다.|
|`decimal`|`System.Decimal`로 변환 합니다.|
|`char`|유니코드 문자인 `System.Char`로 변환 합니다.|
|`enum`|열거형 형식으로 변환 합니다.|

기본 제공 되는 기본 형식 외에도 `op_Explicit`을 구현 하는 형식 또는 적절 한 서명이 있는 `op_Implicit` 메서드에 이러한 연산자를 사용할 수 있습니다. 예를 들어 `int` 변환 연산자는 형식을 매개 변수로 사용 하 고 `int`를 반환 하는 정적 메서드 `op_Explicit`를 제공 하는 모든 형식에서 작동 합니다. 반환 형식으로 메서드를 오버 로드할 수 없다는 일반적인 규칙에 대 한 특별 한 예외로, `op_Explicit` 및 `op_Implicit`에 대해이 작업을 수행할 수 있습니다.

## <a name="enumerated-types"></a>열거형 형식

`enum` 연산자는 변환할 `enum`의 형식을 나타내는 하나의 형식 매개 변수를 사용 하는 제네릭 연산자입니다. 열거형 형식으로 변환 하는 경우 형식 유추는 변환 하려는 `enum`의 형식을 결정 하려고 시도 합니다. 다음 예제에서 `col1` 변수는 명시적으로 주석이 지정 되지 않지만 해당 형식은 이후 같음 테스트에서 유추 됩니다. 따라서 컴파일러는 `Color` 열거형으로 변환 하는 것으로 추론할 수 있습니다. 또는 다음 예제의 `col2`와 마찬가지로 형식 주석을 제공할 수 있습니다.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet4402.fs)]

다음 코드와 같이 명시적으로 대상 열거 형식을 형식 매개 변수로 지정할 수도 있습니다.

```fsharp
let col3 = enum<Color> 3
```

열거형은 열거형의 내부 형식이 변환 중인 형식과 호환 되는 경우에만 작동 합니다. 다음 코드에서는 `int32`와 `uint32`의 불일치 때문에 변환이 컴파일되지 않습니다.

```fsharp
// Error: types are incompatible
let col4 : Color = enum 2u
```

자세한 내용은 [열거형](enumerations.md)을 참조 하세요.

## <a name="casting-object-types"></a>개체 형식 캐스팅

개체 계층 구조에서 형식 간의 변환은 개체 지향 프로그래밍의 기본입니다. 변환에는 두 가지 기본 형식 (업캐스팅)과 캐스팅 (좋기는)이 있습니다. 계층을 위로 캐스팅 하는 것은 파생 된 개체 참조에서 기본 개체 참조로 캐스팅 하는 것을 의미 합니다. 이러한 캐스트는 기본 클래스가 파생 클래스의 상속 계층 구조에 있는 한 작동 하도록 보장 됩니다. 계층에서 파생 된 개체 참조에 대 한 기본 개체 참조로 캐스팅 하는 것은 개체가 실제로 올바른 대상 (파생 된 대상) 형식의 인스턴스이거나 대상 형식에서 파생 된 형식인 경우에만 성공 합니다.

F#이러한 변환 형식에 대 한 연산자를 제공 합니다. `:>` 연산자는 계층을 위로 캐스팅 하 고 `:?>` 연산자는 계층 구조를 아래로 캐스팅 합니다.

### <a name="upcasting"></a>업캐스팅

많은 개체 지향 언어에서 업캐스팅는 암시적입니다. 에서 F#규칙은 약간 다릅니다. 업캐스팅는 개체 형식에 대 한 메서드에 인수를 전달 하면 자동으로 적용 됩니다. 그러나 모듈의 let 바인딩 함수의 경우 업캐스팅는 매개 변수 형식이 유연한 형식으로 선언 되지 않는 한 자동이 아닙니다. 자세한 내용은 [유연한 형식](flexible-Types.md)을 참조 하세요.

`:>` 연산자는 정적 캐스트를 수행 합니다. 즉, 캐스트의 성공은 컴파일 시간에 결정 됩니다. `:>`를 사용 하는 캐스팅이 성공적으로 컴파일되면 유효한 캐스트 이며 런타임에 오류가 발생 하지 않습니다.

`upcast` 연산자를 사용 하 여 이러한 변환을 수행할 수도 있습니다. 다음 식에서는 계층 구조를 변환 하는 방법을 지정 합니다.

```fsharp
upcast expression
```

업 캐스트 연산자를 사용 하는 경우 컴파일러는 컨텍스트에서 변환 하는 형식을 유추 하려고 합니다. 컴파일러가 대상 형식을 확인할 수 없는 경우 컴파일러에서 오류를 보고 합니다. 형식 주석이 필요할 수 있습니다.

### <a name="downcasting"></a>다운 캐스팅

`:?>` 연산자는 동적 캐스트를 수행 합니다. 즉, 캐스트의 성공은 런타임에 결정 됩니다. `:?>` 연산자를 사용 하는 캐스트는 컴파일 타임에 확인 되지 않습니다. 그러나 런타임에는 지정 된 형식으로 캐스팅 하려고 시도 합니다. 개체가 대상 형식과 호환 되 면 캐스팅이 성공 합니다. 개체가 대상 형식과 호환 되지 않으면 런타임에서는 `InvalidCastException`을 발생 시킵니다.

`downcast` 연산자를 사용 하 여 동적 형식 변환을 수행할 수도 있습니다. 다음 식에서는 프로그램 컨텍스트에서 유추 되는 형식에 대 한 계층 구조를 아래로 변환 합니다.

```fsharp
downcast expression
```

`upcast` 연산자의 경우와 같이 컴파일러가 컨텍스트에서 특정 대상 형식을 유추할 수 없는 경우 오류를 보고 합니다. 형식 주석이 필요할 수 있습니다.

다음 코드에서는 `:>` 및 `:?>` 연산자를 사용 하는 방법을 보여 줍니다. 이 코드는 변환이 실패할 경우 `InvalidCastException`을 throw 하기 때문에 변환이 성공 하는 것을 알고 있는 경우 `:?>` 연산자를 사용 하는 것을 보여 줍니다. 변환이 성공 하는 것이 확실 하지 않은 경우에는 예외를 생성 하는 오버 헤드를 방지 하기 때문에 `match` 식을 사용 하는 형식 테스트를 사용 하는 것이 더 좋습니다.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet4403.fs)]

제네릭 연산자 `downcast` 및 `upcast` 형식 유추를 사용 하 여 인수와 반환 형식을 결정 하므로 위의 코드에서 다음을 바꿀 수 있습니다.

```fsharp
let base1 = d1 :> Base1
```

을(를) 다음으로 바꾸면 됩니다.

```fsharp
let base1: Base1 = upcast d1
```

`upcast` 자체에서 기본 클래스를 확인할 수 없기 때문에 형식 주석이 필요 합니다.

## <a name="see-also"></a>참고 항목

- [F# 언어 참조](index.md)
