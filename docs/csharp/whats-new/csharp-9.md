---
title: C# 9.0의 새로운 기능 - C# 가이드
description: C# 9.0의 새로운 기능을 살펴봅니다.
ms.date: 09/04/2020
ms.openlocfilehash: 6a0227b408b894fe450c2a6bb6017d9059d229c0
ms.sourcegitcommit: c04535ad05e374fb269fcfc6509217755fbc0d54
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/25/2020
ms.locfileid: "91247620"
---
# <a name="whats-new-in-c-90"></a><span data-ttu-id="30172-103">C# 9.0의 새로운 기능</span><span class="sxs-lookup"><span data-stu-id="30172-103">What's new in C# 9.0</span></span>

<span data-ttu-id="30172-104">C# 9.0은 다음 기능과 개선 사항을 C# 언어에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-104">C# 9.0 adds the following features and enhancements to the C# language:</span></span>

- [<span data-ttu-id="30172-105">레코드</span><span class="sxs-lookup"><span data-stu-id="30172-105">Records</span></span>](#record-types)
- [<span data-ttu-id="30172-106">Init 전용 setter</span><span class="sxs-lookup"><span data-stu-id="30172-106">Init only setters</span></span>](#init-only-setters)
- [<span data-ttu-id="30172-107">최상위 문</span><span class="sxs-lookup"><span data-stu-id="30172-107">Top-level statements</span></span>](#top-level-statements)
- [<span data-ttu-id="30172-108">패턴 일치 개선 사항</span><span class="sxs-lookup"><span data-stu-id="30172-108">Pattern matching enhancements</span></span>](#pattern-matching-enhancements)
- <span data-ttu-id="30172-109">원시 크기 정수</span><span class="sxs-lookup"><span data-stu-id="30172-109">Native sized integers</span></span>
- <span data-ttu-id="30172-110">함수 포인터</span><span class="sxs-lookup"><span data-stu-id="30172-110">Function pointers</span></span>
- <span data-ttu-id="30172-111">localsinit 플래그 내보내기 무시</span><span class="sxs-lookup"><span data-stu-id="30172-111">Suppress emitting localsinit flag</span></span>
- <span data-ttu-id="30172-112">대상으로 형식화된 새 식</span><span class="sxs-lookup"><span data-stu-id="30172-112">Target-typed new expressions</span></span>
- <span data-ttu-id="30172-113">정적 무명 함수</span><span class="sxs-lookup"><span data-stu-id="30172-113">static anonymous functions</span></span>
- <span data-ttu-id="30172-114">대상으로 형식화된 조건식</span><span class="sxs-lookup"><span data-stu-id="30172-114">Target-typed conditional expressions</span></span>
- <span data-ttu-id="30172-115">공변 반환 형식</span><span class="sxs-lookup"><span data-stu-id="30172-115">Covariant return types</span></span>
- <span data-ttu-id="30172-116">`foreach` 루프에 대한 확장 `GetEnumerator` 지원</span><span class="sxs-lookup"><span data-stu-id="30172-116">Extension `GetEnumerator` support for `foreach` loops</span></span>
- <span data-ttu-id="30172-117">람다 무시 항목 매개 변수</span><span class="sxs-lookup"><span data-stu-id="30172-117">Lambda discard parameters</span></span>
- <span data-ttu-id="30172-118">로컬 함수의 특성</span><span class="sxs-lookup"><span data-stu-id="30172-118">Attributes on local functions</span></span>
- <span data-ttu-id="30172-119">모듈 이니셜라이저</span><span class="sxs-lookup"><span data-stu-id="30172-119">Module initializers</span></span>
- <span data-ttu-id="30172-120">부분 메서드에 대한 새로운 기능</span><span class="sxs-lookup"><span data-stu-id="30172-120">New features for partial methods</span></span>

<span data-ttu-id="30172-121">C# 9.0은 **.NET 5**에서 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="30172-121">C# 9.0 is supported on **.NET 5**.</span></span> <span data-ttu-id="30172-122">자세한 내용은 [C# 언어 버전 관리](../language-reference/configure-language-version.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="30172-122">For more information, see [C# language versioning](../language-reference/configure-language-version.md).</span></span>

## <a name="record-types"></a><span data-ttu-id="30172-123">레코드 유형</span><span class="sxs-lookup"><span data-stu-id="30172-123">Record types</span></span>

<span data-ttu-id="30172-124">C# 9.0에서는 같음에 대한 값 의미 체계를 제공하는 합성 메서드를 포함하는 참조 형식인 ***레코드 종류***가 도입되었습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-124">C# 9.0 introduces ***record types***, which are a reference type that provides synthesized methods to provide value semantics for equality.</span></span> <span data-ttu-id="30172-125">레코드는 기본적으로 변경할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-125">Records are immutable by default.</span></span>

<span data-ttu-id="30172-126">레코드 종류를 사용하면 .NET에서 변경할 수 없는 참조 형식을 쉽게 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-126">Record types make it easy to create immutable reference types in .NET.</span></span> <span data-ttu-id="30172-127">지금까지 .NET 형식은 크게 참조 형식(클래스 및 무명 형식 포함)과 값 형식(구조체 및 튜플 포함)으로 분류되었습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-127">Historically, .NET types are largely classified as reference types (including classes and anonymous types) and value types (including structs and tuples).</span></span> <span data-ttu-id="30172-128">변경할 수 없는 값 형식이 권장되지만, 변경 가능한 값 형식을 사용해도 오류가 자주 발생하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-128">While immutable value types are recommended, mutable value types don’t often introduce errors.</span></span> <span data-ttu-id="30172-129">값 형식 변수에는 값이 포함되므로 값 형식을 메서드에 전달할 때 원래 데이터의 복사본이 변경됩니다.</span><span class="sxs-lookup"><span data-stu-id="30172-129">Value type variables hold the values so changes are made to a copy of the original data when value types are passed to methods.</span></span>

<span data-ttu-id="30172-130">변경할 수 없는 참조 형식에도 많은 이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-130">There are many advantages to immutable reference types as well.</span></span> <span data-ttu-id="30172-131">이러한 이점은 공유 데이터를 사용하는 동시 프로그램에서 더욱 두드러지게 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="30172-131">These advantages are more pronounced in concurrent programs with shared data.</span></span> <span data-ttu-id="30172-132">아쉽게도 C#에서는 변경할 수 없는 참조 형식을 만들기 위한 상당한 추가 코드를 작성해야 했습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-132">Unfortunately, C# forced you to write quite a bit of extra code to create immutable reference types.</span></span> <span data-ttu-id="30172-133">레코드는 같음에 대한 값 의미 체계를 사용하는, 변경할 수 없는 참조 형식의 형식 선언을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-133">Records provide a type declaration for an immutable reference type that uses value semantics for equality.</span></span> <span data-ttu-id="30172-134">같음 및 해시 코드에 대한 합성 메서드는 해당 속성이 모두 동일한 경우 두 레코드가 같다고 간주합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-134">The synthesized methods for equality and hash codes consider two records equal if their properties are all equal.</span></span> <span data-ttu-id="30172-135">다음과 같은 정의를 고려해 보세요.</span><span class="sxs-lookup"><span data-stu-id="30172-135">Consider this definition:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="RecordDefinition":::

<span data-ttu-id="30172-136">레코드 정의에서 `FirstName` 및 `LastName`이라는 두 개의 읽기 전용 속성을 포함하는 `Person` 형식을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="30172-136">The record definition creates a `Person` type that contains two readonly properties: `FirstName` and `LastName`.</span></span> <span data-ttu-id="30172-137">`Person` 형식은 참조 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="30172-137">The `Person` type is a reference type.</span></span> <span data-ttu-id="30172-138">IL을 확인했다면 이 형식은 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="30172-138">If you looked at the IL, it’s a class.</span></span> <span data-ttu-id="30172-139">생성된 후에는 속성을 수정할 수 없다는 점에서 변경할 수 없는 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="30172-139">It’s immutable in that none of the properties can be modified once it's been created.</span></span> <span data-ttu-id="30172-140">레코드 종류를 정의하면 컴파일러에서 다른 여러 메서드를 자동으로 합성합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-140">When you define a record type, the compiler synthesizes several other methods for you:</span></span>

- <span data-ttu-id="30172-141">값 기반 같음 비교 메서드</span><span class="sxs-lookup"><span data-stu-id="30172-141">Methods for value-based equality comparisons</span></span>
- <span data-ttu-id="30172-142"><xref:System.Object.GetHashCode> 재정의</span><span class="sxs-lookup"><span data-stu-id="30172-142">Override for <xref:System.Object.GetHashCode></span></span>
- <span data-ttu-id="30172-143">멤버 복사 및 복제</span><span class="sxs-lookup"><span data-stu-id="30172-143">Copy and Clone members</span></span>
- <span data-ttu-id="30172-144">`PrintMembers` 및 <xref:System.Object.ToString></span><span class="sxs-lookup"><span data-stu-id="30172-144">`PrintMembers` and <xref:System.Object.ToString></span></span>

<span data-ttu-id="30172-145">레코드는 상속을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-145">Records support inheritance.</span></span> <span data-ttu-id="30172-146">`Person`에서 파생된 새 레코드를 다음과 같이 선언할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-146">You can declare a new record derived from `Person` as follows:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="InheritedRecord":::

<span data-ttu-id="30172-147">추가 파생을 방지하기 위해 레코드를 봉인할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-147">You can also seal records to prevent further derivation:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="SealedRecord":::

<span data-ttu-id="30172-148">컴파일러는 위 메서드의 여러 버전을 합성합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-148">The compiler synthesizes different versions of the methods above.</span></span> <span data-ttu-id="30172-149">메서드 시그니처는 레코드 종류가 sealed인지 여부와 직접 기본 클래스가 object인지 여부에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="30172-149">The method signatures depend on if the record type is sealed and if the direct base class is object.</span></span> <span data-ttu-id="30172-150">레코드에는 다음 기능이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-150">Records should have the following capabilities:</span></span>

- <span data-ttu-id="30172-151">같음은 값을 기반으로 하며 형식 일치 검사를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-151">Equality is value-based, and includes a check that the types match.</span></span> <span data-ttu-id="30172-152">예를 들어 `Student`는 두 레코드가 동일한 이름을 공유하는 경우에도 `Person`과 같을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-152">For example, a `Student` can't be equal to a `Person`, even if the two records share the same name.</span></span>
- <span data-ttu-id="30172-153">레코드의 문자열 표현이 일관성 있게 자동으로 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="30172-153">Records have a consistent string representation generated for you.</span></span>
- <span data-ttu-id="30172-154">레코드에서 복사본 생성을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-154">Records support copy construction.</span></span> <span data-ttu-id="30172-155">올바른 복사본 생성에는 상속 계층 구조와 개발자가 추가한 속성이 포함되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-155">Correct copy construction must include inheritance hierarchies, and properties added by developers.</span></span>
- <span data-ttu-id="30172-156">수정 내용과 함께 레코드를 복사할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-156">Records can be copied with modification.</span></span> <span data-ttu-id="30172-157">복사 및 수정 작업에서 비파괴적 변경을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-157">These copy and modify operations supports non-destructive mutation.</span></span>

<span data-ttu-id="30172-158">컴파일러는 익숙한 `Equals` 오버로드, `operator ==`, `operator !=` 외에도 새 `EqualityContract` 속성을 합성합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-158">In addition to the familiar `Equals` overloads, `operator ==`, and `operator !=`, the compiler synthesizes a new `EqualityContract` property.</span></span> <span data-ttu-id="30172-159">이 속성은 레코드 종류와 일치하는 `Type` 개체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-159">The property returns a `Type` object that matches the type of the record.</span></span> <span data-ttu-id="30172-160">기본 형식이 `object`이면 속성은 `virtual`이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="30172-160">If the base type is `object`, the property is `virtual`.</span></span> <span data-ttu-id="30172-161">기본 형식이 다른 레코드 종류이면 속성은 `override`가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="30172-161">If the base type is another record type, the property is an `override`.</span></span> <span data-ttu-id="30172-162">레코드 종류가 `sealed`이면 속성은 `sealed`가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="30172-162">If the record type is `sealed`, the property is `sealed`.</span></span> <span data-ttu-id="30172-163">합성된 `GetHashCode`는 기본 형식 및 레코드 종류에 선언된 모든 속성과 필드의 `GetHashCode`를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-163">The synthesized `GetHashCode` uses the `GetHashCode` from all properties and fields declared in the base type and the record type.</span></span> <span data-ttu-id="30172-164">해당 합성 메서드는 상속 계층 구조 전체에 값 기반 같음을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-164">These synthesized methods enforce value-based equality throughout an inheritance hierarchy.</span></span> <span data-ttu-id="30172-165">즉, `Student`는 동일한 이름을 가진 `Person`과 같다고 간주하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-165">That means a `Student` will never be considered equal to a `Person` with the same name.</span></span> <span data-ttu-id="30172-166">레코드 종류 간에 공유되는 모든 속성이 같을 뿐 아니라 두 레코드 종류도 일치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-166">The types of the two records must match as well as all properties shared among the record types being equal.</span></span>

<span data-ttu-id="30172-167">또한 레코드에는 합성 생성자와 복사본을 만들기 위한 “clone” 메서드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-167">Records also have a synthesized constructor and a "clone" method for creating copies.</span></span> <span data-ttu-id="30172-168">합성 생성자에는 레코드 종류의 인수가 하나 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-168">The synthesized constructor has one argument of the record type.</span></span> <span data-ttu-id="30172-169">합성 생성자는 레코드의 모든 속성에 동일한 값을 사용하여 새 레코드를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-169">It produces a new record with the same values for all properties of the record.</span></span> <span data-ttu-id="30172-170">레코드가 sealed이면 해당 생성자는 private이 되고, 그렇지 않으면 protected가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="30172-170">This constructor is private if the record is sealed, otherwise it's protected.</span></span> <span data-ttu-id="30172-171">합성된 “clone” 메서드는 레코드 계층 구조의 복사본 생성을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-171">The synthesized "clone" method supports copy construction for record hierarchies.</span></span> <span data-ttu-id="30172-172">실제 이름이 컴파일러에서 생성되기 때문에 “clone” 용어는 따옴표 안에 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="30172-172">The term "clone" is in quotes because the actual name is compiler generated.</span></span> <span data-ttu-id="30172-173">레코드 종류에 `Clone`이라는 메서드를 만들 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-173">You can't create a method named `Clone` in a record type.</span></span> <span data-ttu-id="30172-174">합성된 “clone” 메서드는 가상 디스패치를 사용하여 복사되는 레코드 종류를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-174">The synthesized "clone" method returns the type of record being copied using virtual dispatch.</span></span> <span data-ttu-id="30172-175">컴파일러는 `record`의 액세스 한정자에 따라 “clone” 메서드에 대해 다른 한정자를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-175">The compiler adds different modifiers for the "clone" method depending on the access modifiers on the `record`:</span></span>

- <span data-ttu-id="30172-176">레코드 종류가 `abstract`이면 “clone” 메서드도 `abstract`가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="30172-176">If the record type is `abstract`, the "clone" method is also `abstract`.</span></span> <span data-ttu-id="30172-177">기본 형식이 `object`가 아니면 메서드도 `override`가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="30172-177">If the base type isn't `object`, the method is also `override`.</span></span>
- <span data-ttu-id="30172-178">기본 형식이 `object`일 때 `abstract`가 아닌 레코드 종류의 경우:</span><span class="sxs-lookup"><span data-stu-id="30172-178">For record types that aren't `abstract` when the base type is `object`:</span></span>
  - <span data-ttu-id="30172-179">레코드가 `sealed`이면 “clone” 메서드에 한정자가 추가되지 않습니다(즉, `virtual`이 아님).</span><span class="sxs-lookup"><span data-stu-id="30172-179">If the record is `sealed`, no additional modifiers are added to the "clone" method (meaning it is not `virtual`).</span></span>
  - <span data-ttu-id="30172-180">레코드가 `sealed`가 아니면 “clone” 메서드는 `virtual`이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="30172-180">If the record isn't `sealed`, the "clone" method is `virtual`.</span></span>
- <span data-ttu-id="30172-181">기본 형식이 `object`가 아닐 때 `abstract`가 아닌 레코드 종류의 경우:</span><span class="sxs-lookup"><span data-stu-id="30172-181">For record types that aren't `abstract` when the base type is not `object`:</span></span>
  - <span data-ttu-id="30172-182">레코드가 `sealed`이면 “clone” 메서드도 `sealed`가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="30172-182">If the record is `sealed`, the "clone" method is also `sealed`.</span></span>
  - <span data-ttu-id="30172-183">레코드가 `sealed`가 아니면 “clone” 메서드는 `override`가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="30172-183">If the record isn't `sealed`, the "clone" method is `override`.</span></span>

<span data-ttu-id="30172-184">모든 규칙의 결과로, 모든 레코드 종류 계층 구조에서 같음이 일관되게 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="30172-184">The result of all these rules is the equality is implemented consistently across any hierarchy of record types.</span></span> <span data-ttu-id="30172-185">다음 예제와 같이 해당 속성과 종류가 동일하면 두 레코드는 같습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-185">Two records are equal to each other if their properties are equal and their types are the same, as shown in the following example:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="RecordsEquality":::

<span data-ttu-id="30172-186">컴파일러는 인쇄 출력을 지원하는 두 가지 메서드인 <xref:System.Object.ToString> 재정의와 `PrintMembers`를 합성합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-186">The compiler synthesizes two methods that support printed output: a <xref:System.Object.ToString> override, and `PrintMembers`.</span></span> <span data-ttu-id="30172-187">`PrintMembers`는 <xref:System.Text.StringBuilder?displayProperty=nameWithType>을 인수로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-187">The `PrintMembers` takes a <xref:System.Text.StringBuilder?displayProperty=nameWithType> as its argument.</span></span> <span data-ttu-id="30172-188">레코드 종류의 모든 속성에 대해 쉼표로 구분된 속성 이름 및 값 목록이 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="30172-188">It appends a comma-separated list of property names and values for all properties in the record type.</span></span> <span data-ttu-id="30172-189">`PrintMembers`는 다른 레코드에서 파생된 모든 레코드에 대해 기본 구현을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-189">`PrintMembers` calls the base implementation for any records derived from other records.</span></span> <span data-ttu-id="30172-190"><xref:System.Object.ToString> 재정의는 `PrintMembers`에서 생성된 문자열을 `{` 및 `}`로 묶어 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-190">The <xref:System.Object.ToString> override returns the string produced by `PrintMembers`, surrounded by `{` and `}`.</span></span> <span data-ttu-id="30172-191">예를 들어 `Student`의 <xref:System.Object.ToString> 메서드는 다음 코드와 같이 `string`을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-191">For example, the <xref:System.Object.ToString> method for `Student` returns a `string` like the following code:</span></span>

```csharp
"Student { LastName = Wagner, FirstName = Bill, Level = 11 }"
```

<span data-ttu-id="30172-192">지금까지 살펴본 예제에서는 일반적인 구문을 사용하여 속성을 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-192">The examples shown so far use traditional syntax to declare properties.</span></span> <span data-ttu-id="30172-193">***위치 레코드***라는 보다 간결한 형식이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-193">There's a more concise form called ***positional records***.</span></span>  <span data-ttu-id="30172-194">다음은 앞에서 위치 레코드로 정의된 세 가지 레코드 종류입니다.</span><span class="sxs-lookup"><span data-stu-id="30172-194">Here are the three record types defined earlier as positional records:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="PositionalRecords":::

<span data-ttu-id="30172-195">이 선언에서는 이전 버전과 동일한 기능을 만듭니다(다음 섹션에서 설명하는 몇 가지 추가 기능 포함).</span><span class="sxs-lookup"><span data-stu-id="30172-195">These declarations create the same functionality as the earlier version (with a couple extra features covered in the following section).</span></span> <span data-ttu-id="30172-196">레코드에서 메서드를 추가하지 않으므로 이 선언은 대괄호가 아닌 세미콜론으로 끝납니다.</span><span class="sxs-lookup"><span data-stu-id="30172-196">These declarations end with a semicolon instead of brackets because these records don't add additional methods.</span></span> <span data-ttu-id="30172-197">본문을 추가하고 다른 메서드도 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-197">You can add a body, and include any additional methods as well:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="RecordsWithMethods":::

<span data-ttu-id="30172-198">컴파일러는 위치 레코드의 `Deconstruct` 메서드를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-198">The compiler produces a `Deconstruct` method for positional records.</span></span> <span data-ttu-id="30172-199">`Deconstruct` 메서드에는 레코드 종류의 모든 public 속성 이름과 일치하는 매개 변수가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-199">The `Deconstruct` method has parameters that match the names of all public properties in the record type.</span></span> <span data-ttu-id="30172-200">`Deconstruct` 메서드를 사용하여 레코드를 구성 요소 속성으로 분해할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-200">The `Deconstruct` method can be used to deconstruct the record into its component properties:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="DeconstructRecord":::

<span data-ttu-id="30172-201">마지막으로, 레코드는 ***with-expression***을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-201">Finally, records support ***with-expressions***.</span></span> <span data-ttu-id="30172-202">***with-expression***은 컴파일러에 레코드 복사본을 만들지만 *with*에 지정된 속성을 수정하도록 지시합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-202">A ***with-expression*** instructs the compiler to create a copy of a record, but *with* specified properties modified:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="Wither":::

<span data-ttu-id="30172-203">위 줄에서는 `LastName` 속성이 `person`의 복사본이고 `FirstName`이 “Paul”인 새 `Person` 레코드를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="30172-203">The above line creates a new `Person` record where the `LastName` property is a copy of `person`, and the `FirstName` is "Paul".</span></span> <span data-ttu-id="30172-204">with-expression에 속성을 원하는 개수만큼 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-204">You can set any number of properties in a with-expression.</span></span>  <span data-ttu-id="30172-205">“clone” 메서드를 제외한 모든 합성 멤버를 직접 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-205">Any of the synthesized members except the "clone" method may be written by you.</span></span> <span data-ttu-id="30172-206">레코드 종류에 합성 메서드의 시그니처와 일치하는 메서드가 있는 경우 해당 메서드는 컴파일러에서 합성되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-206">If a record type has a method that matches the signature of any synthesized method, the compiler doesn't synthesize that method.</span></span> <span data-ttu-id="30172-207">앞의 `Dog` 레코드 예제에는 수동 코딩된 <xref:System.String.ToString> 메서드가 예제로 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-207">The earlier `Dog` record example contains a hand coded <xref:System.String.ToString> method as an example.</span></span>

## <a name="init-only-setters"></a><span data-ttu-id="30172-208">Init 전용 setter</span><span class="sxs-lookup"><span data-stu-id="30172-208">Init only setters</span></span>

<span data-ttu-id="30172-209">***Init 전용 setter***는 개체의 멤버를 초기화하는 일관성 있는 구문을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-209">***Init only setters*** provide consistent syntax to initialize members of an object.</span></span> <span data-ttu-id="30172-210">속성 이니셜라이저를 사용하면 어떤 값이 어떤 속성을 설정하는지 명확하게 파악할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-210">Property initializers make it clear which value is setting which property.</span></span> <span data-ttu-id="30172-211">단점은 해당 속성이 설정 가능해야 한다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="30172-211">The downside is that those properties must be settable.</span></span> <span data-ttu-id="30172-212">C# 9.0부터 속성 및 인덱서에 대해 `set` 접근자 대신 `init` 접근자를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-212">Starting with C# 9.0, you can create `init` accessors instead of `set` accessors for properties and indexers.</span></span> <span data-ttu-id="30172-213">호출자는 속성 이니셜라이저 구문을 사용하여 생성 식에서 해당 값을 설정할 수 있지만, 생성이 완료되고 나면 readonly 속성이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="30172-213">Callers can use property initializer syntax to set these values in creation expressions, but those properties are readonly once construction has completed.</span></span> <span data-ttu-id="30172-214">Init 전용 setter는 상태 변경 창을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-214">Init only setters provide a window to change state.</span></span> <span data-ttu-id="30172-215">이 창은 생성 단계가 끝날 때 닫힙니다.</span><span class="sxs-lookup"><span data-stu-id="30172-215">That window closes when the construction phase ends.</span></span> <span data-ttu-id="30172-216">속성 이니셜라이저 및 with-expression을 비롯한 모든 초기화가 완료되면 생성 단계가 사실상 끝납니다.</span><span class="sxs-lookup"><span data-stu-id="30172-216">The construction phase effectively ends after all initialization, including property initializers and with-expressions have completed.</span></span>

<span data-ttu-id="30172-217">위치 레코드에 대한 앞의 예제에서는 init 전용 setter를 사용하여 with expression으로 속성을 설정하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="30172-217">The preceding example for positional records demonstrates using an init-only setter to set a property using a with expression.</span></span> <span data-ttu-id="30172-218">작성하는 모든 종류에서 init 전용 setter를 선언할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-218">You can declare init only setters in any type you write.</span></span> <span data-ttu-id="30172-219">예를 들어 다음 구조체는 기상 관측 구조체를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-219">For example, the following struct defines a weather observation structure:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/WeatherObservation.cs" ID="DeclareWeatherObservation":::

<span data-ttu-id="30172-220">호출자는 불변성을 유지하면서 속성 이니셜라이저 구문을 사용하여 값을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-220">Callers can use property initializer syntax to set the values, while still preserving the immutability:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/WeatherObservation.cs" ID="UseWeatherObservation":::

<span data-ttu-id="30172-221">하지만 초기화 후 관측을 변경할 경우 초기화 외부에서 init 전용 속성에 할당하여 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-221">But, changing an observation after initialization is an error by assigning to an init-only property outside of initialization:</span></span>

```csharp
// Error! CS8852.
now.TemperatureInCelsius = 18;
```

<span data-ttu-id="30172-222">init 전용 setter는 파생 클래스에서 기본 클래스 속성을 설정하는 데 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-222">Init only setters can be useful to set base class properties from derived classes.</span></span> <span data-ttu-id="30172-223">기본 클래스의 도우미를 통해 파생 속성을 설정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-223">They can also set derived properties through helpers in a base class.</span></span> <span data-ttu-id="30172-224">위치 레코드는 init 전용 setter를 사용하여 속성을 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-224">Positional records declare properties using init only setters.</span></span> <span data-ttu-id="30172-225">해당 setter는 with-expression에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="30172-225">Those setters are used in with-expressions.</span></span> <span data-ttu-id="30172-226">정의하는 모든 `class` 또는 `struct`에 대해 Init 전용 setter를 선언할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-226">You can declare init only setters for any `class` or `struct` you define.</span></span>

## <a name="top-level-statements"></a><span data-ttu-id="30172-227">최상위 문</span><span class="sxs-lookup"><span data-stu-id="30172-227">Top-level statements</span></span>

<span data-ttu-id="30172-228">***최상위 문***은 많은 애플리케이션에서 불필요한 공식 절차를 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-228">***Top-level statements*** remove unnecessary ceremony from many applications.</span></span> <span data-ttu-id="30172-229">정식 “Hello World!”</span><span class="sxs-lookup"><span data-stu-id="30172-229">Consider the canonical "Hello World!"</span></span> <span data-ttu-id="30172-230">프로그램을 고려해 보세요.</span><span class="sxs-lookup"><span data-stu-id="30172-230">program:</span></span>

```csharp
using System;

namespace HelloWorld
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}
```

<span data-ttu-id="30172-231">작업을 수행하는 코드 줄은 1줄뿐입니다.</span><span class="sxs-lookup"><span data-stu-id="30172-231">There’s only one line of code that does anything.</span></span> <span data-ttu-id="30172-232">최상위 문을 사용하면 모든 상용구를 `using` 문과 작업을 수행하는 1줄로 바꿀 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-232">With top-level statements, you can replace all that boilerplate with the `using` statement and the single line that does the work:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/Program.cs" ID="TopLevelStatements":::

<span data-ttu-id="30172-233">1줄 프로그램을 원하는 경우 `using` 지시문을 제거하고 정규화된 형식 이름을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-233">If you wanted a one-line program, you could remove the `using` directive and use the fully qualified type name:</span></span>

```csharp
System.Console.WriteLine("Hello World!");
```

<span data-ttu-id="30172-234">애플리케이션의 한 파일에서만 최상위 문을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-234">Only one file in your application may use top-level statements.</span></span> <span data-ttu-id="30172-235">컴파일러가 여러 소스 파일에서 최상위 문을 발견할 경우 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-235">If the compiler finds top-level statements in multiple source files, it’s an error.</span></span> <span data-ttu-id="30172-236">일반적으로 `Main` 메서드인 선언된 프로그램 진입점 메서드와 최상위 문을 결합하는 경우에도 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-236">It’s also an error if you combine top-level statements with a declared program entry point method, typically a `Main` method.</span></span> <span data-ttu-id="30172-237">따라서 일반적으로 `Program` 클래스의 `Main` 메서드에 있는 문이 한 파일에 포함되어 있다고 생각할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-237">In a sense, you can think that one file contains the statements that would normally be in the `Main` method of a `Program` class.</span></span>  

<span data-ttu-id="30172-238">이 기능의 가장 일반적인 용도 중 하나는 교육 자료를 만드는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="30172-238">One of the most common uses for this feature is creating teaching materials.</span></span> <span data-ttu-id="30172-239">초급 C# 개발자가 1~2줄의 코드로 정식 “Hello World!”를</span><span class="sxs-lookup"><span data-stu-id="30172-239">Beginner C# developers can write the canonical “Hello World!”</span></span> <span data-ttu-id="30172-240">작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-240">in one or two lines of code.</span></span> <span data-ttu-id="30172-241">추가 공식 절차가 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-241">None of the extra ceremony is needed.</span></span> <span data-ttu-id="30172-242">그러나 숙련된 개발자도 이 기능의 다양한 용도를 발견하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="30172-242">However, seasoned developers will find many uses for this feature as well.</span></span> <span data-ttu-id="30172-243">최상위 수준 문을 통해 Jupyter Notebook에서 제공하는 것과 비슷한 스크립트 유사 환경을 실험용으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-243">Top-level statements enable a script-like experience for experimentation similar to what Jupyter notebooks provide.</span></span> <span data-ttu-id="30172-244">최상위 수준 문은 작은 콘솔 프로그램 및 유틸리티에 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-244">Top-level statements are great for small console programs and utilities.</span></span> <span data-ttu-id="30172-245">Azure 함수는 최상위 문의 이상적인 사용 사례입니다.</span><span class="sxs-lookup"><span data-stu-id="30172-245">Azure functions are an ideal use case for top-level statements.</span></span>

<span data-ttu-id="30172-246">가장 중요한 점은 최상위 문이 애플리케이션의 범위나 복잡성을 제한하지 않는다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="30172-246">Most importantly, top-level statements don't limit your application’s scope or complexity.</span></span> <span data-ttu-id="30172-247">해당 문은 모든 .NET 클래스에 액세스하거나 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-247">Those statements can access or use any .NET class.</span></span> <span data-ttu-id="30172-248">또한 명령줄 인수나 반환 값의 사용을 제한하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-248">They also don’t limit your use of command-line arguments or return values.</span></span> <span data-ttu-id="30172-249">최상위 문은 args라는 문자열 배열에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-249">Top-level statements can access an array of strings named args.</span></span> <span data-ttu-id="30172-250">최상위 문에서 정수 값을 반환하는 경우 해당 값은 합성된 `Main` 메서드의 정수 반환 코드가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="30172-250">If the top-level statements return an integer value, that value becomes the integer return code from a synthesized `Main` method.</span></span> <span data-ttu-id="30172-251">최상위 문에 비동기 식을 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-251">The top-level statements may contain async expressions.</span></span> <span data-ttu-id="30172-252">이 경우 합성 진입점은 `Task` 또는 `Task<int>`를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-252">In that case, the synthesized entry point returns a `Task`, or `Task<int>`.</span></span>

## <a name="pattern-matching-enhancements"></a><span data-ttu-id="30172-253">패턴 일치 개선 사항</span><span class="sxs-lookup"><span data-stu-id="30172-253">Pattern matching enhancements</span></span>

<span data-ttu-id="30172-254">C# 9에는 새로운 패턴 일치 개선 사항이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-254">C# 9 includes new pattern matching improvements:</span></span>

- <span data-ttu-id="30172-255">***형식 패턴***은 변수를 형식과 일치시킵니다.</span><span class="sxs-lookup"><span data-stu-id="30172-255">***Type patterns*** match a variable is a type</span></span>
- <span data-ttu-id="30172-256">***괄호로 묶인 패턴***은 패턴 조합의 우선 순위를 적용하거나 강조합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-256">***Parenthesized patterns*** enforce or emphasize the precedence of pattern combinations</span></span>
- <span data-ttu-id="30172-257">***결합 `and` 패턴***은 두 패턴이 모두 일치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-257">***Conjunctive `and` patterns*** require both patterns to match</span></span>
- <span data-ttu-id="30172-258">***분리 `or` 패턴***은 패턴 중 하나가 일치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-258">***Disjunctive `or` patterns*** require either pattern to match</span></span>
- <span data-ttu-id="30172-259">***부정 `not` 패턴***은 패턴이 일치하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-259">***Negated `not` patterns*** require that a pattern doesn’t match</span></span>
- <span data-ttu-id="30172-260">***관계형 패턴***은 입력과 지정된 상수 간에 작음, 큼, 작거나 같음, 크거나 같음 또는 같음 관계가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-260">***Relational patterns*** require the input be less than, greater than, less than or equal, or greater than or equal to a given constant.</span></span>

<span data-ttu-id="30172-261">새로운 패턴은 패턴 구문을 보강합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-261">These patterns enrich the syntax for patterns.</span></span> <span data-ttu-id="30172-262">이 예제를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="30172-262">Consider these examples:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PatternUtilities.cs" ID="IsLetterPattern":::

<span data-ttu-id="30172-263">또는 선택적 괄호를 사용하여 `and`에 `or`보다 높은 우선 순위가 있음을 명확하게 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-263">Alternatively, with optional parentheses to make it clear that `and` has higher precedence than `or`:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PatternUtilities.cs" ID="IsLetterOrSeparatorPattern":::

<span data-ttu-id="30172-264">가장 일반적인 용도 중 하나는 새로운 null 검사 구문입니다.</span><span class="sxs-lookup"><span data-stu-id="30172-264">One of the most common uses is a new syntax for a null check:</span></span>

```csharp
if (e is not null)
{
    // ...
}
```

<span data-ttu-id="30172-265">`is` 패턴 식, `switch` 식, 중첩 패턴, `switch` 문의 `case` 레이블 패턴 등 패턴이 허용되는 모든 컨텍스트에서 새로운 패턴을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-265">Any of these patterns can be used in any context where patterns are allowed: `is` pattern expressions, `switch` expressions, nested patterns, and the pattern of a `switch` statement’s `case` label.</span></span>

## <a name="performance-and-interop"></a><span data-ttu-id="30172-266">성능 및 interop</span><span class="sxs-lookup"><span data-stu-id="30172-266">Performance and interop</span></span>

<span data-ttu-id="30172-267">원시 크기 정수, 함수 포인터, `localsinit` 플래그 생략의 세 가지 새로운 기능을 통해 고성능이 필요한 하위 수준 라이브러리 및 네이티브 interop 지원이 향상되었습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-267">Three new features improve support for native interop and low-level libraries that require high performance: native sized integers, function pointers, and omitting the `localsinit` flag.</span></span>

<span data-ttu-id="30172-268">원시 크기 정수인 `nint` 및 `nuint`는 정수 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="30172-268">Native sized integers, `nint` and `nuint`, are integer types.</span></span> <span data-ttu-id="30172-269">기본 형식 <xref:System.IntPtr?displayProperty=nameWithType> 및 <xref:System.UIntPtr?displayProperty=nameWithType>으로 표현됩니다.</span><span class="sxs-lookup"><span data-stu-id="30172-269">They're expressed by the underlying types <xref:System.IntPtr?displayProperty=nameWithType> and <xref:System.UIntPtr?displayProperty=nameWithType>.</span></span> <span data-ttu-id="30172-270">컴파일러는 해당 형식의 추가 변환과 연산을 네이티브 정수 형식으로 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-270">The compiler surfaces additional conversions and operations for these types as native ints.</span></span> <span data-ttu-id="30172-271">`MinValue`가 `0`인 `nuint.MinValue`를 제외하고, 원시 크기 정수에는 `MaxValue` 또는 `MinValue` 상수가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-271">Native sized ints don't have constants for `MaxValue` or `MinValue`, except for `nuint.MinValue`, which has a `MinValue` of `0`.</span></span> <span data-ttu-id="30172-272">다른 값은 대상 머신의 정수 원시 크기에 따라 달라지므로 상수로 표현할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-272">Other values can't be expressed as constants because it depends on the native size of an integer on the target machine.</span></span> <span data-ttu-id="30172-273">다음 범위에서 `nint`의 상수 값을 사용할 수 있습니다. [`int.MinValue` ..</span><span class="sxs-lookup"><span data-stu-id="30172-273">You can use constant values for `nint` in the range [`int.MinValue` ..</span></span> <span data-ttu-id="30172-274">`int.MaxValue`].</span><span class="sxs-lookup"><span data-stu-id="30172-274">`int.MaxValue`].</span></span> <span data-ttu-id="30172-275">다음 범위에서 `nuint`의 상수 값을 사용할 수 있습니다. [`uint.MinValue` ..</span><span class="sxs-lookup"><span data-stu-id="30172-275">You can use constant values for `nuint` in the range [`uint.MinValue` ..</span></span> <span data-ttu-id="30172-276">`uint.MaxValue`].</span><span class="sxs-lookup"><span data-stu-id="30172-276">`uint.MaxValue`].</span></span> <span data-ttu-id="30172-277">컴파일러는 <xref:System.Int32?displayProperty=nameWithType> 및 <xref:System.UInt32?displayProperty=nameWithType> 형식을 사용하여 모든 단항 및 이진 연산자에 대해 상수 정리를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-277">The compiler performs constant folding for all unary and binary operators using the <xref:System.Int32?displayProperty=nameWithType> and <xref:System.UInt32?displayProperty=nameWithType> types.</span></span> <span data-ttu-id="30172-278">결과가 32비트에 맞지 않으면 런타임에 연산이 실행되고 상수로 간주하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-278">If the result doesn't fit in 32 bits, the operation is executed at runtime and isn't considered a constant.</span></span> <span data-ttu-id="30172-279">정수 연산이 광범위하게 사용되고 가장 빠른 성능이 필요한 시나리오에서는 원시 크기 정수를 사용하여 성능을 향상할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-279">Native sized integers can increase performance in scenarios where integer math is used extensively and needs to have the fastest performance possible.</span></span>

<span data-ttu-id="30172-280">함수 포인터는 IL opcode `ldftn` 및 `calli`에 액세스하는 편리한 구문을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-280">Function pointers provide an easy syntax to access the IL opcodes `ldftn` and `calli`.</span></span> <span data-ttu-id="30172-281">새로운 `delegate*` 구문을 사용하여 함수 포인터를 선언할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-281">You can declare function pointers using new `delegate*` syntax.</span></span> <span data-ttu-id="30172-282">`delegate*` 형식은 포인터 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="30172-282">A `delegate*` type is a pointer type.</span></span> <span data-ttu-id="30172-283">`delegate*` 형식을 호출하면 `Invoke()` 메서드에서 `callvirt`를 사용하는 대리자와는 달리 `calli`가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="30172-283">Invoking the `delegate*` type uses `calli`, in contrast to a delegate that uses `callvirt` on the `Invoke()` method.</span></span> <span data-ttu-id="30172-284">호출 구문은 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-284">Syntactically, the invocations are identical.</span></span> <span data-ttu-id="30172-285">함수 포인터 호출은 `managed` 호출 규칙을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-285">Function pointer invocation uses the `managed` calling convention.</span></span> <span data-ttu-id="30172-286">`delegate*` 구문 뒤에 `unmanaged` 키워드를 추가하여 `unmanaged` 호출 규칙을 사용하도록 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-286">You add the `unmanaged` keyword after the `delegate*` syntax to declare that you want the `unmanaged` calling convention.</span></span> <span data-ttu-id="30172-287">`delegate*` 선언에서 특성을 사용하여 다른 호출 규칙을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-287">Other calling conventions can be specified using attributes on the `delegate*` declaration.</span></span>

<span data-ttu-id="30172-288">마지막으로, <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute?displayProperty=nameWithType>을 추가하여 컴파일러에 `localsinit` 플래그를 내보내지 않도록 지시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-288">Finally, you can add the <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute?displayProperty=nameWithType> to instruct the compiler not to emit the `localsinit` flag.</span></span> <span data-ttu-id="30172-289">이 플래그는 모든 지역 변수를 0으로 초기화하도록 CLR에 지시합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-289">This flag instructs the CLR to zero-initialize all local variables.</span></span> <span data-ttu-id="30172-290">`localsinit` 플래그는 1.0부터 C#의 기본 동작이었습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-290">The `localsinit` flag has been the default behavior for C# since 1.0.</span></span> <span data-ttu-id="30172-291">그러나 0으로 초기화를 추가로 수행할 경우 일부 시나리오에서 성능에 상당한 영향을 미칠 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-291">However, the extra zero-initialization may have measurable performance impact in some scenarios.</span></span> <span data-ttu-id="30172-292">특히, `stackalloc`를 사용하는 경우에 해당합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-292">In particular, when you use `stackalloc`.</span></span> <span data-ttu-id="30172-293">이 경우에는 <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute>를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-293">In those cases, you can add the <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute>.</span></span> <span data-ttu-id="30172-294">단일 메서드 또는 속성이나 `class`, `struct`, `interface` 또는 모듈에 추가할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-294">You may add it to a single method or property, or to a `class`, `struct`, `interface`, or even a module.</span></span> <span data-ttu-id="30172-295">이 특성은 `abstract` 메서드에는 영향을 주지 않고, 구현과 관련해서 생성된 코드에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="30172-295">This attribute doesn't affect `abstract` methods; it affects the code generated for the implementation.</span></span>

<span data-ttu-id="30172-296">위의 기능은 일부 시나리오에서 성능을 향상할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-296">These features can improve performance in some scenarios.</span></span> <span data-ttu-id="30172-297">채택 전과 후에 모두 신중하게 벤치마킹한 후에만 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-297">They should be used only after careful benchmarking both before and after adoption.</span></span> <span data-ttu-id="30172-298">원시 크기 정수를 사용하는 코드는 여러 대상 플랫폼에서 여러 정수 크기로 테스트해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-298">Code involving native sized integers must be tested on multiple target platforms with different integer sizes.</span></span> <span data-ttu-id="30172-299">다른 기능에는 안전하지 않은 코드가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-299">The other features require unsafe code.</span></span>

## <a name="fit-and-finish-features"></a><span data-ttu-id="30172-300">기능 마무리</span><span class="sxs-lookup"><span data-stu-id="30172-300">Fit and finish features</span></span>

<span data-ttu-id="30172-301">다른 많은 기능을 통해 코드를 보다 효율적으로 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-301">Many of the other features help you write code more efficiently.</span></span> <span data-ttu-id="30172-302">C# 9.0에서는 생성된 개체의 형식이 이미 알려진 경우 새 식에서 형식을 생략할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-302">In C# 9.0, you can omit the type in a new expression when the created object's type is already known.</span></span> <span data-ttu-id="30172-303">가장 일반적인 용도는 필드 선언입니다.</span><span class="sxs-lookup"><span data-stu-id="30172-303">The most common use is in field declarations:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="WeatherStationField":::

<span data-ttu-id="30172-304">메서드에 매개 변수로 전달할 새 개체를 만들어야 하는 경우 대상 유형 new를 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-304">Target type new can also be used when you need to create a new object to pass as a parameter to a method.</span></span> <span data-ttu-id="30172-305">다음 시그니처를 사용하는 `ForecastFor()` 메서드를 고려해 보세요.</span><span class="sxs-lookup"><span data-stu-id="30172-305">Consider a `ForecastFor()` method with the following signature:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="ForecastSignature":::

<span data-ttu-id="30172-306">다음과 같이 메서드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-306">You could call it as follows:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="TargetTypeNewArgument":::

<span data-ttu-id="30172-307">이 기능의 다른 유용한 용도는 init 전용 속성과 결합하여 새 개체를 초기화하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="30172-307">Another nice use for this feature is to combine it with init only properties to initialize a new object:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="InitWeatherStation":::

<span data-ttu-id="30172-308">`return new();` 식을 사용하여 기본 생성자에서 만든 인스턴스를 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-308">You can return an instance created by the default constructor using a `return new();` expression.</span></span>

<span data-ttu-id="30172-309">유사한 기능은 [조건식](../language-reference/operators/conditional-operator.md)의 대상 유형 확인을 개선합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-309">A similar feature improves the target type resolution of [conditional expressions](../language-reference/operators/conditional-operator.md).</span></span> <span data-ttu-id="30172-310">이 변경 내용이 도입되면서 두 식 간에 암시적 변환을 포함할 수는 없지만 두 식에 모두 대상 유형으로의 암시적 변환을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-310">With this change, the two expressions need not have an implicit conversion from one to the other, but may both have implicit conversions to a target type.</span></span> <span data-ttu-id="30172-311">이 변경 내용을 발견하지 못할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-311">You likely won’t notice this change.</span></span> <span data-ttu-id="30172-312">이전에 캐스트가 필요했거나 컴파일되지 않던 일부 조건식이 이제 작동할 뿐입니다.</span><span class="sxs-lookup"><span data-stu-id="30172-312">What you will notice is that some conditional expressions that previously required casts or wouldn’t compile now just work.</span></span>

<span data-ttu-id="30172-313">C# 9.0부터 [람다](../language-reference/operators/lambda-expressions.md) 식 또는 [무명 메서드](../language-reference/operators/delegate-operator.md)에 `static` 한정자를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-313">Starting in C# 9.0, you can add the `static` modifier to [lambda expressions](../language-reference/operators/lambda-expressions.md) or [anonymous methods](../language-reference/operators/delegate-operator.md).</span></span> <span data-ttu-id="30172-314">정적 람다 식은 `static` 로컬 함수와 유사합니다. 정적 람다 또는 무명 메서드는 지역 변수나 인스턴스 상태를 캡처할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-314">Static lambda expressions are analogous to the `static` local functions: a static lambda or anonymous method can't capture local variables or instance state.</span></span> <span data-ttu-id="30172-315">`static` 한정자는 실수에 의한 다른 변수 캡처를 방지합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-315">The `static` modifier prevents accidentally capturing other variables.</span></span>

<span data-ttu-id="30172-316">공변 반환 형식은 재정의된 함수의 반환 형식에 대한 유연성을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-316">Covariant return types provide flexibility for the return types of overridden functions.</span></span> <span data-ttu-id="30172-317">재정의된 가상 함수는 기본 클래스 메서드에 선언된 반환 형식에서 파생된 형식을 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-317">An overridden virtual function can return a type derived from the return type declared in the base class method.</span></span> <span data-ttu-id="30172-318">이 함수는 레코드나 가상 클론 또는 팩터리 메서드를 지원하는 기타 형식에 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-318">This can be useful for Records, and for other types that support virtual clone or factory methods.</span></span>

<span data-ttu-id="30172-319">또한 [`foreach` 루프](../language-reference/keywords/foreach-in.md)는 `foreach` 패턴을 충족하는 확장 메서드 `GetEnumerator`를 인식하고 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-319">In addition, the [`foreach` loop](../language-reference/keywords/foreach-in.md) will recognize and use an extension method `GetEnumerator` that otherwise satisfies the `foreach` pattern.</span></span> <span data-ttu-id="30172-320">이렇게 변경함으로써 `foreach`는 비동기 패턴과 같은 다른 패턴 기반 생성 및 패턴 기반 분해와 일치하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="30172-320">This change means `foreach` is consistent with other pattern-based constructions such as the async pattern, and pattern-based deconstruction.</span></span> <span data-ttu-id="30172-321">실제로 이 변경은 모든 형식에 `foreach` 지원을 추가할 수 있음을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-321">In practice, this change means you can add `foreach` support to any type.</span></span> <span data-ttu-id="30172-322">설계상 개체를 열거하는 것이 적합한 경우로 사용을 제한해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-322">You should limit its use to when enumerating an object makes sense in your design.</span></span>

<span data-ttu-id="30172-323">다음으로, 무시 항목을 람다 식에 대한 매개 변수로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-323">Next, you can use discards as parameters to lambda expressions.</span></span> <span data-ttu-id="30172-324">이 편리한 기능을 사용하면 인수 이름을 지정할 필요가 없으며, 컴파일러에서 인수를 사용하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-324">This convenience enables you to avoid naming the argument, and the compiler may avoid using it.</span></span> <span data-ttu-id="30172-325">모든 인수에 `_`을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-325">You use the `_` for any argument.</span></span> <span data-ttu-id="30172-326">자세한 내용은 [람다 식](../language-reference/operators/lambda-expressions.md) 문서의 [람다 식 입력 매개 변수](../language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression) 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="30172-326">For more information, see the [Input parameters of a lambda expression](../language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression) section of the [Lambda expressions](../language-reference/operators/lambda-expressions.md) article.</span></span>

<span data-ttu-id="30172-327">마지막으로, 이제 로컬 함수에 특성을 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-327">Finally, you can now apply attributes to local functions.</span></span> <span data-ttu-id="30172-328">예를 들어 로컬 함수에 null 허용 특성 주석을 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-328">For example, you can apply nullable attribute annotations to local functions.</span></span>

## <a name="support-for-code-generators"></a><span data-ttu-id="30172-329">코드 생성기 지원</span><span class="sxs-lookup"><span data-stu-id="30172-329">Support for code generators</span></span>

<span data-ttu-id="30172-330">두 가지 최종 기능은 C# 코드 생성기를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-330">Two final features support C# code generators.</span></span> <span data-ttu-id="30172-331">C# 코드 생성기는 Roslyn 분석기나 코드 수정 사항과 유사하게, 직접 작성할 수 있는 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="30172-331">C# code generators are a component you can write that is similar to a roslyn analyzer or code fix.</span></span> <span data-ttu-id="30172-332">차이점은 코드 생성기의 경우 컴파일 프로세스의 일부로 코드를 분석하고 새 소스 코드 파일을 작성한다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="30172-332">The difference is that code generators analyze code and write new source code files as part of the compilation process.</span></span> <span data-ttu-id="30172-333">일반적인 코드 생성기는 코드에서 특성이나 다른 규칙을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-333">A typical code generator searches code for attributes or other conventions.</span></span>

<span data-ttu-id="30172-334">코드 생성기는 Roslyn 분석 API를 사용하여 특성이나 다른 코드 요소를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-334">A code generator read attributes or other code elements using the Roslyn analysis APIs.</span></span> <span data-ttu-id="30172-335">해당 정보를 통해 컴파일에 새 코드를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-335">From that information, it adds new code to the compilation.</span></span> <span data-ttu-id="30172-336">소스 생성기는 코드를 추가할 수만 있고 컴파일의 기존 코드를 수정할 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-336">Source generators can only add code; they aren't allowed to modify any existing code in the compilation.</span></span>

<span data-ttu-id="30172-337">코드 생성기에 대해 추가된 두 가지 기능은 ***부분 메서드 구문*** 확장 및 ***모듈 이니셜라이저***입니다.</span><span class="sxs-lookup"><span data-stu-id="30172-337">The two features added for code generators are extensions to ***partial method syntax***, and ***module initializers***.</span></span> <span data-ttu-id="30172-338">먼저 부분 메서드 변경 내용입니다.</span><span class="sxs-lookup"><span data-stu-id="30172-338">First, the changes to partial methods.</span></span> <span data-ttu-id="30172-339">C# 9.0 이전에는 부분 메서드가 `private`이지만 액세스 한정자를 지정하거나 `void` 반환 또는 `out` 매개 변수를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-339">Before C# 9.0, partial methods are `private` but can't specify an access modifier, have a `void` return, and can't have `out` parameters.</span></span> <span data-ttu-id="30172-340">이 제한 사항 때문에, 메서드 구현을 제공하지 않을 경우 컴파일러에서 부분 메서드 호출을 모두 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-340">These restrictions meant that if no method implementation is provided, the compiler removes all calls to the partial method.</span></span> <span data-ttu-id="30172-341">C# 9.0에서는 해당 제한 사항이 제거되었지만 부분 메서드 선언에 구현이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-341">C# 9.0 removes these restrictions, but requires that partial method declarations have an implementation.</span></span> <span data-ttu-id="30172-342">코드 생성기에서 이 구현을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-342">Code generators can provide that implementation.</span></span> <span data-ttu-id="30172-343">호환성이 손상되는 변경을 방지하기 위해 컴파일러에서 액세스 한정자가 없는 부분 메서드는 이전 규칙을 따른다고 간주합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-343">To avoid introducing a breaking change, the compiler considers any partial method without an access modifier to follow the old rules.</span></span> <span data-ttu-id="30172-344">부분 메서드에 `private` 액세스 한정자가 포함되어 있으면 새 규칙에 따라 부분 메서드가 제어됩니다.</span><span class="sxs-lookup"><span data-stu-id="30172-344">If the partial method includes the `private` access modifier, the new rules govern that partial method.</span></span>

<span data-ttu-id="30172-345">코드 생성기의 두 번째 새로운 기능은 ***모듈 이니셜라이저***입니다.</span><span class="sxs-lookup"><span data-stu-id="30172-345">The second new feature for code generators is ***module initializers***.</span></span> <span data-ttu-id="30172-346">모듈 이니셜라이저는 <xref:System.Runtime.CompilerServices.ModuleInitializerAttribute> 특성이 연결된 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="30172-346">Module initializers are methods that have the <xref:System.Runtime.CompilerServices.ModuleInitializerAttribute> attribute attached to them.</span></span> <span data-ttu-id="30172-347">이 메서드는 어셈블리를 로드할 때 런타임에서 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="30172-347">These methods will be called by the runtime when the assembly loads.</span></span> <span data-ttu-id="30172-348">모듈 이니셜라이저 메서드는 다음과 같아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-348">A module initializer method:</span></span>

- <span data-ttu-id="30172-349">정적이어야 함</span><span class="sxs-lookup"><span data-stu-id="30172-349">Must be static</span></span>
- <span data-ttu-id="30172-350">매개 변수가 없어야 함</span><span class="sxs-lookup"><span data-stu-id="30172-350">Must be parameterless</span></span>
- <span data-ttu-id="30172-351">void를 반환해야 함</span><span class="sxs-lookup"><span data-stu-id="30172-351">Must return void</span></span>
- <span data-ttu-id="30172-352">제네릭 메서드가 아니어야 함</span><span class="sxs-lookup"><span data-stu-id="30172-352">Must not be a generic method</span></span>
- <span data-ttu-id="30172-353">제네릭 클래스에 포함되지 않아야 함</span><span class="sxs-lookup"><span data-stu-id="30172-353">Must not be contained in a generic class</span></span>
- <span data-ttu-id="30172-354">포함하는 모듈에서 액세스할 수 있어야 함</span><span class="sxs-lookup"><span data-stu-id="30172-354">Must be accessible from the containing module</span></span>

<span data-ttu-id="30172-355">마지막 글머리 기호 사항은 사실상, 메서드와 메서드를 포함하는 클래스가 internal 또는 public이어야 함을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="30172-355">That last bullet point effectively means the method and its containing class must be internal or public.</span></span> <span data-ttu-id="30172-356">메서드는 로컬 함수가 될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="30172-356">The method can't be a local function.</span></span>
