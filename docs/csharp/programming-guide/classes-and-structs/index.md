---
title: 클래스 및 구조체 - C# 프로그래밍 가이드
description: C#의 클래스 및 구조(구조체) 사용에 대해 설명합니다.
ms.date: 01/17/2016
helpviewer_keywords:
- structs [C#], about structs
- classes [C#], overview
- C# language, structs
- C# language, objects
- objects [C#]
- C# language, classes
ms.assetid: cc39dbda-8754-423e-b5b1-16a1db0734c0
ms.openlocfilehash: 301ba292010470208e92a225c1014bcb50497106
ms.sourcegitcommit: 5f236cd78cf09593c8945a7d753e0850e96a0b80
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 01/07/2020
ms.locfileid: "75714816"
---
# <a name="classes-and-structs-c-programming-guide"></a><span data-ttu-id="b922a-103">클래스 및 구조체(C# 프로그래밍 가이드)</span><span class="sxs-lookup"><span data-stu-id="b922a-103">Classes and Structs (C# Programming Guide)</span></span>
<span data-ttu-id="b922a-104">클래스와 구조체는 .NET Framework의 공용 형식 시스템의 기본 구문 중 두 가지입니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-104">Classes and structs are two of the basic constructs of the common type system in the .NET Framework.</span></span> <span data-ttu-id="b922a-105">각각은 기본적으로 하나의 논리 단위에 속하는 데이터 및 동작 집합을 캡슐화하는 데이터 구조입니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-105">Each is essentially a data structure that encapsulates a set of data and behaviors that belong together as a logical unit.</span></span> <span data-ttu-id="b922a-106">데이터 및 동작은 클래스 또는 구조체의 *멤버*로, 이 항목의 뒷부분에 나오는 것처럼 메서드, 속성 및 이벤트 등을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-106">The data and behaviors are the *members* of the class or struct, and they include its methods, properties, and events, and so on, as listed later in this topic.</span></span>  
  
 <span data-ttu-id="b922a-107">클래스 또는 구조체 선언은 런타임에 인스턴스 또는 개체를 만드는 데 사용되는 청사진과도 같습니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-107">A class or struct declaration is like a blueprint that is used to create instances or objects at run time.</span></span> <span data-ttu-id="b922a-108">`Person`이라고 하는 클래스 또는 구조체를 정의하는 경우 `Person`이 형식의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-108">If you define a class or struct called `Person`, `Person` is the name of the type.</span></span> <span data-ttu-id="b922a-109">형식 `Person`의 변수 `p`를 선언하고 초기화하면 `p`는 `Person`의 개체 또는 인스턴스로 지칭됩니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-109">If you declare and initialize a variable `p` of type `Person`, `p` is said to be an object or instance of `Person`.</span></span> <span data-ttu-id="b922a-110">같은 `Person` 형식의 여러 인스턴스를 만들 수 있으며 각 인스턴스는 속성 및 필드에 서로 다른 값을 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-110">Multiple instances of the same `Person` type can be created, and each instance can have different values in its properties and fields.</span></span>  
  
 <span data-ttu-id="b922a-111">클래스는 참조 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-111">A class is a reference type.</span></span> <span data-ttu-id="b922a-112">클래스의 개체가 만들어지면 개체가 할당되는 변수는 해당 메모리에 대한 참조만 보유합니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-112">When an object of the class is created, the variable to which the object is assigned holds only a reference to that memory.</span></span> <span data-ttu-id="b922a-113">개체 참조가 새 변수에 할당되면 새 변수는 원래 개체를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-113">When the object reference is assigned to a new variable, the new variable refers to the original object.</span></span> <span data-ttu-id="b922a-114">모두 동일한 데이터를 참조하므로 한 변수의 변경 내용이 다른 변수에도 반영됩니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-114">Changes made through one variable are reflected in the other variable because they both refer to the same data.</span></span>  
  
 <span data-ttu-id="b922a-115">구조체는 값 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-115">A struct is a value type.</span></span> <span data-ttu-id="b922a-116">구조체가 만들어지면 해당 구조체가 할당되는 변수에 구조체의 실제 데이터가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-116">When a struct is created, the variable to which the struct is assigned holds the struct's actual data.</span></span> <span data-ttu-id="b922a-117">구조체를 새 변수에 할당하면 구조체가 복사됩니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-117">When the struct is assigned to a new variable, it is copied.</span></span> <span data-ttu-id="b922a-118">따라서 새 변수와 원래 변수에 동일한 데이터의 두 가지 별도 복사본이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-118">The new variable and the original variable therefore contain two separate copies of the same data.</span></span> <span data-ttu-id="b922a-119">한 복사본의 변경 내용은 다른 복사본에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-119">Changes made to one copy do not affect the other copy.</span></span>  
  
 <span data-ttu-id="b922a-120">일반적으로 클래스는 좀 더 복잡한 동작이나 클래스 개체를 만든 후 수정하려는 데이터를 모델링하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-120">In general, classes are used to model more complex behavior, or data that is intended to be modified after a class object is created.</span></span> <span data-ttu-id="b922a-121">구조체는 구조체를 만든 후에 수정하지 않으려는 데이터를 주로 포함하는 작은 데이터 구조에 가장 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-121">Structs are best suited for small data structures that contain primarily data that is not intended to be modified after the struct is created.</span></span>  
  
 <span data-ttu-id="b922a-122">자세한 내용은 [클래스](./classes.md), [개체](./objects.md) 및 [구조체](./structs.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b922a-122">For more information, see [Classes](./classes.md), [Objects](./objects.md), and [Structs](./structs.md).</span></span>  
  
## <a name="example"></a><span data-ttu-id="b922a-123">예제</span><span class="sxs-lookup"><span data-stu-id="b922a-123">Example</span></span>  
 <span data-ttu-id="b922a-124">다음 예제에서 `ProgrammingGuide` 네임스페이스의 `CustomClass`에는 세 개의 멤버, 즉 인스턴스 생성자, `Number`라는 속성 및 `Multiply`이라는 메서드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-124">In the following example, `CustomClass` in the `ProgrammingGuide` namespace has three members: an instance constructor, a property named `Number`, and a method named `Multiply`.</span></span> <span data-ttu-id="b922a-125">`Program` 클래스의 `Main` 메서드는 `CustomClass`의 인스턴스(개체)를 만들고 개체의 메서드 및 속성은 점 표기법을 사용하여 액세스됩니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-125">The `Main` method in the `Program` class creates an instance (object) of `CustomClass`, and the object’s method and property are accessed by using dot notation.</span></span>
  
 [!code-csharp[csProgGuideObjects#1](../../../../samples/snippets/csharp/programming-guide/classes-and-structs/class1.cs#1)]  
  
## <a name="encapsulation"></a><span data-ttu-id="b922a-126">캡슐화</span><span class="sxs-lookup"><span data-stu-id="b922a-126">Encapsulation</span></span>  
 <span data-ttu-id="b922a-127">*캡슐화*는 경우에 따라 개체 지향 프로그래밍의 첫 번째 pillar 또는 원리로 인식됩니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-127">*Encapsulation* is sometimes referred to as the first pillar or principle of object-oriented programming.</span></span> <span data-ttu-id="b922a-128">캡슐화의 원리에 따라 클래스 또는 구조체는 클래스 또는 구조체 외부의 코드에 각 멤버가 액세스하는 방법을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-128">According to the principle of encapsulation, a class or struct can specify how accessible each of its members is to code outside of the class or struct.</span></span> <span data-ttu-id="b922a-129">코딩 오류 또는 악의적인 악용 가능성을 제한하려면 클래스 또는 어셈블리 외부에서 사용하지 않으려는 메서드 및 변수는 숨길 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-129">Methods and variables that are not intended to be used from outside of the class or assembly can be hidden to limit the potential for coding errors or malicious exploits.</span></span>  
  
 <span data-ttu-id="b922a-130">클래스에 대한 자세한 내용은 [클래스](./classes.md) 및 [개체](./objects.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b922a-130">For more information about classes, see [Classes](./classes.md) and [Objects](./objects.md).</span></span>  
  
### <a name="members"></a><span data-ttu-id="b922a-131">멤버</span><span class="sxs-lookup"><span data-stu-id="b922a-131">Members</span></span>  
 <span data-ttu-id="b922a-132">모든 메서드, 필드, 상수, 속성 및 이벤트는 형식 내에서 선언되어야 합니다. 이것을 형식의 *멤버*라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-132">All methods, fields, constants, properties, and events must be declared within a type; these are called the *members* of the type.</span></span> <span data-ttu-id="b922a-133">다른 언어에는 있지만 C#에는 전역 변수 또는 메서드가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-133">In C#, there are no global variables or methods as there are in some other languages.</span></span> <span data-ttu-id="b922a-134">프로그램의 진입점인 `Main` 메서드까지도 클래스 또는 구조체 내에서 선언되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-134">Even a program's entry point, the `Main` method, must be declared within a class or struct.</span></span> <span data-ttu-id="b922a-135">다음은 클래스 또는 구조체에서 선언될 수 있는 모든 다양한 종류의 멤버입니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-135">The following list includes all the various kinds of members that may be declared in a class or struct.</span></span>  
  
- [<span data-ttu-id="b922a-136">필드</span><span class="sxs-lookup"><span data-stu-id="b922a-136">Fields</span></span>](./fields.md)  
  
- [<span data-ttu-id="b922a-137">상수</span><span class="sxs-lookup"><span data-stu-id="b922a-137">Constants</span></span>](./constants.md)  
  
- [<span data-ttu-id="b922a-138">속성</span><span class="sxs-lookup"><span data-stu-id="b922a-138">Properties</span></span>](./properties.md)  
  
- [<span data-ttu-id="b922a-139">메서드</span><span class="sxs-lookup"><span data-stu-id="b922a-139">Methods</span></span>](./methods.md)  
  
- [<span data-ttu-id="b922a-140">생성자</span><span class="sxs-lookup"><span data-stu-id="b922a-140">Constructors</span></span>](./constructors.md)  
  
- [<span data-ttu-id="b922a-141">이벤트</span><span class="sxs-lookup"><span data-stu-id="b922a-141">Events</span></span>](../events/index.md)  
  
- [<span data-ttu-id="b922a-142">종료자</span><span class="sxs-lookup"><span data-stu-id="b922a-142">Finalizers</span></span>](./destructors.md)  
  
- [<span data-ttu-id="b922a-143">인덱서</span><span class="sxs-lookup"><span data-stu-id="b922a-143">Indexers</span></span>](../indexers/index.md)  
  
- [<span data-ttu-id="b922a-144">연산자</span><span class="sxs-lookup"><span data-stu-id="b922a-144">Operators</span></span>](../../language-reference/operators/index.md)  
  
- [<span data-ttu-id="b922a-145">중첩 형식</span><span class="sxs-lookup"><span data-stu-id="b922a-145">Nested Types</span></span>](./nested-types.md)  
  
### <a name="accessibility"></a><span data-ttu-id="b922a-146">액세스 가능성</span><span class="sxs-lookup"><span data-stu-id="b922a-146">Accessibility</span></span>  
 <span data-ttu-id="b922a-147">일부 메서드 및 속성은 *클라이언트 코드*라고 하는 클래스 또는 구조체 외부의 코드에서 호출하거나 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-147">Some methods and properties are meant to be called or accessed from code outside your class or struct, known as *client code*.</span></span> <span data-ttu-id="b922a-148">다른 메서드 및 속성은 클래스 또는 구조체 자체에서만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-148">Other methods and properties might be only for use in the class or struct itself.</span></span> <span data-ttu-id="b922a-149">의도된 클라이언트 코드에서만 연결될 수 있도록 코드의 액세스 가능성을 제한하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-149">It is important to limit the accessibility of your code so that only the intended client code can reach it.</span></span> <span data-ttu-id="b922a-150">형식 및 해당 멤버가 클라이언트 코드에 액세스하는 방법은 액세스 한정자 [public](../../language-reference/keywords/public.md), [protected](../../language-reference/keywords/protected.md), [internal](../../language-reference/keywords/internal.md), [protected internal](../../language-reference/keywords/protected-internal.md), [private](../../language-reference/keywords/private.md) 및 [private protected](../../language-reference/keywords/private-protected.md)를 사용하여 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-150">You specify how accessible your types and their members are to client code by using the access modifiers [public](../../language-reference/keywords/public.md), [protected](../../language-reference/keywords/protected.md), [internal](../../language-reference/keywords/internal.md), [protected internal](../../language-reference/keywords/protected-internal.md), [private](../../language-reference/keywords/private.md) and [private protected](../../language-reference/keywords/private-protected.md).</span></span> <span data-ttu-id="b922a-151">기본 액세스 가능성은 `private`입니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-151">The default accessibility is `private`.</span></span> <span data-ttu-id="b922a-152">자세한 내용은 [액세스 한정자](./access-modifiers.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b922a-152">For more information, see [Access Modifiers](./access-modifiers.md).</span></span>  
  
### <a name="inheritance"></a><span data-ttu-id="b922a-153">상속</span><span class="sxs-lookup"><span data-stu-id="b922a-153">Inheritance</span></span>  
 <span data-ttu-id="b922a-154">클래스(구조체는 아님)는 상속 개념을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-154">Classes (but not structs) support the concept of inheritance.</span></span> <span data-ttu-id="b922a-155">다른 클래스(*기본 클래스*)에서 파생되는 클래스는 생성자와 종료자를 제외하고 기본 클래스의 모든 public, protected 및 internal 멤버를 자동으로 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-155">A class that derives from another class (the *base class*) automatically contains all the public, protected, and internal members of the base class except its constructors and finalizers.</span></span> <span data-ttu-id="b922a-156">자세한 내용은 [상속](./inheritance.md) 및 [다형성](./polymorphism.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b922a-156">For more information, see [Inheritance](./inheritance.md) and [Polymorphism](./polymorphism.md).</span></span>  
  
 <span data-ttu-id="b922a-157">클래스를 [abstract](../../language-reference/keywords/abstract.md)로 선언할 수도 있습니다. 즉, 하나 이상의 해당 메서드에 구현이 없는 상태를 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-157">Classes may be declared as [abstract](../../language-reference/keywords/abstract.md), which means that one or more of their methods have no implementation.</span></span> <span data-ttu-id="b922a-158">추상 클래스는 직접 인스턴스화할 수 없지만 누락된 구현을 제공하는 다른 클래스에 대한 기본 클래스로 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-158">Although abstract classes cannot be instantiated directly, they can serve as base classes for other classes that provide the missing implementation.</span></span> <span data-ttu-id="b922a-159">다른 클래스가 이 클래스에서 상속 받지 못하게 하려면 클래스를 [sealed](../../language-reference/keywords/sealed.md)로 선언할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-159">Classes can also be declared as [sealed](../../language-reference/keywords/sealed.md) to prevent other classes from inheriting from them.</span></span> <span data-ttu-id="b922a-160">자세한 내용은 [Abstract 및 Sealed 클래스와 클래스 멤버](./abstract-and-sealed-classes-and-class-members.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b922a-160">For more information, see [Abstract and Sealed Classes and Class Members](./abstract-and-sealed-classes-and-class-members.md).</span></span>  
  
### <a name="interfaces"></a><span data-ttu-id="b922a-161">인터페이스</span><span class="sxs-lookup"><span data-stu-id="b922a-161">Interfaces</span></span>  
 <span data-ttu-id="b922a-162">클래스 및 구조체는 여러 인터페이스에서 상속할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-162">Classes and structs can inherit multiple interfaces.</span></span> <span data-ttu-id="b922a-163">인터페이스에서 상속하는 것은 형식이 해당 인터페이스에 정의된 모든 메서드를 구현한다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-163">To inherit from an interface means that the type implements all the methods defined in the interface.</span></span> <span data-ttu-id="b922a-164">자세한 내용은 [인터페이스](../interfaces/index.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b922a-164">For more information, see [Interfaces](../interfaces/index.md).</span></span>  
  
### <a name="generic-types"></a><span data-ttu-id="b922a-165">제네릭 형식</span><span class="sxs-lookup"><span data-stu-id="b922a-165">Generic Types</span></span>  
 <span data-ttu-id="b922a-166">하나 이상의 형식 매개 변수를 사용하여 클래스 및 구조체를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-166">Classes and structs can be defined with one or more type parameters.</span></span> <span data-ttu-id="b922a-167">클라이언트 코드는 형식의 인스턴스를 만들 때 형식을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-167">Client code supplies the type when it creates an instance of the type.</span></span> <span data-ttu-id="b922a-168">예를 들어 <xref:System.Collections.Generic> 네임스페이스의 <xref:System.Collections.Generic.List%601> 클래스는 하나의 형식 매개 변수로 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-168">For example The <xref:System.Collections.Generic.List%601> class in the <xref:System.Collections.Generic> namespace is defined with one type parameter.</span></span> <span data-ttu-id="b922a-169">클라이언트 코드는 `List<string>` 또는 `List<int>`의 인스턴스를 만들어 목록에 포함될 형식을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-169">Client code creates an instance of a `List<string>` or `List<int>` to specify the type that the list will hold.</span></span> <span data-ttu-id="b922a-170">자세한 내용은 [제네릭](../generics/index.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b922a-170">For more information, see [Generics](../generics/index.md).</span></span>  
  
### <a name="static-types"></a><span data-ttu-id="b922a-171">정적 형식</span><span class="sxs-lookup"><span data-stu-id="b922a-171">Static Types</span></span>  
 <span data-ttu-id="b922a-172">클래스(구조체는 아님)를 [static](../../language-reference/keywords/static.md)으로 선언할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-172">Classes (but not structs) can be declared as [static](../../language-reference/keywords/static.md).</span></span> <span data-ttu-id="b922a-173">static 클래스는 static 멤버만 포함할 수 있고 new 키워드로 인스턴스화할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-173">A static class can contain only static members and cannot be instantiated with the new keyword.</span></span> <span data-ttu-id="b922a-174">프로그램이 로드될 때 클래스의 단일 복사본만 메모리에 로드되고 해당 멤버는 클래스 이름을 통해 액세스됩니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-174">One copy of the class is loaded into memory when the program loads, and its members are accessed through the class name.</span></span> <span data-ttu-id="b922a-175">클래스와 구조체 둘 다 정적 멤버를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-175">Both classes and structs can contain static members.</span></span> <span data-ttu-id="b922a-176">자세한 내용은 [static 클래스 및 static 클래스 멤버](./static-classes-and-static-class-members.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b922a-176">For more information, see [Static Classes and Static Class Members](./static-classes-and-static-class-members.md).</span></span>  
  
### <a name="nested-types"></a><span data-ttu-id="b922a-177">중첩 형식</span><span class="sxs-lookup"><span data-stu-id="b922a-177">Nested Types</span></span>  
 <span data-ttu-id="b922a-178">클래스 또는 구조체는 다른 클래스 또는 구조체 내에 중첩될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-178">A class or struct can be nested within another class or struct.</span></span> <span data-ttu-id="b922a-179">자세한 내용은 [중첩 형식](./nested-types.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b922a-179">For more information, see [Nested Types](./nested-types.md).</span></span>  
  
### <a name="partial-types"></a><span data-ttu-id="b922a-180">부분 형식(Partial Type)</span><span class="sxs-lookup"><span data-stu-id="b922a-180">Partial Types</span></span>  
 <span data-ttu-id="b922a-181">하나의 코드 파일 및 별도 코드 파일의 다른 부분에서 클래스, 구조체 또는 메서드의 부분을 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-181">You can define part of a class, struct or method in one code file and another part in a separate code file.</span></span> <span data-ttu-id="b922a-182">자세한 내용은 [Partial 클래스 및 메서드](./partial-classes-and-methods.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b922a-182">For more information, see [Partial Classes and Methods](./partial-classes-and-methods.md).</span></span>  
  
### <a name="object-initializers"></a><span data-ttu-id="b922a-183">개체 이니셜라이저</span><span class="sxs-lookup"><span data-stu-id="b922a-183">Object Initializers</span></span>  
 <span data-ttu-id="b922a-184">해당 생성자를 명시적으로 호출하지 않고 클래스 또는 구조체 개체, 개체 컬렉션을 인스턴스화하고 초기화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-184">You can instantiate and initialize class or struct objects, and collections of objects, without explicitly calling their constructor.</span></span> <span data-ttu-id="b922a-185">자세한 내용은 [개체 및 컬렉션 이니셜라이저](./object-and-collection-initializers.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b922a-185">For more information, see [Object and Collection Initializers](./object-and-collection-initializers.md).</span></span>  
  
### <a name="anonymous-types"></a><span data-ttu-id="b922a-186">익명 형식</span><span class="sxs-lookup"><span data-stu-id="b922a-186">Anonymous Types</span></span>  
 <span data-ttu-id="b922a-187">유지하거나 다른 메서드에 전달할 필요가 없는 데이터 구조로 목록을 채우는 경우처럼 명명된 클래스를 만드는 것이 불편하거나 필요하지 않은 상황에서는 무명 형식을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-187">In situations where it is not convenient or necessary to create a named class, for example when you are populating a list with data structures that you do not have to persist or pass to another method, you use anonymous types.</span></span> <span data-ttu-id="b922a-188">자세한 내용은 [무명 형식](./anonymous-types.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b922a-188">For more information, see [Anonymous Types](./anonymous-types.md).</span></span>  
  
### <a name="extension-methods"></a><span data-ttu-id="b922a-189">확장명 메서드</span><span class="sxs-lookup"><span data-stu-id="b922a-189">Extension Methods</span></span>  
 <span data-ttu-id="b922a-190">마치 원래 형식에 속하는 것처럼 해당 메서드를 호출할 수 있는 별도 형식을 만들면 파생 클래스를 만들지 않고도 클래스를 “확장”할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-190">You can "extend" a class without creating a derived class by creating a separate type whose methods can be called as if they belonged to the original type.</span></span> <span data-ttu-id="b922a-191">자세한 내용은 [확장 메서드](./extension-methods.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b922a-191">For more information, see [Extension Methods](./extension-methods.md).</span></span>  
  
### <a name="implicitly-typed-local-variables"></a><span data-ttu-id="b922a-192">암시적으로 형식화한 지역 변수</span><span class="sxs-lookup"><span data-stu-id="b922a-192">Implicitly Typed Local Variables</span></span>  
 <span data-ttu-id="b922a-193">클래스 또는 구조체 메서드 내에서 암시적 형식 지정을 사용하여 컴파일러가 컴파일 타임에 올바른 형식을 결정하도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b922a-193">Within a class or struct method, you can use implicit typing to instruct the compiler to determine the correct type at compile time.</span></span> <span data-ttu-id="b922a-194">자세한 내용은 [암시적으로 형식화된 지역 변수](./implicitly-typed-local-variables.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b922a-194">For more information, see [Implicitly Typed Local Variables](./implicitly-typed-local-variables.md).</span></span>  
  
## <a name="c-language-specification"></a><span data-ttu-id="b922a-195">C# 언어 사양</span><span class="sxs-lookup"><span data-stu-id="b922a-195">C# Language Specification</span></span>  
 [!INCLUDE[CSharplangspec](~/includes/csharplangspec-md.md)]  
  
## <a name="see-also"></a><span data-ttu-id="b922a-196">참조</span><span class="sxs-lookup"><span data-stu-id="b922a-196">See also</span></span>

- [<span data-ttu-id="b922a-197">C# 프로그래밍 가이드</span><span class="sxs-lookup"><span data-stu-id="b922a-197">C# Programming Guide</span></span>](../index.md)
