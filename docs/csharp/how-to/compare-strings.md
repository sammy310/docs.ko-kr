---
title: 문자열 비교 방법 - C# 가이드
description: 문화권별 순서 지정 여부나 대/소문자와 상관없이 문자열 값을 비교하고 정렬하는 방법에 대해 알아봅니다.
ms.date: 10/03/2018
helpviewer_keywords:
- strings [C#], comparison
- comparing strings [C#]
ms.openlocfilehash: 5c417ccbdd763de5bbb67ae6a17ac1a5ff165065
ms.sourcegitcommit: 42d436ebc2a7ee02fc1848c7742bc7d80e13fc2f
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/04/2021
ms.locfileid: "102104980"
---
# <a name="how-to-compare-strings-in-c"></a><span data-ttu-id="38ad5-103">C\#에서 문자열을 비교하는 방법</span><span class="sxs-lookup"><span data-stu-id="38ad5-103">How to compare strings in C\#</span></span>

<span data-ttu-id="38ad5-104">문자열을 비교하여 다음 두 가지 질문 중 하나를 해결할 수 있습니다. "이 두 문자열이 같나요?"</span><span class="sxs-lookup"><span data-stu-id="38ad5-104">You compare strings to answer one of two questions: "Are these two strings equal?"</span></span> <span data-ttu-id="38ad5-105">또는 "정렬할 때 이 문자열을 어떤 순서로 정렬해야 하는가?"</span><span class="sxs-lookup"><span data-stu-id="38ad5-105">or "In what order should these strings be placed when sorting them?"</span></span>

<span data-ttu-id="38ad5-106">이러한 두 가지 질문은 문자열 비교에 영향을 주는 요소에 의해 복잡해 집니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-106">Those two questions are complicated by factors that affect string comparisons:</span></span>

- <span data-ttu-id="38ad5-107">서수 또는 언어 비교를 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-107">You can choose an ordinal or linguistic comparison.</span></span>
- <span data-ttu-id="38ad5-108">대/소문자를 구분할지 여부를 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-108">You can choose if case matters.</span></span>
- <span data-ttu-id="38ad5-109">문화권별 비교를 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-109">You can choose culture-specific comparisons.</span></span>
- <span data-ttu-id="38ad5-110">언어적 비교는 문화권 및 플랫폼에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-110">Linguistic comparisons are culture and platform-dependent.</span></span>

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

<span data-ttu-id="38ad5-111">문자열을 비교할 때 순서를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-111">When you compare strings, you define an order among them.</span></span> <span data-ttu-id="38ad5-112">비교는 문자열 시퀀스를 정렬하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-112">Comparisons are used to sort a sequence of strings.</span></span> <span data-ttu-id="38ad5-113">시퀀스가 알려진 순서대로 되면 소프트웨어와 사람 모두를 검색하는 것이 더 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-113">Once the sequence is in a known order, it is easier to search, both for software and for humans.</span></span> <span data-ttu-id="38ad5-114">다른 비교로 문자열이 같은지 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-114">Other comparisons may check if strings are the same.</span></span> <span data-ttu-id="38ad5-115">이러한 동일성 검사는 동등 여부와 유사하지만 대/소문자 차이 같은 일부 차이점은 무시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-115">These sameness checks are similar to equality, but some differences, such as case differences, may be ignored.</span></span>

## <a name="default-ordinal-comparisons"></a><span data-ttu-id="38ad5-116">기본 서수 비교</span><span class="sxs-lookup"><span data-stu-id="38ad5-116">Default ordinal comparisons</span></span>

<span data-ttu-id="38ad5-117">기본적으로 가장 일반적인 작업:</span><span class="sxs-lookup"><span data-stu-id="38ad5-117">By default, the most common operations:</span></span>

- <xref:System.String.Equals%2A?displayProperty=nameWithType>
- <span data-ttu-id="38ad5-118"><xref:System.String.op_Equality%2A?displayProperty=nameWithType> 및 <xref:System.String.op_Inequality%2A?displayProperty=nameWithType>, 즉 [같음 연산자 `==` 및 `!=`](../language-reference/operators/equality-operators.md#string-equality)는 각각</span><span class="sxs-lookup"><span data-stu-id="38ad5-118"><xref:System.String.op_Equality%2A?displayProperty=nameWithType> and <xref:System.String.op_Inequality%2A?displayProperty=nameWithType>, that is, [equality operators `==` and `!=`](../language-reference/operators/equality-operators.md#string-equality), respectively</span></span>

<span data-ttu-id="38ad5-119">대/소문자 구분 서수 비교를 수행하고 필요한 경우 현재 문화권을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-119">perform a case-sensitive ordinal comparison and, if necessary, use the current culture.</span></span> <span data-ttu-id="38ad5-120">다음은 해당 예입니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-120">The following example demonstrates that:</span></span>

:::code language="csharp" interactive="try-dotnet-method" source="../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs" id="Snippet1":::

<span data-ttu-id="38ad5-121">기본 서수 비교는 문자열을 비교할 때 언어 규칙을 고려하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-121">The default ordinal comparison doesn't take linguistic rules into account when comparing strings.</span></span> <span data-ttu-id="38ad5-122">두 문자열에서 각 <xref:System.Char> 개체의 이진값을 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-122">It compares the binary value of each <xref:System.Char> object in two strings.</span></span> <span data-ttu-id="38ad5-123">결과적으로, 기본 서수 비교도 대/소문자를 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-123">As a result, the default ordinal comparison is also case-sensitive.</span></span>

<span data-ttu-id="38ad5-124"><xref:System.String.Equals%2A?displayProperty=nameWithType>, `==` 및 `!=` 연산자를 사용한 같음 테스트는 <xref:System.String.CompareTo%2A?displayProperty=nameWithType> 및 <xref:System.String.Compare(System.String,System.String)?displayProperty=nameWithType)> 메서드를 사용한 문자열 비교와 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-124">The test for equality with <xref:System.String.Equals%2A?displayProperty=nameWithType> and the `==` and `!=` operators differs from string comparison using the <xref:System.String.CompareTo%2A?displayProperty=nameWithType> and <xref:System.String.Compare(System.String,System.String)?displayProperty=nameWithType)> methods.</span></span> <span data-ttu-id="38ad5-125">동일성에 대한 테스트가 대/소문자 구분 서수 비교를 수행하는 동안 비교 메서드는 현재 문화권을 사용하여 대/소문자를 구분하고 문화권 구분 비교를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-125">While the tests for equality perform a case-sensitive ordinal comparison, the comparison methods perform a case-sensitive, culture-sensitive comparison using the current culture.</span></span> <span data-ttu-id="38ad5-126">기본 비교 메서드는 종종 다양한 유형의 비교를 수행하기 때문에 수행할 비교 형식을 명시적으로 지정하는 오버로드를 호출하여 코드의 의도를 항상 명확히 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-126">Because the default comparison methods often perform different types of comparisons, we recommend that you always make the intent of your code clear by calling an overload that explicitly specifies the type of comparison to perform.</span></span>

## <a name="case-insensitive-ordinal-comparisons"></a><span data-ttu-id="38ad5-127">대/소문자를 구분하지 않는 서수 비교</span><span class="sxs-lookup"><span data-stu-id="38ad5-127">Case-insensitive ordinal comparisons</span></span>

<span data-ttu-id="38ad5-128"><xref:System.String.Equals(System.String,System.StringComparison)?displayProperty=nameWithType> 메서드를 사용하면 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>의 <xref:System.StringComparison> 값을 지정하여</span><span class="sxs-lookup"><span data-stu-id="38ad5-128">The <xref:System.String.Equals(System.String,System.StringComparison)?displayProperty=nameWithType> method enables you to specify a <xref:System.StringComparison> value of <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType></span></span>
<span data-ttu-id="38ad5-129">대/소문자를 구분하지 않는 서수 비교.</span><span class="sxs-lookup"><span data-stu-id="38ad5-129">for a case-insensitive ordinal comparison.</span></span> <span data-ttu-id="38ad5-130"><xref:System.StringComparison> 인수에 대해 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> 값을 지정하는 경우 대/소문자를 구분 하지 않는 서수 비교를 수행하는 정적 <xref:System.String.Compare(System.String,System.String,System.StringComparison)?displayProperty=nameWithType> 메서드도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-130">There is also a static <xref:System.String.Compare(System.String,System.String,System.StringComparison)?displayProperty=nameWithType> method that performs a case-insensitive ordinal comparison if you specify a value of <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> for the <xref:System.StringComparison> argument.</span></span> <span data-ttu-id="38ad5-131">이는 다음 코드에서 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-131">These are shown in the following code:</span></span>

:::code language="csharp" interactive="try-dotnet-method" source="../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs" id="Snippet2":::

<span data-ttu-id="38ad5-132">대/소문자를 구분하지 않는 서수 비교를 수행하는 경우 이러한 메서드는 [고정 문화권](xref:System.Globalization.CultureInfo.InvariantCulture)의 대/소문자 규칙을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-132">When performing a case-insensitive ordinal comparison, these methods use the casing conventions of the [invariant culture](xref:System.Globalization.CultureInfo.InvariantCulture).</span></span>

## <a name="linguistic-comparisons"></a><span data-ttu-id="38ad5-133">언어 비교</span><span class="sxs-lookup"><span data-stu-id="38ad5-133">Linguistic comparisons</span></span>

<span data-ttu-id="38ad5-134">또한 현재 문화권에 대한 언어 규칙을 사용하여 문자열을 정렬할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-134">Strings can also be ordered using linguistic rules for the current culture.</span></span>
<span data-ttu-id="38ad5-135">이를 종종 "단어 정렬 순서"라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-135">This is sometimes referred to as "word sort order."</span></span> <span data-ttu-id="38ad5-136">언어 비교를 수행할 때 일부 영숫자가 아닌 유니코드 문자에 특별한 가중치가 할당될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-136">When you perform a linguistic comparison, some nonalphanumeric Unicode characters might have special weights assigned.</span></span> <span data-ttu-id="38ad5-137">예를 들어, 하이픈 “-”은 작은 가중치가 할당될 수 있으므로 “co-op” 및 “coop”는 정렬 순서에 나란히 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-137">For example, the hyphen "-" may have a small weight assigned to it so that "co-op" and "coop" appear next to each other in sort order.</span></span> <span data-ttu-id="38ad5-138">또한 일부 유니코드 문자는 <xref:System.Char> 인스턴스의 시퀀스와 동일할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-138">In addition, some Unicode characters may be equivalent to a sequence of <xref:System.Char> instances.</span></span> <span data-ttu-id="38ad5-139">다음 예에서는 "ss" 및 'ß'를 사용하여 독일어로</span><span class="sxs-lookup"><span data-stu-id="38ad5-139">The following example uses the phrase "They dance in the street."</span></span> <span data-ttu-id="38ad5-140">독일어에서는 "ss"(U+0073 U+0073)가 한 문자열에 있고 'ß'(U+00DF)가 다른 문자열에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-140">in German with the "ss" (U+0073 U+0073) in one string and 'ß' (U+00DF) in another.</span></span> <span data-ttu-id="38ad5-141">언어적으로(Windows의 경우) "ss"는 "en-US" 및 "de-DE" 문화권에서 독일어 Esszet: 'ß' 문자와 같습니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-141">Linguistically (in Windows), "ss" is equal to the German Esszet: 'ß' character in both the "en-US" and "de-DE" cultures.</span></span>

:::code language="csharp" interactive="try-dotnet-method" source="../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs" id="Snippet3":::

<span data-ttu-id="38ad5-142">이 샘플에서는 운영 체제별 언어 비교 특성을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-142">This sample demonstrates the operating system-dependent nature of linguistic comparisons.</span></span> <span data-ttu-id="38ad5-143">대화형 창 호스트는 Linux 호스트입니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-143">The host for the interactive window is a Linux host.</span></span> <span data-ttu-id="38ad5-144">언어 및 서수 비교는 동일한 결과를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-144">The linguistic and ordinal comparisons produce the same results.</span></span> <span data-ttu-id="38ad5-145">같은 샘플을 Windows 호스트에서 실행한 경우 다음과 같은 출력이 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-145">If you run this same sample on a Windows host, you see the following output:</span></span>

```console
<coop> is less than <co-op> using invariant culture
<coop> is greater than <co-op> using ordinal comparison
<coop> is less than <cop> using invariant culture
<coop> is less than <cop> using ordinal comparison
<co-op> is less than <cop> using invariant culture
<co-op> is less than <cop> using ordinal comparison
```

<span data-ttu-id="38ad5-146">Windows에서 언어 비교를 서수 비교로 변경하면 "cop", "coop" 및 "co-op"의 정렬 순서가 변경됩니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-146">On Windows, the sort order of "cop", "coop", and "co-op" change when you change from a linguistic comparison to an ordinal comparison.</span></span> <span data-ttu-id="38ad5-147">두 개의 독일어 문장도 서로 다른 비교 형식을 사용하여 다르게 비교됩니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-147">The two German sentences also compare differently using the different comparison types.</span></span>

## <a name="comparisons-using-specific-cultures"></a><span data-ttu-id="38ad5-148">특정 문화권을 사용한 비교</span><span class="sxs-lookup"><span data-stu-id="38ad5-148">Comparisons using specific cultures</span></span>

<span data-ttu-id="38ad5-149">이 샘플은 en-US 및 de-DE 문화권에 대한 <xref:System.Globalization.CultureInfo> 개체를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-149">This sample stores <xref:System.Globalization.CultureInfo> objects for the en-US and de-DE cultures.</span></span>
<span data-ttu-id="38ad5-150">비교는 문화권별 비교를 보장하기 위해 <xref:System.Globalization.CultureInfo> 개체를 사용하여 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-150">The comparisons are performed using a <xref:System.Globalization.CultureInfo> object to ensure a culture-specific comparison.</span></span>

<span data-ttu-id="38ad5-151">사용된 문화권은 언어 비교에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-151">The culture used affects linguistic comparisons.</span></span> <span data-ttu-id="38ad5-152">다음 예에서는 "en-US" 문화권과 "de-DE" 문화권을 사용하여 두 개의 독일어 문장을 비교한 결과를 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-152">The following example shows the results of comparing the two German sentences using the "en-US" culture and the "de-DE" culture:</span></span>

:::code language="csharp" interactive="try-dotnet-method" source="../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs" id="Snippet4":::

<span data-ttu-id="38ad5-153">문화권별 비교는 일반적으로 사용자가 입력한 문자열을 사용자가 입력한 다른 문자열과 비교하여 정렬하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-153">Culture-sensitive comparisons are typically used to compare and sort strings input by users with other strings input by users.</span></span> <span data-ttu-id="38ad5-154">이러한 문자열의 문자 및 정렬 규칙은 사용자 컴퓨터의 로캘에 따라 달라질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-154">The characters and sorting conventions of these strings might vary depending on the locale of the user's computer.</span></span> <span data-ttu-id="38ad5-155">똑같은 문자가 포함된 문자열이라도 현재 스레드의 문화권에 따라 다르게 정렬될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-155">Even strings that contain identical characters might sort differently depending on the culture of the current thread.</span></span> <span data-ttu-id="38ad5-156">또한 이 샘플 코드를 Windows 머신에서 로컬로 시도하면 다음과 같은 결과가 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-156">In addition, try this sample code locally on a Windows machine, and you'll get the following results:</span></span>

```console
<coop> is less than <co-op> using en-US culture
<coop> is greater than <co-op> using ordinal comparison
<coop> is less than <cop> using en-US culture
<coop> is less than <cop> using ordinal comparison
<co-op> is less than <cop> using en-US culture
<co-op> is less than <cop> using ordinal comparison
```

<span data-ttu-id="38ad5-157">언어 비교는 현재 문화권에 따라 달라지며 OS에 종속됩니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-157">Linguistic comparisons are dependent on the current culture, and are OS dependent.</span></span> <span data-ttu-id="38ad5-158">문자열 비교 작업을 할 때 이 점을 고려하세요.</span><span class="sxs-lookup"><span data-stu-id="38ad5-158">Take that into account when you work with string comparisons.</span></span>

## <a name="linguistic-sorting-and-searching-strings-in-arrays"></a><span data-ttu-id="38ad5-159">배열의 언어적 정렬 및 문자열 검색</span><span class="sxs-lookup"><span data-stu-id="38ad5-159">Linguistic sorting and searching strings in arrays</span></span>

<span data-ttu-id="38ad5-160">다음 예에서는 현재 문화권에 따라 언어 비교를 사용하여 배열에서 문자열을 정렬하고 검색하는 방법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-160">The following examples show how to sort and search for strings in an array using a linguistic comparison dependent on the current culture.</span></span> <span data-ttu-id="38ad5-161"><xref:System.StringComparer?displayProperty=nameWithType> 매개 변수를 사용하는 정적 <xref:System.Array> 메서드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-161">You use the static <xref:System.Array> methods that take a <xref:System.StringComparer?displayProperty=nameWithType> parameter.</span></span>

<span data-ttu-id="38ad5-162">이 예에서는 현재 문화권을 사용하여 문자열 배열을 정렬하는 방법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-162">This example shows how to sort an array of strings using the current culture:</span></span>

:::code language="csharp" interactive="try-dotnet-method" source="../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs" id="Snippet5":::

<span data-ttu-id="38ad5-163">배열이 정렬되면 이진 검색을 사용하여 항목을 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-163">Once the array is sorted, you can search for entries using a binary search.</span></span> <span data-ttu-id="38ad5-164">이진 검색은 컬렉션의 중간에서 시작하여 컬렉션의 절반에서 검색 문자열이 포함되어 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-164">A binary search starts in the middle of the collection to determine which half of the collection would contain the sought string.</span></span> <span data-ttu-id="38ad5-165">이후의 각 비교는 컬렉션의 나머지 부분을 절반으로 세분합니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-165">Each subsequent comparison subdivides the remaining part of the collection in half.</span></span>  <span data-ttu-id="38ad5-166">배열은 <xref:System.StringComparer.CurrentCulture?displayProperty=nameWithType>을 사용하여 정렬됩니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-166">The array is sorted using the <xref:System.StringComparer.CurrentCulture?displayProperty=nameWithType>.</span></span> <span data-ttu-id="38ad5-167">로컬 함수 `ShowWhere`는 문자열이 발견된 위치에 대한 정보를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-167">The local function `ShowWhere` displays information about where the string was found.</span></span> <span data-ttu-id="38ad5-168">문자열을 찾을 수 없는 경우 반환된 값은 발견된 그 위치를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-168">If the string wasn't found, the returned value indicates where it would be if it were found.</span></span>

:::code language="csharp" interactive="try-dotnet-method" source="../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs" id="Snippet6":::

## <a name="ordinal-sorting-and-searching-in-collections"></a><span data-ttu-id="38ad5-169">컬렉션의 서수 정렬 및 검색</span><span class="sxs-lookup"><span data-stu-id="38ad5-169">Ordinal sorting and searching in collections</span></span>

<span data-ttu-id="38ad5-170">다음 코드에서는 <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> 컬렉션 클래스를 사용하여 문자열을 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-170">The following code uses the <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> collection class to store strings.</span></span> <span data-ttu-id="38ad5-171">문자열은 <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType> 메서드를 사용하여 정렬됩니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-171">The strings are sorted using the <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="38ad5-172">이 메서드에는 두 문자열을 비교하고 정렬하는 대리자가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-172">This method needs a delegate that compares and orders two strings.</span></span> <span data-ttu-id="38ad5-173"><xref:System.String.CompareTo%2A?displayProperty=nameWithType> 메서드는 비교 함수를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-173">The <xref:System.String.CompareTo%2A?displayProperty=nameWithType> method provides that comparison function.</span></span> <span data-ttu-id="38ad5-174">이 샘플을 실행하고 순서를 관찰합니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-174">Run the sample and observe the order.</span></span> <span data-ttu-id="38ad5-175">이 정렬 작업은 서수 대/소문자 구분 정렬을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-175">This sort operation uses an ordinal case-sensitive sort.</span></span> <span data-ttu-id="38ad5-176">정적 <xref:System.String.Compare%2A?displayProperty=nameWithType> 메서드를 사용하여 여러 비교 규칙을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-176">You would use the static <xref:System.String.Compare%2A?displayProperty=nameWithType> methods to specify different comparison rules.</span></span>

:::code language="csharp" interactive="try-dotnet-method" source="../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs" id="Snippet7":::

<span data-ttu-id="38ad5-177">정렬된 후에는 이진 검색을 사용하여 문자열 목록을 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-177">Once sorted, the list of strings can be searched using a binary search.</span></span> <span data-ttu-id="38ad5-178">다음 샘플에서는 동일한 비교 함수를 사용하여 정렬된 목록을 검색하는 방법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-178">The following sample shows how to search the sorted listed using the same comparison function.</span></span> <span data-ttu-id="38ad5-179">로컬 함수 `ShowWhere`는 검색된 텍스트가 어디에 있는지를 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-179">The local function `ShowWhere` shows where the sought text is or would be:</span></span>

:::code language="csharp" interactive="try-dotnet-method" source="../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs" id="Snippet8":::

<span data-ttu-id="38ad5-180">정렬 및 검색 시 항상 동일한 형식의 비교를 사용하도록 하세요.</span><span class="sxs-lookup"><span data-stu-id="38ad5-180">Always make sure to use the same type of comparison for sorting and searching.</span></span> <span data-ttu-id="38ad5-181">정렬 및 검색에 대해 서로 다른 비교 형식을 사용하면 예기치 않은 결과가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-181">Using different comparison types for sorting and searching produces unexpected results.</span></span>

<span data-ttu-id="38ad5-182"><xref:System.Collections.Hashtable?displayProperty=nameWithType>, <xref:System.Collections.Generic.Dictionary%602?displayProperty=nameWithType>, <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> 등의 컬렉션 클래스는 요소 또는 키의 형식이 `string`인 경우 <xref:System.StringComparer?displayProperty=nameWithType> 매개 변수를 사용하는 생성자를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-182">Collection classes such as <xref:System.Collections.Hashtable?displayProperty=nameWithType>, <xref:System.Collections.Generic.Dictionary%602?displayProperty=nameWithType>, and <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> have constructors that take a <xref:System.StringComparer?displayProperty=nameWithType> parameter when the type of the elements or keys is `string`.</span></span> <span data-ttu-id="38ad5-183">일반적으로 가능하면 이러한 생성자를 사용하고 <xref:System.StringComparer.Ordinal?displayProperty=nameWithType> 또는 <xref:System.StringComparer.OrdinalIgnoreCase?displayProperty=nameWithType>를 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-183">In general, you should use these constructors whenever possible, and specify either <xref:System.StringComparer.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparer.OrdinalIgnoreCase?displayProperty=nameWithType>.</span></span>

## <a name="reference-equality-and-string-interning"></a><span data-ttu-id="38ad5-184">참조 동일성과 문자열 인터닝</span><span class="sxs-lookup"><span data-stu-id="38ad5-184">Reference equality and string interning</span></span>

<span data-ttu-id="38ad5-185">샘플 중에 <xref:System.Object.ReferenceEquals%2A>를 사용한 것은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-185">None of the samples have used <xref:System.Object.ReferenceEquals%2A>.</span></span> <span data-ttu-id="38ad5-186">이 메서드는 두 문자열이 동일한 개체인지 여부를 결정하므로 문자열 비교의 결과가 일관되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-186">This method determines if two strings are the same object, which can lead to inconsistent results in string comparisons.</span></span> <span data-ttu-id="38ad5-187">다음 예에서는 C#의 *문자열 인터닝* 기능을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-187">The following example demonstrates the *string interning* feature of C#.</span></span> <span data-ttu-id="38ad5-188">프로그램이 두 개 이상의 동일 문자열 변수를 선언할 경우 컴파일러는 변수를 모두 같은 위치에 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-188">When a program declares two or more identical string variables, the compiler stores them all in the same location.</span></span> <span data-ttu-id="38ad5-189"><xref:System.Object.ReferenceEquals%2A> 메서드를 호출하여 두 문자열이 실제로 메모리에서 같은 개체를 참조하는지 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-189">By calling the <xref:System.Object.ReferenceEquals%2A> method, you can see that the two strings actually refer to the same object in memory.</span></span> <span data-ttu-id="38ad5-190">인터닝을 방지하려면 <xref:System.String.Copy%2A?displayProperty=nameWithType> 메서드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-190">Use the <xref:System.String.Copy%2A?displayProperty=nameWithType> method to avoid interning.</span></span> <span data-ttu-id="38ad5-191">복사본이 생성된 후 두 개의 문자열은 동일한 값을 가지더라도 스토리지 위치가 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-191">After the copy has been made, the two strings have different storage locations, even though they have the same value.</span></span> <span data-ttu-id="38ad5-192">`a` 및 `b`가 *인터닝* 되었음을, 즉 동일한 스토리지를 공유한다는 것을 보여주는 다음 샘플을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-192">Run the following sample to show that strings `a` and `b` are *interned* meaning they share the same storage.</span></span> <span data-ttu-id="38ad5-193">문자열 `a`와 `c`는 그렇지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-193">The strings `a` and `c` are not.</span></span>

:::code language="csharp" interactive="try-dotnet-method" source="../../../samples/snippets/csharp/how-to/strings/CompareStrings.cs" id="Snippet9":::

> [!NOTE]
> <span data-ttu-id="38ad5-194">문자열의 동일성을 테스트할 때, 어떤 유형의 비교를 수행할지 명시적으로 지정하는 메서드를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-194">When you test for equality of strings, you should use the methods that explicitly specify what kind of comparison you intend to perform.</span></span> <span data-ttu-id="38ad5-195">코드를 훨씬 더 쉽게 유지 관리하고 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-195">Your code is much more maintainable and readable.</span></span> <span data-ttu-id="38ad5-196"><xref:System.StringComparison> 열거형 매개 변수를 사용하는 <xref:System.String?displayProperty=nameWithType> 및 <xref:System.Array?displayProperty=nameWithType> 클래스의 메서드 오버로드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-196">Use the overloads of the methods of the <xref:System.String?displayProperty=nameWithType> and <xref:System.Array?displayProperty=nameWithType> classes that take a <xref:System.StringComparison> enumeration parameter.</span></span> <span data-ttu-id="38ad5-197">수행할 비교 형식을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-197">You specify which type of comparison to perform.</span></span> <span data-ttu-id="38ad5-198">동일성을 테스트할 때 `==` 및 `!=` 연산자를 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-198">Avoid using the `==` and `!=` operators when you test for equality.</span></span> <span data-ttu-id="38ad5-199"><xref:System.String.CompareTo%2A?displayProperty=nameWithType> 인스턴스 메서드는 항상 서수 대/소문자 구분 비교를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-199">The <xref:System.String.CompareTo%2A?displayProperty=nameWithType> instance methods always perform an ordinal case-sensitive comparison.</span></span> <span data-ttu-id="38ad5-200">주로 알파벳순으로 문자열을 정렬하는 데 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-200">They are primarily suited for ordering strings alphabetically.</span></span>

<span data-ttu-id="38ad5-201"><xref:System.String.Intern%2A?displayProperty=nameWithType> 메서드를 호출하여 문자열을 인터트하거나 기존의 인턴된 문자열에 대한 참조를 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-201">You can intern a string or retrieve a reference to an existing interned string by calling the <xref:System.String.Intern%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="38ad5-202">문자열이 인턴트되었는지 확인하려면 <xref:System.String.IsInterned%2A?displayProperty=nameWithType> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="38ad5-202">To determine whether a string is interned, call the <xref:System.String.IsInterned%2A?displayProperty=nameWithType> method.</span></span>

## <a name="see-also"></a><span data-ttu-id="38ad5-203">참조</span><span class="sxs-lookup"><span data-stu-id="38ad5-203">See also</span></span>

- <xref:System.Globalization.CultureInfo?displayProperty=nameWithType>
- <xref:System.StringComparer?displayProperty=nameWithType>
- [<span data-ttu-id="38ad5-204">문자열</span><span class="sxs-lookup"><span data-stu-id="38ad5-204">Strings</span></span>](../programming-guide/strings/index.md)
- [<span data-ttu-id="38ad5-205">문자열 비교</span><span class="sxs-lookup"><span data-stu-id="38ad5-205">Comparing strings</span></span>](../../standard/base-types/comparing.md)
- [<span data-ttu-id="38ad5-206">애플리케이션 전역화 및 지역화</span><span class="sxs-lookup"><span data-stu-id="38ad5-206">Globalizing and localizing applications</span></span>](/visualstudio/ide/globalizing-and-localizing-applications)
