---
title: C#에서 기본 인터페이스 메서드를 사용하여 안전하게 인터페이스 업데이트
description: 이 고급 자습서에서는 해당 인터페이스를 구현하는 모든 클래스 및 구성 요소를 훼손하지 않고 기존 인터페이스 정의에 새 기능을 안전하게 추가할 수 있는 방법을 살펴봅니다.
ms.date: 05/06/2019
ms.technlogy: csharp-advanced-concepts
ms.custom: mvc
ms.openlocfilehash: b9194b769a3ba6d2906d6177c2363d6093b85188
ms.sourcegitcommit: ad800f019ac976cb669e635fb0ea49db740e6890
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/29/2019
ms.locfileid: "73039246"
---
# <a name="tutorial-update-interfaces-with-default-interface-methods-in-c-80"></a><span data-ttu-id="0705b-103">자습서: C# 8.0에서 기본 인터페이스 메서드로 인터페이스를 업데이트</span><span class="sxs-lookup"><span data-stu-id="0705b-103">Tutorial: Update interfaces with default interface methods in C# 8.0</span></span>

<span data-ttu-id="0705b-104">.NET Core 3.0의 C# 8.0에서부터, 인터페이스 멤버 선언 시 구현을 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-104">Beginning with C# 8.0 on .NET Core 3.0, you can define an implementation when you declare a member of an interface.</span></span> <span data-ttu-id="0705b-105">가장 일반적인 시나리오는 이미 릴리스되어 수많은 클라이언트가 사용하는 인터페이스에 멤버를 안전하게 추가하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-105">The most common scenario is to safely add members to an interface already released and used by innumerable clients.</span></span>

<span data-ttu-id="0705b-106">이 자습서에서는 다음과 같은 작업을 수행하는 방법을 알아봅니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-106">In this tutorial, you'll learn how to:</span></span>

> [!div class="checklist"]
>
> * <span data-ttu-id="0705b-107">구현으로 메서드를 추가하여 안전하게 인터페이스를 확장합니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-107">Extend interfaces safely by adding methods with implementations.</span></span>
> * <span data-ttu-id="0705b-108">매개 변수가 있는 구현을 생성하여 향상된 유연성을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-108">Create parameterized implementations to provide greater flexibility.</span></span>
> * <span data-ttu-id="0705b-109">구현자가 재정의 형식으로 더 구체적인 구현을 제공하도록 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-109">Enable implementers to provide a more specific implementation in the form of an override.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="0705b-110">전제 조건</span><span class="sxs-lookup"><span data-stu-id="0705b-110">Prerequisites</span></span>

<span data-ttu-id="0705b-111">C# 8.0 컴파일러를 포함하여 .NET Core를 실행하도록 머신을 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-111">You’ll need to set up your machine to run .NET Core, including the C# 8.0 compiler.</span></span> <span data-ttu-id="0705b-112">C# 8.0 컴파일러는 [Visual Studio 2019 버전 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019) 또는 [.NET CORE 3.0 SDK](https://dotnet.microsoft.com/download)부터 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-112">The C# 8.0 compiler is available starting with [Visual Studio 2019 version 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019) or the [.NET Core 3.0 SDK](https://dotnet.microsoft.com/download).</span></span>

## <a name="scenario-overview"></a><span data-ttu-id="0705b-113">시나리오 개요</span><span class="sxs-lookup"><span data-stu-id="0705b-113">Scenario overview</span></span>

<span data-ttu-id="0705b-114">이 자습서는 고객 관계 라이브러리의 버전 1부터 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-114">This tutorial starts with version 1 of a customer relationship library.</span></span> <span data-ttu-id="0705b-115">[GitHub의 샘플 리포지토리](https://github.com/dotnet/samples/tree/master/csharp/tutorials/default-interface-members-versions/starter/customer-relationship)에서 시작 애플리케이션을 다운로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-115">You can get the starter application on our [samples repo on GitHub](https://github.com/dotnet/samples/tree/master/csharp/tutorials/default-interface-members-versions/starter/customer-relationship).</span></span> <span data-ttu-id="0705b-116">이 라이브러리를 구축한 회사는 기존 애플리케이션이 있는 고객이 자사의 라이브러리를 채택할 것을 의도했으며,</span><span class="sxs-lookup"><span data-stu-id="0705b-116">The company that built this library intended customers with existing applications to adopt their library.</span></span> <span data-ttu-id="0705b-117">구현할 라이브러리의 사용자에게 최소의 인터페이스 정의를 제공했습니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-117">They provided minimal interface definitions for users of their library to implement.</span></span> <span data-ttu-id="0705b-118">다음은 고객에 대한 인터페이스 정의입니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-118">Here's the interface definition for a customer:</span></span>

[!code-csharp[InitialCustomerInterface](~/samples/csharp/tutorials/default-interface-members-versions/starter/customer-relationship/ICustomer.cs?name=SnippetICustomerVersion1)]

<span data-ttu-id="0705b-119">이들은 주문을 나타내는 두 번째 인터페이스를 정의했습니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-119">They defined a second interface that represents an order:</span></span>

[!code-csharp[InitialOrderInterface](~/samples/csharp/tutorials/default-interface-members-versions/starter/customer-relationship/IOrder.cs?name=SnippetIorderVersion1)]

<span data-ttu-id="0705b-120">이러한 인터페이스에서, 팀은 사용자가 고객을 위해 더 나은 경험을 만들 수 있는 라이브러리를 빌드할 수 있었습니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-120">From those interfaces, the team could build a library for their users to create a better experience for their customers.</span></span> <span data-ttu-id="0705b-121">이들의 목표는 기존 고객과 더 깊은 관계를 형성하고 신규 고객과의 관계를 개선하는 것이었습니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-121">Their goal was to create a deeper relationship with existing customers and improve their relationships with new customers.</span></span>

<span data-ttu-id="0705b-122">이제, 다음 릴리스를 위해 라이브러리를 업그레이드할 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-122">Now, it's time to upgrade the library for the next release.</span></span> <span data-ttu-id="0705b-123">요청된 기능 중 하나는 주문건이 많은 고객을 위해 충성도 할인을 지원하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-123">One of the requested features enables a loyalty discount for customers that have lots of orders.</span></span> <span data-ttu-id="0705b-124">고객이 주문할 때마다 이 새로운 충성도 할인이 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-124">This new loyalty discount gets applied whenever a customer makes an order.</span></span> <span data-ttu-id="0705b-125">특정 할인은 각 개인 고객의 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-125">The specific discount is a property of each individual customer.</span></span> <span data-ttu-id="0705b-126">구현된 각 `ICustomer`마다 고객 할인에 대해 다른 규칙을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-126">Each implementation of `ICustomer` can set different rules for the loyalty discount.</span></span> 

<span data-ttu-id="0705b-127">이 기능을 추가하는 가장 일반적인 방법은 충성도 할인을 적용할 메서드로 `ICustomer` 인터페이스를 개선하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-127">The most natural way to add this functionality is to enhance the `ICustomer` interface with a method to apply any loyalty discount.</span></span> <span data-ttu-id="0705b-128">이러한 설계 제안은 숙련된 개발자 사이에서 우려를 일으켰습니다. "인터페이스는 릴리스된 후에는 변경이 불가합니다!</span><span class="sxs-lookup"><span data-stu-id="0705b-128">This design suggestion caused concern among experienced developers: "Interfaces are immutable once they've been released!</span></span> <span data-ttu-id="0705b-129">주요 변경 사항입니다!”</span><span class="sxs-lookup"><span data-stu-id="0705b-129">This is a breaking change!"</span></span> <span data-ttu-id="0705b-130">C#8.0은 인터페이스 업그레이드를 위해 *기본 인터페이스 구현*을 추가했습니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-130">C# 8.0 adds *default interface implementations* for upgrading interfaces.</span></span> <span data-ttu-id="0705b-131">라이브러리 작성자가 인터페이스에 새 멤버를 추가하고 해당 멤버에 대한 기본 구현을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-131">The library authors can add new members to the interface and provide a default implementation for those members.</span></span>

<span data-ttu-id="0705b-132">기본 인터페이스 구현을 통해 구현자는 해당 구현을 재지정하고 개발자는 인터페이스를 업그레이드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-132">Default interface implementations enable developers to upgrade an interface while still enabling any implementors to override that implementation.</span></span> <span data-ttu-id="0705b-133">라이브러리의 사용자는 기본 구현을 일반적인 변경으로 받아들일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-133">Users of the library can accept the default implementation as a non-breaking change.</span></span> <span data-ttu-id="0705b-134">비즈니스 규칙이 다른 경우 재지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-134">If their business rules are different, they can override.</span></span>

## <a name="upgrade-with-default-interface-methods"></a><span data-ttu-id="0705b-135">기본 인터페이스 메서드를 사용하여 업그레이드</span><span class="sxs-lookup"><span data-stu-id="0705b-135">Upgrade with default interface methods</span></span>

<span data-ttu-id="0705b-136">팀은 가장 가능성 있는 기본 구현, 즉 고객을 위한 충성도 할인에 합의했습니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-136">The team agreed on the most likely default implementation: a loyalty discount for customers.</span></span>

<span data-ttu-id="0705b-137">업그레이드는 할인 자격을 갖추기 위해 필요한 주문 수, 할인율, 이 두 가지 속성에 기능을 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-137">The upgrade should provide the functionality to set two properties: the number of orders needed to be eligible for the discount, and the percentage of the discount.</span></span> <span data-ttu-id="0705b-138">이로써 기본 인터페이스 메서드에 완벽한 시나리오가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-138">This makes it a perfect scenario for default interface methods.</span></span> <span data-ttu-id="0705b-139">`ICustomer` 인터페이스에 메서드를 추가하고 가장 가능성이 높은 구현을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-139">You can add a method to the `ICustomer` interface, and provide the most likely implementation.</span></span> <span data-ttu-id="0705b-140">모든 기존, 그리고 새 구현은 기본 구현을 사용하거나 자체 구현을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-140">All existing, and any new implementations can use the default implementation, or provide their own.</span></span>

<span data-ttu-id="0705b-141">먼저, 구현에 새 메서드를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-141">First, add the new method to the implementation:</span></span>

[!code-csharp[InitialOrderInterface](~/samples/csharp/tutorials/default-interface-members-versions/finished/customer-relationship/ICustomer.cs?name=SnippetLoyaltyDiscountVersionOne)]

<span data-ttu-id="0705b-142">라이브러리 작성자는 구현을 확인하기 위해 첫 번재 테스트를 작성했습니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-142">The library author wrote a first test to check the implementation:</span></span>

[!code-csharp[TestDefaultImplementation](~/samples/csharp/tutorials/default-interface-members-versions/finished/customer-relationship/Program.cs?name=SnippetTestDefaultImplementation)]

<span data-ttu-id="0705b-143">테스트의 다음 부분을 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-143">Notice the following portion of the test:</span></span>

[!code-csharp[TestDefaultImplementation](~/samples/csharp/tutorials/default-interface-members-versions/finished/customer-relationship/Program.cs?name=SnippetHighlightCast)]

<span data-ttu-id="0705b-144">`SampleCustomer`에서 `ICustomer`로의 캐스트가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-144">That cast from `SampleCustomer` to `ICustomer` is necessary.</span></span> <span data-ttu-id="0705b-145">`SampleCustomer` 클래스는 `ComputeLoyaltyDiscount`에 대한 구현을 제공할 필요가 없으며, `ICustomer` 인터페이스에서 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-145">The `SampleCustomer` class doesn't need to provide an implementation for `ComputeLoyaltyDiscount`; that's provided by the `ICustomer` interface.</span></span> <span data-ttu-id="0705b-146">그러나 `SampleCustomer` 클래스는 인터페이스에서 멤버를 상속하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-146">However, the `SampleCustomer` class doesn't inherit members from its interfaces.</span></span> <span data-ttu-id="0705b-147">이 규칙은 바뀌지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-147">That rule hasn't changed.</span></span> <span data-ttu-id="0705b-148">인터페이스에서 선언 및 구현된 메서드를 호출하려면 변수는 인터페이스 유형(이 예에서는 `ICustomer`)이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-148">In order to call any method declared and implemented in the interface, the variable must be the type of the interface, `ICustomer` in this example.</span></span>

## <a name="provide-parameterization"></a><span data-ttu-id="0705b-149">매개 변수화 제공</span><span class="sxs-lookup"><span data-stu-id="0705b-149">Provide parameterization</span></span>

<span data-ttu-id="0705b-150">시작이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-150">That's a good start.</span></span> <span data-ttu-id="0705b-151">그러나 기본 구현은 너무 제한적입니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-151">But, the default implementation is too restrictive.</span></span> <span data-ttu-id="0705b-152">이 시스템의 많은 소비자가 구매 건수에 다른 임계값, 다른 멤버십 기간 또는 다른 할인율을 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-152">Many consumers of this system may choose different thresholds for number of purchases, a different length of membership, or a different percentage discount.</span></span> <span data-ttu-id="0705b-153">이러한 매개 변수를 설정하는 방법을 제공하여 더 많은 고객에게 향상된 업그레이드 환경을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-153">You can provide a better upgrade experience for more customers by providing a way to set those parameters.</span></span> <span data-ttu-id="0705b-154">기본 구현을 제어하는 세 개의 매개 변수를 설정하는 정적 메서드를 추가해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-154">Let's add a static method that sets those three parameters controlling the default implementation:</span></span>

[!code-csharp[VersionTwoImplementation](~/samples/csharp/tutorials/default-interface-members-versions/finished/customer-relationship/ICustomer.cs?name=SnippetLoyaltyDiscountVersionTwo)]

<span data-ttu-id="0705b-155">이 작은 코드 조각에 표시되는 많은 새 언어 기능이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-155">There are many new language capabilities shown in that small code fragment.</span></span> <span data-ttu-id="0705b-156">이제 인터페이스는 필드 및 메서드를 포함한 정적 멤버를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-156">Interfaces can now include static members, including fields and methods.</span></span> <span data-ttu-id="0705b-157">서로 다른 액세스 한정자도 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-157">Different access modifiers are also enabled.</span></span> <span data-ttu-id="0705b-158">추가 필드는 비공개이고 새 메서드는 공개입니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-158">The additional fields are private, the new method is public.</span></span> <span data-ttu-id="0705b-159">어떠한 한정자도 인터페이스 멤버에서 허용됩니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-159">Any of the modifiers are allowed on interface members.</span></span>

<span data-ttu-id="0705b-160">충성도 할인을 계산하기 위해 일반 공식을 사용하지만 매개 변수는 다른 애플리케이션은 사용자 지정 구현을 제공할 필요가 없지만, 정적 메서드를 통해 인수를 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-160">Applications that use the general formula for computing the loyalty discount, but different parameters, don't need to provide a custom implementation; they can set the arguments through a static method.</span></span> <span data-ttu-id="0705b-161">예를 들어, 다음 코드는 멤버십이 1개월 이상인 고객에게 보답하는 “고객 감사”를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-161">For example, the following code sets a "customer appreciation" that rewards any customer with more than one month's membership:</span></span>

[!code-csharp[SetLoyaltyThresholds](~/samples/csharp/tutorials/default-interface-members-versions/finished/customer-relationship/Program.cs?name=SnippetSetLoyaltyThresholds)]

## <a name="extend-the-default-implementation"></a><span data-ttu-id="0705b-162">기본 구현 확장</span><span class="sxs-lookup"><span data-stu-id="0705b-162">Extend the default implementation</span></span>

<span data-ttu-id="0705b-163">지금까지 추가한 코드는 사용자가 기본 구현과 같은 것을 원하거나, 관련 없는 규칙 세트를 제공하는 시나리오에 편리한 구현을 제공했습니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-163">The code you've added so far has provided a convenient implementation for those scenarios where users want something like the default implementation, or to provide an unrelated set of rules.</span></span> <span data-ttu-id="0705b-164">최종 기능을 위해, 코드를 약간 리팩터링하여 사용자가 기본 구현을 기반으로 구축하려는 시나리오를 구현해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-164">For a final feature, let's refactor the code a bit to enable scenarios where users may want to build on the default implementation.</span></span> 

<span data-ttu-id="0705b-165">신규 고객을 유치하고 싶은 스타트업 회사가 있다고 해보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-165">Consider a startup that wants to attract new customers.</span></span> <span data-ttu-id="0705b-166">이 회사는 신규 고객의 첫 주문에 50% 할인을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-166">They offer a 50% discount off a new customer's first order.</span></span> <span data-ttu-id="0705b-167">한편, 기존 고객에게는 표준 할인이 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-167">Otherwise, existing customers get the standard discount.</span></span> <span data-ttu-id="0705b-168">라이브러리 작성자는 이 인터페이스를 구현하는 클래스가 해당 구현에서 코드를 재사용할 수 있도록 기본 구현을 `protected static` 메서드로 이동해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-168">The library author needs to move the default implementation into a `protected static` method so that any class implementing this interface can reuse the code in their implementation.</span></span> <span data-ttu-id="0705b-169">인터페이스 멤버의 기본 구현은 이 공유 메서드로 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-169">The default implementation of the interface member calls this shared method as well:</span></span>

[!code-csharp[VersionTwoImplementation](~/samples/csharp/tutorials/default-interface-members-versions/finished/customer-relationship/ICustomer.cs?name=SnippetFinalVersion)]

<span data-ttu-id="0705b-170">이 인터페이스를 구현하는 클래스의 구현에서 재지정은 정적 도우미 메서드를 호출하며, 이 논리를 확장하여 “신규 고객” 할인을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-170">In an implementation of a class that implements this interface, the override can call the static helper method, and extend that logic to provide the "new customer" discount:</span></span>

[!code-csharp[VersionTwoImplementation](~/samples/csharp/tutorials/default-interface-members-versions/finished/customer-relationship/SampleCustomer.cs?name=SnippetOverrideAndExtend)]

<span data-ttu-id="0705b-171">[GitHub의 샘플 리포지토리](https://github.com/dotnet/samples/tree/master/csharp/tutorials/default-interface-members-versions/finished/customer-relationship)에서 완성된 전체 코드를 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-171">You can see the entire finished code in our [samples repo on GitHub](https://github.com/dotnet/samples/tree/master/csharp/tutorials/default-interface-members-versions/finished/customer-relationship).</span></span> <span data-ttu-id="0705b-172">[GitHub의 샘플 리포지토리](https://github.com/dotnet/samples/tree/master/csharp/tutorials/default-interface-members-versions/starter/customer-relationship)에서 시작 애플리케이션을 다운로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-172">You can get the starter application on our [samples repo on GitHub](https://github.com/dotnet/samples/tree/master/csharp/tutorials/default-interface-members-versions/starter/customer-relationship).</span></span>

<span data-ttu-id="0705b-173">이러한 새 기능은 신규 멤버에 대한 합리적인 기본 구현이 있는 경우 인터페이스를 안전하게 업데이트할 수 있음을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-173">These new features mean that interfaces can be updated safely when there's a reasonable default implementation for those new members.</span></span> <span data-ttu-id="0705b-174">여러 클래스를 통해 구현할 수 있는 단일 기능 아이디어를 표현하려면 인터페이스를 신중하게 설계하세요.</span><span class="sxs-lookup"><span data-stu-id="0705b-174">Carefully design interfaces to express single functional ideas that can be implemented by multiple classes.</span></span> <span data-ttu-id="0705b-175">이를 통해 동일한 기능 아이디어에 새로운 요구 사항이 발견될 경우 해당 인터페이스 정의를 훨씬 쉽게 업그레이드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0705b-175">That makes it easier to upgrade those interface definitions when new requirements are discovered for that same functional idea.</span></span>
