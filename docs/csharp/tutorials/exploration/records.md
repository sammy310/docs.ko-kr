---
title: 레코드 형식 사용 - C# 자습서
description: 레코드 종류를 사용하는 방법, 레코드의 계층 구조를 작성하는 방법, 클래스에 대해 레코드를 선택하는 시기에 대해 알아봅니다.
ms.date: 11/12/2020
ms.openlocfilehash: 33075c4cafc9a91683960daa8101c9f1defaa36a
ms.sourcegitcommit: 9c589b25b005b9a7f87327646020eb85c3b6306f
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/06/2021
ms.locfileid: "102258958"
---
# <a name="create-record-types"></a><span data-ttu-id="c92a0-103">레코드 종류 만들기</span><span class="sxs-lookup"><span data-stu-id="c92a0-103">Create record types</span></span>

<span data-ttu-id="c92a0-104">C# 9에서는 클래스나 구조체 대신 만들 수 있는 새 참조 형식인 ‘레코드’를 소개합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-104">C# 9 introduces *records*, a new reference type that you can create instead of classes or structs.</span></span> <span data-ttu-id="c92a0-105">레코드는 레코드 종류가 ‘값 기반 같음’을 사용한다는 점에서 클래스와 구분됩니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-105">Records are distinct from classes in that record types use *value-based equality*.</span></span> <span data-ttu-id="c92a0-106">레코드 종류의 두 변수는 레코드 종류 정의가 동일한 경우와 모든 필드에 대해 두 레코드의 값이 같은 경우에 같습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-106">Two variables of a record type are equal if the record type definitions are identical, and if for every field, the values in both records are equal.</span></span> <span data-ttu-id="c92a0-107">클래스 형식의 두 변수는 참조되는 개체가 동일한 클래스 형식이고 변수가 동일한 개체를 참조하는 경우에 같습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-107">Two variables of a class type are equal if the objects referred to are the same class type and the variables refer to the same object.</span></span> <span data-ttu-id="c92a0-108">값 기반 같음은 레코드 종류에 필요할 수 있는 다른 기능을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-108">Value-based equality implies other capabilities you'll probably want in record types.</span></span> <span data-ttu-id="c92a0-109">컴파일러는 `class`대신 `record`를 선언할 때 이러한 멤버 대부분을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-109">The compiler generates many of those members when you declare a `record` instead of a `class`.</span></span>

<span data-ttu-id="c92a0-110">이 자습서에서 학습할 방법은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-110">In this tutorial, you'll learn how to:</span></span>

> [!div class="checklist"]
>
> - <span data-ttu-id="c92a0-111">`class`를 선언할지 `record`를 선언할지를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-111">Decide if you should declare a `class` or a `record`.</span></span>
> - <span data-ttu-id="c92a0-112">레코드 종류 및 위치 레코드 종류를 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-112">Declare record types and positional record types.</span></span>
> - <span data-ttu-id="c92a0-113">레코드에서 컴파일러 생성 메서드를 자신의 메서드로 대체합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-113">Substitute your methods for compiler generated methods in records.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="c92a0-114">사전 요구 사항</span><span class="sxs-lookup"><span data-stu-id="c92a0-114">Prerequisites</span></span>

<span data-ttu-id="c92a0-115">C# 9.0 이상 컴파일러를 포함하여 .NET 5 이상을 실행하도록 컴퓨터를 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-115">You'll need to set up your machine to run .NET 5 or later, including the C# 9.0 or later compiler.</span></span> <span data-ttu-id="c92a0-116">C# 9.0 컴파일러는 [Visual Studio 2019 버전 16.8](https://visualstudio.microsoft.com/vs) 또는 [.NET 5.0 SDK](https://dotnet.microsoft.com/download)부터 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-116">The C# 9.0 compiler is available starting with [Visual Studio 2019 version 16.8](https://visualstudio.microsoft.com/vs) or the [.NET 5.0 SDK](https://dotnet.microsoft.com/download).</span></span>

## <a name="characteristics-of-records"></a><span data-ttu-id="c92a0-117">레코드의 특징</span><span class="sxs-lookup"><span data-stu-id="c92a0-117">Characteristics of records</span></span>

<span data-ttu-id="c92a0-118">`class` 또는 `struct` 키워드 대신 `record` 키워드로 형식을 선언하여 ‘레코드’를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-118">You define a *record* by declaring a type with the `record` keyword, instead of the `class` or `struct` keyword.</span></span> <span data-ttu-id="c92a0-119">레코드는 참조 형식이며 값 기반 같음 의미 체계를 따릅니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-119">A record is a reference type and follows value-based equality semantics.</span></span> <span data-ttu-id="c92a0-120">값 의미 체계를 적용하기 위해 컴파일러는 레코드 종류에 대해 여러 가지 메서드를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-120">To enforce value semantics, the compiler generates several methods for your record type:</span></span>

- <span data-ttu-id="c92a0-121"><xref:System.Object.Equals(System.Object)?displayProperty=nameWithType>의 재정의.</span><span class="sxs-lookup"><span data-stu-id="c92a0-121">An override of <xref:System.Object.Equals(System.Object)?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="c92a0-122">매개 변수가 레코드 종류인 가상 `Equals` 메서드.</span><span class="sxs-lookup"><span data-stu-id="c92a0-122">A virtual `Equals` method whose parameter is the record type.</span></span>
- <span data-ttu-id="c92a0-123"><xref:System.Object.GetHashCode?displayProperty=nameWithType>의 재정의.</span><span class="sxs-lookup"><span data-stu-id="c92a0-123">An override of <xref:System.Object.GetHashCode?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="c92a0-124">`operator ==` 및 `operator !=`에 대한 메서드.</span><span class="sxs-lookup"><span data-stu-id="c92a0-124">Methods for `operator ==` and `operator !=`.</span></span>
- <span data-ttu-id="c92a0-125">레코드 종류는 <xref:System.IEquatable%601?displayProperty=nameWithType>를 구현.</span><span class="sxs-lookup"><span data-stu-id="c92a0-125">Record types implement <xref:System.IEquatable%601?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="c92a0-126">또한 레코드는 <xref:System.Object.ToString?displayProperty=nameWithType>의 재정의를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-126">In addition, records provide an override of <xref:System.Object.ToString?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c92a0-127">컴파일러는 <xref:System.Object.ToString?displayProperty=nameWithType>을 사용하여 레코드를 표시하기 위해 메서드를 합성합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-127">The compiler synthesizes methods for displaying records using <xref:System.Object.ToString?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c92a0-128">이 자습서에 대한 코드를 작성할 때 이러한 멤버를 살펴봅니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-128">You'll explore those members as you write the code for this tutorial.</span></span> <span data-ttu-id="c92a0-129">레코드는 레코드의 비파괴적 변경을 사용하도록 설정하는 `with` 식을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-129">Records support `with` expressions to enable non-destructive mutation of records.</span></span>

<span data-ttu-id="c92a0-130">더욱 간결한 구문을 사용하여 ‘위치 레코드’를 선언할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-130">You can also declare *positional records* using a more concise syntax.</span></span> <span data-ttu-id="c92a0-131">컴파일러는 위치 레코드를 선언할 때 더 많은 메서드를 합성합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-131">The compiler synthesizes more methods for you when you declare positional records:</span></span>

- <span data-ttu-id="c92a0-132">매개 변수가 레코드 선언의 위치 매개 변수와 일치하는 기본 생성자.</span><span class="sxs-lookup"><span data-stu-id="c92a0-132">A primary constructor whose parameters match the positional parameters on the record declaration.</span></span>
- <span data-ttu-id="c92a0-133">기본 생성자의 각 매개 변수에 대한 퍼블릭 init 전용 속성.</span><span class="sxs-lookup"><span data-stu-id="c92a0-133">Public init-only properties for each parameter of a primary constructor.</span></span>
- <span data-ttu-id="c92a0-134">레코드에서 속성을 추출하는 `Deconstruct` 메서드.</span><span class="sxs-lookup"><span data-stu-id="c92a0-134">A `Deconstruct` method to extract properties from the record.</span></span>

## <a name="build-temperature-data"></a><span data-ttu-id="c92a0-135">온도 데이터 빌드</span><span class="sxs-lookup"><span data-stu-id="c92a0-135">Build temperature data</span></span>

<span data-ttu-id="c92a0-136">데이터 및 통계는 레코드를 사용하려는 시나리오 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-136">Data and statistics are among the scenarios where you'll want to use records.</span></span> <span data-ttu-id="c92a0-137">이 자습서에서는 서로 다른 용도로 ‘도일’(degree days)을 계산하는 애플리케이션을 빌드합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-137">For this tutorial, you'll build an application that computes *degree days* for different uses.</span></span> <span data-ttu-id="c92a0-138">‘도일’은 일정 기간(일, 주, 월) 동안 열(또는 열 부족)을 측정한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-138">*Degree days* are a measure of heat (or lack of heat) over a period of days, weeks, or months.</span></span> <span data-ttu-id="c92a0-139">도일은 에너지 사용량을 추적하고 예측합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-139">Degree days track and predict energy usage.</span></span> <span data-ttu-id="c92a0-140">더운 날이 많을수록 에어컨 사용량이 많아지고, 추운 날이 많을수록 난로 사용량이 많아집니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-140">More hotter days means more air conditioning, and more colder days means more furnace usage.</span></span> <span data-ttu-id="c92a0-141">도일은 식물 개체군 관리에 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-141">Degree days help manage plant populations.</span></span> <span data-ttu-id="c92a0-142">도일은 계절 변화에 따른 식물 성장과 상관 관계가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-142">Degree days correlate to plant growth as the seasons change.</span></span> <span data-ttu-id="c92a0-143">도일은 기후에 따라 이동하는 동물 종의 이동을 추적하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-143">Degree days help track animal migrations for species that travel to match climate.</span></span>

<span data-ttu-id="c92a0-144">수식은 지정된 날짜의 평균 온도와 기준 온도를 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-144">The formula is based on the mean temperature on a given day and a baseline temperature.</span></span> <span data-ttu-id="c92a0-145">시간에 따른 도일을 계산하려면 일정 기간 동안 각 날짜의 높은 온도와 낮은 온도가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-145">To compute degree days over time, you'll need the high and low temperature each day for a period of time.</span></span> <span data-ttu-id="c92a0-146">먼저 새 애플리케이션을 만들어 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-146">Let's start by creating a new application.</span></span> <span data-ttu-id="c92a0-147">새 콘솔 애플리케이션을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-147">Make a new console application.</span></span> <span data-ttu-id="c92a0-148">“DailyTemperature.cs”라는 새 파일에 새 레코드 종류를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-148">Create a new record type in a new file named "DailyTemperature.cs":</span></span>

:::code language="csharp" source="snippets/record-types/InterimSteps.cs" ID="DailyRecord":::

<span data-ttu-id="c92a0-149">위의 코드는 ‘위치 레코드’를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-149">The preceding code defines a *positional record*.</span></span> <span data-ttu-id="c92a0-150">`HighTemp`와 `LowTemp`의 두 속성을 포함하는 참조 형식을 만들었습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-150">You've created a reference type that contains two properties: `HighTemp`, and `LowTemp`.</span></span> <span data-ttu-id="c92a0-151">이러한 속성은 ‘init 전용 속성’이므로 생성자에서 설정하거나 속성 이니셜라이저를 사용하여 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-151">Those properties are *init only properties*, meaning they can be set in the constructor or using a property initializer.</span></span> <span data-ttu-id="c92a0-152">`DailyTemperature` 형식에는 두 개의 속성과 일치하는 두 개의 매개 변수가 있는 ‘기본 생성자’도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-152">The `DailyTemperature` type also has a *primary constructor* that has two parameters that match the two properties.</span></span> <span data-ttu-id="c92a0-153">기본 생성자를 사용하여 `DailyTemperature` 레코드를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-153">You use the primary constructor to initialize a `DailyTemperature` record:</span></span>

:::code language="csharp" source="snippets/record-types/Program.cs" ID="DeclareData":::

<span data-ttu-id="c92a0-154">위치 레코드를 포함하여 고유한 속성 또는 메서드를 레코드에 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-154">You can add your own properties or methods to records, including positional records.</span></span> <span data-ttu-id="c92a0-155">각 날짜의 평균 온도를 계산해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-155">You'll need to compute the mean temperature for each day.</span></span> <span data-ttu-id="c92a0-156">`DailyTemperature` 레코드에 해당 속성을 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-156">You can add that property to the `DailyTemperature` record:</span></span>

:::code language="csharp" source="snippets/record-types/DailyTemperature.cs" ID="TemperatureRecord":::

<span data-ttu-id="c92a0-157">이 데이터를 사용할 수 있는지 확인해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-157">Let's make sure you can use this data.</span></span> <span data-ttu-id="c92a0-158">`Main` 메서드에 다음 코드를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-158">Add the following code to your `Main` method:</span></span>

```csharp
foreach (var item in data)
    Console.WriteLine(item);
```

<span data-ttu-id="c92a0-159">애플리케이션을 실행하면 다음과 같은 출력이 표시됩니다(공간상의 이유로 여러 행을 제거함).</span><span class="sxs-lookup"><span data-stu-id="c92a0-159">Run your application, and you'll see output that looks similar to the following display (several rows removed for space):</span></span>

```dotnetcli
DailyTemperature { HighTemp = 57, LowTemp = 30, Mean = 43.5 }
DailyTemperature { HighTemp = 60, LowTemp = 35, Mean = 47.5 }


DailyTemperature { HighTemp = 80, LowTemp = 60, Mean = 70 }
DailyTemperature { HighTemp = 85, LowTemp = 66, Mean = 75.5 }
```

<span data-ttu-id="c92a0-160">위의 코드는 컴파일러에 의해 합성된 `ToString` 재정의의 출력을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-160">The preceding code shows the output from the override of `ToString` synthesized by the compiler.</span></span> <span data-ttu-id="c92a0-161">다른 텍스트를 원하는 경우 `ToString`의 고유한 버전을 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-161">If you prefer different text, you can write your own version of `ToString`.</span></span> <span data-ttu-id="c92a0-162">그러면 컴파일러에서 자동으로 버전을 합성할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-162">That prevents the compiler from synthesizing a version for you.</span></span>

## <a name="compute-degree-days"></a><span data-ttu-id="c92a0-163">도일 계산</span><span class="sxs-lookup"><span data-stu-id="c92a0-163">Compute degree days</span></span>

<span data-ttu-id="c92a0-164">도일을 계산하려면 지정된 날짜의 기준 온도와 평균 온도의 차이를 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-164">To compute degree days, you take the difference from a baseline temperature and the mean temperature on a given day.</span></span> <span data-ttu-id="c92a0-165">시간에 따른 더위를 측정하려면 평균 온도가 기준보다 낮은 날짜를 모두 삭제합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-165">To measure heat over time, you discard any days where the mean temperature is below the baseline.</span></span> <span data-ttu-id="c92a0-166">시간에 따른 추위를 측정하려면 평균 온도가 기준보다 높은 날짜를 모두 삭제합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-166">To measure cold over time, you discard any days where the mean temperature is above the baseline.</span></span> <span data-ttu-id="c92a0-167">예를 들어 미국은 난방 및 냉방 도일의 기준으로 65F를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-167">For example, the U.S. uses 65F as the base for both heating  and cooling degree days.</span></span> <span data-ttu-id="c92a0-168">이 온도는 난방 또는 냉방이 필요하지 않은 온도입니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-168">That's the temperature where no heating or cooling is needed.</span></span> <span data-ttu-id="c92a0-169">하루 평균 온도가 70F인 경우 그날 냉방 도일은 5이고 난방 도일은 0입니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-169">If a day has a mean temperature of 70F, that day is 5 cooling degree days and 0 heating degree days.</span></span> <span data-ttu-id="c92a0-170">반대로 평균 온도가 55F인 경우 난방 도일은 10이고 냉방 도일은 0입니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-170">Conversely, if the mean temperature is 55F, that day is 10 heating degree days and 0 cooling degree days.</span></span>

<span data-ttu-id="c92a0-171">이러한 수식을 레코드 형식의 작은 계층 구조, 즉 하나의 추상적 도일 형식과 그 아래에 난방 도일 및 냉방 도일이라는 구체적인 두 가지 형식으로 표현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-171">You can express these formulas as a small hierarchy of record types: an abstract degree day type and two concrete types for heating degree days and cooling degree days.</span></span> <span data-ttu-id="c92a0-172">이러한 형식은 위치 레코드일 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-172">These types can also be positional records.</span></span> <span data-ttu-id="c92a0-173">기준 온도와 일련의 일일 온도를 기본 생성자의 인수로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-173">They take a baseline temperature and a sequence of daily temperature records as arguments to the primary constructor:</span></span>

:::code language="csharp" source="snippets/record-types/InterimSteps.cs" ID="DegreeDaysRecords":::

<span data-ttu-id="c92a0-174">추상 `DegreeDays` 레코드는 `HeatingDegreeDays` 및 `CoolingDegreeDays` 레코드의 공유 기본 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-174">The abstract `DegreeDays` record is the shared base class for both the `HeatingDegreeDays` and `CoolingDegreeDays` records.</span></span> <span data-ttu-id="c92a0-175">파생 레코드의 기본 생성자 선언에서는 기본 레코드 초기화를 관리하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-175">The primary constructor declarations on the derived records show how to manage base record initialization.</span></span> <span data-ttu-id="c92a0-176">파생 레코드는 기본 레코드 기본 생성자의 모든 매개 변수에 대한 매개 변수를 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-176">Your derived record declares parameters for all the parameters in the base record primary constructor.</span></span> <span data-ttu-id="c92a0-177">기본 레코드는 이러한 속성을 선언하고 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-177">The base record declares and initializes those properties.</span></span> <span data-ttu-id="c92a0-178">파생 레코드는 이러한 속성을 숨기지는 않지만 기본 레코드에 선언되지 않은 매개 변수의 속성만 만들고 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-178">The derived record doesn't hide them, but only creates and initializes properties for parameters that aren't declared in its base record.</span></span> <span data-ttu-id="c92a0-179">이 예제에서 파생 레코드는 새로운 기본 생성자 매개 변수를 추가하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-179">In this example, the derived records don't add new primary constructor parameters.</span></span> <span data-ttu-id="c92a0-180">`Main` 메서드에 다음 코드를 추가하여 코드를 테스트합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-180">Test your code by adding the following code to your `Main` method:</span></span>

:::code language="csharp" source="snippets/record-types/Program.cs" ID="HeatingAndCooling":::

<span data-ttu-id="c92a0-181">다음과 같은 출력이 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-181">You'll get output like the following display:</span></span>

```dotnetcli
HeatingDegreeDays { BaseTemperature = 65, TempRecords = record_types.DailyTemperature[], DegreeDays = 85 }
CoolingDegreeDays { BaseTemperature = 65, TempRecords = record_types.DailyTemperature[], DegreeDays = 71.5 }
```

## <a name="define-compiler-synthesized-methods"></a><span data-ttu-id="c92a0-182">컴파일러 합성 메서드 정의</span><span class="sxs-lookup"><span data-stu-id="c92a0-182">Define compiler-synthesized methods</span></span>

<span data-ttu-id="c92a0-183">코드는 해당 기간 동안의 정확한 난방 및 냉방 도일 수를 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-183">Your code calculates the correct number of heating and cooling degree days over that period of time.</span></span> <span data-ttu-id="c92a0-184">그러나 이 예제에서는 레코드에 대한 합성 메서드 중 일부를 바꿔야 하는 이유를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-184">But this example shows why you may want to replace some of the synthesized methods for records.</span></span> <span data-ttu-id="c92a0-185">clone 메서드를 제외하고 고유한 버전의 컴파일러 합성 메서드를 레코드 종류에서 선언할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-185">You can declare your own version of any of the compiler-synthesized methods in a record type except the clone method.</span></span> <span data-ttu-id="c92a0-186">clone 메서드는 컴파일러 생성 이름을 사용하므로 다른 구현을 제공할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-186">The clone method has a compiler generated name and you cannot provide a different implementation.</span></span> <span data-ttu-id="c92a0-187">이러한 합성 메서드로는 복사 생성자, <xref:System.IEquatable%601?displayProperty=nameWithType> 인터페이스의 멤버, 같음 및 같지 않음 테스트, <xref:System.Object.GetHashCode>가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-187">These synthesized methods include a copy constructor, the members of the <xref:System.IEquatable%601?displayProperty=nameWithType> interface, equality and inequality tests, and <xref:System.Object.GetHashCode>.</span></span> <span data-ttu-id="c92a0-188">이러한 용도로 `PrintMembers`를 합성합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-188">For this purpose, you'll synthesize `PrintMembers`.</span></span> <span data-ttu-id="c92a0-189">고유한 `ToString`을 선언할 수도 있지만 `PrintMembers`는 상속 시나리오에 더 나은 옵션을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-189">You could also declare your own `ToString`, but `PrintMembers` provides a better option for inheritance scenarios.</span></span> <span data-ttu-id="c92a0-190">고유한 버전의 합성 메서드를 제공하려면 서명이 합성 메서드와 일치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-190">To provide your own version of a synthesized method, the signature must match the synthesized method.</span></span>

<span data-ttu-id="c92a0-191">콘솔 출력의 `TempRecords` 요소는 유용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-191">The `TempRecords` element in the console output isn't useful.</span></span> <span data-ttu-id="c92a0-192">이 요소는 형식만 표시하고 다른 항목은 전혀 표시하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-192">It displays the type, but nothing else.</span></span> <span data-ttu-id="c92a0-193">합성 `PrintMembers` 메서드의 고유한 구현을 제공하여 이 동작을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-193">You can change this behavior by providing your own implementation of the synthesized `PrintMembers` method.</span></span> <span data-ttu-id="c92a0-194">서명은 `record` 선언에 적용된 한정자에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-194">The signature depends on modifiers applied to the `record` declaration:</span></span>

- <span data-ttu-id="c92a0-195">레코드 종류가 `sealed`이면 서명은 `private bool PrintMembers(StringBuilder builder);`입니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-195">If a record type is `sealed`, the signature is `private bool PrintMembers(StringBuilder builder);`</span></span>
- <span data-ttu-id="c92a0-196">레코드 종류가 `sealed`가 아니고 `object`에서 파생되면(즉, 기본 레코드를 선언하지 않음) 서명은 `protected virtual bool PrintMembers(StringBuilder builder);`입니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-196">If a record type isn't `sealed` and derives from `object` (that is, it doesn't declare a base record), the signature is `protected virtual bool PrintMembers(StringBuilder builder);`</span></span>
- <span data-ttu-id="c92a0-197">레코드 종류가 `sealed`가 아니고 다른 레코드에서 파생되면 서명은 `protected override bool PrintMembers(StringBuilder builder);`입니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-197">If a record type isn't `sealed` and derives from another record, the signature is `protected override bool PrintMembers(StringBuilder builder);`</span></span>

<span data-ttu-id="c92a0-198">이러한 규칙은 `PrintMembers`의 용도에 대한 이해를 통해 가장 쉽게 이해할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-198">These rules are easiest to comprehend through understanding the purpose of `PrintMembers`.</span></span> <span data-ttu-id="c92a0-199">`PrintMembers`는 레코드 종류의 각 속성에 대한 정보를 문자열에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-199">`PrintMembers` adds information about each property in a record type to a string.</span></span> <span data-ttu-id="c92a0-200">계약에서는 표시할 멤버를 추가하려면 기본 레코드가 필요하며 파생 멤버는 해당 멤버를 추가하는 것으로 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-200">The contract requires base records to add their members to the display and assumes derived members will add their members.</span></span> <span data-ttu-id="c92a0-201">각 레코드 종류는 `HeatingDegreeDays`에 대한 다음 예제와 유사하게 표시되는 `ToString` 재정의를 합성합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-201">Each record type synthesizes a `ToString` override that looks similar to the following example for `HeatingDegreeDays`:</span></span>

```csharp
public override string ToString()
{
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.Append("HeatingDegreeDays");
    stringBuilder.Append(" { ");
    if (PrintMembers(stringBuilder))
    {
        stringBuilder.Append(" ");
    }
    stringBuilder.Append("}");
    return stringBuilder.ToString();
}
```

<span data-ttu-id="c92a0-202">컬렉션의 형식을 출력하지 않는 `DegreeDays` 레코드에 `PrintMembers` 메서드를 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-202">You declare a `PrintMembers` method in the `DegreeDays` record that doesn't print the type of the collection:</span></span>

:::code language="csharp" source="snippets/record-types/DegreeDays.cs" ID="AddPrintMembers":::

<span data-ttu-id="c92a0-203">서명은 컴파일러의 버전과 일치하도록 `virtual protected` 메서드를 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-203">The signature declares a `virtual protected` method to match the compiler's version.</span></span> <span data-ttu-id="c92a0-204">잘못된 접근자를 가져와도 걱정할 필요가 없습니다. 언어에서 올바른 서명을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-204">Don't worry if you get the accessors wrong; the language enforces the correct signature.</span></span> <span data-ttu-id="c92a0-205">합성 메서드에 대한 올바른 한정자를 잊은 경우 컴파일러는 올바른 서명을 가져오는 데 도움이 되는 경고 또는 오류를 발생시킵니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-205">If you forget the correct modifiers for any synthesized method, the compiler issues warnings or errors that help you get the right signature.</span></span>

## <a name="non-destructive-mutation"></a><span data-ttu-id="c92a0-206">비파괴적 변경</span><span class="sxs-lookup"><span data-stu-id="c92a0-206">Non-destructive mutation</span></span>

<span data-ttu-id="c92a0-207">위치 레코드의 합성 멤버는 레코드의 상태를 수정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-207">The synthesized members in a positional record don't modify the state of the record.</span></span> <span data-ttu-id="c92a0-208">목표는 변경이 불가능한 레코드를 더욱 쉽게 만들 수 있도록 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-208">The goal is that you can more easily create immutable records.</span></span> <span data-ttu-id="c92a0-209">`HeatingDegreeDays` 및 `CoolingDegreeDays`에 대한 위의 선언을 다시 살펴보세요.</span><span class="sxs-lookup"><span data-stu-id="c92a0-209">Look again at the preceding declarations for `HeatingDegreeDays` and `CoolingDegreeDays`.</span></span> <span data-ttu-id="c92a0-210">추가된 멤버는 레코드의 값에 대해 계산을 수행하지만 상태를 변경하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-210">The members added perform computations on the values for the record, but don't mutate state.</span></span> <span data-ttu-id="c92a0-211">위치 레코드를 사용하면 변경이 불가능한 참조 형식을 더욱 쉽게 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-211">Positional records make it easier for you to create immutable reference types.</span></span>

<span data-ttu-id="c92a0-212">변경이 불가능한 참조 형식을 만드는 것은 비파괴적 변경을 사용한다는 의미입니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-212">Creating immutable reference types means you'll want to use non-destructive mutation.</span></span> <span data-ttu-id="c92a0-213">[`with` 식](../../language-reference/operators/with-expression.md)을 사용하여 기존 레코드 인스턴스와 유사한 새 레코드 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-213">You  create new record instances that are similar to existing record instances using [`with` expressions](../../language-reference/operators/with-expression.md).</span></span> <span data-ttu-id="c92a0-214">이러한 식은 복사본을 수정하는 추가 할당이 있는 복사본 생성입니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-214">These expressions are a copy construction with additional assignments that modify the copy.</span></span> <span data-ttu-id="c92a0-215">그러면 각 속성이 기존 레코드에서 복사되고 선택적으로 수정된 새 레코드 인스턴스가 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-215">The result is a new record instance where each property has been copied from the existing record and optionally modified.</span></span> <span data-ttu-id="c92a0-216">원래 레코드는 변경되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-216">The original record is unchanged.</span></span>

<span data-ttu-id="c92a0-217">`with` 식을 보여 주는 몇 가지 기능을 프로그램에 추가해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-217">Let's add a couple features to your program that demonstrate `with` expressions.</span></span> <span data-ttu-id="c92a0-218">먼저 동일한 데이터를 사용하여 증가하는 도일을 계산하는 새 레코드를 만들어 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-218">First, let's create a new record to compute growing degree days using the same data.</span></span> <span data-ttu-id="c92a0-219">일반적으로 ‘증가하는 도일’은 41F를 기준으로 사용하고 기준보다 높은 온도를 측정합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-219">*Growing degree days* typically uses 41F as the baseline and measures temperatures above the baseline.</span></span> <span data-ttu-id="c92a0-220">동일한 데이터를 사용하려면 `coolingDegreeDays`와 유사하지만 기본 온도는 다른 새 레코드를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-220">To use the same data, you can create a new record that is similar to the `coolingDegreeDays`, but with a different base temperature:</span></span>

:::code language="csharp" source="snippets/record-types/Program.cs" ID="GrowingDegreeDays":::

<span data-ttu-id="c92a0-221">계산된 도수를 더 높은 기준 온도로 생성된 수와 비교할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-221">You can compare the number of degrees computed to the numbers generated with a higher baseline temperature.</span></span> <span data-ttu-id="c92a0-222">레코드는 ‘참조 형식’이며 이러한 복사본은 단순 복사본입니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-222">Remember that records are *reference types* and these copies are shallow copies.</span></span> <span data-ttu-id="c92a0-223">데이터의 배열은 복사되지 않지만 두 레코드 모두 동일한 데이터를 참조합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-223">The array for the data isn't copied, but both records refer to the same data.</span></span> <span data-ttu-id="c92a0-224">이러한 사실은 또 다른 시나리오에서 장점이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-224">That fact is an advantage in one other scenario.</span></span> <span data-ttu-id="c92a0-225">증가하는 도일의 경우 이전 5일간의 합계를 추적하는 것이 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-225">For growing degree days, it's useful to keep track of the total for the previous 5 days.</span></span> <span data-ttu-id="c92a0-226">`with` 식을 사용하여 다른 소스 데이터로 새 레코드를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-226">You can create new records with different source data using `with` expressions.</span></span> <span data-ttu-id="c92a0-227">다음 코드에서는 이러한 누적의 컬렉션을 빌드하고 값을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-227">The following code builds a collection of these accumulations, then displays the values:</span></span>

:::code language="csharp" source="snippets/record-types/Program.cs" ID="RunningFiveDayTotal":::

<span data-ttu-id="c92a0-228">`with` 식을 사용하여 레코드 복사본을 만들 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-228">You can also use `with` expressions to create copies of records.</span></span> <span data-ttu-id="c92a0-229">`with` 식의 중괄호 사이에 속성을 지정하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="c92a0-229">Don't specify any properties between the braces for the `with` expression.</span></span> <span data-ttu-id="c92a0-230">그러면 복사본을 만들고 속성은 변경하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-230">That means create a copy, and don't change any properties:</span></span>

```csharp
var growingDegreeDaysCopy = growingDegreeDays with { };
```

<span data-ttu-id="c92a0-231">완성된 애플리케이션을 실행하여 결과를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-231">Run the finished application to see the results.</span></span>

## <a name="summary"></a><span data-ttu-id="c92a0-232">요약</span><span class="sxs-lookup"><span data-stu-id="c92a0-232">Summary</span></span>

<span data-ttu-id="c92a0-233">이 자습서에서는 레코드의 여러 측면을 보여 주었습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-233">This tutorial showed several aspects of records.</span></span> <span data-ttu-id="c92a0-234">레코드는 기본 용도가 데이터 저장인 참조 형식에 대해 간결한 구문을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-234">Records provide concise syntax for reference types where the fundamental use is storing data.</span></span> <span data-ttu-id="c92a0-235">개체 지향 클래스의 기본 용도는 책임을 정의하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-235">For object-oriented classes, the fundamental use is defining responsibilities.</span></span> <span data-ttu-id="c92a0-236">이 자습서에서는 간결한 구문을 사용하여 레코드에 대한 init 전용 속성을 선언할 수 있는 ‘위치 레코드’를 집중적으로 살펴보았습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-236">This tutorial focused on *positional records*, where you can use a concise syntax to declare the init-only properties for a record.</span></span> <span data-ttu-id="c92a0-237">컴파일러는 레코드를 복사하고 비교하기 위해 레코드의 여러 멤버를 합성합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-237">The compiler synthesizes several members of the record for copying and comparing records.</span></span> <span data-ttu-id="c92a0-238">레코드 종류에 필요한 다른 멤버를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-238">You can add any other members you need for your record types.</span></span> <span data-ttu-id="c92a0-239">컴파일러 생성 멤버는 상태가 변경되지 않는다는 점을 이해하고 변경 불가능한 레코드 형식을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-239">You can create immutable record types knowing that none of the compiler-generated members would mutate state.</span></span> <span data-ttu-id="c92a0-240">그리고 `with` 식을 사용하여 비파괴적 변경을 쉽게 지원할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-240">And `with` expressions make it easy to support non-destructive mutation.</span></span>

<span data-ttu-id="c92a0-241">레코드는 형식을 정의하는 또 다른 방법을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-241">Records add another way to define types.</span></span> <span data-ttu-id="c92a0-242">`class` 정의를 사용하여 개체의 책임이나 동작에 중점을 둔 개체 지향 계층 구조를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-242">You use `class` definitions to create object-oriented hierarchies that focus on the responsibilities and behavior of objects.</span></span> <span data-ttu-id="c92a0-243">데이터를 저장할 뿐만 아니라 아주 작아서 효율적으로 복사할 수 있는 데이터 구조에 대해 `struct` 형식을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-243">You create `struct` types for data structures that store data and are small enough to copy efficiently.</span></span> <span data-ttu-id="c92a0-244">값 기반 같음 및 비교를 원하지만 값을 복사하지 않고 참조 변수를 사용하려는 경우 레코드를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-244">You create records when you want value-based equality and comparison, don't want to copy values, and want to use reference variables.</span></span>

<span data-ttu-id="c92a0-245">[레코드 형식에 대한 C# 언어 참조 설명서](../../language-reference/builtin-types/record.md) 및 [제안된 레코드 형식 사양](~/_csharplang/proposals/csharp-9.0/records.md)을 참조하여 레코드에 대한 자세한 설명을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c92a0-245">You can learn the complete description of records by reading the [C# language reference article for the record type)](../../language-reference/builtin-types/record.md) and the [proposed record type specification](~/_csharplang/proposals/csharp-9.0/records.md).</span></span>
