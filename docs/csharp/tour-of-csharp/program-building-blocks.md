---
title: C# 프로그램의 구성 요소
description: C# 멤버, 식 및 문에 대해 알아봅니다. 형식에는 사용자가 작성하는 멤버가 포함됩니다. 이러한 멤버는 문과 식에서 빌드됩니다.
ms.date: 08/06/2020
ms.openlocfilehash: e4350f2c2b6005fb59dd868f0f7f628bd07b0053
ms.sourcegitcommit: ffd4d5e824db6c5f0c3521c0e802fd9e8f0edcbe
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/04/2020
ms.locfileid: "93342698"
---
# <a name="program-building-blocks"></a>프로그램 구성 요소

이전 문서에 설명된 형식은 [***멤버** _](../programming-guide/classes-and-structs/members.md), [_*_식_*_ , _*_문_*_](../programming-guide/statements-expressions-operators/index.md)이라는 구성 요소를 사용하여 빌드됩니다.

## <a name="members"></a>멤버

`class`의 멤버는 정적 멤버 또는 인스턴스 멤버입니다.  정적 멤버는 클래스에 속하며 인스턴스 멤버는 개체(클래스의 인스턴스)에 속합니다.

다음은 클래스가 포함할 수는 멤버의 종류입니다.

- 상수: 클래스와 연결된 상수 값
- **필드** :  클래스와 연결된 변수
- **메서드** :  클래스가 수행할 수 있는 작업
- **Properties** : 클래스의 명명된 속성에 대한 읽기 및 쓰기와 관련된 작업
- **인덱서** : 클래스 인스턴스를 배열처럼 인덱싱하는 것과 관련된 작업
- **이벤트** : 클래스에 의해 생성될 수 있는 알림
- **연산자** : 클래스가 지원하는 변환 및 식 연산자
- **생성자** : 클래스의 인스턴스 또는 클래스 자체를 초기화하는 데 필요한 작업
- **종료자** : 클래스의 인스턴스가 영구적으로 삭제되기 전에 수행한 작업
- **형식** : 클래스에 의해 선언된 중첩 형식

## <a name="accessibility"></a>접근성

클래스의 각 멤버에는 해당 멤버에 액세스할 수 있는 프로그램 텍스트의 영역을 제어하는 액세스 수준이 있습니다. 액세스 가능성은 여섯 가지 형태로 제공됩니다. 다음은 액세스 한정자입니다.

- `public`: 액세스가 제한되지 않음
- `private`: 이 클래스로만 액세스가 제한됨
- `protected`: 이 클래스 또는 이 클래스에서 파생된 클래스로만 액세스가 제한됨
- `internal`: 액세스가 현재 어셈블리(`.exe` 또는 `.dll`)로 제한됩니다.
- `protected internal`: 액세스가 이 클래스, 이 클래스에서 파생된 클래스 또는 동일한 어셈블리 내의 클래스로만 제한됩니다.
- `private protected`: 액세스가 이 클래스 또는 동일한 어셈블리 내의 이 형식에서 파생된 클래스로만 제한됩니다.

## <a name="fields"></a>필드

*필드* 는 클래스 또는 클래스의 인스턴스와 연결된 변수입니다.

static 한정자를 사용하여 선언된 필드는 정적 필드를 정의합니다. 정적 필드는 정확히 하나의 스토리지 위치를 식별합니다. 클래스의 인스턴스가 몇 개나 만들어졌는지에 관계없이 정적 필드의 복사본은 하나뿐입니다.

static 한정자 없이 선언된 필드는 인스턴스 필드를 정의합니다. 클래스의 모든 인스턴스는 해당 클래스의 모든 인스턴스 필드의 별도 복사본을 포함합니다.

다음 예제에서 `Color` 클래스의 각 인스턴스는 `R`, `G` 및 `B` 인스턴스 필드의 별도 복사본을 갖지만 `Black`, `White`, `Red`, `Green` 및 `Blue` 정적 필드의 복사본은 하나뿐입니다.

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ColorClassDefinition":::

앞의 예제와 같이 *읽기 전용 필드* 는 `readonly` 한정자를 사용하여 선언될 수 있습니다. 읽기 전용 필드에 대한 할당은 필드 선언의 일부로 또는 동일한 클래스의 생성자에서만 발생할 수 있습니다.

## <a name="methods"></a>메서드

*메서드* 는 개체 또는 클래스에서 수행할 수 있는 계산이나 작업을 구현하는 멤버입니다. *정적 메서드* 는 클래스를 통해 액세스됩니다. *인스턴스 메서드* 는 클래스의 인스턴스를 통해 액세스됩니다.

메서드에는 메서드로 전달되는 값 또는 변수 참조를 나타내는 ‘매개 변수’ 목록이 있을 수 있습니다. 메서드에는 메서드에 의해 계산되고 반환되는 값의 형식을 지정하는 ‘반환 형식’이 있습니다. 메서드가 값을 반환하지 않을 경우 반환 형식은 `void`입니다.

형식과 마찬가지로 메서드에는 메서드가 호출될 때 형식 인수가 지정되어야 하는 형식 매개 변수 집합도 있을 수 있습니다. 형식과 달리 형식 인수는 종종 메서드 호출의 인수에서 유추될 수 있으므로 명시적으로 지정할 필요가 없습니다.

메서드의 *시그니처* 는 메서드가 선언되는 클래스에서 고유해야 합니다. 메서드 시그니처는 메서드의 이름, 형식 매개 변수의 수, 해당 매개 변수의 수, 한정자 및 형식으로 구성됩니다. 메서드 시그니처는 반환 형식을 포함하지 않습니다.

메서드 본문이 단일 식인 경우 메서드는 다음 예제와 같이 간결한 식 형식을 사용하여 정의할 수 있습니다.

```csharp
public override string ToString() => "This is an object";
```

### <a name="parameters"></a>매개 변수

매개 변수는 메서드에 값 또는 변수 참조를 전달하는 데 사용됩니다. 메서드의 매개 변수는 메서드가 호출될 때 지정된 *인수* 에서 실제 값을 가져옵니다. 매개 변수에는 값 매개 변수, 참조 매개 변수, 출력 매개 변수 및 매개 변수 배열의 네 가지 종류가 있습니다.

*값 매개 변수* 는 입력 매개 변수를 전달하는 데 사용됩니다. 값 매개 변수는 매개 변수에 전달된 인수에서 초기 값을 가져오는 지역 변수에 해당합니다. 값 매개 변수를 수정해도 해당 매개 변수에 전달된 인수에는 영향을 주지 않습니다.

해당 인수를 생략할 수 있도록 기본값을 지정하면 값 매개 변수는 선택적일 수 있습니다.

*참조 매개 변수* 는 인수를 참조로 전달하는 데 사용됩니다. 참조 매개 변수에 전달되는 인수는 한정된 값을 가진 변수여야 합니다. 메서드를 실행하는 동안 참조 매개 변수는 인수 변수와 동일한 스토리지 위치를 나타냅니다. 참조 매개 변수는 `ref` 한정자를 사용하여 선언됩니다. 다음 예제에서는 `ref` 매개 변수를 사용하는 방법을 보여 줍니다.

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="RefExample":::

*출력 매개 변수* 는 인수를 참조로 전달하는 데 사용됩니다. 호출자가 제공한 인수에 값을 명시적으로 할당할 필요가 없다는 점을 제외하고 참조 매개 변수와 비슷합니다. 출력 매개 변수는 `out` 한정자를 사용하여 선언됩니다. 다음 예제에서는 C# 7에서 도입된 구문으로 `out` 매개 변수를 사용하는 방법을 보여 줍니다.

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="OutExample":::

*매개 변수 배열* 은 다양한 개수의 인수가 메서드에 전달되도록 허용합니다. 매개 변수 배열은 `params` 한정자를 사용하여 선언됩니다. 메서드의 마지막 매개 변수만 매개 변수 배열일 수 있으며 매개 변수 배열의 형식은 1차원 배열 형식이어야 합니다. <xref:System.Console?displayProperty=nameWithType> 클래스의 `Write` 및 `WriteLine` 메서드는 매개 변수 배열 사용의 좋은 예입니다. 이러한 메서드는 다음과 같이 선언됩니다.

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ConsoleExtract":::

매개 변수 배열을 사용하는 메서드 내에서 매개 변수 배열은 배열 형식의 일반 매개 변수와 정확히 동일하게 동작합니다. 그러나 매개 변수 배열을 사용한 메서드 호출에서 매개 변수 배열 형식의 단일 인수 또는 매개 변수 배열에 있는 임의 개수의 요소 형식 인수를 전달할 수 있습니다. 후자의 경우 지정된 인수를 사용하여 배열 인스턴스가 자동으로 만들어지고 초기화됩니다. 다음 예제는

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UseParamsArgs":::

다음을 작성하는 것과 같습니다.

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="CompilerParams":::

### <a name="method-body-and-local-variables"></a>메서드 본문 및 지역 변수

메서드의 본문은 메서드가 호출될 때 실행할 문을 지정합니다.

메서드 본문은 메서드 호출과 관련된 변수를 선언할 수 있습니다. 이러한 변수를 *지역 변수* 라고 합니다. 지역 변수 선언은 형식 이름, 변수 이름을 지정하며 초기 값을 지정할 수도 있습니다. 다음 예제에서는 초기 값이 0인 지역 변수 `i`와 초기 값이 없는 지역 변수 `j`를 선언합니다.

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="SquaresClass":::

C#에서는 해당 값을 얻기 위해 먼저 로컬 변수를 *명확 하게 할당* 해야 합니다. 예를 들어 이전 `i`의 선언이 초기 값을 포함하지 않으면 컴파일러는 `i`의 후속 사용에 대해 오류를 보고합니다. `i`는 프로그램에서 해당 시점에 명확하게 할당되지 않은 것이기 때문입니다.

메서드는 `return` 문을 사용하여 해당 호출자에게 컨트롤을 반환할 수 있습니다. `void`를 반환하는 메서드에서 `return` 문은 식을 지정할 수 없습니다. void 이외의 값을 반환하는 메서드에서 `return` 문은 반환 값을 계산하는 식을 포함해야 합니다.

### <a name="static-and-instance-methods"></a>정적 및 인스턴스 메서드

`static` 한정자를 사용하여 선언된 메서드는 ‘정적 메서드’입니다. 정적 메서드는 특정 인스턴스에 작동하지 않고 정적 멤버에 직접적으로만 액세스할 수 있습니다.

`static` 한정자를 사용하지 않고 선언된 메서드는 ‘인스턴스 메서드’입니다. 인스턴스 메서드는 특정 인스턴스에 작동하며 정적 및 인스턴스 멤버 둘 다에 액세스할 수 있습니다. 인스턴스 메서드가 호출된 인스턴스는 `this`로 명시적으로 액세스할 수 있습니다. 정적 메서드에서 `this`를 참조하면 오류가 발생합니다.

다음 `Entity` 클래스에는 정적 멤버와 인스턴스 멤버가 모두 있습니다.

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="EntityClass":::

각 `Entity` 인스턴스에는 일련 번호(및 여기에 표시되지 않는 몇몇 정보)가 포함되어 있습니다. `Entity` 생성자(인스턴스 메서드와 유사함)는 사용 가능한 다음 일련 번호를 사용하여 새 인스턴스를 초기화합니다. 생성자가 인스턴스 멤버이기 때문에 `_serialNo` 인스턴스 필드 및 `s_nextSerialNo` 정적 필드 둘 다에 액세스하도록 허용됩니다.

`GetNextSerialNo` 및 `SetNextSerialNo` 정적 메서드는 `s_nextSerialNo` 정적 필드에 액세스할 수 있지만 `_serialNo` 인스턴스 필드에 직접 액세스하면 오류가 발생합니다.

다음 예제에서는 사용 된 `Entity` 클래스입니다.

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UsingEntity":::

`SetNextSerialNo` 및 `GetNextSerialNo` 정적 메서드는 클래스에 대해 호출되지만 `GetSerialNo` 인스턴스 메서드는 클래스의 인스턴스에 대해 호출됩니다.

### <a name="virtual-override-and-abstract-methods"></a>가상, 재정의 및 추상 메서드

인스턴스 메서드 선언에 `virtual` 한정자가 포함되면 해당 메서드를 *가상 메서드* 라고 합니다. 가상 한정자가 없으면 해당 메서드를 *비가상 메서드* 라고 합니다.

가상 메서드가 호출되면 호출이 발생하는 인스턴스의 *런타임 형식* 에 따라 호출할 실제 메서드 구현이 결정됩니다. 비가상 메서드 호출에서는 인스턴스의 *컴파일 타임 형식* 이 결정 요인입니다.

가상 메서드는 파생된 클래스에서 *재정의* 될 수 있습니다. 인스턴스 메서드 선언에 재정의 한정자가 포함될 경우 메서드는 동일한 시그니처로 상속된 가상 메서드를 재정의합니다. 가상 메서드 선언은 새 메서드를 도입합니다. 재정의 메서드 선언은 해당 메서드의 새 구현을 제공하여 기존의 상속된 가상 메서드를 특수화합니다.

*추상 메서드* 는 구현이 없는 가상 메서드입니다. 추상 메서드는 `abstract` 한정자를 사용하여 선언되며 추상 클래스에서만 허용됩니다. 추상 메서드는 모든 비추상 파생 클래스에서 재정의해야 합니다.

다음 예제에서는 식 트리 노드를 나타내는 추상 클래스 `Expression`와 상수, 변수 참조 및 산술 연산에 대한 식 트리 노드를 구현하는 세 개의 파생 클래스 `Constant`, `VariableReference` 및 `Operation`을 선언합니다. (이 예제는 식 트리 형식과 비슷하지만 관련은 없습니다.)

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="WorkingWithExpressions":::

이전의 4개 클래스는 산술 연산자를 모델링하는 데 사용할 수 있습니다. 예를 들어 이러한 클래스의 인스턴스를 사용할 경우 식 `x + 3`을 다음과 같이 나타낼 수 있습니다.

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UseExpressions":::

`Expression` 인스턴스의 `Evaluate` 메서드는 지정된 식을 계산하고 `double` 값을 생성하기 위해 호출됩니다. 이 메서드는 변수 이름(항목의 키)과 값(항목의 값)을 포함하는 `Dictionary` 인수를 사용합니다. `Evaluate`가 추상 메서드이기 때문에 `Expression`에서 파생된 비추상 클래스는 `Evaluate`를 재정의해야 합니다.

`Evaluate`의 `Constant` 구현은 단순히 저장된 상수를 반환합니다. `VariableReference`의 구현은 사전에서 변수 이름을 조회하고 결과 값을 반환합니다. `Operation`의 구현은 먼저 왼쪽 및 오른쪽 피연산자를 계산하고(재귀적으로 해당 `Evaluate` 메서드 호출) 지정된 산술 연산을 수행합니다.

다음 프로그램에서는 `Expression` 클래스를 사용하여 `x` 및 `y`의 다른 값에 대해 식 `x * (y + 2)`를 계산합니다.

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UsingExpressions":::

### <a name="method-overloading"></a>메서드 오버로드

메서드 *오버로드* 는 동일한 클래스가 고유한 시그니처를 갖는 한, 동일한 이름을 갖도록 허용합니다. 오버로드된 메서드의 호출을 컴파일할 때 컴파일러는 *오버로드 확인* 을 사용하여 호출할 특정 메서드를 결정합니다. 오버로드 확인은 인수와 가장 적합하게 일치하는 단일 메서드를 찾습니다. 최상의 일치 메서드를 찾을 수 있는 경우 오류를 보고합니다. 다음 예제에서는 실제로 진행되는 오버로드 확인을 보여 줍니다. `UsageExample` 메서드의 각 호출에 대한 주석은 어느 메서드가 호출되었는지 보여 줍니다.

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="Overloading":::

예제와 같이, 인수를 정확한 매개 변수 형식과 형식 인수로 명시적으로 캐스팅하여 항상 특정 메서드를 선택할 수 있습니다.

## <a name="other-function-members"></a>기타 함수 멤버

실행 코드를 포함하는 멤버를 통칭하여 클래스의 *함수 멤버* 라고 합니다. 이전 섹션에서는 함수 멤버의 기본 종류인 메서드에 대해 설명했습니다. 이 섹션에서는 C#에서 지원하는 다른 종류의 함수 멤버인 생성자, 속성, 인덱서, 이벤트, 연산자 및 종료자에 대해 설명합니다.

다음 예제에서는 늘어날 수 있는 개체 목록을 구현하는 `MyList<T>`라는 제네릭 클래스를 보여 줍니다. 이 클래스는 함수 멤버의 가장 일반적인 몇 가지 예제를 포함합니다.

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListExample":::

### <a name="constructors"></a>생성자

C#은 인스턴스 및 정적 생성자를 모두 지원합니다. *인스턴스 생성자* 는 클래스의 인스턴스를 초기화하는 데 필요한 작업을 구현하는 멤버입니다. ‘정적 생성자’는 처음 로드될 때 클래스 자체를 초기화하는 데 필요한 동작을 구현하는 멤버입니다.

생성자는 반환 형식이 없고 포함하는 클래스와 동일한 이름을 갖는 메서드처럼 선언됩니다. 생성자 선언에 `static` 한정자가 포함될 경우 정적 생성자를 선언합니다. 그렇지 않으면 인스턴스 생성자를 선언합니다.

인스턴스 생성자는 오버로드될 수 있으며 선택적 매개 변수를 가질 수 있습니다. 예를 들어 `MyList<T>` 클래스는 단일 선택적 `int` 매개 변수를 사용하여 하나의 인스턴스 생성자를 선언합니다. 인스턴스 생성자는 `new` 연산자를 사용하여 호출됩니다. 다음 문은 각각 선택적 인수를 사용하거나 사용하지 않고 `MyList<string>` 클래스의 생성자를 사용하여 2가지 `MyList` 인스턴스를 할당합니다.

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="CreateLists":::

다른 멤버와 달리 인스턴스 생성자는 상속되지 않습니다. 클래스에는 클래스에서 실제로 선언된 인스턴스 생성자 외에는 인스턴스 생성자가 없습니다. 클래스에 대해 인스턴스 생성자가 제공되지 않으면 매개 변수가 없는 빈 인스턴스 생성자가 자동으로 제공됩니다.

### <a name="properties"></a>속성

*속성* 은 필드의 기본 확장입니다. 둘 다 연결된 형식으로 명명되는 멤버이며, 필드 및 속성에 액세스하는 구문은 동일합니다. 그러나 필드와 달리 속성은 스토리지 위치를 명시하지 않습니다. 대신, 속성에는 해당 값을 읽거나 쓸 때 실행될 문을 지정하는 ‘접근자’가 있습니다.

속성은 필드처럼 선언되지만, 선언이 세미콜론으로 끝나지 않고, 구분 기호 `{` 및 `}` 사이에 쓴 get 접근자 또는 set 접근자로 끝난다는 점이 다릅니다. get 접근자 및 set 접근자가 둘 다 있는 속성은 *읽기/쓰기 속성* 이고, get 접근자만 있는 속성은 *읽기 전용 속성* 이고, set 접근자만 있는 속성은 *쓰기 전용 속성* 입니다.

get 접근자는 속성 형식의 반환 값을 갖는 매개 변수 없는 메서드에 해당합니다. set 접근자는 value라는 단일 매개 변수를 가지며 반환 형식이 없는 메서드에 해당합니다. get 접근자는 속성의 값을 계산합니다. set 접근자는 속성에 새 값을 제공합니다. 속성이 할당의 대상이거나 `++` 또는 `--`의 피연산자인 경우 set 접근자가 호출됩니다. 속성이 참조되는 그 밖의 경우에는 get 접근자가 호출됩니다.

`MyList<T>` 클래스는 각각 읽기 전용 및 읽기/쓰기 특성을 갖는 두 개의 속성 `Count` 및 `Capacity`를 선언합니다. 다음 코드는 이러한 속성을 사용하는 예입니다.

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="AccessProperties":::

필드 및 메서드와 마찬가지로, C#은 인스턴스 속성 및 정적 속성을 모두 지원합니다. 정적 속성은 static 한정자를 사용하여 선언되고 인스턴스 속성은 이 한정자를 사용하지 않고 선언됩니다.

속성의 접근자는 가상일 수 있습니다. 속성 선언에 `virtual`, `abstract`, 또는 `override` 한정자가 포함되면 속성의 접근자에 적용됩니다.

### <a name="indexers"></a>인덱서

*인덱서* 는 개체가 배열과 같은 방식으로 인덱싱될 수 있도록 하는 멤버입니다. 인덱서는 `this`과(와) 구분 기호 `[` 및 `]` 사이에 작성된 매개 변수 목록을 합쳐서 구성원 이름으로 사용한다는 점을 제외하고 속성처럼 선언됩니다. 매개 변수는 인덱서의 접근자에서 사용할 수 있습니다. 속성과 마찬가지로 인덱서는 읽기/쓰기, 읽기 전용 및 쓰기 전용일 수 있으며 인덱서의 접근자는 가상일 수 있습니다.

`MyList<T>` 클래스는 `int` 매개 변수를 사용하는 단일 읽기/쓰기 인덱서를 선언합니다. 인덱서는 `MyList<T>` 인스턴스를 `int` 값으로 인덱싱할 수 있도록 합니다. 예를 들어 다음과 같은 가치를 제공해야 합니다.

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListAccess":::

인덱서는 오버로드될 수 있습니다. 하나의 클래스는 매개 변수의 수와 형식이 다른 여러 인덱서를 선언할 수 있습니다.

### <a name="events"></a>이벤트

*이벤트* 는 클래스 또는 개체가 알림을 제공할 수 있도록 하는 멤버입니다. 이벤트는 선언에 `event` 키워드가 포함되고 형식이 대리자 형식이어야 한다는 점을 제외하고 필드처럼 선언됩니다.

이벤트 멤버를 선언하는 클래스 내에서 이벤트는 대리자 형식의 필드처럼 동작합니다(이벤트가 추상이 아니고 접근자를 선언하지 않을 경우). 필드는 이벤트에 추가된 이벤트 처리기를 나타내는 대리자에 대한 참조를 저장합니다. 이벤트 처리기가 없는 경우 필드는 `null`입니다.

`MyList<T>` 클래스는 `Changed`라는 단일 이벤트 멤버를 선언합니다. 이것은 새 항목이 목록에 추가되었음을 나타냅니다. Changed 이벤트는 `OnChanged` 가상 메서드에 의해 발생합니다. 이 메서드는 먼저 이벤트가 `null`인지 확인합니다(처리기가 없음을 의미함). 이벤트 발생 개념은 이벤트가 나타내는 대리자를 호출하는 것과 정확히 동일하므로 이벤트 발생을 위한 특수한 언어 구문은 없습니다.

클라이언트는 *이벤트 처리기* 를 통해 이벤트에 반응합니다. 이벤트 처리기는 `+=` 연산자를 사용하여 추가되고, `-=` 연산자를 사용하여 제거됩니다. 다음 예제에서는 이벤트 처리기를 `MyList<string>`의 `Changed` 이벤트에 추가합니다.

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="RespondToEvents":::

이벤트의 기본 스토리지를 제어하려고 하는 고급 시나리오의 경우 이벤트 선언에서 속성의 `set` 접근자와 비슷한 `add` 및 `remove` 접근자를 명시적으로 제공할 수 있습니다.

### <a name="operators"></a>연산자

*연산자* 는 클래스 인스턴스에 특정 식 연산자를 적용하는 것의 의미를 정의하는 멤버입니다. 세 가지 종류의 연산자, 즉, 단항 연산자, 이항 연산자 및 변환 연산자를 정의할 수 있습니다. 모든 연산자는 `public` 및 `static`으로 선언해야 합니다.

`MyList<T>` 클래스는 두 개의 연산자 `operator ==` 및 `operator !=`를 선언합니다. 이들 재정의된 연산자는 해당 연산자를 `MyList` 인스턴스에 적용하는 식에 새로운 의미를 부여합니다. 특히, 이러한 연산자는 해당 `Equals` 메서드를 사용하여 포함된 각 개체를 비교할 때 두 `MyList<T>` 인스턴스의 같음을 정의합니다. 다음 예제에서는 `==` 연산자를 사용하여 두 `MyList<int>` 인스턴스를 비교합니다.

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListAddition":::

두 목록은 같은 순서로 같은 값을 갖는 동일한 수의 개체를 포함하므로 첫 번째 `Console.WriteLine`은 `True`를 출력합니다. `MyList<T>`에서 `operator ==`이 정의되지 않았으면 `a` 및 `b`은 다른 `MyList<int>` 인스턴스를 참조하므로 첫 번째 `Console.WriteLine`은 `False`를 출력합니다.

### <a name="finalizers"></a>종료자

*종료자* 는 클래스의 인스턴스를 종결하는 데 필요한 작업을 구현하는 멤버입니다. 종료자는 일반적으로 관리되지 않는 리소스를 해제하는 데 필요합니다. 종료자는 매개 변수를 가질 수 없고, 액세스 수준 한정자를 가질 수 없으며, 명시적으로 호출할 수 없습니다. 인스턴스에 대한 종료자는 가비지 수집 중에 자동으로 호출됩니다. 자세한 내용은 [종료자](../programming-guide/classes-and-structs/destructors.md) 문서를 참조하세요.

가비지 수집기는 개체를 수집하고 종료자를 실행할 시기를 유연하게 결정할 수 있도록 합니다. 특히, 종료자 호출 타이밍은 결정적이 아니며, 모든 스레드에서 종료자를 실행할 수 있습니다. 이러한 이유 및 기타 이유로 클래스는 가능한 다른 솔루션이 없을 때만 종료자를 구현해야 합니다.

`using` 문은 개체 소멸을 위한 더 나은 방법을 제공합니다.

## <a name="expressions"></a>표현식

*식* 은 *피연산자* 및 *연산자* 로 생성됩니다. 식의 연산자는 피연산자에 적용할 연산을 나타냅니다. 연산자의 예로 `+`, `-`, `*`, `/` 및 `new`가 있습니다. 피연산자의 예로는 리터럴, 필드, 지역 변수 및 식이 있습니다.

식에 여러 연산자가 포함된 경우 연산자의 ‘우선 순위’는 개별 연산자가 평가되는 순서를 제어합니다. 예를 들어 `*` 연산자는 `+` 연산자보다 우선 순위가 더 높기 때문에 식 `x + y * z`는 `x + (y * z)`로 계산됩니다.

피연산자는 동일한 우선 순위를 가진 두 연산자 사이에 나올 경우 연산자의 *결합성* 에 따라 연산이 수행되는 순서가 제어됩니다.

* 대입 및 Null 병합 연산자를 제외하고 모든 이항 연산자는 *왼쪽 결합성* 을 갖습니다. 즉, 연산이 왼쪽에서 오른쪽으로 수행됩니다. 예를 들어, `x + y + z`는 `(x + y) + z`로 계산됩니다.
* 대입 연산자, Null 병합 `??` 및 `??=` 연산자, 조건부 연산자(`?:`)는 *오른쪽 결합성* 을 갖습니다. 즉, 연산이 오른쪽에서 왼쪽으로 수행됩니다. 예를 들어, `x = y = z`는 `x = (y = z)`로 계산됩니다.

우선 순위 및 결합성은 괄호를 사용하여 제어할 수 있습니다. 예를 들어 `x + y * z`는 먼저 `y`와 `z`를 곱한 다음 그 결과를 `x`와 더하지만 `(x + y) * z`는 먼저 `x`와 `y`를 더한 다음 그 결과에 `z`를 곱합니다.

대부분의 연산자는 [*오버로드*](../language-reference/operators/operator-overloading.md)할 수 있습니다. 연산자 오버로드는 피연산자 중 하나 또는 둘 다가 사용자 정의 클래스 또는 구조체 형식인 연산에 대해 사용자 정의 연산자 구현을 지정할 수 있도록 허용합니다.

C#은 [산술](../language-reference/operators/arithmetic-operators.md), [논리](../language-reference/operators/boolean-logical-operators.md), [비트 및 시프트](../language-reference/operators/bitwise-and-shift-operators.md) 연산과 [같음](../language-reference/operators/equality-operators.md) 및 [순서](../language-reference/operators/comparison-operators.md) 비교를 수행하는 여러 연산자를 제공합니다.

우선 순위 수준에 따라 정렬된 전체 연산자 목록은 [C# 연산자](../language-reference/operators/index.md)를 참조하세요.

## <a name="statements"></a>문

프로그램의 동작은 *문* 을 사용하여 표현됩니다. C#은 여러 다른 종류의 문을 지원하며 이중 많은 문이 포함 문에 대해 정의됩니다.

- *블록* 은 단일 문이 허용되는 컨텍스트에서 여러 문을 쓸 수 있도록 허용합니다. 블록은 구분 기호 `{`와 `}` 사이에 쓴 문 목록으로 구성됩니다.
- *선언 문* 은 지역 변수 및 상수를 선언하는 데 사용됩니다.
- *식 문* 은 식을 평가하는 데 사용됩니다. 문으로 사용할 수 있는 식에는 메서드 호출, `new` 연산자를 사용하는 개체 할당, `=` 및 복합 할당 연산자를 사용하는 대입, `++` 및 `--` 연산자를 사용하는 증가 및 감소 연산, `await` 식이 포함됩니다.
- *선택 문* 은 일부 식 값에 따라 실행할 수 있는 다양한 문 중에서 하나를 선택하는 데 사용됩니다. 이 그룹에는 `if` 문과 `switch` 문이 포함됩니다.
- *반복 문* 은 포함 문을 반복해서 실행하는 데 사용됩니다. 이 그룹에는 `while` 문, `do` 문, `for` 문과 `foreach` 문이 포함됩니다.
- *점프 문* 은 제어를 전달하는 데 사용됩니다. 이 그룹에는 `break` 문, `continue` 문, `goto` 문, `throw` 문, `return` 문과 `yield` 문이 포함됩니다.
- `try`... `catch` 문은 블록 실행 중에 발생하는 예외를 catch하는 데 사용되고 `try`... `finally` 문은 예외 발생 여부에 관계 없이 항상 실행되는 종료 코드를 지정하는 데 사용됩니다.
- `checked` 및 `unchecked` 문은 정수 계열 형식 산술 연산 및 변환에 대한 오버플로 검사 컨텍스트를 제어하는 데 사용됩니다.
- `lock` 문은 지정된 개체에 대한 상호 배타적 잠금을 획득하고, 문을 실행한 후 잠금을 해제하는 데 사용됩니다.
- `using` 문은 리소스를 획득하고, 문을 실행한 후 해당 리소스를 삭제하는 데 사용됩니다.

다음은 사용할 수 있는 문 종류입니다.

* 지역 변수 선언
* 지역 상수 선언
* 식 문
* `if` 문
* `switch` 문
* `while` 문
* `do` 문
* `for` 문
* `foreach` 문
* `break` 문
* `continue` 문
* `goto` 문
* `return` 문
* `yield` 문
* `throw` 문과 `try` 문
* `checked` 및 `unchecked` 문
* `lock` 문
* `using` 문

>[!div class="step-by-step"]
>[이전](types.md)
>[다음](features.md)
