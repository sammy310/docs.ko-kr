---
title: C# 프로그램의 구성 요소
description: C# 멤버, 식 및 문에 대해 알아봅니다. 형식에는 사용자가 작성하는 멤버가 포함됩니다. 이러한 멤버는 문과 식에서 빌드됩니다.
ms.date: 08/06/2020
ms.openlocfilehash: 142fe7b5a3424a8925638bfb4e4437392347f4c6
ms.sourcegitcommit: 0100be20fcf23f61dab672deced70059ed71bb2e
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/17/2020
ms.locfileid: "88268142"
---
# <a name="program-building-blocks"></a><span data-ttu-id="49e57-105">프로그램 구성 요소</span><span class="sxs-lookup"><span data-stu-id="49e57-105">Program building blocks</span></span>

<span data-ttu-id="49e57-106">이전 문서에 설명된 형식은 [멤버](../programming-guide/classes-and-structs/members.md), [식, 문](../programming-guide/statements-expressions-operators/index.md)이라는 구성 요소를 사용하여 빌드됩니다.\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*</span><span class="sxs-lookup"><span data-stu-id="49e57-106">The types described in the previous article are built using these building blocks: [***members***](../programming-guide/classes-and-structs/members.md), [***expressions***, and ***statements***](../programming-guide/statements-expressions-operators/index.md).</span></span>

## <a name="members"></a><span data-ttu-id="49e57-107">멤버</span><span class="sxs-lookup"><span data-stu-id="49e57-107">Members</span></span>

<span data-ttu-id="49e57-108">`class`의 멤버는 ‘정적 멤버’ 또는 ‘인스턴스 멤버’입니다.\*\*\*\*\*\*\*\*\*\*\*\*</span><span class="sxs-lookup"><span data-stu-id="49e57-108">The members of a `class` are either ***static members*** or ***instance members***.</span></span> <span data-ttu-id="49e57-109">정적 멤버는 클래스에 속하며 인스턴스 멤버는 개체(클래스의 인스턴스)에 속합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-109">Static members belong to classes, and instance members belong to objects (instances of classes).</span></span>

<span data-ttu-id="49e57-110">다음은 클래스가 포함할 수는 멤버의 종류입니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-110">The following list provides an overview of the kinds of members a class can contain.</span></span>

- <span data-ttu-id="49e57-111">**상수**: 클래스와 연결된 상수 값</span><span class="sxs-lookup"><span data-stu-id="49e57-111">**Constants**: Constant values associated with the class</span></span>
- <span data-ttu-id="49e57-112">**필드**:  클래스와 연결된 변수</span><span class="sxs-lookup"><span data-stu-id="49e57-112">**Fields**:  Variables that are associated of the class</span></span>
- <span data-ttu-id="49e57-113">**메서드**:  클래스가 수행할 수 있는 작업</span><span class="sxs-lookup"><span data-stu-id="49e57-113">**Methods**:  Actions that can be performed by the class</span></span>
- <span data-ttu-id="49e57-114">**Properties**: 클래스의 명명된 속성에 대한 읽기 및 쓰기와 관련된 작업</span><span class="sxs-lookup"><span data-stu-id="49e57-114">**Properties**: Actions associated with reading and writing named properties of the class</span></span>
- <span data-ttu-id="49e57-115">**인덱서**: 클래스 인스턴스를 배열처럼 인덱싱하는 것과 관련된 작업</span><span class="sxs-lookup"><span data-stu-id="49e57-115">**Indexers**: Actions associated with indexing instances of the class like an array</span></span>
- <span data-ttu-id="49e57-116">**이벤트**: 클래스에 의해 생성될 수 있는 알림</span><span class="sxs-lookup"><span data-stu-id="49e57-116">**Events**: Notifications that can be generated by the class</span></span>
- <span data-ttu-id="49e57-117">**연산자**: 클래스가 지원하는 변환 및 식 연산자</span><span class="sxs-lookup"><span data-stu-id="49e57-117">**Operators**: Conversions and expression operators supported by the class</span></span>
- <span data-ttu-id="49e57-118">**생성자**: 클래스의 인스턴스 또는 클래스 자체를 초기화하는 데 필요한 작업</span><span class="sxs-lookup"><span data-stu-id="49e57-118">**Constructors**: Actions required to initialize instances of the class or the class itself</span></span>
- <span data-ttu-id="49e57-119">**종료자**: 클래스의 인스턴스가 영구적으로 삭제되기 전에 수행한 작업</span><span class="sxs-lookup"><span data-stu-id="49e57-119">**Finalizers**: Actions performed before instances of the class are permanently discarded</span></span>
- <span data-ttu-id="49e57-120">**형식**: 클래스에 의해 선언된 중첩 형식</span><span class="sxs-lookup"><span data-stu-id="49e57-120">**Types**: Nested types declared by the class</span></span>

## <a name="accessibility"></a><span data-ttu-id="49e57-121">접근성</span><span class="sxs-lookup"><span data-stu-id="49e57-121">Accessibility</span></span>

<span data-ttu-id="49e57-122">클래스의 각 멤버에는 해당 멤버에 액세스할 수 있는 프로그램 텍스트의 영역을 제어하는 액세스 수준이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-122">Each member of a class has an associated accessibility, which controls the regions of program text that can access the member.</span></span> <span data-ttu-id="49e57-123">액세스 가능성은 여섯 가지 형태로 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-123">There are six possible forms of accessibility.</span></span> <span data-ttu-id="49e57-124">다음은 액세스 한정자입니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-124">The access modifiers are summarized below.</span></span>

- <span data-ttu-id="49e57-125">`public`: 액세스가 제한되지 않음</span><span class="sxs-lookup"><span data-stu-id="49e57-125">`public`: Access isn't limited.</span></span>
- <span data-ttu-id="49e57-126">`private`: 이 클래스로만 액세스가 제한됨</span><span class="sxs-lookup"><span data-stu-id="49e57-126">`private`: Access is limited to this class.</span></span>
- <span data-ttu-id="49e57-127">`protected`: 이 클래스 또는 이 클래스에서 파생된 클래스로만 액세스가 제한됨</span><span class="sxs-lookup"><span data-stu-id="49e57-127">`protected`: Access is limited to this class or classes derived from this class.</span></span>
- <span data-ttu-id="49e57-128">`internal`: 액세스가 현재 어셈블리(`.exe` 또는 `.dll`)로 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-128">`internal`: Access is limited to the current assembly (`.exe` or `.dll`).</span></span>
- <span data-ttu-id="49e57-129">`protected internal`: 액세스가 이 클래스, 이 클래스에서 파생된 클래스 또는 동일한 어셈블리 내의 클래스로만 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-129">`protected internal`: Access is limited to this class, classes derived from this class, or classes within the same assembly.</span></span>
- <span data-ttu-id="49e57-130">`private protected`: 액세스가 이 클래스 또는 동일한 어셈블리 내의 이 형식에서 파생된 클래스로만 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-130">`private protected`: Access is limited to this class or classes derived from this type within the same assembly.</span></span>

## <a name="fields"></a><span data-ttu-id="49e57-131">필드</span><span class="sxs-lookup"><span data-stu-id="49e57-131">Fields</span></span>

<span data-ttu-id="49e57-132">*필드*는 클래스 또는 클래스의 인스턴스와 연결된 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-132">A *field* is a variable that is associated with a class or with an instance of a class.</span></span>

<span data-ttu-id="49e57-133">static 한정자를 사용하여 선언된 필드는 정적 필드를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-133">A field declared with the static modifier defines a static field.</span></span> <span data-ttu-id="49e57-134">정적 필드는 정확히 하나의 스토리지 위치를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-134">A static field identifies exactly one storage location.</span></span> <span data-ttu-id="49e57-135">클래스의 인스턴스가 몇 개나 만들어졌는지에 관계없이 정적 필드의 복사본은 하나뿐입니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-135">No matter how many instances of a class are created, there's only ever one copy of a static field.</span></span>

<span data-ttu-id="49e57-136">static 한정자 없이 선언된 필드는 인스턴스 필드를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-136">A field declared without the static modifier defines an instance field.</span></span> <span data-ttu-id="49e57-137">클래스의 모든 인스턴스는 해당 클래스의 모든 인스턴스 필드의 별도 복사본을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-137">Every instance of a class contains a separate copy of all the instance fields of that class.</span></span>

<span data-ttu-id="49e57-138">다음 예제에서 `Color` 클래스의 각 인스턴스는 `r`, `g` 및 `b` 인스턴스 필드의 별도 복사본을 갖지만 `Black`, `White`, `Red`, `Green` 및 `Blue` 정적 필드의 복사본은 하나뿐입니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-138">In the following example, each instance of the `Color` class has a separate copy of the `r`, `g`, and `b` instance fields, but there's only one copy of the `Black`, `White`, `Red`, `Green`, and `Blue` static fields:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ColorClassDefinition":::

<span data-ttu-id="49e57-139">앞의 예제와 같이 *읽기 전용 필드*는 `readonly` 한정자를 사용하여 선언될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-139">As shown in the previous example, *read-only fields* may be declared with a `readonly` modifier.</span></span> <span data-ttu-id="49e57-140">읽기 전용 필드에 대한 할당은 필드 선언의 일부로 또는 동일한 클래스의 생성자에서만 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-140">Assignment to a read-only field can only occur as part of the field’s declaration or in a constructor in the same class.</span></span>

## <a name="methods"></a><span data-ttu-id="49e57-141">메서드</span><span class="sxs-lookup"><span data-stu-id="49e57-141">Methods</span></span>

<span data-ttu-id="49e57-142">*메서드*는 개체 또는 클래스에서 수행할 수 있는 계산이나 작업을 구현하는 멤버입니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-142">A *method* is a member that implements a computation or action that can be performed by an object or class.</span></span> <span data-ttu-id="49e57-143">*정적 메서드*는 클래스를 통해 액세스됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-143">*Static methods* are accessed through the class.</span></span> <span data-ttu-id="49e57-144">*인스턴스 메서드*는 클래스의 인스턴스를 통해 액세스됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-144">*Instance methods* are accessed through instances of the class.</span></span>

<span data-ttu-id="49e57-145">메서드에는 메서드로 전달되는 값 또는 변수 참조를 나타내는 ‘매개 변수’ 목록이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-145">Methods may have a list of *parameters*, which represent values or variable references passed to the method.</span></span> <span data-ttu-id="49e57-146">메서드에는 메서드에 의해 계산되고 반환되는 값의 형식을 지정하는 ‘반환 형식’이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-146">Methods have a *return type*, which specifies the type of the value computed and returned by the method.</span></span> <span data-ttu-id="49e57-147">메서드가 값을 반환하지 않을 경우 반환 형식은 `void`입니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-147">A method’s return type is `void` if it doesn't return a value.</span></span>

<span data-ttu-id="49e57-148">형식과 마찬가지로 메서드에는 메서드가 호출될 때 형식 인수가 지정되어야 하는 형식 매개 변수 집합도 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-148">Like types, methods may also have a set of type parameters, for which type arguments must be specified when the method is called.</span></span> <span data-ttu-id="49e57-149">형식과 달리 형식 인수는 종종 메서드 호출의 인수에서 유추될 수 있으므로 명시적으로 지정할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-149">Unlike types, the type arguments can often be inferred from the arguments of a method call and need not be explicitly given.</span></span>

<span data-ttu-id="49e57-150">메서드의 *시그니처*는 메서드가 선언되는 클래스에서 고유해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-150">The *signature* of a method must be unique in the class in which the method is declared.</span></span> <span data-ttu-id="49e57-151">메서드 시그니처는 메서드의 이름, 형식 매개 변수의 수, 해당 매개 변수의 수, 한정자 및 형식으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-151">The signature of a method consists of the name of the method, the number of type parameters, and the number, modifiers, and types of its parameters.</span></span> <span data-ttu-id="49e57-152">메서드 시그니처는 반환 형식을 포함하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-152">The signature of a method doesn't include the return type.</span></span>

<span data-ttu-id="49e57-153">메서드 본문이 단일 식인 경우 메서드는 다음 예제와 같이 간결한 식 형식을 사용하여 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-153">When a method body is a single expression, the method can be defined using a compact expression format, as shown in the following example:</span></span>

```csharp
public override ToString() => "This is an object";
```

### <a name="parameters"></a><span data-ttu-id="49e57-154">매개 변수</span><span class="sxs-lookup"><span data-stu-id="49e57-154">Parameters</span></span>

<span data-ttu-id="49e57-155">매개 변수는 메서드에 값 또는 변수 참조를 전달하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-155">Parameters are used to pass values or variable references to methods.</span></span> <span data-ttu-id="49e57-156">메서드의 매개 변수는 메서드가 호출될 때 지정된 *인수*에서 실제 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-156">The parameters of a method get their actual values from the *arguments* that are specified when the method is invoked.</span></span> <span data-ttu-id="49e57-157">매개 변수에는 값 매개 변수, 참조 매개 변수, 출력 매개 변수 및 매개 변수 배열의 네 가지 종류가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-157">There are four kinds of parameters: value parameters, reference parameters, output parameters, and parameter arrays.</span></span>

<span data-ttu-id="49e57-158">*값 매개 변수*는 입력 매개 변수를 전달하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-158">A *value parameter* is used for passing input arguments.</span></span> <span data-ttu-id="49e57-159">값 매개 변수는 매개 변수에 전달된 인수에서 초기 값을 가져오는 지역 변수에 해당합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-159">A value parameter corresponds to a local variable that gets its initial value from the argument that was passed for the parameter.</span></span> <span data-ttu-id="49e57-160">값 매개 변수를 수정해도 해당 매개 변수에 전달된 인수에는 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-160">Modifications to a value parameter don't affect the argument that was passed for the parameter.</span></span>

<span data-ttu-id="49e57-161">해당 인수를 생략할 수 있도록 기본값을 지정하면 값 매개 변수는 선택적일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-161">Value parameters can be optional, by specifying a default value so that corresponding arguments can be omitted.</span></span>

<span data-ttu-id="49e57-162">*참조 매개 변수*는 인수를 참조로 전달하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-162">A *reference parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="49e57-163">참조 매개 변수에 전달되는 인수는 한정된 값을 가진 변수여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-163">The argument passed for a reference parameter must be a variable with a definite value.</span></span> <span data-ttu-id="49e57-164">메서드를 실행하는 동안 참조 매개 변수는 인수 변수와 동일한 스토리지 위치를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-164">During execution of the method, the reference parameter represents the same storage location as the argument variable.</span></span> <span data-ttu-id="49e57-165">참조 매개 변수는 `ref` 한정자를 사용하여 선언됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-165">A reference parameter is declared with the `ref` modifier.</span></span> <span data-ttu-id="49e57-166">다음 예제에서는 `ref` 매개 변수를 사용하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-166">The following example shows the use of `ref` parameters.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="RefExample":::

<span data-ttu-id="49e57-167">*출력 매개 변수*는 인수를 참조로 전달하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-167">An *output parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="49e57-168">호출자가 제공한 인수에 값을 명시적으로 할당할 필요가 없다는 점을 제외하고 참조 매개 변수와 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-168">It's similar to a reference parameter, except that it doesn't require that you explicitly assign a value to the caller-provided argument.</span></span> <span data-ttu-id="49e57-169">출력 매개 변수는 `out` 한정자를 사용하여 선언됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-169">An output parameter is declared with the `out` modifier.</span></span> <span data-ttu-id="49e57-170">다음 예제에서는 C# 7에서 도입된 구문으로 `out` 매개 변수를 사용하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-170">The following example shows the use of `out` parameters using the syntax introduced in C# 7.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="OutExample":::

<span data-ttu-id="49e57-171">*매개 변수 배열*은 다양한 개수의 인수가 메서드에 전달되도록 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-171">A *parameter array* permits a variable number of arguments to be passed to a method.</span></span> <span data-ttu-id="49e57-172">매개 변수 배열은 `params` 한정자를 사용하여 선언됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-172">A parameter array is declared with the `params` modifier.</span></span> <span data-ttu-id="49e57-173">메서드의 마지막 매개 변수만 매개 변수 배열일 수 있으며 매개 변수 배열의 형식은 1차원 배열 형식이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-173">Only the last parameter of a method can be a parameter array, and the type of a parameter array must be a single-dimensional array type.</span></span> <span data-ttu-id="49e57-174"><xref:System.Console?displayProperty=nameWithType> 클래스의 `Write` 및 `WriteLine` 메서드는 매개 변수 배열 사용의 좋은 예입니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-174">The `Write` and `WriteLine` methods of the <xref:System.Console?displayProperty=nameWithType> class are good examples of parameter array usage.</span></span> <span data-ttu-id="49e57-175">이러한 메서드는 다음과 같이 선언됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-175">They're declared as follows.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ConsoleExtract":::

<span data-ttu-id="49e57-176">매개 변수 배열을 사용하는 메서드 내에서 매개 변수 배열은 배열 형식의 일반 매개 변수와 정확히 동일하게 동작합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-176">Within a method that uses a parameter array, the parameter array behaves exactly like a regular parameter of an array type.</span></span> <span data-ttu-id="49e57-177">그러나 매개 변수 배열을 사용한 메서드 호출에서 매개 변수 배열 형식의 단일 인수 또는 매개 변수 배열에 있는 임의 개수의 요소 형식 인수를 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-177">However, in an invocation of a method with a parameter array, it's possible to pass either a single argument of the parameter array type or any number of arguments of the element type of the parameter array.</span></span> <span data-ttu-id="49e57-178">후자의 경우 지정된 인수를 사용하여 배열 인스턴스가 자동으로 만들어지고 초기화됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-178">In the latter case, an array instance is automatically created and initialized with the given arguments.</span></span> <span data-ttu-id="49e57-179">다음 예제는</span><span class="sxs-lookup"><span data-stu-id="49e57-179">This example</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UseParamsArgs":::

<span data-ttu-id="49e57-180">다음을 작성하는 것과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-180">is equivalent to writing the following.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="CompilerParams":::

### <a name="method-body-and-local-variables"></a><span data-ttu-id="49e57-181">메서드 본문 및 지역 변수</span><span class="sxs-lookup"><span data-stu-id="49e57-181">Method body and local variables</span></span>

<span data-ttu-id="49e57-182">메서드의 본문은 메서드가 호출될 때 실행할 문을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-182">A method’s body specifies the statements to execute when the method is invoked.</span></span>

<span data-ttu-id="49e57-183">메서드 본문은 메서드 호출과 관련된 변수를 선언할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-183">A method body can declare variables that are specific to the invocation of the method.</span></span> <span data-ttu-id="49e57-184">이러한 변수를 *지역 변수*라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-184">Such variables are called *local variables*.</span></span> <span data-ttu-id="49e57-185">지역 변수 선언은 형식 이름, 변수 이름을 지정하며 초기 값을 지정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-185">A local variable declaration specifies a type name, a variable name, and possibly an initial value.</span></span> <span data-ttu-id="49e57-186">다음 예제에서는 초기 값이 0인 지역 변수 `i`와 초기 값이 없는 지역 변수 `j`를 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-186">The following example declares a local variable `i` with an initial value of zero and a local variable `j` with no initial value.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="SquaresClass":::

<span data-ttu-id="49e57-187">C#에서는 해당 값을 얻기 위해 먼저 로컬 변수를 *명확 하게 할당*해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-187">C# requires a local variable to be *definitely assigned* before its value can be obtained.</span></span> <span data-ttu-id="49e57-188">예를 들어 이전 `i`의 선언이 초기 값을 포함하지 않으면 컴파일러는 `i`의 후속 사용에 대해 오류를 보고합니다. `i`는 프로그램에서 해당 시점에 명확하게 할당되지 않은 것이기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-188">For example, if the declaration of the previous `i` didn't include an initial value, the compiler would report an error for the later usages of `i` because `i` wouldn't be definitely assigned at those points in the program.</span></span>

<span data-ttu-id="49e57-189">메서드는 `return` 문을 사용하여 해당 호출자에게 컨트롤을 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-189">A method can use `return` statements to return control to its caller.</span></span> <span data-ttu-id="49e57-190">`void`를 반환하는 메서드에서 `return` 문은 식을 지정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-190">In a method returning `void`, `return` statements can't specify an expression.</span></span> <span data-ttu-id="49e57-191">void 이외의 값을 반환하는 메서드에서 `return` 문은 반환 값을 계산하는 식을 포함해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-191">In a method returning non-void, `return` statements must include an expression that computes the return value.</span></span>

### <a name="static-and-instance-methods"></a><span data-ttu-id="49e57-192">정적 및 인스턴스 메서드</span><span class="sxs-lookup"><span data-stu-id="49e57-192">Static and instance methods</span></span>

<span data-ttu-id="49e57-193">`static` 한정자를 사용하여 선언된 메서드는 ‘정적 메서드’입니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-193">A method declared with a `static` modifier is a *static method*.</span></span> <span data-ttu-id="49e57-194">정적 메서드는 특정 인스턴스에 작동하지 않고 정적 멤버에 직접적으로만 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-194">A static method doesn't operate on a specific instance and can only directly access static members.</span></span>

<span data-ttu-id="49e57-195">`static` 한정자를 사용하지 않고 선언된 메서드는 ‘인스턴스 메서드’입니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-195">A method declared without a `static` modifier is an *instance method*.</span></span> <span data-ttu-id="49e57-196">인스턴스 메서드는 특정 인스턴스에 작동하며 정적 및 인스턴스 멤버 둘 다에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-196">An instance method operates on a specific instance and can access both static and instance members.</span></span> <span data-ttu-id="49e57-197">인스턴스 메서드가 호출된 인스턴스는 `this`로 명시적으로 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-197">The instance on which an instance method was invoked can be explicitly accessed as `this`.</span></span> <span data-ttu-id="49e57-198">정적 메서드에서 `this`를 참조하면 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-198">It's an error to refer to `this` in a static method.</span></span>

<span data-ttu-id="49e57-199">다음 `Entity` 클래스에는 정적 멤버와 인스턴스 멤버가 모두 있습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-199">The following `Entity` class has both static and instance members.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="EntityClass":::

<span data-ttu-id="49e57-200">각 `Entity` 인스턴스에는 일련 번호(및 여기에 표시되지 않는 몇몇 정보)가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-200">Each `Entity` instance contains a serial number (and presumably some other information that isn't shown here).</span></span> <span data-ttu-id="49e57-201">`Entity` 생성자(인스턴스 메서드와 유사함)는 사용 가능한 다음 일련 번호를 사용하여 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-201">The `Entity` constructor (which is like an instance method) initializes the new instance with the next available serial number.</span></span> <span data-ttu-id="49e57-202">생성자가 인스턴스 멤버이기 때문에 `_serialNo` 인스턴스 필드 및 `s_nextSerialNo` 정적 필드 둘 다에 액세스하도록 허용됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-202">Because the constructor is an instance member, it's permitted to access both the `_serialNo` instance field and the `s_nextSerialNo` static field.</span></span>

<span data-ttu-id="49e57-203">`GetNextSerialNo` 및 `SetNextSerialNo` 정적 메서드는 `s_nextSerialNo` 정적 필드에 액세스할 수 있지만 `_serialNo` 인스턴스 필드에 직접 액세스하면 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-203">The `GetNextSerialNo` and `SetNextSerialNo` static methods can access the `s_nextSerialNo` static field, but it would be an error for them to directly access the `_serialNo` instance field.</span></span>

<span data-ttu-id="49e57-204">다음 예제에서는 사용 된 `Entity` 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-204">The following example shows the use of the `Entity` class.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UsingEntity":::

<span data-ttu-id="49e57-205">`SetNextSerialNo` 및 `GetNextSerialNo` 정적 메서드는 클래스에 대해 호출되지만 `GetSerialNo` 인스턴스 메서드는 클래스의 인스턴스에 대해 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-205">The `SetNextSerialNo` and `GetNextSerialNo` static methods are invoked on the class whereas the `GetSerialNo` instance method is invoked on instances of the class.</span></span>

### <a name="virtual-override-and-abstract-methods"></a><span data-ttu-id="49e57-206">가상, 재정의 및 추상 메서드</span><span class="sxs-lookup"><span data-stu-id="49e57-206">Virtual, override, and abstract methods</span></span>

<span data-ttu-id="49e57-207">인스턴스 메서드 선언에 `virtual` 한정자가 포함되면 해당 메서드를 *가상 메서드*라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-207">When an instance method declaration includes a `virtual` modifier, the method is said to be a *virtual method*.</span></span> <span data-ttu-id="49e57-208">가상 한정자가 없으면 해당 메서드를 *비가상 메서드*라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-208">When no virtual modifier is present, the method is said to be a *nonvirtual method*.</span></span>

<span data-ttu-id="49e57-209">가상 메서드가 호출되면 호출이 발생하는 인스턴스의 *런타임 형식*에 따라 호출할 실제 메서드 구현이 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-209">When a virtual method is invoked, the *run-time type* of the instance for which that invocation takes place determines the actual method implementation to invoke.</span></span> <span data-ttu-id="49e57-210">비가상 메서드 호출에서는 인스턴스의 *컴파일 타임 형식*이 결정 요인입니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-210">In a nonvirtual method invocation, the *compile-time type* of the instance is the determining factor.</span></span>

<span data-ttu-id="49e57-211">가상 메서드는 파생된 클래스에서 *재정의*될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-211">A virtual method can be *overridden* in a derived class.</span></span> <span data-ttu-id="49e57-212">인스턴스 메서드 선언에 재정의 한정자가 포함될 경우 메서드는 동일한 시그니처로 상속된 가상 메서드를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-212">When an instance method declaration includes an override modifier, the method overrides an inherited virtual method with the same signature.</span></span> <span data-ttu-id="49e57-213">가상 메서드 선언은 새 메서드를 도입합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-213">Aa virtual method declaration introduces a new method.</span></span> <span data-ttu-id="49e57-214">재정의 메서드 선언은 해당 메서드의 새 구현을 제공하여 기존의 상속된 가상 메서드를 특수화합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-214">An override method declaration specializes an existing inherited virtual method by providing a new implementation of that method.</span></span>

<span data-ttu-id="49e57-215">*추상 메서드*는 구현이 없는 가상 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-215">An *abstract method* is a virtual method with no implementation.</span></span> <span data-ttu-id="49e57-216">추상 메서드는 `abstract` 한정자를 사용하여 선언되며 추상 클래스에서만 허용됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-216">An abstract method is declared with the `abstract` modifier and is permitted only in an abstract class.</span></span> <span data-ttu-id="49e57-217">추상 메서드는 모든 비추상 파생 클래스에서 재정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-217">An abstract method must be overridden in every non-abstract derived class.</span></span>

<span data-ttu-id="49e57-218">다음 예제에서는 식 트리 노드를 나타내는 추상 클래스 `Expression`와 상수, 변수 참조 및 산술 연산에 대한 식 트리 노드를 구현하는 세 개의 파생 클래스 `Constant`, `VariableReference` 및 `Operation`을 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-218">The following example declares an abstract class, `Expression`, which represents an expression tree node, and three derived classes, `Constant`, `VariableReference`, and `Operation`, which implement expression tree nodes for constants, variable references, and arithmetic operations.</span></span> <span data-ttu-id="49e57-219">(이 예제는 식 트리 형식과 비슷하지만 관련은 없습니다.)</span><span class="sxs-lookup"><span data-stu-id="49e57-219">(This example is similar to, but not related to the expression tree types).</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="WorkingWithExpressions":::

<span data-ttu-id="49e57-220">이전의 4개 클래스는 산술 연산자를 모델링하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-220">The previous four classes can be used to model arithmetic expressions.</span></span> <span data-ttu-id="49e57-221">예를 들어 이러한 클래스의 인스턴스를 사용할 경우 식 `x + 3`을 다음과 같이 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-221">For example, using instances of these classes, the expression `x + 3` can be represented as follows.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UseExpressions":::

<span data-ttu-id="49e57-222">`Expression` 인스턴스의 `Evaluate` 메서드는 지정된 식을 계산하고 `double` 값을 생성하기 위해 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-222">The `Evaluate` method of an `Expression` instance is invoked to evaluate the given expression and produce a `double` value.</span></span> <span data-ttu-id="49e57-223">이 메서드는 변수 이름(항목의 키)과 값(항목의 값)을 포함하는 `Dictionary` 인수를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-223">The method takes a `Dictionary` argument that contains variable names (as keys of the entries) and values (as values of the entries).</span></span> <span data-ttu-id="49e57-224">`Evaluate`가 추상 메서드이기 때문에 `Expression`에서 파생된 비추상 클래스는 `Evaluate`를 재정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-224">Because `Evaluate` is an abstract method, non-abstract classes derived from `Expression` must override `Evaluate`.</span></span>

<span data-ttu-id="49e57-225">`Evaluate`의 `Constant` 구현은 단순히 저장된 상수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-225">A `Constant`'s implementation of `Evaluate` simply returns the stored constant.</span></span> <span data-ttu-id="49e57-226">`VariableReference`의 구현은 사전에서 변수 이름을 조회하고 결과 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-226">A `VariableReference`'s implementation looks up the variable name in the dictionary and returns the resulting value.</span></span> <span data-ttu-id="49e57-227">`Operation`의 구현은 먼저 왼쪽 및 오른쪽 피연산자를 계산하고(재귀적으로 해당 `Evaluate` 메서드 호출) 지정된 산술 연산을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-227">An `Operation`'s implementation first evaluates the left and right operands (by recursively invoking their `Evaluate` methods) and then performs the given arithmetic operation.</span></span>

<span data-ttu-id="49e57-228">다음 프로그램에서는 `Expression` 클래스를 사용하여 `x` 및 `y`의 다른 값에 대해 식 `x * (y + 2)`를 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-228">The following program uses the `Expression` classes to evaluate the expression `x * (y + 2)` for different values of `x` and `y`.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UsingExpressions":::

### <a name="method-overloading"></a><span data-ttu-id="49e57-229">메서드 오버로드</span><span class="sxs-lookup"><span data-stu-id="49e57-229">Method overloading</span></span>

<span data-ttu-id="49e57-230">메서드 *오버로드*는 동일한 클래스가 고유한 시그니처를 갖는 한, 동일한 이름을 갖도록 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-230">Method *overloading* permits multiple methods in the same class to have the same name as long as they have unique signatures.</span></span> <span data-ttu-id="49e57-231">오버로드된 메서드의 호출을 컴파일할 때 컴파일러는 *오버로드 확인*을 사용하여 호출할 특정 메서드를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-231">When compiling an invocation of an overloaded method, the compiler uses *overload resolution* to determine the specific method to invoke.</span></span> <span data-ttu-id="49e57-232">오버로드 확인은 인수와 가장 적합하게 일치하는 단일 메서드를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-232">Overload resolution finds the one method that best matches the arguments.</span></span> <span data-ttu-id="49e57-233">최상의 일치 메서드를 찾을 수 있는 경우 오류를 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-233">If no single best match can be found, an error is reported.</span></span> <span data-ttu-id="49e57-234">다음 예제에서는 실제로 진행되는 오버로드 확인을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-234">The following example shows overload resolution in effect.</span></span> <span data-ttu-id="49e57-235">`UsageExample` 메서드의 각 호출에 대한 주석은 어느 메서드가 호출되었는지 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-235">The comment for each invocation in the `UsageExample` method shows which method is invoked.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="Overloading":::

<span data-ttu-id="49e57-236">예제와 같이, 인수를 정확한 매개 변수 형식과 형식 인수로 명시적으로 캐스팅하여 항상 특정 메서드를 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-236">As shown by the example, a particular method can always be selected by explicitly casting the arguments to the exact parameter types and type arguments.</span></span>

## <a name="other-function-members"></a><span data-ttu-id="49e57-237">기타 함수 멤버</span><span class="sxs-lookup"><span data-stu-id="49e57-237">Other function members</span></span>

<span data-ttu-id="49e57-238">실행 코드를 포함하는 멤버를 통칭하여 클래스의 *함수 멤버*라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-238">Members that contain executable code are collectively known as the *function members* of a class.</span></span> <span data-ttu-id="49e57-239">이전 섹션에서는 함수 멤버의 기본 종류인 메서드에 대해 설명했습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-239">The preceding section describes methods, which are the primary types of function members.</span></span> <span data-ttu-id="49e57-240">이 섹션에서는 C#에서 지원하는 다른 종류의 함수 멤버인 생성자, 속성, 인덱서, 이벤트, 연산자 및 종료자에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-240">This section describes the other kinds of function members supported by C#: constructors, properties, indexers, events, operators, and finalizers.</span></span>

<span data-ttu-id="49e57-241">다음 예제에서는 늘어날 수 있는 개체 목록을 구현하는 `MyList<T>`라는 제네릭 클래스를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-241">The following example shows a generic class called `MyList<T>`, which implements a growable list of objects.</span></span> <span data-ttu-id="49e57-242">이 클래스는 함수 멤버의 가장 일반적인 몇 가지 예제를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-242">The class contains several examples of the most common kinds of function members.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListExample":::

### <a name="constructors"></a><span data-ttu-id="49e57-243">생성자</span><span class="sxs-lookup"><span data-stu-id="49e57-243">Constructors</span></span>

<span data-ttu-id="49e57-244">C#은 인스턴스 및 정적 생성자를 모두 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-244">C# supports both instance and static constructors.</span></span> <span data-ttu-id="49e57-245">*인스턴스 생성자*는 클래스의 인스턴스를 초기화하는 데 필요한 작업을 구현하는 멤버입니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-245">An *instance constructor* is a member that implements the actions required to initialize an instance of a class.</span></span> <span data-ttu-id="49e57-246">‘정적 생성자’는 처음 로드될 때 클래스 자체를 초기화하는 데 필요한 동작을 구현하는 멤버입니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-246">A *static constructor* is a member that implements the actions required to initialize a class itself when it's first loaded.</span></span>

<span data-ttu-id="49e57-247">생성자는 반환 형식이 없고 포함하는 클래스와 동일한 이름을 갖는 메서드처럼 선언됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-247">A constructor is declared like a method with no return type and the same name as the containing class.</span></span> <span data-ttu-id="49e57-248">생성자 선언에 `static` 한정자가 포함될 경우 정적 생성자를 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-248">If a constructor declaration includes a `static` modifier, it declares a static constructor.</span></span> <span data-ttu-id="49e57-249">그렇지 않으면 인스턴스 생성자를 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-249">Otherwise, it declares an instance constructor.</span></span>

<span data-ttu-id="49e57-250">인스턴스 생성자는 오버로드될 수 있으며 선택적 매개 변수를 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-250">Instance constructors can be overloaded and can have optional parameters.</span></span> <span data-ttu-id="49e57-251">예를 들어 `MyList<T>` 클래스는 단일 선택적 `int` 매개 변수를 사용하여 하나의 인스턴스 생성자를 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-251">For example, the `MyList<T>` class declares one instance constructor with a single optional `int` parameter.</span></span> <span data-ttu-id="49e57-252">인스턴스 생성자는 `new` 연산자를 사용하여 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-252">Instance constructors are invoked using the `new` operator.</span></span> <span data-ttu-id="49e57-253">다음 문은 각각 선택적 인수를 사용하거나 사용하지 않고 `MyList<string>` 클래스의 생성자를 사용하여 2가지 `MyList` 인스턴스를 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-253">The following statements allocate two `MyList<string>` instances using the constructor of the `MyList` class with and without the optional argument.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="CreateLists":::

<span data-ttu-id="49e57-254">다른 멤버와 달리 인스턴스 생성자는 상속되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-254">Unlike other members, instance constructors aren't inherited.</span></span> <span data-ttu-id="49e57-255">클래스에는 클래스에서 실제로 선언된 인스턴스 생성자 외에는 인스턴스 생성자가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-255">A class has no instance constructors other than those constructors actually declared in the class.</span></span> <span data-ttu-id="49e57-256">클래스에 대해 인스턴스 생성자가 제공되지 않으면 매개 변수가 없는 빈 인스턴스 생성자가 자동으로 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-256">If no instance constructor is supplied for a class, then an empty one with no parameters is automatically provided.</span></span>

### <a name="properties"></a><span data-ttu-id="49e57-257">속성</span><span class="sxs-lookup"><span data-stu-id="49e57-257">Properties</span></span>

<span data-ttu-id="49e57-258">*속성*은 필드의 기본 확장입니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-258">*Properties* are a natural extension of fields.</span></span> <span data-ttu-id="49e57-259">둘 다 연결된 형식으로 명명되는 멤버이며, 필드 및 속성에 액세스하는 구문은 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-259">Both are named members with associated types, and the syntax for accessing fields and properties is the same.</span></span> <span data-ttu-id="49e57-260">그러나 필드와 달리 속성은 스토리지 위치를 명시하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-260">However, unlike fields, properties don't denote storage locations.</span></span> <span data-ttu-id="49e57-261">대신, 속성에는 해당 값을 읽거나 쓸 때 실행될 문을 지정하는 ‘접근자’가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-261">Instead, properties have *accessors* that specify the statements executed when their values are read or written.</span></span>

<span data-ttu-id="49e57-262">속성은 필드처럼 선언되지만, 선언이 세미콜론으로 끝나지 않고, 구분 기호 `{` 및 `}` 사이에 쓴 get 접근자 또는 set 접근자로 끝난다는 점이 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-262">A property is declared like a field, except that the declaration ends with a get accessor or a set accessor written between the delimiters `{` and `}` instead of ending in a semicolon.</span></span> <span data-ttu-id="49e57-263">get 접근자 및 set 접근자가 둘 다 있는 속성은 *읽기/쓰기 속성*이고, get 접근자만 있는 속성은 *읽기 전용 속성*이고, set 접근자만 있는 속성은 *쓰기 전용 속성*입니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-263">A property that has both a get accessor and a set accessor is a *read-write property*, a property that has only a get accessor is a *read-only property*, and a property that has only a set accessor is a *write-only property*.</span></span>

<span data-ttu-id="49e57-264">get 접근자는 속성 형식의 반환 값을 갖는 매개 변수 없는 메서드에 해당합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-264">A get accessor corresponds to a parameterless method with a return value of the property type.</span></span> <span data-ttu-id="49e57-265">set 접근자는 value라는 단일 매개 변수를 가지며 반환 형식이 없는 메서드에 해당합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-265">A set accessor corresponds to a method with a single parameter named value and no return type.</span></span> <span data-ttu-id="49e57-266">get 접근자는 속성의 값을 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-266">The get accessor computes the value of the property.</span></span> <span data-ttu-id="49e57-267">set 접근자는 속성에 새 값을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-267">The set accessor provides a new value for the property.</span></span> <span data-ttu-id="49e57-268">속성이 할당의 대상이거나 `++` 또는 `--`의 피연산자인 경우 set 접근자가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-268">When the property is the target of an assignment, or the operand of `++` or `--`, the set accessor is invoked.</span></span> <span data-ttu-id="49e57-269">속성이 참조되는 그 밖의 경우에는 get 접근자가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-269">In other cases where the property is referenced, the get accessor is invoked.</span></span>

 <span data-ttu-id="49e57-270">속성이 할당 대상이나 ++ 또는 --의 피연산자로 참조되면 set 접근자는 새 값을 제공하는 인수를 사용하여 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-270">When a property is referenced as the target of an assignment or as the operand of ++ or --, the set accessor is invoked with an argument that provides the new value.</span></span>

<span data-ttu-id="49e57-271">`MyList<T>` 클래스는 각각 읽기 전용 및 읽기/쓰기 특성을 갖는 두 개의 속성 `Count` 및 `Capacity`를 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-271">The `MyList<T>` class declares two properties, `Count` and `Capacity`, which are read-only and read-write, respectively.</span></span> <span data-ttu-id="49e57-272">다음 코드는 이러한 속성을 사용하는 예입니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-272">The following code is an example of use of these properties:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="AccessProperties":::

<span data-ttu-id="49e57-273">필드 및 메서드와 마찬가지로, C#은 인스턴스 속성 및 정적 속성을 모두 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-273">Similar to fields and methods, C# supports both instance properties and static properties.</span></span> <span data-ttu-id="49e57-274">정적 속성은 static 한정자를 사용하여 선언되고 인스턴스 속성은 이 한정자를 사용하지 않고 선언됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-274">Static properties are declared with the static modifier, and instance properties are declared without it.</span></span>

<span data-ttu-id="49e57-275">속성의 접근자는 가상일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-275">The accessor(s) of a property can be virtual.</span></span> <span data-ttu-id="49e57-276">속성 선언에 `virtual`, `abstract`, 또는 `override` 한정자가 포함되면 속성의 접근자에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-276">When a property declaration includes a `virtual`, `abstract`, or `override` modifier, it applies to the accessor(s) of the property.</span></span>

### <a name="indexers"></a><span data-ttu-id="49e57-277">인덱서</span><span class="sxs-lookup"><span data-stu-id="49e57-277">Indexers</span></span>

<span data-ttu-id="49e57-278">*인덱서*는 개체가 배열과 같은 방식으로 인덱싱될 수 있도록 하는 멤버입니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-278">An *indexer* is a member that enables objects to be indexed in the same way as an array.</span></span> <span data-ttu-id="49e57-279">인덱서는 `this`과(와) 구분 기호 `[` 및 `]` 사이에 작성된 매개 변수 목록을 합쳐서 구성원 이름으로 사용한다는 점을 제외하고 속성처럼 선언됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-279">An indexer is declared like a property except that the name of the member is `this` followed by a parameter list written between the delimiters `[` and `]`.</span></span> <span data-ttu-id="49e57-280">매개 변수는 인덱서의 접근자에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-280">The parameters are available in the accessor(s) of the indexer.</span></span> <span data-ttu-id="49e57-281">속성과 마찬가지로 인덱서는 읽기/쓰기, 읽기 전용 및 쓰기 전용일 수 있으며 인덱서의 접근자는 가상일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-281">Similar to properties, indexers can be read-write, read-only, and write-only, and the accessor(s) of an indexer can be virtual.</span></span>

<span data-ttu-id="49e57-282">`MyList<T>` 클래스는 `int` 매개 변수를 사용하는 단일 읽기/쓰기 인덱서를 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-282">The `MyList<T>` class declares a single read-write indexer that takes an `int` parameter.</span></span> <span data-ttu-id="49e57-283">인덱서는 `MyList<T>` 인스턴스를 `int` 값으로 인덱싱할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-283">The indexer makes it possible to index `MyList<T>` instances with `int` values.</span></span> <span data-ttu-id="49e57-284">예를 들어 다음과 같은 가치를 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-284">For example:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListAccess":::

<span data-ttu-id="49e57-285">인덱서는 오버로드될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-285">Indexers can be overloaded.</span></span> <span data-ttu-id="49e57-286">하나의 클래스는 매개 변수의 수와 형식이 다른 여러 인덱서를 선언할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-286">A class can declare multiple indexers as long as the number or types of their parameters differ.</span></span>

### <a name="events"></a><span data-ttu-id="49e57-287">이벤트</span><span class="sxs-lookup"><span data-stu-id="49e57-287">Events</span></span>

<span data-ttu-id="49e57-288">*이벤트*는 클래스 또는 개체가 알림을 제공할 수 있도록 하는 멤버입니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-288">An *event* is a member that enables a class or object to provide notifications.</span></span> <span data-ttu-id="49e57-289">이벤트는 선언에 `event` 키워드가 포함되고 형식이 대리자 형식이어야 한다는 점을 제외하고 필드처럼 선언됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-289">An event is declared like a field except that the declaration includes an `event` keyword and the type must be a delegate type.</span></span>

<span data-ttu-id="49e57-290">이벤트 멤버를 선언하는 클래스 내에서 이벤트는 대리자 형식의 필드처럼 동작합니다(이벤트가 추상이 아니고 접근자를 선언하지 않을 경우).</span><span class="sxs-lookup"><span data-stu-id="49e57-290">Within a class that declares an event member, the event behaves just like a field of a delegate type (provided the event isn't abstract and doesn't declare accessors).</span></span> <span data-ttu-id="49e57-291">필드는 이벤트에 추가된 이벤트 처리기를 나타내는 대리자에 대한 참조를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-291">The field stores a reference to a delegate that represents the event handlers that have been added to the event.</span></span> <span data-ttu-id="49e57-292">이벤트 처리기가 없는 경우 필드는 `null`입니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-292">If no event handlers are present, the field is `null`.</span></span>

<span data-ttu-id="49e57-293">`MyList<T>` 클래스는 `Changed`라는 단일 이벤트 멤버를 선언합니다. 이것은 새 항목이 목록에 추가되었음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-293">The `MyList<T>` class declares a single event member called `Changed`, which indicates that a new item has been added to the list.</span></span> <span data-ttu-id="49e57-294">Changed 이벤트는 `OnChanged` 가상 메서드에 의해 발생합니다. 이 메서드는 먼저 이벤트가 `null`인지 확인합니다(처리기가 없음을 의미함).</span><span class="sxs-lookup"><span data-stu-id="49e57-294">The Changed event is raised by the `OnChanged` virtual method, which first checks whether the event is `null` (meaning that no handlers are present).</span></span> <span data-ttu-id="49e57-295">이벤트 발생 개념은 이벤트가 나타내는 대리자를 호출하는 것과 정확히 동일하므로</span><span class="sxs-lookup"><span data-stu-id="49e57-295">The notion of raising an event is precisely equivalent to invoking the delegate represented by the event.</span></span> <span data-ttu-id="49e57-296">이벤트 발생을 위한 특수한 언어 구문은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-296">There are no special language constructs for raising events.</span></span>

<span data-ttu-id="49e57-297">클라이언트는 *이벤트 처리기*를 통해 이벤트에 반응합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-297">Clients react to events through *event handlers*.</span></span> <span data-ttu-id="49e57-298">이벤트 처리기는 `+=` 연산자를 사용하여 추가되고, `-=` 연산자를 사용하여 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-298">Event handlers are attached using the `+=` operator and removed using the `-=` operator.</span></span> <span data-ttu-id="49e57-299">다음 예제에서는 이벤트 처리기를 `MyList<string>`의 `Changed` 이벤트에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-299">The following example attaches an event handler to the `Changed` event of a `MyList<string>`.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="RespondToEvents":::

<span data-ttu-id="49e57-300">이벤트의 기본 스토리지를 제어하려고 하는 고급 시나리오의 경우 이벤트 선언에서 속성의 `set` 접근자와 비슷한 `add` 및 `remove` 접근자를 명시적으로 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-300">For advanced scenarios where control of the underlying storage of an event is desired, an event declaration can explicitly provide `add` and `remove` accessors, which are similar to the `set` accessor of a property.</span></span>

### <a name="operators"></a><span data-ttu-id="49e57-301">연산자</span><span class="sxs-lookup"><span data-stu-id="49e57-301">Operators</span></span>

<span data-ttu-id="49e57-302">*연산자*는 클래스 인스턴스에 특정 식 연산자를 적용하는 것의 의미를 정의하는 멤버입니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-302">An *operator* is a member that defines the meaning of applying a particular expression operator to instances of a class.</span></span> <span data-ttu-id="49e57-303">세 가지 종류의 연산자, 즉, 단항 연산자, 이항 연산자 및 변환 연산자를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-303">Three kinds of operators can be defined: unary operators, binary operators, and conversion operators.</span></span> <span data-ttu-id="49e57-304">모든 연산자는 `public` 및 `static`으로 선언해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-304">All operators must be declared as `public` and `static`.</span></span>

<span data-ttu-id="49e57-305">`MyList<T>` 클래스는 두 개의 연산자 `operator ==` 및 `operator !=`를 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-305">The `MyList<T>` class declares two operators, `operator ==` and `operator !=`.</span></span> <span data-ttu-id="49e57-306">이들 재정의된 연산자는 해당 연산자를 `MyList` 인스턴스에 적용하는 식에 새로운 의미를 부여합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-306">These overridden operators give new meaning to expressions that apply those operators to `MyList` instances.</span></span> <span data-ttu-id="49e57-307">특히, 이러한 연산자는 해당 `Equals` 메서드를 사용하여 포함된 각 개체를 비교할 때 두 `MyList<T>` 인스턴스의 같음을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-307">Specifically, the operators define equality of two `MyList<T>` instances as comparing each of the contained objects using their `Equals` methods.</span></span> <span data-ttu-id="49e57-308">다음 예제에서는 `==` 연산자를 사용하여 두 `MyList<int>` 인스턴스를 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-308">The following example uses the `==` operator to compare two `MyList<int>` instances.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListAddition":::

<span data-ttu-id="49e57-309">두 목록은 같은 순서로 같은 값을 갖는 동일한 수의 개체를 포함하므로 첫 번째 `Console.WriteLine`은 `True`를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-309">The first `Console.WriteLine` outputs `True` because the two lists contain the same number of objects with the same values in the same order.</span></span> <span data-ttu-id="49e57-310">`MyList<T>`에서 `operator ==`이 정의되지 않았으면 `a` 및 `b`은 다른 `MyList<int>` 인스턴스를 참조하므로 첫 번째 `Console.WriteLine`은 `False`를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-310">Had `MyList<T>` not defined `operator ==`, the first `Console.WriteLine` would have output `False` because `a` and `b` reference different `MyList<int>` instances.</span></span>

### <a name="finalizers"></a><span data-ttu-id="49e57-311">종료자</span><span class="sxs-lookup"><span data-stu-id="49e57-311">Finalizers</span></span>

<span data-ttu-id="49e57-312">*종료자*는 클래스의 인스턴스를 종결하는 데 필요한 작업을 구현하는 멤버입니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-312">A *finalizer* is a member that implements the actions required to finalize an instance of a class.</span></span> <span data-ttu-id="49e57-313">종료자는 일반적으로 관리되지 않는 리소스를 해제하는 데 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-313">Typically, a finalizer is needed to release unmanaged resources.</span></span> <span data-ttu-id="49e57-314">종료자는 매개 변수를 가질 수 없고, 액세스 수준 한정자를 가질 수 없으며, 명시적으로 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-314">Finalizers can't have parameters, they can't have accessibility modifiers, and they can't be invoked explicitly.</span></span> <span data-ttu-id="49e57-315">인스턴스에 대한 종료자는 가비지 수집 중에 자동으로 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-315">The finalizer for an instance is invoked automatically during garbage collection.</span></span> <span data-ttu-id="49e57-316">자세한 내용은 [종료자](../programming-guide/classes-and-structs/destructors.md) 문서를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="49e57-316">For more details, see the article on [finalizers](../programming-guide/classes-and-structs/destructors.md).</span></span>

<span data-ttu-id="49e57-317">가비지 수집기는 개체를 수집하고 종료자를 실행할 시기를 유연하게 결정할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-317">The garbage collector is allowed wide latitude in deciding when to collect objects and run finalizers.</span></span> <span data-ttu-id="49e57-318">특히, 종료자 호출 타이밍은 결정적이 아니며, 모든 스레드에서 종료자를 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-318">Specifically, the timing of finalizer invocations isn't deterministic, and finalizers may be executed on any thread.</span></span> <span data-ttu-id="49e57-319">이러한 이유 및 기타 이유로 클래스는 가능한 다른 솔루션이 없을 때만 종료자를 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-319">For these and other reasons, classes should implement finalizers only when no other solutions are feasible.</span></span>

<span data-ttu-id="49e57-320">`using` 문은 개체 소멸을 위한 더 나은 방법을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-320">The `using` statement provides a better approach to object destruction.</span></span>

## <a name="expressions"></a><span data-ttu-id="49e57-321">표현식</span><span class="sxs-lookup"><span data-stu-id="49e57-321">Expressions</span></span>

<span data-ttu-id="49e57-322">*식*은 *피연산자* 및 *연산자*로 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-322">*Expressions* are constructed from *operands* and *operators*.</span></span> <span data-ttu-id="49e57-323">식의 연산자는 피연산자에 적용할 연산을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-323">The operators of an expression indicate which operations to apply to the operands.</span></span> <span data-ttu-id="49e57-324">연산자의 예로 `+`, `-`, `*`, `/` 및 `new`가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-324">Examples of operators include `+`, `-`, `*`, `/`, and `new`.</span></span> <span data-ttu-id="49e57-325">피연산자의 예로는 리터럴, 필드, 지역 변수 및 식이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-325">Examples of operands include literals, fields, local variables, and expressions.</span></span>

<span data-ttu-id="49e57-326">식에 여러 연산자가 포함된 경우 연산자의 ‘우선 순위’는 개별 연산자가 평가되는 순서를 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-326">When an expression contains multiple operators, the *precedence* of the operators controls the order in which the individual operators are evaluated.</span></span> <span data-ttu-id="49e57-327">예를 들어 `*` 연산자는 `+` 연산자보다 우선 순위가 더 높기 때문에 식 `x + y * z`는 `x + (y * z)`로 계산됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-327">For example, the expression `x + y * z` is evaluated as `x + (y * z)` because the `*` operator has higher precedence than the `+` operator.</span></span>

<span data-ttu-id="49e57-328">피연산자는 동일한 우선 순위를 가진 두 연산자 사이에 나올 경우 연산자의 *결합성*에 따라 연산이 수행되는 순서가 제어됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-328">When an operand occurs between two operators with the same precedence, the *associativity* of the operators controls the order in which the operations are performed:</span></span>

* <span data-ttu-id="49e57-329">대입 및 Null 병합 연산자를 제외하고 모든 이항 연산자는 *왼쪽 결합성*을 갖습니다. 즉, 연산이 왼쪽에서 오른쪽으로 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-329">Except for the assignment and null-coalescing operators, all binary operators are *left-associative*, meaning that operations are performed from left to right.</span></span> <span data-ttu-id="49e57-330">예를 들어, `x + y + z`는 `(x + y) + z`로 계산됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-330">For example, `x + y + z` is evaluated as `(x + y) + z`.</span></span>
* <span data-ttu-id="49e57-331">대입 연산자, Null 병합 `??` 및 `??=` 연산자, 조건부 연산자(`?:`)는 *오른쪽 결합성*을 갖습니다. 즉, 연산이 오른쪽에서 왼쪽으로 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-331">The assignment operators, the null-coalescing `??` and `??=` operators, and the conditional operator `?:` are *right-associative*, meaning that operations are performed from right to left.</span></span> <span data-ttu-id="49e57-332">예를 들어, `x = y = z`는 `x = (y = z)`로 계산됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-332">For example, `x = y = z` is evaluated as `x = (y = z)`.</span></span>

<span data-ttu-id="49e57-333">우선 순위 및 결합성은 괄호를 사용하여 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-333">Precedence and associativity can be controlled using parentheses.</span></span> <span data-ttu-id="49e57-334">예를 들어 `x + y * z`는 먼저 `y`와 `z`를 곱한 다음 그 결과를 `x`와 더하지만 `(x + y) * z`는 먼저 `x`와 `y`를 더한 다음 그 결과에 `z`를 곱합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-334">For example, `x + y * z` first multiplies `y` by `z` and then adds the result to `x`, but `(x + y) * z` first adds `x` and `y` and then multiplies the result by `z`.</span></span>

<span data-ttu-id="49e57-335">대부분의 연산자는 [*오버로드*](../language-reference/operators/operator-overloading.md)할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-335">Most operators can be [*overloaded*](../language-reference/operators/operator-overloading.md).</span></span> <span data-ttu-id="49e57-336">연산자 오버로드는 피연산자 중 하나 또는 둘 다가 사용자 정의 클래스 또는 구조체 형식인 연산에 대해 사용자 정의 연산자 구현을 지정할 수 있도록 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-336">Operator overloading permits user-defined operator implementations to be specified for operations where one or both of the operands are of a user-defined class or struct type.</span></span>

<span data-ttu-id="49e57-337">C#은 [산술](../language-reference/operators/arithmetic-operators.md), [논리](../language-reference/operators/boolean-logical-operators.md), [비트 및 시프트](../language-reference/operators/bitwise-and-shift-operators.md) 연산과 [같음](../language-reference/operators/equality-operators.md) 및 [순서](../language-reference/operators/comparison-operators.md) 비교를 수행하는 여러 연산자를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-337">C# provides a number of operators to perform [arithmetic](../language-reference/operators/arithmetic-operators.md), [logical](../language-reference/operators/boolean-logical-operators.md), [bitwise and shift](../language-reference/operators/bitwise-and-shift-operators.md) operations and [equality](../language-reference/operators/equality-operators.md) and [order](../language-reference/operators/comparison-operators.md) comparisons.</span></span>

<span data-ttu-id="49e57-338">우선 순위 수준에 따라 정렬된 전체 연산자 목록은 [C# 연산자](../language-reference/operators/index.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="49e57-338">For the complete list of C# operators ordered by precedence level, see [C# operators](../language-reference/operators/index.md).</span></span>

## <a name="statements"></a><span data-ttu-id="49e57-339">문</span><span class="sxs-lookup"><span data-stu-id="49e57-339">Statements</span></span>

<span data-ttu-id="49e57-340">프로그램의 동작은 *문*을 사용하여 표현됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-340">The actions of a program are expressed using *statements*.</span></span> <span data-ttu-id="49e57-341">C#은 여러 다른 종류의 문을 지원하며 이중 많은 문이 포함 문에 대해 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-341">C# supports several different kinds of statements, a number of which are defined in terms of embedded statements.</span></span>

- <span data-ttu-id="49e57-342">*블록*은 단일 문이 허용되는 컨텍스트에서 여러 문을 쓸 수 있도록 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-342">A *block* permits multiple statements to be written in contexts where a single statement is allowed.</span></span> <span data-ttu-id="49e57-343">블록은 구분 기호 `{`와 `}` 사이에 쓴 문 목록으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-343">A block consists of a list of statements written between the delimiters `{` and `}`.</span></span>
- <span data-ttu-id="49e57-344">*선언 문*은 지역 변수 및 상수를 선언하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-344">*Declaration statements* are used to declare local variables and constants.</span></span>
- <span data-ttu-id="49e57-345">*식 문*은 식을 평가하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-345">*Expression statements* are used to evaluate expressions.</span></span> <span data-ttu-id="49e57-346">문으로 사용할 수 있는 식에는 메서드 호출, `new` 연산자를 사용하는 개체 할당, `=` 및 복합 할당 연산자를 사용하는 대입, `++` 및 `--` 연산자를 사용하는 증가 및 감소 연산, `await` 식이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-346">Expressions that can be used as statements include method invocations, object allocations using the `new` operator, assignments using `=` and the compound assignment operators, increment and decrement operations using the `++` and `--` operators and `await` expressions.</span></span>
- <span data-ttu-id="49e57-347">*선택 문*은 일부 식 값에 따라 실행할 수 있는 다양한 문 중에서 하나를 선택하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-347">*Selection statements* are used to select one of a number of possible statements for execution based on the value of some expression.</span></span> <span data-ttu-id="49e57-348">이 그룹에는 `if` 문과 `switch` 문이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-348">This group contains the `if` and `switch` statements.</span></span>
- <span data-ttu-id="49e57-349">*반복 문*은 포함 문을 반복해서 실행하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-349">*Iteration statements* are used to execute repeatedly an embedded statement.</span></span> <span data-ttu-id="49e57-350">이 그룹에는 `while` 문, `do` 문, `for` 문과 `foreach` 문이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-350">This group contains the `while`, `do`, `for`, and `foreach` statements.</span></span>
- <span data-ttu-id="49e57-351">*점프 문*은 제어를 전달하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-351">*Jump statements* are used to transfer control.</span></span> <span data-ttu-id="49e57-352">이 그룹에는 `break` 문, `continue` 문, `goto` 문, `throw` 문, `return` 문과 `yield` 문이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-352">This group contains the `break`, `continue`, `goto`, `throw`, `return`, and `yield` statements.</span></span>
- <span data-ttu-id="49e57-353">`try`... `catch` 문은 블록 실행 중에 발생하는 예외를 catch하는 데 사용되고 `try`... `finally` 문은 예외 발생 여부에 관계 없이 항상 실행되는 종료 코드를 지정하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-353">The `try`...`catch` statement is used to catch exceptions that occur during execution of a block, and the `try`...`finally` statement is used to specify finalization code that is always executed, whether an exception occurred or not.</span></span>
- <span data-ttu-id="49e57-354">`checked` 및 `unchecked` 문은 정수 계열 형식 산술 연산 및 변환에 대한 오버플로 검사 컨텍스트를 제어하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-354">The `checked` and `unchecked` statements are used to control the overflow-checking context for integral-type arithmetic operations and conversions.</span></span>
- <span data-ttu-id="49e57-355">`lock` 문은 지정된 개체에 대한 상호 배타적 잠금을 획득하고, 문을 실행한 후 잠금을 해제하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-355">The `lock` statement is used to obtain the mutual-exclusion lock for a given object, execute a statement, and then release the lock.</span></span>
- <span data-ttu-id="49e57-356">`using` 문은 리소스를 획득하고, 문을 실행한 후 해당 리소스를 삭제하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-356">The `using` statement is used to obtain a resource, execute a statement, and then dispose of that resource.</span></span>

<span data-ttu-id="49e57-357">다음은 사용할 수 있는 문 종류입니다.</span><span class="sxs-lookup"><span data-stu-id="49e57-357">The following lists the kinds of statements that can be used:</span></span>

* <span data-ttu-id="49e57-358">지역 변수 선언</span><span class="sxs-lookup"><span data-stu-id="49e57-358">Local variable declaration.</span></span>
* <span data-ttu-id="49e57-359">지역 상수 선언</span><span class="sxs-lookup"><span data-stu-id="49e57-359">Local constant declaration.</span></span>
* <span data-ttu-id="49e57-360">식 문</span><span class="sxs-lookup"><span data-stu-id="49e57-360">Expression statement.</span></span>
* <span data-ttu-id="49e57-361">`if` 문</span><span class="sxs-lookup"><span data-stu-id="49e57-361">`if` statement.</span></span>
* <span data-ttu-id="49e57-362">`switch` 문</span><span class="sxs-lookup"><span data-stu-id="49e57-362">`switch` statement.</span></span>
* <span data-ttu-id="49e57-363">`while` 문</span><span class="sxs-lookup"><span data-stu-id="49e57-363">`while` statement.</span></span>
* <span data-ttu-id="49e57-364">`do` 문</span><span class="sxs-lookup"><span data-stu-id="49e57-364">`do` statement.</span></span>
* <span data-ttu-id="49e57-365">`for` 문</span><span class="sxs-lookup"><span data-stu-id="49e57-365">`for` statement.</span></span>
* <span data-ttu-id="49e57-366">`foreach` 문</span><span class="sxs-lookup"><span data-stu-id="49e57-366">`foreach` statement.</span></span>
* <span data-ttu-id="49e57-367">`break` 문</span><span class="sxs-lookup"><span data-stu-id="49e57-367">`break` statement.</span></span>
* <span data-ttu-id="49e57-368">`continue` 문</span><span class="sxs-lookup"><span data-stu-id="49e57-368">`continue` statement.</span></span>
* <span data-ttu-id="49e57-369">`goto` 문</span><span class="sxs-lookup"><span data-stu-id="49e57-369">`goto` statement.</span></span>
* <span data-ttu-id="49e57-370">`return` 문</span><span class="sxs-lookup"><span data-stu-id="49e57-370">`return` statement.</span></span>
* <span data-ttu-id="49e57-371">`yield` 문</span><span class="sxs-lookup"><span data-stu-id="49e57-371">`yield` statement.</span></span>
* <span data-ttu-id="49e57-372">`throw` 문과 `try` 문</span><span class="sxs-lookup"><span data-stu-id="49e57-372">`throw` statements and `try` statements.</span></span>
* <span data-ttu-id="49e57-373">`checked` 및 `unchecked` 문</span><span class="sxs-lookup"><span data-stu-id="49e57-373">`checked` and `unchecked` statements.</span></span>
* <span data-ttu-id="49e57-374">`lock` 문</span><span class="sxs-lookup"><span data-stu-id="49e57-374">`lock` statement.</span></span>
* <span data-ttu-id="49e57-375">`using` 문</span><span class="sxs-lookup"><span data-stu-id="49e57-375">`using` statement.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="49e57-376">[이전](types.md)
>[다음](features.md)</span><span class="sxs-lookup"><span data-stu-id="49e57-376">[Previous](types.md)
[Next](features.md)</span></span>
