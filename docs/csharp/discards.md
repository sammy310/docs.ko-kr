---
title: 무시 항목 - C# 가이드
description: 할당되지 않은 무시 가능한 변수인 무시 항목에 대한 C#의 지원과 무시 항목을 사용할 수 있는 방법에 관해 설명합니다.
ms.technology: csharp-fundamentals
ms.date: 09/22/2020
ms.openlocfilehash: 3c18fbb0bbb80c2c29c9f5d8334a5dd711b68cc5
ms.sourcegitcommit: 10e719780594efc781b15295e499c66f316068b8
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/14/2021
ms.locfileid: "100432636"
---
# <a name="discards---c-guide"></a><span data-ttu-id="ae376-103">무시 항목 - C# 가이드</span><span class="sxs-lookup"><span data-stu-id="ae376-103">Discards - C# Guide</span></span>

<span data-ttu-id="ae376-104">C# 7.0부터 C#에서는 애플리케이션 코드에서 의도적으로 사용되지 않는 자리 표시자 변수인 무시 항목을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-104">Starting with C# 7.0, C# supports discards, which are placeholder variables that are intentionally unused in application code.</span></span> <span data-ttu-id="ae376-105">무시 항목은 할당되지 않은 변수에 해당하므로 값을 가지지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-105">Discards are equivalent to unassigned variables; they don't have a value.</span></span> <span data-ttu-id="ae376-106">무시 항목은 컴파일러 및 코드를 읽는 다른 사용자에게 의도를 전달합니다. 식의 결과를 무시하라는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-106">A discard communicates intent to the compiler and others that read your code: You intended to ignore the result of an expression.</span></span> <span data-ttu-id="ae376-107">식의 결과, 하나 이상의 튜플 식 멤버, 메서드에 대한 `out` 매개 변수 또는 패턴 일치 식의 대상을 무시해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-107">You may want to ignore the result of an expression, one or more members of a tuple expression, an `out` parameter to a method, or the target of a pattern matching expression.</span></span>

<span data-ttu-id="ae376-108">단일 무시 변수만 있으므로 해당 변수를 스토리지에 할당하지 못할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-108">Because there's only a single discard variable, that variable may not even be allocated storage.</span></span> <span data-ttu-id="ae376-109">무시 항목은 메모리 할당을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-109">Discards can reduce memory allocations.</span></span> <span data-ttu-id="ae376-110">무시 항목은 코드의 의도를 명확하게 합니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-110">Discards make the intent of your code clear.</span></span> <span data-ttu-id="ae376-111">또한 코드의 가독성 및 유지 관리를 향상시킵니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-111">They enhance its readability and maintainability.</span></span>

<span data-ttu-id="ae376-112">변수가 무시 항목임을 지정하려면 변수에 밑줄(`_`)을 이름으로 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-112">You indicate that a variable is a discard by assigning it the underscore (`_`) as its name.</span></span> <span data-ttu-id="ae376-113">예를 들어 다음 메서드 호출은 첫 번째 및 두 번째 값이 무시 항목인 튜플을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-113">For example, the following method call returns a tuple in which the first and second values are discards.</span></span> <span data-ttu-id="ae376-114">`area`는 이전에 선언된 변수로, `GetCityInformation`에서 반환된 세 번째 구성 요소로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-114">`area` is a previously declared variable set to the third component returned by `GetCityInformation`:</span></span>

```csharp
(_, _, area) = city.GetCityInformation(cityName);
```

<span data-ttu-id="ae376-115">C# 9.0부터 무시 항목을 사용하여 람다 식의 사용하지 않는 입력 매개 변수를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-115">Beginning with C# 9.0, you can use discards to specify unused input parameters of a lambda expression.</span></span> <span data-ttu-id="ae376-116">자세한 내용은 [람다 식](language-reference/operators/lambda-expressions.md) 문서의 [람다 식 입력 매개 변수](language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression) 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ae376-116">For more information, see the [Input parameters of a lambda expression](language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression) section of the [Lambda expressions](language-reference/operators/lambda-expressions.md) article.</span></span>

<span data-ttu-id="ae376-117">`_`이 유효한 무시 항목인 경우, 해당 값을 검색하거나 할당 작업에서 사용하려고 하면 “이름 ‘\_’이 현재 컨텍스트에 없습니다.”라는 컴파일러 오류 CS0301이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-117">When `_` is a valid discard, attempting to retrieve its value or use it in an assignment operation generates compiler error CS0301, "The name '\_' doesn't exist in the current context".</span></span> <span data-ttu-id="ae376-118">이 오류는 `_`에 값이 할당되어 있지 않고 스토리지 위치도 할당되어 있지 않을 수 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-118">This error is because `_` isn't assigned a value, and may not even be assigned a storage location.</span></span> <span data-ttu-id="ae376-119">실제 변수인 경우에는 이전 예제에서처럼 2개 이상의 값을 무시할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-119">If it were an actual variable, you couldn't discard more than one value, as the previous example did.</span></span>

## <a name="tuple-and-object-deconstruction"></a><span data-ttu-id="ae376-120">튜플 및 개체 분해</span><span class="sxs-lookup"><span data-stu-id="ae376-120">Tuple and object deconstruction</span></span>

<span data-ttu-id="ae376-121">무시 항목은 튜플을 작업할 때 애플리케이션 코드에 튜플 요소 중 일부만 사용하고 일부는 무시하는 경우에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-121">Discards are useful in working with tuples when your application code uses some tuple elements but ignores others.</span></span> <span data-ttu-id="ae376-122">예를 들어, 다음 `QueryCityDataForYears` 메서드는 도시의 이름, 도시의 면적, 연도, 해당 연도의 도시 인구, 두 번째 연도, 해당 두 번째 연도의 도구 인구를 포함하는 튜플을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-122">For example, the following `QueryCityDataForYears` method returns a tuple with the name of a city, its area, a year, the city's population for that year, a second year, and the city's population for that second year.</span></span> <span data-ttu-id="ae376-123">이 예제는 이러한 두 연도 사이의 인구 변화를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-123">The example shows the change in population between those two years.</span></span> <span data-ttu-id="ae376-124">튜플에서 사용 가능한 데이터 중 도시 면적에는 관심이 없고 디자인 타임에 도시 이름과 두 날짜를 알고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-124">Of the data available from the tuple, we're unconcerned with the city area, and we know the city name and the two dates at design-time.</span></span> <span data-ttu-id="ae376-125">따라서 튜플에 저장된 두 가지 인구 값에만 관심이 있고 나머지 값은 무시 항목으로 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-125">As a result, we're only interested in the two population values stored in the tuple, and can handle its remaining values as discards.</span></span>  

:::code language="csharp" source="snippets/discards/discard-tuple.cs" ID="DiscardTupleMember" :::

<span data-ttu-id="ae376-126">무시 항목을 사용한 튜플 분해에 대한 자세한 내용은 [튜플 및 기타 형식 분해](deconstruct.md#deconstructing-tuple-elements-with-discards)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ae376-126">For more information on deconstructing tuples with discards, see [Deconstructing tuples and other types](deconstruct.md#deconstructing-tuple-elements-with-discards).</span></span>

<span data-ttu-id="ae376-127">클래스, 구조체 또는 인터페이스의 `Deconstruct` 메서드로도 개체에서 특정 데이터 집합을 검색 및 분해할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-127">The `Deconstruct` method of a class, structure, or interface also allows you to retrieve and deconstruct a specific set of data from an object.</span></span> <span data-ttu-id="ae376-128">분해된 값의 하위 집합만으로 작업하려는 경우 무시 항목을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-128">You can use discards when you're interested in working with only a subset of the deconstructed values.</span></span> <span data-ttu-id="ae376-129">다음 예제에서는 `Person` 개체를 4개의 문자열(이름, 성, 도시 및 주)로 분해하지만 성과 주는 무시합니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-129">The following example deconstructs a `Person` object into four strings (the first and last names, the city, and the state), but discards the last name and the state.</span></span>

:::code language="csharp" source="snippets/discards/discard-class.cs" :::

<span data-ttu-id="ae376-130">무시 항목을 사용한 사용자 정의 형식 분해에 대한 자세한 내용은 [튜플 및 기타 형식 분해](deconstruct.md#deconstructing-a-user-defined-type-with-discards)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ae376-130">For more information on deconstructing user-defined types with discards, see [Deconstructing tuples and other types](deconstruct.md#deconstructing-a-user-defined-type-with-discards).</span></span>

## <a name="pattern-matching-with-switch"></a><span data-ttu-id="ae376-131">`switch`를 사용한 패턴 일치</span><span class="sxs-lookup"><span data-stu-id="ae376-131">Pattern matching with `switch`</span></span>

<span data-ttu-id="ae376-132">무시 패턴은 [switch](language-reference/keywords/switch.md) 키워드를 사용한 패턴 일치에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-132">The *discard pattern* can be used in pattern matching with the [switch](language-reference/keywords/switch.md) keyword.</span></span> <span data-ttu-id="ae376-133">모든 식은 무시 패턴과 항상 일치됩니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-133">Every expression always matches the discard pattern.</span></span> <span data-ttu-id="ae376-134">([is](language-reference/keywords/is.md) 식과 함께 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-134">(It can be used with [is](language-reference/keywords/is.md) expressions.</span></span> <span data-ttu-id="ae376-135">그러나 해당 의미를 변경하지 않고 무시 항목을 제거할 수 있으므로 그렇게 사용하는 경우는 드뭅니다.)</span><span class="sxs-lookup"><span data-stu-id="ae376-135">However, that use is rare because the discard can be removed without changing its meaning).</span></span>

<span data-ttu-id="ae376-136">다음 예제에서는 [is](language-reference/keywords/is.md) 문을 사용하여 개체가 <xref:System.IFormatProvider> 구현을 제공하고 개체가 `null`인지 테스트하는지를 결정하는 `ProvidesFormatInfo` 메서드를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-136">The following example defines a `ProvidesFormatInfo` method that uses [is](language-reference/keywords/is.md) statements to determine whether an object provides an <xref:System.IFormatProvider> implementation and tests whether the object is `null`.</span></span> <span data-ttu-id="ae376-137">또한 무시 패턴을 사용하여 다른 형식의 null이 아닌 개체도 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-137">It also uses the discard pattern to handle non-null objects of any other type.</span></span>

:::code language="csharp" source="snippets/discards/discard-pattern2.cs" ID="DiscardSwitchExample" :::

## <a name="calls-to-methods-with-out-parameters"></a><span data-ttu-id="ae376-138">`out` 매개 변수를 사용한 메서드 호출</span><span class="sxs-lookup"><span data-stu-id="ae376-138">Calls to methods with `out` parameters</span></span>

<span data-ttu-id="ae376-139">`Deconstruct` 메서드를 호출하여 사용자 정의 형식(클래스, 구조체 또는 인터페이스의 인스턴스)를 분해할 때 개별 `out` 인수의 값을 무시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-139">When calling the `Deconstruct` method to deconstruct a user-defined type (an instance of a class, structure, or interface), you can discard the values of individual `out` arguments.</span></span> <span data-ttu-id="ae376-140">하지만 어느 메서드든 `out` 매개 변수를 사용하여 호출할 때 `out` 인수의 값을 무시할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-140">But you can also discard the value of `out` arguments when calling any method with an `out` parameter.</span></span>

<span data-ttu-id="ae376-141">다음 예제에서는 [DateTime.TryParse(String, out DateTime)](<xref:System.DateTime.TryParse(System.String,System.DateTime@)>) 메서드를 호출하여 날짜의 문자열 표현이 현재 문화권에 유효한지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-141">The following example calls the [DateTime.TryParse(String, out DateTime)](<xref:System.DateTime.TryParse(System.String,System.DateTime@)>) method to determine whether the string representation of a date is valid in the current culture.</span></span> <span data-ttu-id="ae376-142">이 예제에서는 날짜 문자열의 유효성 검사에만 관심이 있고 이 문자열의 구문 검사를 통한 날짜 추출에는 관심이 없으므로 메서드의 `out` 인수는 무시 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-142">Because the example is concerned only with validating the date string and not with parsing it to extract the date, the `out` argument to the method is a discard.</span></span>

:::code language="csharp" source="snippets/discards/discard-out1.cs" ID="DiscardOutParameter" :::

## <a name="a-standalone-discard"></a><span data-ttu-id="ae376-143">독립 실행형 무시 항목</span><span class="sxs-lookup"><span data-stu-id="ae376-143">A standalone discard</span></span>

<span data-ttu-id="ae376-144">독립 실행형 무시 항목을 사용하여 무시할 변수를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-144">You can use a standalone discard to indicate any variable that you choose to ignore.</span></span> <span data-ttu-id="ae376-145">한 가지 일반적인 용도는 인수가 null이 아니도록 할당을 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-145">One typical use is to use an assignment to ensure that an argument isn't null.</span></span> <span data-ttu-id="ae376-146">다음 코드에서는 무시 항목을 사용하여 할당을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-146">The following code uses a discard to force an assignment.</span></span> <span data-ttu-id="ae376-147">할당의 오른쪽은 [null 병합 연산자](language-reference/operators/null-coalescing-operator.md)를 사용하여 인수가 `null`일 때 <xref:System.ArgumentNullException?displayProperty=nameWithType>을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-147">The right side of the assignment uses the [null coalescing operator](language-reference/operators/null-coalescing-operator.md) to throw an <xref:System.ArgumentNullException?displayProperty=nameWithType> when the argument is `null`.</span></span> <span data-ttu-id="ae376-148">코드에 할당 결과가 필요하지 않으므로 할당이 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-148">The code doesn't need the result of the assignment, so it's discarded.</span></span> <span data-ttu-id="ae376-149">식에서 null 검사를 강제로 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-149">The expression forces a null check.</span></span> <span data-ttu-id="ae376-150">무시 항목은 할당 결과가 필요하지 않거나 사용되지 않는다는 의도를 명확하게 합니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-150">The discard clarifies your intent: the result of the assignment isn't needed or used.</span></span>

:::code language="csharp" source="snippets/discards/standalone-discard1.cs" ID="ArgNullCheck" :::

<span data-ttu-id="ae376-151">다음 예제에서는 독립 실행형 무시 항목을 사용하여 비동기 작업에서 반환되는 <xref:System.Threading.Tasks.Task>개체를 무시합니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-151">The following example uses a standalone discard to ignore the <xref:System.Threading.Tasks.Task> object returned by an asynchronous operation.</span></span> <span data-ttu-id="ae376-152">작업을 할당하면 작업이 완료되려고 할 때 throw되는 예외가 표시되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-152">Assigning the task has the effect of suppressing the exception that the operation throws as it is about to complete.</span></span> <span data-ttu-id="ae376-153">그러므로 `Task`를 무시하고 해당 비동기 작업에서 생성되는 모든 오류를 무시하려고 하는 의도를 명확하게 합니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-153">It makes your intent clear: You want to discard the `Task`, and ignore any errors generated from that asynchronous operation.</span></span>

:::code language="csharp" source="snippets/discards/standalone-discard1.cs" ID="SnippetDiscardTask" :::

<span data-ttu-id="ae376-154">작업을 무시 항목에 할당하지 않으면 다음 코드는 컴파일러 경고를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-154">Without assigning the task to a discard, the following code generates a compiler warning:</span></span>

:::code language="csharp" source="snippets/discards/standalone-discard1.cs" ID="SnippetNoDiscardTask" :::

> [!NOTE]
> <span data-ttu-id="ae376-155">디버거를 사용하여 위의 두 샘플 중 하나를 실행하면 예외가 throw될 때 디버거가 프로그램을 중지합니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-155">If you run either of the preceding two samples using a debugger, the debugger will stop the program when the exception is thrown.</span></span> <span data-ttu-id="ae376-156">연결된 디버거가 없으면 두 경우 모두 예외가 자동으로 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-156">Without a debugger attached, the exception is silently ignored in both cases.</span></span>

<span data-ttu-id="ae376-157">`_`은 유효한 식별자이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-157">`_` is also a valid identifier.</span></span> <span data-ttu-id="ae376-158">지원되는 컨텍스트 외부에서 사용하면 `_`은 무시 항목이 아니라 유효한 변수로 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-158">When used outside of a supported context, `_` is treated not as a discard but as a valid variable.</span></span> <span data-ttu-id="ae376-159">`_`이라는 식별자가 이미 범위 내에 있는 경우 `_`을 독립 실행형 무시 항목으로 사용하면 다음과 같은 결과가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-159">If an identifier named `_` is already in scope, the use of `_` as a standalone discard can result in:</span></span>

- <span data-ttu-id="ae376-160">범위 내 `_` 변수 값을 실수로 수정하여 의도한 무시 항목의 값 할당.</span><span class="sxs-lookup"><span data-stu-id="ae376-160">Accidental modification of the value of the in-scope `_` variable by assigning it the value of the intended discard.</span></span> <span data-ttu-id="ae376-161">예들 들어 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-161">For example:</span></span>
   :::code language="csharp" source="snippets/discards/standalone-discard2.cs" ID="VariableIdentifier" :::
- <span data-ttu-id="ae376-162">형식 안전성 위반으로 인한 컴파일러 오류.</span><span class="sxs-lookup"><span data-stu-id="ae376-162">A compiler error for violating type safety.</span></span> <span data-ttu-id="ae376-163">예들 들어 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-163">For example:</span></span>
   :::code language="csharp" source="snippets/discards/standalone-discard2.cs" ID="VariableTypeInference" :::
- <span data-ttu-id="ae376-164">컴파일러 오류 CS0136, “이름이 ‘\_’인 지역 또는 매개 변수는 이 범위에서 선언될 수 없습니다. 해당 이름이 지역 또는 매개 변수를 정의하기 위해 바깥쪽 지역 범위에서 사용되었습니다.”</span><span class="sxs-lookup"><span data-stu-id="ae376-164">Compiler error CS0136, "A local or parameter named '\_' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter."</span></span> <span data-ttu-id="ae376-165">예를 들면 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ae376-165">For example:</span></span>
   :::code language="csharp" source="snippets/discards/standalone-discard2.cs" ID="CannotRedeclare" :::

## <a name="see-also"></a><span data-ttu-id="ae376-166">참고 항목</span><span class="sxs-lookup"><span data-stu-id="ae376-166">See also</span></span>

- [<span data-ttu-id="ae376-167">튜플 및 기타 형식 분해</span><span class="sxs-lookup"><span data-stu-id="ae376-167">Deconstructing tuples and other types</span></span>](deconstruct.md)
- [<span data-ttu-id="ae376-168">`is` 키워드</span><span class="sxs-lookup"><span data-stu-id="ae376-168">`is` keyword</span></span>](language-reference/keywords/is.md)
- [<span data-ttu-id="ae376-169">`switch` 키워드</span><span class="sxs-lookup"><span data-stu-id="ae376-169">`switch` keyword</span></span>](language-reference/keywords/switch.md)
