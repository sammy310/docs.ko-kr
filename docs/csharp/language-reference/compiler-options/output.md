---
description: 컴파일러 출력을 제어하는 C# 컴파일러 옵션입니다. 이러한 옵션은 컴파일에서 어셈블리 생성을 제어합니다.
title: 'C # 컴파일러 옵션 - 출력 옵션'
ms.date: 03/12/2021
f1_keywords:
- cs.build.options
helpviewer_keywords:
- DocumentationFile compiler option [C#]
- OutputAssembly compiler option [C#]
- PlatformTarget compiler option [C#]
- ProduceReferenceAssembly compiler option [C#]
- TargetType compiler option [C#]
ms.openlocfilehash: 2d8b7edbf970875d7300a394ab75756c1316ac9d
ms.sourcegitcommit: 0bb8074d524e0dcf165430b744bb143461f17026
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/15/2021
ms.locfileid: "103482444"
---
# <a name="c-compiler-options-that-control-compiler-output"></a><span data-ttu-id="682b6-104">컴파일러 출력을 제어하는 C# 컴파일러 옵션</span><span class="sxs-lookup"><span data-stu-id="682b6-104">C# Compiler Options that control compiler output</span></span>

<span data-ttu-id="682b6-105">다음 옵션은 컴파일러 출력 생성을 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-105">The following options control compiler output generation.</span></span> <span data-ttu-id="682b6-106">새 MSBuild 구문은 **굵게** 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-106">The new MSBuild syntax is shown in **Bold**.</span></span> <span data-ttu-id="682b6-107">이전 *csc.exe* 구문은 `code style`에 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-107">The older *csc.exe* syntax is shown in `code style`.</span></span>

- <span data-ttu-id="682b6-108">**DocumentationFile** / `-doc`: `///` 주석에서 XML 문서 파일을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-108">**DocumentationFile** / `-doc`: Generate XML doc file from `///` comments.</span></span>
- <span data-ttu-id="682b6-109">**OutputAssembly** / `-out`: 출력 어셈블리 파일을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-109">**OutputAssembly** / `-out`: Specify the output assembly file.</span></span>
- <span data-ttu-id="682b6-110">**PlatformTarget** / `-platform`: 대상 플랫폼 CPU를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-110">**PlatformTarget** / `-platform`: Specify the target platform CPU.</span></span>
- <span data-ttu-id="682b6-111">**ProduceReferenceAssembly** / `-refout`: 참조 어셈블리를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-111">**ProduceReferenceAssembly** / `-refout`: Generate a reference assembly.</span></span>
- <span data-ttu-id="682b6-112">**TargetType** `-target`: 출력 어셈블리의 유형을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-112">**TargetType** `-target`: Specify the type of the output assembly.</span></span>

## <a name="documentationfile"></a><span data-ttu-id="682b6-113">DocumentationFile</span><span class="sxs-lookup"><span data-stu-id="682b6-113">DocumentationFile</span></span>

<span data-ttu-id="682b6-114">**DocumentationFile** 옵션을 사용하면 XML 파일에 문서 주석을 삽입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-114">The **DocumentationFile** option allows you to place documentation comments in an XML file.</span></span> <span data-ttu-id="682b6-115">코드를 문서화하는 방법에 대한 자세한 내용은 [문서 주석에 대한 권장 태그](../../programming-guide/xmldoc/recommended-tags-for-documentation-comments.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="682b6-115">To learn more about documenting your code, see [Recommended Tags for Documentation Comments](../../programming-guide/xmldoc/recommended-tags-for-documentation-comments.md).</span></span> <span data-ttu-id="682b6-116">값은 출력 XML 파일의 경로를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-116">The value specifies the path to the output XML file.</span></span> <span data-ttu-id="682b6-117">XML 파일에는 컴파일의 소스 코드 파일에 주석이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-117">The XML file contains the comments in the source code files of the compilation.</span></span>

```xml
<DocumentationFile>path/to/file.xml</DocumentationFile>
```

<span data-ttu-id="682b6-118">주 또는 최상위 문이 포함된 소스 코드 파일이 먼저 XML로 출력됩니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-118">The source code file that contains Main or top-level statements is output first into the XML.</span></span> <span data-ttu-id="682b6-119">생성된 .xml 파일을 [IntelliSense](/visualstudio/ide/using-intellisense)와 함께 사용하는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-119">You'll often want to use the generated .xml file with [IntelliSense](/visualstudio/ide/using-intellisense).</span></span> <span data-ttu-id="682b6-120">*.xml* 파일 이름은 어셈블리 이름과 동일해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-120">The *.xml* filename must be the same as the assembly name.</span></span> <span data-ttu-id="682b6-121">*.xml* 파일은 어셈블리와 동일한 디렉터리에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-121">The *.xml* file must be in the same directory as the assembly.</span></span> <span data-ttu-id="682b6-122">어셈블리가 Visual Studio 프로젝트에서 참조되면 *.xml* 파일도 검색됩니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-122">When the assembly is referenced in a Visual Studio project, the *.xml* file is found as well.</span></span> <span data-ttu-id="682b6-123">코드 주석을 생성하는 방법에 대한 자세한 내용은 [코드 주석 제공](/visualstudio/ide/reference/generate-xml-documentation-comments)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="682b6-123">For more information about generating code comments, see [Supplying Code Comments](/visualstudio/ide/reference/generate-xml-documentation-comments).</span></span> <span data-ttu-id="682b6-124">[`<TargetType:Module>`](#targettype)을 사용하여 컴파일하지 않으면 `file`은 파일의 출력 파일에 대한 어셈블리 매니페스트를 포함하는 파일의 이름을 지정하는 `<assembly>` 및 `</assembly>` 태그를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-124">Unless you compile with [`<TargetType:Module>`](#targettype), `file` will contain `<assembly>` and `</assembly>` tags specifying the name of the file containing the assembly manifest for the output file.</span></span> <span data-ttu-id="682b6-125">예제는 [XML 설명서 기능을 사용하는 방법](../../programming-guide/xmldoc/how-to-use-the-xml-documentation-features.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="682b6-125">For examples, see [How to use the XML documentation features](../../programming-guide/xmldoc/how-to-use-the-xml-documentation-features.md).</span></span>

> [!NOTE]
> <span data-ttu-id="682b6-126">**DocumentationFile** 옵션은 프로젝트의 모든 파일에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-126">The **DocumentationFile** option applies to all files in the project.</span></span> <span data-ttu-id="682b6-127">특정 파일 또는 코드 섹션에 대한 문서 주석 관련 경고를 사용하지 않으려면 [#pragma warning](../preprocessor-directives/preprocessor-pragma-warning.md)을 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="682b6-127">To disable warnings related to documentation comments for a specific file or section of code, use [#pragma warning](../preprocessor-directives/preprocessor-pragma-warning.md).</span></span>

## <a name="outputassembly"></a><span data-ttu-id="682b6-128">OutputAssembly</span><span class="sxs-lookup"><span data-stu-id="682b6-128">OutputAssembly</span></span>

<span data-ttu-id="682b6-129">**OutputAssembly** 옵션은 출력 파일의 이름을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-129">The **OutputAssembly** option specifies the name of the output file.</span></span> <span data-ttu-id="682b6-130">출력 경로는 컴파일러 출력이 배치되는 폴더를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-130">The output path specifies the folder where compiler output is placed.</span></span>

```xml
<OutputAssembly>folder</OutputAssembly>
```

<span data-ttu-id="682b6-131">만들려는 파일의 전체 이름과 확장명을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-131">Specify the full name and extension of the file you want to create.</span></span> <span data-ttu-id="682b6-132">출력 파일의 이름을 지정하지 않으면 MSBuild는 프로젝트 이름을 사용하여 출력 어셈블리의 이름을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-132">If you don't specify the name of the output file, MSBuild uses the name of the project to specify the name of the output assembly.</span></span> <span data-ttu-id="682b6-133">이전 스타일 프로젝트는 다음 규칙을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-133">Old style projects use the following rules:</span></span>

- <span data-ttu-id="682b6-134">.exe는 `Main` 메서드 또는 최상위 문이 포함된 소스 코드 파일에서 해당 이름을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-134">An .exe will take its name from the source code file that contains the `Main` method or top-level statements.</span></span>  
- <span data-ttu-id="682b6-135">.dll 또는 netmodule은 첫 번째 소스 코드 파일에서 해당 이름을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-135">A .dll or .netmodule will take its name from the first source code file.</span></span>

<span data-ttu-id="682b6-136">컴파일의 일부로 생성된 모든 모듈은 컴파일할 때 함께 생성된 어셈블리와 연결된 파일이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-136">Any modules produced as part of a compilation become files associated with any assembly also produced in the compilation.</span></span> <span data-ttu-id="682b6-137">연결된 파일을 보려면 [ildasm.exe](../../../framework/tools/ildasm-exe-il-disassembler.md)를 사용하여 어셈블리 매니페스트를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-137">Use [ildasm.exe](../../../framework/tools/ildasm-exe-il-disassembler.md) to view the assembly manifest to see the associated files.</span></span>

<span data-ttu-id="682b6-138">exe가 [friend 어셈블리](../../../standard/assembly/friend.md)의 대상이 되려면 **OutputAssembly** 컴파일러 옵션이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-138">The **OutputAssembly** compiler option is required in order for an exe to be the target of a [friend assembly](../../../standard/assembly/friend.md).</span></span>

## <a name="platformtarget"></a><span data-ttu-id="682b6-139">PlatformTarget</span><span class="sxs-lookup"><span data-stu-id="682b6-139">PlatformTarget</span></span>

<span data-ttu-id="682b6-140">어셈블리를 실행할 수 있는 CLR 버전을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-140">Specifies which version of the CLR can run the assembly.</span></span>

```xml
<PlatformTarget>anycpu</PlatformTarget>
```

- <span data-ttu-id="682b6-141">**anycpu**(기본값)는 어셈블리를 모든 플랫폼에서 실행되도록 컴파일합니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-141">**anycpu** (default) compiles your assembly to run on any platform.</span></span> <span data-ttu-id="682b6-142">애플리케이션은 가능할 때마다 64비트로 실행되고 해당 모드를 사용할 수 있을 때만 32비트로 전환됩니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-142">Your application runs as a 64-bit process whenever possible and falls back to 32-bit when only that mode is available.</span></span>
- <span data-ttu-id="682b6-143">**anycpu32bitpreferred** 는 어셈블리를 모든 플랫폼에서 실행되도록 컴파일합니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-143">**anycpu32bitpreferred** compiles your assembly to run on any platform.</span></span> <span data-ttu-id="682b6-144">애플리케이션은 64비트와 32비트 애플리케이션을 모두 지원하는 시스템에서 32비트로 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-144">Your application runs in 32-bit mode on systems that support both 64-bit and 32-bit applications.</span></span> <span data-ttu-id="682b6-145">.NET Framework 4.5 이상을 대상으로 하는 프로젝트에 대해서만 이 옵션을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-145">You can specify this option only for projects that target .NET Framework 4.5 or later.</span></span>
- <span data-ttu-id="682b6-146">**ARM** 은 ARM(고급 RISC 컴퓨터) 프로세서가 있는 컴퓨터에서 실행할 어셈블리를 컴파일합니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-146">**ARM** compiles your assembly to run on a computer that has an Advanced RISC Machine (ARM) processor.</span></span>
- <span data-ttu-id="682b6-147">**ARM64** 는 A64 명령 집합을 지원하는 ARM(고급 RISC 머신) 프로세서가 있는 컴퓨터에서 64비트 CLR에 의해 실행되도록 어셈블리를 컴파일합니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-147">**ARM64** compiles your assembly to run by the 64-bit CLR on a computer that has an Advanced RISC Machine (ARM) processor that supports the A64 instruction set.</span></span>
- <span data-ttu-id="682b6-148">**x64** 는 AMD64 또는 EM64T 명령 집합을 지원하는 컴퓨터에서 64비트 CLR에 의해 실행되도록 어셈블리를 컴파일합니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-148">**x64** compiles your assembly to be run by the 64-bit CLR on a computer that supports the AMD64 or EM64T instruction set.</span></span>
- <span data-ttu-id="682b6-149">**x86** 은 32비트, x86 호환 CLR에 의해 실행되도록 어셈블리를 컴파일합니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-149">**x86** compiles your assembly to be run by the 32-bit, x86-compatible CLR.</span></span>
- <span data-ttu-id="682b6-150">**Itanium** 은 Itanium 프로세서 탑재 컴퓨터에서 64비트 CLR에 의해 실행되도록 어셈블리를 컴파일합니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-150">**Itanium** compiles your assembly to be run by the 64-bit CLR on a computer with an Itanium processor.</span></span>

<span data-ttu-id="682b6-151">64비트 Windows 운영 체제:</span><span class="sxs-lookup"><span data-stu-id="682b6-151">On a 64-bit Windows operating system:</span></span>

- <span data-ttu-id="682b6-152">**x86** 으로 컴파일된 어셈블리는 WOW64 아래에서 실행되는 32비트 CLR에서 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-152">Assemblies compiled with **x86** execute on the 32-bit CLR running under WOW64.</span></span>
- <span data-ttu-id="682b6-153">**anycpu** 로 컴파일된 DLL은 해당 DLL이 로드된 프로세스와 동일한 CLR에서 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-153">A DLL compiled with the **anycpu** executes on the same CLR as the process into which it's loaded.</span></span>
- <span data-ttu-id="682b6-154">**anycpu** 로 컴파일된 실행 파일은 64비트 CLR에서 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-154">Executables that are compiled with the **anycpu** execute on the 64-bit CLR.</span></span>
- <span data-ttu-id="682b6-155">**anycpu32bitpreferred** 로 컴파일된 실행 파일은 32비트 CLR에서 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-155">Executables compiled with **anycpu32bitpreferred** execute on the 32-bit CLR.</span></span>

<span data-ttu-id="682b6-156">**anycpu32bitpreferred** 설정은 실행 파일(.EXE)에 대해서만 유효하고 .NET Framework 4.5 이상이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-156">The **anycpu32bitpreferred** setting is valid only for executable (.EXE) files, and it requires .NET Framework 4.5 or later.</span></span> <span data-ttu-id="682b6-157">Windows 64비트 운영 체제에서 실행할 애플리케이션을 개발하는 방법에 대한 자세한 내용은 [64비트 애플리케이션](../../../framework/64-bit-apps.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="682b6-157">For more information about developing an application to run on a Windows 64-bit operating system, see [64-bit Applications](../../../framework/64-bit-apps.md).</span></span>

<span data-ttu-id="682b6-158">Visual Studio의 프로젝트에 대한 **빌드** 속성 페이지에서 **PlatformTarget** 옵션을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-158">You set the **PlatformTarget** option from **Build** properties page for your project in Visual Studio.</span></span>

<span data-ttu-id="682b6-159">**anycpu** 의 동작에는 .NET Core 및 .NET 5 이상 릴리스에 대한 몇 가지 추가 뉘앙스가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-159">The behavior of **anycpu** has some additional nuances on .NET Core and .NET 5 and later releases.</span></span> <span data-ttu-id="682b6-160">**anycpu** 를 설정할 때 앱을 게시하고 x86 `dotnet.exe` 또는 x64 `dotnet.exe`로 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-160">When you set **anycpu**, publish your app and execute it with either the x86 `dotnet.exe` or the x64 `dotnet.exe`.</span></span> <span data-ttu-id="682b6-161">자체 포함 앱의 경우 `dotnet publish` 단계에서 구성 RID에 대한 실행 파일을 패키징합니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-161">For self-contained apps, the `dotnet publish` step packages the executable for the configure RID.</span></span>

## <a name="producereferenceassembly"></a><span data-ttu-id="682b6-162">ProduceReferenceAssembly</span><span class="sxs-lookup"><span data-stu-id="682b6-162">ProduceReferenceAssembly</span></span>

<span data-ttu-id="682b6-163">**ProduceReferenceAssembly** 옵션은 참조 어셈블리가 출력되어야 하는 파일 경로를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-163">The **ProduceReferenceAssembly** option specifies a file path where the reference assembly should be output.</span></span> <span data-ttu-id="682b6-164">Emit API에서 `metadataPeStream`으로 전환됩니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-164">It translates to `metadataPeStream` in the Emit API.</span></span> <span data-ttu-id="682b6-165">`filepath`는 참조 어셈블리의 경로를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-165">The `filepath` specifies the path for the reference assembly.</span></span> <span data-ttu-id="682b6-166">일반적으로 주 어셈블리의 경로와 일치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-166">It should generally match that of the primary assembly.</span></span> <span data-ttu-id="682b6-167">권장되는 규칙(MSBuild에서 사용됨)은 주 어셈블리를 기준으로 “ref/” 하위 폴더에 참조 어셈블리를 배치하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-167">The recommended convention (used by MSBuild) is to place the reference assembly in a "ref/" subfolder relative to the primary assembly.</span></span>

```xml
<ProduceReferenceAssembly>filepath</ProduceReferenceAssembly>
```

<span data-ttu-id="682b6-168">참조 어셈블리는 라이브러리의 퍼블릭 API 표면을 나타내는 데 필요한 최소한의 메타데이터만 포함하는 특수한 형식의 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-168">Reference assemblies are a special type of assembly that contains only the minimum amount of metadata required to represent the library's public API surface.</span></span> <span data-ttu-id="682b6-169">여기에는 빌드 도구에서 어셈블리를 참조할 때 중요한 모든 멤버에 대한 선언이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-169">They include declarations for all members that are significant when referencing an assembly in build tools.</span></span> <span data-ttu-id="682b6-170">참조 어셈블리는 모든 멤버 구현 및 프라이빗 멤버 선언을 제외합니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-170">Reference assemblies exclude all member implementations and declarations of private members.</span></span> <span data-ttu-id="682b6-171">이러한 멤버는 해당 API 계약에 뚜렷한 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-171">Those members have no observable impact on their API contract.</span></span> <span data-ttu-id="682b6-172">자세한 내용은 .NET 가이드에서 [참조 어셈블리](../../../standard/assembly/reference-assemblies.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="682b6-172">For more information, see [Reference assemblies](../../../standard/assembly/reference-assemblies.md) in the .NET Guide.</span></span>

<span data-ttu-id="682b6-173">**ProduceReferenceAssembly** 및 [**ProduceOnlyReferenceAssembly**](./code-generation.md#produceonlyreferenceassembly) 옵션은 함께 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-173">The **ProduceReferenceAssembly** and [**ProduceOnlyReferenceAssembly**](./code-generation.md#produceonlyreferenceassembly) options are mutually exclusive.</span></span>

## <a name="targettype"></a><span data-ttu-id="682b6-174">TargetType</span><span class="sxs-lookup"><span data-stu-id="682b6-174">TargetType</span></span>

<span data-ttu-id="682b6-175">**TargetType** 컴파일러 옵션은 다음 양식 중 하나로 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-175">The **TargetType** compiler option can be specified in one of the following forms:</span></span>  
  
- <span data-ttu-id="682b6-176">**library**: 코드 라이브러리를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-176">**library**: to create a code library.</span></span> <span data-ttu-id="682b6-177">**library** 는 기본값입니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-177">**library** is the default value.</span></span>
- <span data-ttu-id="682b6-178">**exe**: .exe 파일을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-178">**exe**: to create an .exe file.</span></span>  
- <span data-ttu-id="682b6-179">**module**: 모듈을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-179">**module** to create a module.</span></span>  
- <span data-ttu-id="682b6-180">**winexe**: Windows 프로그램을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-180">**winexe** to create a Windows program.</span></span>
- <span data-ttu-id="682b6-181">**winmdobj**: 중간 *.winmdobj* 파일을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-181">**winmdobj** to create an intermediate *.winmdobj* file.</span></span>
- <span data-ttu-id="682b6-182">**appcontainerexe**: Windows 8.x 스토어 앱용 .exe 파일을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-182">**appcontainerexe** to create an .exe file for Windows 8.x Store apps.</span></span>
  
> [!NOTE]
> <span data-ttu-id="682b6-183">.NET Framework 대상의 경우 **module** 을 지정하지 않는 한 이 옵션을 사용하면 .NET Framework 어셈블리 매니페스트가 출력 파일에 배치됩니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-183">For .NET Framework targets, unless you specify **module**, this option causes a .NET Framework assembly manifest to be placed in an output file.</span></span> <span data-ttu-id="682b6-184">자세한 내용은 [.NET의 어셈블리](../../../standard/assembly/index.md) 및 [공통 특성](../attributes/global.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="682b6-184">For more information, see [Assemblies in .NET](../../../standard/assembly/index.md) and [Common Attributes](../attributes/global.md).</span></span>

```xml
<TargetType>library</TargetType>
```

<span data-ttu-id="682b6-185">컴파일러는 컴파일당 하나의 어셈블리 매니페스트만 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-185">The compiler creates only one assembly manifest per compilation.</span></span> <span data-ttu-id="682b6-186">컴파일의 모든 파일에 대한 정보가 어셈블리 매니페스트에 배치됩니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-186">Information about all files in a compilation is placed in the assembly manifest.</span></span> <span data-ttu-id="682b6-187">명령줄에서 여러 출력 파일을 생성하는 경우 하나의 어셈블리 매니페스트만 만들 수 있으며, 명령줄에 지정된 첫 번째 출력 파일로 이동해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-187">When producing multiple output files at the command line, only one assembly manifest can be created and it must go into the first output file specified on the command line.</span></span>

<span data-ttu-id="682b6-188">어셈블리를 만드는 경우 <xref:System.CLSCompliantAttribute> 특성을 사용하여 코드의 전체 또는 일부를 CLS 규격으로 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-188">If you create an assembly, you can indicate that all or part of your code is CLS-compliant with the <xref:System.CLSCompliantAttribute> attribute.</span></span>

### <a name="library"></a><span data-ttu-id="682b6-189">라이브러리</span><span class="sxs-lookup"><span data-stu-id="682b6-189">library</span></span>

<span data-ttu-id="682b6-190">**library** 옵션을 사용하면 컴파일러가 실행 파일(EXE) 대신 DLL(동적 연결 라이브러리)을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-190">The **library** option causes the compiler to create a dynamic-link library (DLL) rather than an executable file (EXE).</span></span> <span data-ttu-id="682b6-191">DLL은 *.dll* 확장명으로 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-191">The DLL will be created with the *.dll* extension.</span></span> <span data-ttu-id="682b6-192">[**OutputAssembly**](#outputassembly) 옵션을 사용하여 달리 지정되지 않는 한 첫 번째 입력 파일의 이름이 출력 파일의 이름으로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-192">Unless otherwise specified with the [**OutputAssembly**](#outputassembly) option, the output file name takes the name of the first input file.</span></span> <span data-ttu-id="682b6-193">*.dll* 파일을 빌드하는 경우에는 [`Main`](../../programming-guide/main-and-command-args/index.md) 메서드가 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-193">When building a *.dll* file, a [`Main`](../../programming-guide/main-and-command-args/index.md) method isn't required.</span></span>

### <a name="exe"></a><span data-ttu-id="682b6-194">exe</span><span class="sxs-lookup"><span data-stu-id="682b6-194">exe</span></span>

<span data-ttu-id="682b6-195">**exe** 옵션을 사용하면 컴파일러가 콘솔 애플리케이션 실행 파일(EXE)을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-195">The **exe** option causes the compiler to create an executable (EXE), console application.</span></span> <span data-ttu-id="682b6-196">실행 파일은 .exe 확장명으로 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-196">The executable file will be created with the .exe extension.</span></span> <span data-ttu-id="682b6-197">**winexe** 를 사용하여 Windows 프로그램 실행 파일을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-197">Use **winexe** to create a Windows program executable.</span></span> <span data-ttu-id="682b6-198">[**OutputAssembly**](#outputassembly) 옵션을 사용하여 달리 지정하지 않는 한 출력 파일 이름은 진입점을 포함하는 입력 파일의 이름을 사용합니다([Main](../../programming-guide/main-and-command-args/index.md) 메서드 또는 최상위 문).</span><span class="sxs-lookup"><span data-stu-id="682b6-198">Unless otherwise specified with the [**OutputAssembly**](#outputassembly) option, the output file name takes the name of the input file that contains the entry point ([Main](../../programming-guide/main-and-command-args/index.md) method or top-level statements).</span></span> <span data-ttu-id="682b6-199">.exe 파일로 컴파일되는 소스 코드 파일에는 진입점이 하나만 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-199">One and only one entry point is required in the source code files that are compiled into an .exe file.</span></span> <span data-ttu-id="682b6-200">[**StartupObject**](./advanced.md#mainentrypoint-or-startupobject) 컴파일러 옵션을 사용하면 코드에 `Main` 메서드를 포함하는 클래스가 둘 이상 있는 경우 `Main` 메서드를 포함하는 클래스를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-200">The [**StartupObject**](./advanced.md#mainentrypoint-or-startupobject) compiler option lets you specify which class contains the `Main` method, in cases where your code has more than one class with a `Main` method.</span></span>  

### <a name="module"></a><span data-ttu-id="682b6-201">모듈(module)</span><span class="sxs-lookup"><span data-stu-id="682b6-201">module</span></span>

<span data-ttu-id="682b6-202">이 옵션은 컴파일러에서 어셈블리 매니페스트를 생성하지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-202">This option causes the compiler to not generate an assembly manifest.</span></span> <span data-ttu-id="682b6-203">기본적으로 이 옵션으로 컴파일하여 생성되는 출력 파일의 확장명은 *.netmodule* 입니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-203">By default, the output file created by compiling with this option will have an extension of *.netmodule*.</span></span> <span data-ttu-id="682b6-204">어셈블리 매니페스트가 없는 파일은 .NET 런타임에서 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-204">A file that doesn't have an assembly manifest cannot be loaded by the .NET runtime.</span></span> <span data-ttu-id="682b6-205">그러나 이러한 파일은 [**AddModules**](inputs.md#addmodules)를 사용하여 어셈블리의 어셈블리 매니페스트에 통합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-205">However, such a file can be incorporated into the assembly manifest of an assembly with [**AddModules**](inputs.md#addmodules).</span></span> <span data-ttu-id="682b6-206">둘 이상의 모듈이 단일 컴파일에서 생성될 경우 한 모듈의 [내부](../keywords/internal.md) 형식을 컴파일에 포함된 다른 모듈에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-206">If more than one module is created in a single compilation, [internal](../keywords/internal.md) types in one module will be available to other modules in the compilation.</span></span> <span data-ttu-id="682b6-207">한 모듈의 코드가 다른 모듈의 `internal` 형식을 참조하는 경우 [**AddModules**](inputs.md#addmodules)를 통해 두 모듈을 모두 어셈블리 매니페스트에 통합해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-207">When code in one module references `internal` types in another module, then both modules must be incorporated into an assembly manifest, with [**AddModules**](inputs.md#addmodules).</span></span> <span data-ttu-id="682b6-208">Visual Studio 개발 환경에서는 모듈을 만들 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-208">Creating a module isn't supported in the Visual Studio development environment.</span></span>

### <a name="winexe"></a><span data-ttu-id="682b6-209">winexe</span><span class="sxs-lookup"><span data-stu-id="682b6-209">winexe</span></span>

<span data-ttu-id="682b6-210">**winexe** 옵션을 사용하면 컴파일러가 Windows 프로그램 실행 파일(EXE)을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-210">The **winexe** option causes the compiler to create an executable (EXE), Windows program.</span></span> <span data-ttu-id="682b6-211">실행 파일은 .exe 확장명으로 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-211">The executable file will be created with the .exe extension.</span></span> <span data-ttu-id="682b6-212">Windows 프로그램은 .NET 라이브러리나 Windows API를 통해 사용자 인터페이스를 제공하는 프로그램입니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-212">A Windows program is one that provides a user interface from either the .NET library or with the Windows APIs.</span></span> <span data-ttu-id="682b6-213">**exe** 를 사용하여 콘솔 애플리케이션을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-213">Use **exe** to create a console application.</span></span> <span data-ttu-id="682b6-214">[**OutputAssembly**](#outputassembly) 옵션을 사용하여 달리 지정하지 않는 한 [`Main`](../../programming-guide/main-and-command-args/index.md) 메서드가 포함된 입력 파일의 이름이 출력 파일의 이름으로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-214">Unless otherwise specified with the [**OutputAssembly**](#outputassembly) option, the output file name takes the name of the input file that contains the [`Main`](../../programming-guide/main-and-command-args/index.md) method.</span></span> <span data-ttu-id="682b6-215">.exe 파일로 컴파일되는 소스 코드 파일에 `Main` 메서드가 하나만 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-215">One and only one `Main` method is required in the source code files that are compiled into an .exe file.</span></span> <span data-ttu-id="682b6-216">[**StartupObject**](./advanced.md#mainentrypoint-or-startupobject) 옵션을 사용하면 코드에 `Main` 메서드를 포함하는 클래스가 둘 이상 있는 경우 `Main` 메서드를 포함하는 클래스를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-216">The [**StartupObject**](./advanced.md#mainentrypoint-or-startupobject) option lets you specify which class contains the `Main` method, in cases where your code has more than one class with a `Main` method.</span></span>

### <a name="winmdobj"></a><span data-ttu-id="682b6-217">winmdobj</span><span class="sxs-lookup"><span data-stu-id="682b6-217">winmdobj</span></span>

<span data-ttu-id="682b6-218">**winmdobj** 옵션을 사용하는 경우 컴파일러는 Windows 런타임 이진( *.winmd*) 파일로 변환할 수 있는 중간 *.winmdobj* 파일을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-218">If you use the **winmdobj** option, the compiler creates an intermediate *.winmdobj* file that you can convert to a Windows Runtime binary (*.winmd*) file.</span></span> <span data-ttu-id="682b6-219">그러면 관리형 언어 프로그램뿐만 아니라 JavaScript 및 C++ 프로그램에서도 *.winmd* 파일을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-219">The *.winmd* file can then be consumed by JavaScript and C++ programs, in addition to managed language programs.</span></span>

<span data-ttu-id="682b6-220">**winmdobj** 설정이 컴파일러에 중간 모듈이 필요하다는 신호를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-220">The **winmdobj** setting signals to the compiler that an intermediate module is required.</span></span> <span data-ttu-id="682b6-221">그러면 <xref:Microsoft.Build.Tasks.WinMDExp> 내보내기 도구를 통해 *.winmdobj* 파일을 공급하여 Windows 메타데이터( *.winmd*) 파일을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-221">The *.winmdobj* file can then be fed through the <xref:Microsoft.Build.Tasks.WinMDExp> export tool to produce a Windows metadata (*.winmd*) file.</span></span> <span data-ttu-id="682b6-222">*.winmd* 파일에는 원본 라이브러리의 코드와 JavaScript 또는 C++ 및 Windows 런타임에서 사용하는 WinMD 메타데이터가 모두 들어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-222">The *.winmd* file contains both the code from the original library and the WinMD metadata that is used by JavaScript or C++ and by the Windows Runtime.</span></span> <span data-ttu-id="682b6-223">**winmdobj** 컴파일러 옵션을 사용하여 컴파일된 파일의 출력은 WimMDExp 내보내기 도구의 입력으로만 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-223">The output of a file that’s compiled by using the **winmdobj** compiler option is used only as input for the WimMDExp export tool.</span></span> <span data-ttu-id="682b6-224">*.winmdobj* 파일 자체는 직접 참조되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-224">The *.winmdobj* file itself isn’t referenced directly.</span></span> <span data-ttu-id="682b6-225">[**OutputAssembly**](#outputassembly) 옵션을 사용하지 않으면 첫 번째 입력 파일의 이름이 출력 파일의 이름으로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-225">Unless you use the [**OutputAssembly**](#outputassembly) option, the output file name takes the name of the first input file.</span></span> <span data-ttu-id="682b6-226">[`Main`](../../programming-guide/main-and-command-args/index.md) 메서드는 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-226">A [`Main`](../../programming-guide/main-and-command-args/index.md) method isn’t required.</span></span>

### <a name="appcontainerexe"></a><span data-ttu-id="682b6-227">appcontainerexe</span><span class="sxs-lookup"><span data-stu-id="682b6-227">appcontainerexe</span></span>

<span data-ttu-id="682b6-228">**appcontainerexe** 컴파일러 옵션을 사용하면 컴파일러는 앱 컨테이너에서 실행해야 하는 Windows 실행 파일( *.exe*)을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-228">If you use the **appcontainerexe** compiler option, the compiler creates a Windows executable (*.exe*) file that must be run in an app container.</span></span> <span data-ttu-id="682b6-229">이 옵션은 [-target:winexe](./target-winexe-compiler-option.md)와 같지만, Windows 8.x 스토어 앱을 위해 설계되었습니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-229">This option is equivalent to [-target:winexe](./target-winexe-compiler-option.md) but is designed for Windows 8.x Store apps.</span></span>

<span data-ttu-id="682b6-230">이 옵션은 앱이 앱 컨테이너에서 실행되도록 하기 위해 PE([이식 가능 파일](/windows/desktop/Debug/pe-format))에 비트를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-230">To require the app to run in an app container, this option sets a bit in the [Portable Executable](/windows/desktop/Debug/pe-format) (PE) file.</span></span> <span data-ttu-id="682b6-231">해당 비트가 설정된 경우 CreateProcess 메서드가 응용 프로그램 밖에서 실행 파일을 실행하려고 시도하면 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-231">When that bit is set, an error occurs if the CreateProcess method tries to launch the executable file outside an app container.</span></span> <span data-ttu-id="682b6-232">[**OutputAssembly**](#outputassembly) 옵션을 사용하지 않으면 [`Main`](../../programming-guide/main-and-command-args/index.md) 메서드가 포함된 입력 파일의 이름이 출력 파일의 이름으로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="682b6-232">Unless you use the [**OutputAssembly**](#outputassembly) option, the output file name takes the name of the input file that contains the [`Main`](../../programming-guide/main-and-command-args/index.md) method.</span></span>
