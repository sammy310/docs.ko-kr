---
description: 컴파일을 위한 입력 파일을 제어하는 C# 컴파일러 옵션입니다. 이러한 옵션은 컴파일러가 종속 어셈블리 및 모듈에서 메타데이터를 읽는 방법을 지정합니다.
title: C# 컴파일러 옵션 - 입력 파일 옵션
ms.date: 03/12/2021
f1_keywords:
- cs.build.options
helpviewer_keywords:
- References compiler option [C#]
- AddModules compiler option [C#]
- EmbedInteropTypes compiler option [C#]
ms.openlocfilehash: 819e2322720782b94bd744e00c602221f023c0d8
ms.sourcegitcommit: 0bb8074d524e0dcf165430b744bb143461f17026
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/15/2021
ms.locfileid: "103482503"
---
# <a name="c-compiler-options-that-specify-inputs"></a><span data-ttu-id="4f269-104">입력을 지정하는 C# 컴파일러 옵션</span><span class="sxs-lookup"><span data-stu-id="4f269-104">C# Compiler Options that specify inputs</span></span>

<span data-ttu-id="4f269-105">다음 옵션은 컴파일러 입력을 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-105">The following options control compiler inputs.</span></span> <span data-ttu-id="4f269-106">새 MSBuild 구문은 **굵게** 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-106">The new MSBuild syntax is shown in **Bold**.</span></span> <span data-ttu-id="4f269-107">이전 *csc.exe* 구문은 `code style`에 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-107">The older *csc.exe* syntax is shown in `code style`.</span></span>

- <span data-ttu-id="4f269-108">**References** / `-reference` 또는 `-references`: 지정한 어셈블리 파일에서 메타데이터를 참조합니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-108">**References** / `-reference` or `-references`: Reference metadata from the specified assembly file or files.</span></span>
- <span data-ttu-id="4f269-109">**AddModules** / `-addmodule`: 모듈을 추가합니다(이 어셈블리에 `target:module`로 생성됨)</span><span class="sxs-lookup"><span data-stu-id="4f269-109">**AddModules** / `-addmodule`: Add a module (created with `target:module` to this assembly.)</span></span>
- <span data-ttu-id="4f269-110">**EmbedInteropTypes** / `-link`: 지정된 interop 어셈블리 파일에서 메타데이터를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-110">**EmbedInteropTypes** / `-link`: Embed metadata from the specified interop assembly files.</span></span>

## <a name="references"></a><span data-ttu-id="4f269-111">참조</span><span class="sxs-lookup"><span data-stu-id="4f269-111">References</span></span>

<span data-ttu-id="4f269-112">**References** 옵션을 사용하면 컴파일러가 지정된 파일의 [public](../keywords/public.md) 형식 정보를 현재 프로젝트로 가져와 지정된 어셈블리 파일에서 메타데이터를 참조할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-112">The **References** option causes the compiler to import [public](../keywords/public.md) type information in the specified file into the current project, enabling you to reference metadata from the specified assembly files.</span></span>

```xml
<Reference Include="filename" />
```

 <span data-ttu-id="4f269-113">`filename`은 어셈블리 매니페스트를 포함하는 파일의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-113">`filename` is the name of a file that contains an assembly manifest.</span></span> <span data-ttu-id="4f269-114">둘 이상의 파일을 가져오기 위해 각 파일에 대해 별도의 **Reference** 요소를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-114">To import more than one file, include a separate **Reference** element for each file.</span></span> <span data-ttu-id="4f269-115">별칭을 **Reference** 요소의 자식 요소로 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-115">You can define an alias as a child element of the **Reference** element:</span></span>

```xml
<Reference Include="filename.dll">
  <Aliases>LS</Aliases>
</Reference>
```

<span data-ttu-id="4f269-116">이전 예제에서 `LS`는 어셈블리 *filename.dll* 의 모든 네임스페이스를 포함하는 루트 네임스페이스를 나타내는 유효한 C# 식별자입니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-116">In the previous example, `LS` is the valid C# identifier that represents a root namespace that will contain all namespaces in the assembly *filename.dll*.</span></span> <span data-ttu-id="4f269-117">가져오는 파일에는 매니페스트가 포함되어 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-117">The files you import must contain a manifest.</span></span> <span data-ttu-id="4f269-118">[**AdditionalLibPaths**](advanced.md#additionallibpaths)를 사용하여 하나 이상의 어셈블리 참조가 있는 디렉터리를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-118">Use [**AdditionalLibPaths**](advanced.md#additionallibpaths) to specify the directory in which one or more of your assembly references is located.</span></span> <span data-ttu-id="4f269-119">[**AdditionalLibPaths**](advanced.md#additionallibpaths) 항목에서는 컴파일러가 어셈블리를 검색하는 디렉터리에 대해서도 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-119">The [**AdditionalLibPaths**](advanced.md#additionallibpaths) topic also discusses the directories in which the compiler searches for assemblies.</span></span> <span data-ttu-id="4f269-120">컴파일러가 모듈이 아니라 어셈블리의 형식을 인식하려면 강제로 형식을 확인하도록 해야 하며, 이 작업을 위해 형식의 인스턴스를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-120">In order for the compiler to recognize a type in an assembly, and not in a module, it needs to be forced to resolve the type, which you can do by defining an instance of the type.</span></span> <span data-ttu-id="4f269-121">컴파일러를 위해 어셈블리의 형식 이름을 확인하는 다른 방법이 있습니다. 예를 들어 어셈블리의 형식에서 상속하는 경우 컴파일러가 형식 이름을 인식합니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-121">There are other ways to resolve type names in an assembly for the compiler: for example, if you inherit from a type in an assembly, the type name will then be recognized by the compiler.</span></span> <span data-ttu-id="4f269-122">때로는 하나의 어셈블리 내에서 동일한 구성 요소의 두 가지 버전을 참조해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-122">Sometimes it is necessary to reference two different versions of the same component from within one assembly.</span></span> <span data-ttu-id="4f269-123">이렇게 하려면 각 파일에 대한 **References** 요소에 있는 **Aliases** 요소를 사용하여 두 파일을 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-123">To do this, use the **Aliases** element on the **References** element for each file to distinguish between the two files.</span></span> <span data-ttu-id="4f269-124">이 별칭은 구성 요소 이름에 대한 한정자로 사용되며, 파일 중 하나의 구성 요소로 확인됩니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-124">This alias will be used as a qualifier for the component name, and will resolve to the component in one of the files.</span></span>

> [!NOTE]
> <span data-ttu-id="4f269-125">Visual Studio에서 **참조 추가** 명령을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-125">In Visual Studio, use the **Add Reference** command.</span></span> <span data-ttu-id="4f269-126">자세한 내용은 [방법: 참조 관리자를 사용하여 참조 추가 또는 제거](/visualstudio/ide/how-to-add-or-remove-references-by-using-the-reference-manager)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="4f269-126">For more information, see [How to: Add or Remove References By Using the Reference Manager](/visualstudio/ide/how-to-add-or-remove-references-by-using-the-reference-manager).</span></span>

## <a name="addmodules"></a><span data-ttu-id="4f269-127">AddModules</span><span class="sxs-lookup"><span data-stu-id="4f269-127">AddModules</span></span>

<span data-ttu-id="4f269-128">이 옵션은 `<TargetType>module</TargetType>` 스위치로 만들어진 모듈을 현재 컴파일에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-128">This option adds a module that was created with the `<TargetType>module</TargetType>` switch to the current compilation:</span></span>

```xml
<AddModule Include=file1 />
<AddModule Include=file2 />
```

<span data-ttu-id="4f269-129">여기서 `file`, `file2`는 메타데이터를 포함하는 출력 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-129">Where `file`, `file2` are output files that contain metadata.</span></span> <span data-ttu-id="4f269-130">파일에 어셈블리 매니페스트를 포함할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-130">The file can't contain an assembly manifest.</span></span> <span data-ttu-id="4f269-131">둘 이상의 파일을 가져오려면 파일 이름을 쉼표 또는 세미콜론으로 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-131">To import more than one file, separate file names with either a comma or a semicolon.</span></span> <span data-ttu-id="4f269-132">**AddModules** 를 사용하여 추가된 모든 모듈은 런타임에 출력 파일과 동일한 디렉터리에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-132">All modules added with **AddModules** must be in the same directory as the output file at run time.</span></span> <span data-ttu-id="4f269-133">즉, 컴파일 시간에 임의 디렉터리에 있는 모듈을 지정할 수 있지만 런타임에 모듈이 애플리케이션 디렉터리에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-133">That is, you can specify a module in any directory at compile time but the module must be in the application directory at run time.</span></span> <span data-ttu-id="4f269-134">모듈이 런타임에 애플리케이션 디렉터리에 없는 경우 <xref:System.TypeLoadException>을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-134">If the module isn't in the application directory at run time, you'll get a <xref:System.TypeLoadException>.</span></span> <span data-ttu-id="4f269-135">`file`에 어셈블리를 포함할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-135">`file` can't contain an assembly.</span></span> <span data-ttu-id="4f269-136">예를 들어, **module** 의 [**TargetType**](output.md#targettype)을 사용하여 출력 파일이 만들어진 경우 해당 메타데이터를 **AddModules** 를 사용하여 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-136">For example, if the output file was created with [**TargetType**](output.md#targettype) option of **module**, its metadata can be imported with **AddModules**.</span></span>

<span data-ttu-id="4f269-137">출력 파일이 **module** 이외의 [**TargetType**](output.md#targettype) 옵션으로 생성된 경우 해당 메타데이터를 **AddModules** 로 가져올 수 없지만 [**References**](#references) 옵션으로 가져올수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-137">If the output file was created with a [**TargetType**](output.md#targettype) option other than **module**, its metadata cannot be imported with **AddModules** but can be imported with the [**References**](#references) option.</span></span>

## <a name="embedinteroptypes"></a><span data-ttu-id="4f269-138">EmbedInteropTypes</span><span class="sxs-lookup"><span data-stu-id="4f269-138">EmbedInteropTypes</span></span>

<span data-ttu-id="4f269-139">컴파일러에서 지정된 어셈블리의 COM 형식 정보를 현재 컴파일하고 있는 프로젝트에 사용할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-139">Causes the compiler to make COM type information in the specified assemblies available to the project that you are currently compiling.</span></span>

```xml
<References>
  <EmbedInteropTypes>file1;file2;file3</EmbedInteropTypes>
</References>
```

<span data-ttu-id="4f269-140">여기서 `file1;file2;file3`은 세미콜론으로 구분된 어셈블리 파일 이름 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-140">Where  `file1;file2;file3` is a semicolon-delimited list of assembly file names.</span></span> <span data-ttu-id="4f269-141">파일 이름에 공백이 있으면 이름을 따옴표로 묶습니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-141">If the file name contains a space, enclose the name in quotation marks.</span></span> <span data-ttu-id="4f269-142">**EmbedInteropTypes** 옵션을 사용하면 포함된 형식 정보가 있는 애플리케이션을 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-142">The **EmbedInteropTypes** option enables you to deploy an application that has embedded type information.</span></span> <span data-ttu-id="4f269-143">그러면 애플리케이션은 런타임 어셈블리에 대한 참조를 요구하지 않고 포함된 형식 정보를 구현하는 형식을 런타임 어셈블리에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-143">The application can then use types in a runtime assembly that implement the embedded type information without requiring a reference to the runtime assembly.</span></span> <span data-ttu-id="4f269-144">다양한 버전의 런타임 어셈블리가 게시된 경우 포함된 형식 정보를 포함하는 애플리케이션은 다시 컴파일하지 않아도 다양한 버전에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-144">If various versions of the runtime assembly are published, the application that contains the embedded type information can work with the various versions without having to be recompiled.</span></span> <span data-ttu-id="4f269-145">예제를 보려면 [연습: 관리되는 어셈블리의 형식 포함](../../../standard/assembly/embed-types-visual-studio.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="4f269-145">For an example, see [Walkthrough: Embedding Types from Managed Assemblies](../../../standard/assembly/embed-types-visual-studio.md).</span></span>

<span data-ttu-id="4f269-146">**EmbedInteropTypes** 옵션을 사용하면 COM interop으로 작업할 때 특히 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-146">Using the **EmbedInteropTypes** option is especially useful when you're working with COM interop.</span></span> <span data-ttu-id="4f269-147">애플리케이션에 대상 컴퓨터의 PIA(주 interop 어셈블리)가 더 이상 필요하지 않도록 COM 형식을 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-147">You can embed COM types so that your application no longer requires a primary interop assembly (PIA) on the target computer.</span></span> <span data-ttu-id="4f269-148">**EmbedInteropTypes** 옵션은 참조된 interop 어셈블리의 COM 형식 정보를 컴파일된 결과 코드에 포함하도록 컴파일러에 지시합니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-148">The **EmbedInteropTypes** option instructs the compiler to embed the COM type information from the referenced interop assembly into the resulting compiled code.</span></span> <span data-ttu-id="4f269-149">COM 형식은 CLSID(GUID) 값으로 식별됩니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-149">The COM type is identified by the CLSID (GUID) value.</span></span> <span data-ttu-id="4f269-150">따라서 동일한 CLSID 값을 갖는 동일한 COM 형식이 설치된 대상 컴퓨터에서 애플리케이션을 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-150">As a result, your application can run on a target computer that has installed the same COM types with the same CLSID values.</span></span> <span data-ttu-id="4f269-151">Microsoft Office를 자동화하는 애플리케이션이 좋은 예입니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-151">Applications that automate Microsoft Office are a good example.</span></span> <span data-ttu-id="4f269-152">Office와 같은 애플리케이션은 일반적으로 여러 버전에서 동일한 CLSID 값을 유지하지 때문에 .NET Framework 4 이상이 대상 컴퓨터에 설치되어 있고 애플리케이션이 참조된 COM 형식에 포함된 메서드, 속성 또는 이벤트를 사용하는 한 애플리케이션에서 참조된 COM 형식을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-152">Because applications like Office usually keep the same CLSID value across different versions, your application can use the referenced COM types as long as .NET Framework 4 or later is installed on the target computer and your application uses methods, properties, or events that are included in the referenced COM types.</span></span> <span data-ttu-id="4f269-153">**EmbedInteropTypes** 옵션은 인터페이스, 구조체 및 대리자만 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-153">The **EmbedInteropTypes** option embeds only interfaces, structures, and delegates.</span></span> <span data-ttu-id="4f269-154">COM 클래스 포함은 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-154">Embedding COM classes isn't supported.</span></span>

> [!NOTE]
> <span data-ttu-id="4f269-155">코드에서 포함된 COM 형식의 인스턴스를 만드는 경우 적절한 인터페이스를 사용하여 인스턴스를 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-155">When you create an instance of an embedded COM type in your code, you must create the instance by using the appropriate interface.</span></span> <span data-ttu-id="4f269-156">CoClass를 사용하여 포함된 COM 형식의 인스턴스를 만들려고 하면 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-156">Attempting to create an instance of an embedded COM type by using the CoClass causes an error.</span></span>

<span data-ttu-id="4f269-157">[**References**](#references) 컴파일러 옵션과 마찬가지로, **EmbedInteropTypes** 컴파일러 옵션은 자주 사용되는 .NET 어셈블리를 참조하는 Csc.rsp 지시 파일을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-157">Like the [**References**](#references) compiler option, the **EmbedInteropTypes** compiler option uses the Csc.rsp response file, which references frequently used .NET assemblies.</span></span> <span data-ttu-id="4f269-158">컴파일러가 Csc.rsp 파일을 사용하지 않도록 하려면 [**NoConfig**](miscellaneous.md#noconfig) 컴파일러 옵션을 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="4f269-158">Use the [**NoConfig**](miscellaneous.md#noconfig) compiler option if you don't want the compiler to use the Csc.rsp file.</span></span>

[!code-csharp[VbLinkCompilerCS#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/vblinkcompilercs/cs/program.cs#1)]

<span data-ttu-id="4f269-159">형식이 interop 어셈블리에서 포함된 제네릭 매개 변수가 있는 형식은 해당 형식이 외부 어셈블리에서 제공된 경우 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-159">Types that have a generic parameter whose type is embedded from an interop assembly cannot be used if that type is from an external assembly.</span></span> <span data-ttu-id="4f269-160">인터스페이스에는 이 제한이 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-160">This restriction doesn't apply to interfaces.</span></span> <span data-ttu-id="4f269-161">예를 들어 <xref:Microsoft.Office.Interop.Excel> 어셈블리에 정의된 <xref:Microsoft.Office.Interop.Excel.Range> 인터페이스를 살펴보세요.</span><span class="sxs-lookup"><span data-stu-id="4f269-161">For example, consider the <xref:Microsoft.Office.Interop.Excel.Range> interface that is defined in the <xref:Microsoft.Office.Interop.Excel> assembly.</span></span> <span data-ttu-id="4f269-162">다음 코드 예제와 같이 라이브러리가 <xref:Microsoft.Office.Interop.Excel> 어셈블리의 interop 형식을 포함하고 형식이 <xref:Microsoft.Office.Interop.Excel.Range> 인터페이스인 매개 변수가 있는 제네릭 형식을 반환하는 메서드를 노출하는 경우 해당 메서드는 제네릭 인터페이스를 반환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-162">If a library embeds interop types from the <xref:Microsoft.Office.Interop.Excel> assembly and exposes a method that returns a generic type that has a parameter whose type is the <xref:Microsoft.Office.Interop.Excel.Range> interface, that method must return a generic interface, as shown in the following code example.</span></span>

[!code-csharp[VbLinkCompilerCS#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/vblinkcompilercs/cs/utility.cs)]

<span data-ttu-id="4f269-163">다음 예제에서 클라이언트 코드는 <xref:System.Collections.IList> 제네릭 인터페이스를 반환하는 메서드를 오류 없이 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4f269-163">In the following example, client code can call the method that returns the <xref:System.Collections.IList> generic interface without error.</span></span>

[!code-csharp[VbLinkCompilerCS#5](~/samples/snippets/csharp/VS_Snippets_VBCSharp/vblinkcompilercs/cs/program.cs#5)]
