---
description: '자세한 정보: Visual Basic의 새로운 기능'
title: 새로운 기능
ms.date: 10/24/2018
f1_keywords:
- VB.StartPage.WhatsNew
helpviewer_keywords:
- new features, Visual Basic
- what's new [Visual Basic]
- Visual Basic, what's new
ms.assetid: d7e97396-7f42-4873-a81c-4ebcc4b6ca02
ms.openlocfilehash: 1e5f7dec0476d0b7fbf09fa3b253d3d5dfedf426
ms.sourcegitcommit: e3cf8227573e13b8e1f4e3dc007404881cdafe47
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2021
ms.locfileid: "103190374"
---
# <a name="whats-new-for-visual-basic"></a><span data-ttu-id="6d262-103">Visual Basic의 새로운 기능</span><span class="sxs-lookup"><span data-stu-id="6d262-103">What's new for Visual Basic</span></span>

<span data-ttu-id="6d262-104">이 항목에는 각 Visual Basic 버전의 주요 기능 이름과 최신 Visual Basic 버전의 새로운 기능 및 향상된 기능에 대한 자세한 설명이 정리되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-104">This topic lists key feature names for each version of Visual Basic, with detailed descriptions of the new and enhanced features in the latest versions of the language.</span></span>

## <a name="current-version"></a><span data-ttu-id="6d262-105">현재 버전</span><span class="sxs-lookup"><span data-stu-id="6d262-105">Current version</span></span>

<span data-ttu-id="6d262-106">Visual Basic 16.9/Visual Studio 2019 버전 16.9</span><span class="sxs-lookup"><span data-stu-id="6d262-106">Visual Basic 16.9 / Visual Studio 2019 version 16.9</span></span>\
<span data-ttu-id="6d262-107">새 기능은 [Visual Basic 16.9](#visual-basic-169)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6d262-107">For new features, see [Visual Basic 16.9](#visual-basic-169).</span></span>

<span data-ttu-id="6d262-108">[.NET 다운로드 페이지](https://dotnet.microsoft.com/download)에서 최신 .NET SDK를 다운로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-108">You can download the latest .NET SDK from the [.NET downloads page](https://dotnet.microsoft.com/download).</span></span>

## <a name="previous-versions"></a><span data-ttu-id="6d262-109">이전 버전</span><span class="sxs-lookup"><span data-stu-id="6d262-109">Previous versions</span></span>

<span data-ttu-id="6d262-110">Visual Basic 16.0/Visual Studio 2019 버전 16.0</span><span class="sxs-lookup"><span data-stu-id="6d262-110">Visual Basic 16.0 / Visual Studio 2019 version 16.0</span></span>\
<span data-ttu-id="6d262-111">새 기능은 [Visual Basic 16.0](#visual-basic-160)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6d262-111">For new features, see [Visual Basic 16.0](#visual-basic-160).</span></span>

<span data-ttu-id="6d262-112">Visual Basic 15.5/Visual Studio 2017 버전 15.5</span><span class="sxs-lookup"><span data-stu-id="6d262-112">Visual Basic 15.5 / Visual Studio 2017 version 15.5</span></span>\
<span data-ttu-id="6d262-113">새 기능은 [Visual Basic 15.5](#visual-basic-155)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6d262-113">For new features, see [Visual Basic 15.5](#visual-basic-155).</span></span>

<span data-ttu-id="6d262-114">Visual Basic 15.3/Visual Studio 2017 버전 15.3</span><span class="sxs-lookup"><span data-stu-id="6d262-114">Visual Basic 15.3 / Visual Studio 2017 version 15.3</span></span>\
<span data-ttu-id="6d262-115">새 기능은 [Visual Basic 15.3](#visual-basic-153)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6d262-115">For new features, see [Visual Basic 15.3](#visual-basic-153).</span></span>

<span data-ttu-id="6d262-116">Visual Basic 15 / Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="6d262-116">Visual Basic 15 / Visual Studio 2017</span></span>\
<span data-ttu-id="6d262-117">새 기능은 [Visual Basic 2017](#visual-basic-15)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6d262-117">For new features, see [Visual Basic 2017](#visual-basic-15).</span></span>

<span data-ttu-id="6d262-118">Visual Basic/Visual Studio 2015</span><span class="sxs-lookup"><span data-stu-id="6d262-118">Visual Basic / Visual Studio 2015</span></span>\
<span data-ttu-id="6d262-119">새 기능은 [Visual Basic 14](#visual-basic-14)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6d262-119">For new features, see [Visual Basic 14](#visual-basic-14).</span></span>

<span data-ttu-id="6d262-120">Visual Basic/Visual Studio 2013</span><span class="sxs-lookup"><span data-stu-id="6d262-120">Visual Basic / Visual Studio 2013</span></span>\
<span data-ttu-id="6d262-121">.NET 컴파일러 플랫폼("Roslyn")의 기술 미리 보기</span><span class="sxs-lookup"><span data-stu-id="6d262-121">Technology previews of the .NET Compiler Platform ("Roslyn")</span></span>

<span data-ttu-id="6d262-122">Visual Basic/Visual Studio 2012</span><span class="sxs-lookup"><span data-stu-id="6d262-122">Visual Basic / Visual Studio 2012</span></span>\
<span data-ttu-id="6d262-123">`Async` 및 `await` 키워드, 반복기, 호출자 정보 특성</span><span class="sxs-lookup"><span data-stu-id="6d262-123">`Async` and `await` keywords, iterators, caller info attributes</span></span>

<span data-ttu-id="6d262-124">Visual Basic, Visual Studio 2010</span><span class="sxs-lookup"><span data-stu-id="6d262-124">Visual Basic, Visual Studio 2010</span></span>\
<span data-ttu-id="6d262-125">자동으로 구현된 속성, 컬렉션 이니셜라이저, 암시적 줄 연속, 동적, 제네릭 공변성(Covariance)/반공변성(Contravariance), 전역 네임스페이스 액세스</span><span class="sxs-lookup"><span data-stu-id="6d262-125">Auto-implemented properties, collection initializers, implicit line continuation, dynamic, generic co/contra variance, global namespace access</span></span>

<span data-ttu-id="6d262-126">Visual Basic/Visual Studio 2008</span><span class="sxs-lookup"><span data-stu-id="6d262-126">Visual Basic / Visual Studio 2008</span></span>\
<span data-ttu-id="6d262-127">LINQ(통합 언어 쿼리), XML 리터럴, 지역 형식 유추, 개체 이니셜라이저, 익명 형식, 확장 메서드, 로컬 `var` 형식 유추, 람다 식, `if` 연산자, 부분 메서드(Partial Method), nullable 값 형식</span><span class="sxs-lookup"><span data-stu-id="6d262-127">Language Integrated Query (LINQ), XML literals, local type inference, object initializers, anonymous types, extension methods, local `var` type inference, lambda expressions, `if` operator, partial methods, nullable value types</span></span>

<span data-ttu-id="6d262-128">Visual Basic/Visual Studio 2005</span><span class="sxs-lookup"><span data-stu-id="6d262-128">Visual Basic / Visual Studio 2005</span></span>\
<span data-ttu-id="6d262-129">`My` 형식 및 도우미 형식(앱, 컴퓨터, 파일 시스템, 네트워크에 액세스)</span><span class="sxs-lookup"><span data-stu-id="6d262-129">The `My` type and helper types (access to app, computer, files system, network)</span></span>

<span data-ttu-id="6d262-130">Visual Basic/Visual Studio .NET 2003</span><span class="sxs-lookup"><span data-stu-id="6d262-130">Visual Basic / Visual Studio .NET 2003</span></span>\
<span data-ttu-id="6d262-131">비트 시프트 연산자, 루프 변수 선언</span><span class="sxs-lookup"><span data-stu-id="6d262-131">Bit-shift operators, loop variable declaration</span></span>

<span data-ttu-id="6d262-132">Visual Basic/Visual Studio .NET 2002</span><span class="sxs-lookup"><span data-stu-id="6d262-132">Visual Basic / Visual Studio .NET 2002</span></span>\
<span data-ttu-id="6d262-133">Visual Basic .NET의 첫 번째 릴리스</span><span class="sxs-lookup"><span data-stu-id="6d262-133">The first release of Visual Basic .NET</span></span>

## <a name="visual-basic-169"></a><span data-ttu-id="6d262-134">Visual Basic 16.9</span><span class="sxs-lookup"><span data-stu-id="6d262-134">Visual Basic 16.9</span></span>

<span data-ttu-id="6d262-135">Visual Basic 16.9는 init 전용 속성을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-135">Visual Basic 16.9 enables consumption of init-only properties.</span></span>

## <a name="visual-basic-160"></a><span data-ttu-id="6d262-136">Visual Basic 16.0</span><span class="sxs-lookup"><span data-stu-id="6d262-136">Visual Basic 16.0</span></span>

<span data-ttu-id="6d262-137">Visual Basic 16.0은 .NET Core에 더 많은 Visual Basic 런타임 기능(microsoft.visualbasic.dll)을 제공하는 데 초점을 맞추며, .NET Core에 초점을 맞춘 Visual Basic의 첫 번째 버전입니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-137">Visual Basic 16.0 focuses on supplying more of the features of the Visual Basic Runtime (microsoft.visualbasic.dll) to .NET Core and is the first version of Visual Basic focused on .NET Core.</span></span> <span data-ttu-id="6d262-138">Visual Basic 런타임의 많은 부분은 WinForms에 종속되며, 이후 버전의 Visual Basic에 추가될 예정입니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-138">Many portions of the Visual Basic Runtime depend on WinForms and these will be added in a later version of Visual Basic.</span></span>

<span data-ttu-id="6d262-139">**문 내의 더 많은 위치에서 주석 허용**</span><span class="sxs-lookup"><span data-stu-id="6d262-139">**Comments allowed in more places within statements**</span></span>

<span data-ttu-id="6d262-140">Visual Basic 15.8 및 이전 버전에서는 빈 줄, 문의 끝 또는 암시적 줄 연속이 허용되는 문 내의 특정 위치에서만 주석이 허용됩니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-140">In Visual Basic 15.8 and earlier versions, comments are only allowed on blank lines, at the end of a statement, or in specific places within a statement where an implicit line continuation is allowed.</span></span> <span data-ttu-id="6d262-141">Visual Basic 16.0부터 명시적 줄 연속 뒤와 공백 다음 밑줄로 시작하는 줄의 문 내에서도 주석이 허용됩니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-141">Starting with Visual Basic 16.0, comments are also allowed after explicit line continuations and within a statement on a line beginning with a space followed by an underscore.</span></span>

```vb
Public Sub Main()
    cmd.CommandText = ' Comment is allowed here without _
        "SELECT * FROM Titles JOIN Publishers " _ ' This is a comment
        & "ON Publishers.PubId = Titles.PubID " _
 _ ' This is a comment on a line without code
        & "WHERE Publishers.State = 'CA'"
End Sub
```

<span data-ttu-id="6d262-142">**최적화된 부동 소수점-정수 변환**</span><span class="sxs-lookup"><span data-stu-id="6d262-142">**Optimized floating-point to integer conversion**</span></span>

<span data-ttu-id="6d262-143">이전 버전의 Visual Basic에서 [Double](../language-reference/data-types/double-data-type.md) 및 [Single](../language-reference/data-types/single-data-type.md) 값을 정수로 변환하면 성능이 상대적으로 떨어졌습니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-143">In previous versions of Visual Basic, conversion of [Double](../language-reference/data-types/double-data-type.md) and [Single](../language-reference/data-types/single-data-type.md) values to integers offered relatively poor performance.</span></span> <span data-ttu-id="6d262-144">Visual Basic 15.8은 다음 메서드 중 하나에 의해 반환된 값을 [내장 Visual Basic 정수 변환 함수](../language-reference/functions/type-conversion-functions.md)(CByte, CShort, CInt, CLng, CSByte, CUShort, CUInt, CULng) 중 하나에 전달하거나, [Option Strict](../language-reference/statements/option-strict-statement.md)가 `Off`로 설정된 경우 다음 메서드 중 하나로 반환되는 값이 암시적으로 정수 형식으로 캐스팅될 때 정수에 대한 부동 소수점 변환의 성능을 크게 향상시킵니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-144">Visual Basic 15.8 significantly enhances the performance of floating-point conversions to integers when you pass the value returned by any of the following methods to one of the [intrinsic Visual Basic integer conversion functions](../language-reference/functions/type-conversion-functions.md) (CByte, CShort, CInt, CLng, CSByte, CUShort, CUInt, CULng), or when the value returned by any of the following methods is implicitly cast to an integral type when [Option Strict](../language-reference/statements/option-strict-statement.md) is set to `Off`:</span></span>

- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Double)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Object)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Single)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Int(System.Double)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Int(System.Object)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Int(System.Single)?displayProperty=nameWithType>
- <xref:System.Math.Ceiling(System.Double)?displayProperty=nameWithType>
- <xref:System.Math.Floor(System.Double)?displayProperty=nameWithType>
- <xref:System.Math.Round(System.Double)?displayProperty=nameWithType>
- <xref:System.Math.Truncate(System.Double)?displayProperty=nameWithType>

<span data-ttu-id="6d262-145">이렇게 최적화하면 다량의 정수 형식 변환을 수행하는 코드의 경우 코드 실행 속도가 최대 2배까지 더 빨라집니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-145">This optimization allows code to run faster -- up to twice as fast for code that does a large number of conversions to integer types.</span></span> <span data-ttu-id="6d262-146">다음 예제에서는 이 최적화에 영향을 받는 몇 가지 간단한 메서드 호출을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-146">The following example illustrates some simple method calls that are affected by this optimization:</span></span>

```vb
Dim s As Single = 173.7619
Dim d As Double = s

Dim i1 As Integer = CInt(Fix(s))               ' Result: 173
Dim b1 As Byte = CByte(Int(d))                 ' Result: 173
Dim s1 AS Short = CShort(Math.Truncate(s))     ' Result: 173
Dim i2 As Integer = CInt(Math.Ceiling(d))      ' Result: 174
Dim i3 As Integer = CInt(Math.Round(s))        ' Result: 174
```

<span data-ttu-id="6d262-147">부동 소수점 값을 반올림하는 것이 아니라 잘린다는 점에 유의하세요.</span><span class="sxs-lookup"><span data-stu-id="6d262-147">Note that this truncates rather than rounds floating-point values.</span></span>

## <a name="visual-basic-155"></a><span data-ttu-id="6d262-148">Visual Basic 15.5</span><span class="sxs-lookup"><span data-stu-id="6d262-148">Visual Basic 15.5</span></span>

[<span data-ttu-id="6d262-149">뒤에 오지 않는 명명된 인수</span><span class="sxs-lookup"><span data-stu-id="6d262-149">Non-trailing named arguments</span></span>](../programming-guide/language-features/procedures/passing-arguments-by-position-and-by-name.md#mixing-arguments-by-position-and-by-name)

<span data-ttu-id="6d262-150">Visual Basic 15.3 및 이전 버전에서 메서드 호출이 위치 및 이름별 인수를 포함하는 경우 위치 인수는 명명된 인수 앞에 와야 했습니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-150">In Visual Basic 15.3 and earlier versions, when a method call included arguments both by position and by name, positional arguments had to precede named arguments.</span></span> <span data-ttu-id="6d262-151">Visual Basic 15.5부터 위치 및 명명된 인수는 마지막 위치 인수까지 모든 인수가 올바른 위치에 있는 한 순서에 관계 없이 나타날 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-151">Starting with Visual Basic 15.5, positional and named arguments can appear in any order as long as all arguments up to the last positional argument are in the correct position.</span></span> <span data-ttu-id="6d262-152">이는 명명된 인수가 코드를 더 쉽게 읽을 수 있도록 사용되는 경우 특히 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-152">This is particularly useful when named arguments are used to make code more readable.</span></span>

<span data-ttu-id="6d262-153">예를 들어 다음 메서드 호출은 명명된 인수 사이에 두 개의 위치 인수를 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-153">For example, the following method call has two positional arguments between a named argument.</span></span> <span data-ttu-id="6d262-154">명명된 인수는 값 19가 나이를 나타낸다는 것을 명백하게 합니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-154">The named argument makes it clear that the value 19 represents an age.</span></span>

```vb
StudentInfo.Display("Mary", age:=19, #9/21/1998#)
```

[<span data-ttu-id="6d262-155">`Private Protected` 멤버 액세스 한정자</span><span class="sxs-lookup"><span data-stu-id="6d262-155">`Private Protected` member access modifier</span></span>](../language-reference/modifiers/private-protected.md)

<span data-ttu-id="6d262-156">이 새 키워드 조합은 포함하는 클래스의 모든 멤버를 통해 액세스하고 포함하는 클래스에서 파생된 형식(해당 형식이 포함하는 어셈블리에 있는 경우에만)을 통해 액세스할 수 있는 멤버를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-156">This new keyword combination defines a member that is accessible by all members in its containing class as well as by types derived from the containing class, but only if they are also found in the containing assembly.</span></span> <span data-ttu-id="6d262-157">구조체를 상속할 수 없으므로 `Private Protected`는 클래스의 멤버에만 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-157">Because structures cannot be inherited, `Private Protected` can only be applied to the members of a class.</span></span>

<span data-ttu-id="6d262-158">**선행 16진수/이진/8진수 구분 기호**</span><span class="sxs-lookup"><span data-stu-id="6d262-158">**Leading hex/binary/octal separator**</span></span>

<span data-ttu-id="6d262-159">Visual Basic 2017은 숫자 구분 기호로 밑줄 문자(`_`)에 대한 지원을 추가했습니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-159">Visual Basic 2017 added support for the underscore character (`_`) as a digit separator.</span></span> <span data-ttu-id="6d262-160">Visual Basic 15.5부터 접두사와 16 진수, 이진 또는 8진수 숫자 사이의 선행 구분 기호로 밑줄 문자를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-160">Starting with Visual Basic 15.5, you can use the underscore character as a leading separator between the prefix and hexadecimal, binary, or octal digits.</span></span> <span data-ttu-id="6d262-161">다음 예제에서는 선행 숫자 구분 기호를 사용하여 16진수 숫자로 3,271,948,384를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-161">The following example uses a leading digit separator to define 3,271,948,384 as a hexadecimal number:</span></span>

```vb
Dim number As Integer = &H_C305_F860
```

<span data-ttu-id="6d262-162">선행 구분 기호로 밑줄 문자를 사용하려면 Visual Basic 프로젝트(\*.vbproj) 파일에 다음 요소를 추가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-162">To use the underscore character as a leading separator, you must add the following element to your Visual Basic project (\*.vbproj) file:</span></span>

```xml
<PropertyGroup>
  <LangVersion>15.5</LangVersion>
</PropertyGroup>
```

## <a name="visual-basic-153"></a><span data-ttu-id="6d262-163">Visual Basic 15.3</span><span class="sxs-lookup"><span data-stu-id="6d262-163">Visual Basic 15.3</span></span>

[<span data-ttu-id="6d262-164">**명명된 튜플 유추**</span><span class="sxs-lookup"><span data-stu-id="6d262-164">**Named tuple inference**</span></span>](../programming-guide/language-features/data-types/tuples.md#inferred-tuple-element-names)

<span data-ttu-id="6d262-165">변수에서 튜플 요소의 값을 할당할 때 Visual Basic는 해당 변수 이름에서 튜플 요소의 이름을 유추합니다. 튜블 요소의 이름을 명시적으로 지정할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-165">When you assign the value of tuple elements from variables, Visual Basic infers the name of tuple elements from the corresponding variable names; you do not have to explicitly name a tuple element.</span></span> <span data-ttu-id="6d262-166">다음 예제에서는 유추를 사용하여 세 개의 명명된 요소, `state`, `stateName` 및 `capital`로 튜플을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-166">The following example uses inference to create a tuple with three named elements, `state`, `stateName`, and `capital`.</span></span>

[!code-vb[Inferred tuple names](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/named-tuples/program.vb#2)]

<span data-ttu-id="6d262-167">**추가 컴파일러 스위치**</span><span class="sxs-lookup"><span data-stu-id="6d262-167">**Additional compiler switches**</span></span>

<span data-ttu-id="6d262-168">이제 Visual Basic 명령줄 컴파일러는 참조 어셈블리의 출력을 제어하기 위해 [ **-refout**](../reference/command-line-compiler/refout-compiler-option.md) 및 [ **-refonly**](../reference/command-line-compiler/refonly-compiler-option.md) 컴파일러 옵션을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-168">The Visual Basic command-line compiler now supports the [**-refout**](../reference/command-line-compiler/refout-compiler-option.md) and [**-refonly**](../reference/command-line-compiler/refonly-compiler-option.md) compiler options to control the output of reference assemblies.</span></span> <span data-ttu-id="6d262-169">**-refout** 는 참조 어셈블리의 출력 디렉터리를 정의하고 **-refonly** 는 참조 어셈블리만 컴파일로 출력되도록 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-169">**-refout** defines the output directory of the reference assembly, and **-refonly** specifies that only a reference assembly is to be output by compilation.</span></span>

## <a name="visual-basic-15"></a><span data-ttu-id="6d262-170">Visual Basic 15</span><span class="sxs-lookup"><span data-stu-id="6d262-170">Visual Basic 15</span></span>

[<span data-ttu-id="6d262-171">**튜플**</span><span class="sxs-lookup"><span data-stu-id="6d262-171">**Tuples**</span></span>](../programming-guide/language-features/data-types/tuples.md)

<span data-ttu-id="6d262-172">튜플은 단일 메서드 호출에서 여러 값을 반환하는 데 주로 사용되는 간단한 데이터 구조입니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-172">Tuples are a lightweight data structure that most commonly is used to return multiple values from a single method call.</span></span> <span data-ttu-id="6d262-173">일반적으로 하나의 메서드에서 여러 값을 반환하려면 다음 중 하나를 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-173">Ordinarily, to return multiple values from a method, you have to do one of the following:</span></span>

- <span data-ttu-id="6d262-174">사용자 지정 형식(`Class` 또는 `Structure`)을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-174">Define a custom type (a `Class` or a `Structure`).</span></span> <span data-ttu-id="6d262-175">이는 대규모 솔루션입니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-175">This is a heavyweight solution.</span></span>

- <span data-ttu-id="6d262-176">메서드에서 값을 반환하는 것 외에도 `ByRef` 매개 변수를 하나 이상 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-176">Define one or more `ByRef` parameters, in addition to returning a value from the method.</span></span>

<span data-ttu-id="6d262-177">Visual Basic의 튜플 지원을 사용하면 튜플을 신속하게 정의하고, 필요에 따라 해당 값에 의미 체계 이름을 할당하고, 해당 값을 빠르게 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-177">Visual Basic's support for tuples lets you quickly define a tuple, optionally assign semantic names to its values, and quickly retrieve its values.</span></span> <span data-ttu-id="6d262-178">다음 예제에서는 <xref:System.Int32.TryParse%2A> 메서드 호출을 래핑하고 튜플을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-178">The following example wraps a call to the <xref:System.Int32.TryParse%2A> method and returns a tuple.</span></span>

[!code-vb[Tuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#2)]

<span data-ttu-id="6d262-179">그런 다음 메서드를 호출하고 반환된 튜플을 코드에서 다음과 같이 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-179">You can then call the method and handle the returned tuple with code like the following.</span></span>

[!code-vb[ReturnTuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#3)]

<span data-ttu-id="6d262-180">**이진 리터럴 및 자릿수 구분 기호**</span><span class="sxs-lookup"><span data-stu-id="6d262-180">**Binary literals and digit separators**</span></span>

<span data-ttu-id="6d262-181">`&B` 또는 `&b` 접두사를 사용하여 이진 리터럴을 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-181">You can define a binary literal by using the prefix `&B` or `&b`.</span></span> <span data-ttu-id="6d262-182">또한 밑줄 문자 `_`를 자릿수 구분 기호로 사용하여 가독성을 향상할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-182">In addition, you can use the underscore character, `_`, as a digit separator to enhance readability.</span></span> <span data-ttu-id="6d262-183">다음 예제에서는 두 기능을 모두 사용하여 `Byte` 값을 할당하고 10진수, 16진수, 이진수로 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-183">The following example uses both features to assign a `Byte` value and to display it as a decimal, hexadecimal, and binary number.</span></span>

[!code-vb[Binary](../../../samples/snippets/visualbasic/getting-started/bin-example.vb#1)]

<span data-ttu-id="6d262-184">자세한 내용은 [바이트](../language-reference/data-types/byte-data-type.md#literal-assignments), [정수](../language-reference/data-types/integer-data-type.md#literal-assignments), [Long](../language-reference/data-types/long-data-type.md#literal-assignments), [Short](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments) 및 [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments) 데이터 형식의 "리터럴 할당" 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6d262-184">For more information, see the "Literal assignments" section of the [Byte](../language-reference/data-types/byte-data-type.md#literal-assignments), [Integer](../language-reference/data-types/integer-data-type.md#literal-assignments), [Long](../language-reference/data-types/long-data-type.md#literal-assignments), [Short](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments), and [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments) data types.</span></span>

[<span data-ttu-id="6d262-185">**C# 참조 반환 값 지원**</span><span class="sxs-lookup"><span data-stu-id="6d262-185">**Support for C# reference return values**</span></span>](../programming-guide/language-features/procedures/ref-return-values.md)

<span data-ttu-id="6d262-186">C# 7.0부터 C#에서 참조 반환 값을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-186">Starting with C# 7.0, C# supports reference return values.</span></span> <span data-ttu-id="6d262-187">즉, 호출하는 메서드가 참조로 반환된 값을 받을 때 참조 값을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-187">That is, when the calling method receives a value returned by reference, it can change the value of the reference.</span></span> <span data-ttu-id="6d262-188">Visual Basic에서 참조 반환 값이 있는 메서드를 작성할 수는 없지만 참조 반환 값을 사용하고 수정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-188">Visual Basic does not allow you to author methods with reference return values, but it does allow you to consume and modify the reference return values.</span></span>

<span data-ttu-id="6d262-189">예를 들어 C#으로 작성된 다음 `Sentence` 클래스에는 문장 내에서 지정한 하위 문자열로 시작하는 다음 단어를 찾는 `FindNext` 메서드가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-189">For example, the following `Sentence` class written in C# includes a `FindNext` method that finds the next word in a sentence that begins with a specified substring.</span></span> <span data-ttu-id="6d262-190">문자열은 참조 반환 값으로 반환되며, 메서드에 참조로 전달된 `Boolean` 변수는 검색에 성공했는지 여부를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-190">The string is returned as a reference return value, and a `Boolean` variable passed by reference to the method indicates whether the search was successful.</span></span> <span data-ttu-id="6d262-191">즉, 호출자는 반환된 값을 읽을 뿐 아니라 수정할 수도 있으며 수정 내용이 `Sentence` 클래스에 반영됩니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-191">This means that in addition to reading the returned value, the caller can also modify it, and that modification is reflected in the `Sentence` class.</span></span>

[!code-csharp[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-returns.cs)]

<span data-ttu-id="6d262-192">가장 간단한 형태로, 문장에서 찾은 단어를 코드에서 다음과 같이 수정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-192">In its simplest form, you can modify the word found in the sentence by using code like the following.</span></span> <span data-ttu-id="6d262-193">메서드 대신 메서드가 반환하는 식, 즉 참조 반환 값에 값을 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-193">Note that you are not assigning a value to the method, but rather to the expression that the method returns, which is the reference return value.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#1)]

<span data-ttu-id="6d262-194">그러나 이 코드의 문제는 일치 항목이 없을 경우 메서드가 첫 번째 단어를 반환한다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-194">A problem with this code, though, is that if a match is not found, the method returns the first word.</span></span> <span data-ttu-id="6d262-195">이 예제에서는 `Boolean` 인수의 값을 검사하여 일치 항목이 있는지 확인하지 않으므로 일치 항목이 없을 경우 첫 번째 단어를 수정합니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-195">Since the example does not examine the value of the `Boolean` argument to determine whether a match is found, it modifies the first word if there is no match.</span></span> <span data-ttu-id="6d262-196">다음 예제에서는 일치 항목이 없을 경우 첫 번째 단어를 해당 단어로 대체하여 이 문제를 해결합니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-196">The following example corrects this by replacing the first word with itself if there is no match.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#2)]

<span data-ttu-id="6d262-197">더 나은 해결 방법은 참조 반환 값이 참조로 전달되는 도우미 메서드를 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-197">A better solution is to use a helper method to which the reference return value is passed by reference.</span></span> <span data-ttu-id="6d262-198">그러면 도우미 메서드가 참조로 전달된 인수를 수정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-198">The helper method can then modify the argument passed to it by reference.</span></span> <span data-ttu-id="6d262-199">다음 예제에서는 해당 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-199">The following example does that.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return-helper.vb#1)]

<span data-ttu-id="6d262-200">자세한 내용은 [참조 반환 값](../programming-guide/language-features/procedures/ref-return-values.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6d262-200">For more information, see [Reference Return Values](../programming-guide/language-features/procedures/ref-return-values.md).</span></span>

## <a name="visual-basic-14"></a><span data-ttu-id="6d262-201">Visual Basic 14</span><span class="sxs-lookup"><span data-stu-id="6d262-201">Visual Basic 14</span></span>

[<span data-ttu-id="6d262-202">NameOf</span><span class="sxs-lookup"><span data-stu-id="6d262-202">NameOf</span></span>](../language-reference/operators/nameof.md)

<span data-ttu-id="6d262-203">문자열을 하드 코드하지 않고 오류 메시지에서 사용하기 위해 형식이나 멤버의 정규화되지 않은 문자열 이름을 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-203">You can get the unqualified string name of a type or member for use in an error message without hard coding a string.</span></span>  <span data-ttu-id="6d262-204">이 기능을 사용하면 리팩터링할 때 코드를 올바르게 유지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-204">This allows your code to remain correct when refactoring.</span></span>  <span data-ttu-id="6d262-205">이 기능은 MVC(Model-View-Controller) 링크를 연결하고 속성 변경 이벤트를 발생시키는 데도 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-205">This feature is also useful for hooking up model-view-controller MVC links and firing property changed events.</span></span>

[<span data-ttu-id="6d262-206">문자열 보간</span><span class="sxs-lookup"><span data-stu-id="6d262-206">String interpolation</span></span>](../programming-guide/language-features/strings/interpolated-strings.md)

<span data-ttu-id="6d262-207">문자열 보간 식을 사용하여 문자열을 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-207">You can use string interpolation expressions to construct strings.</span></span>  <span data-ttu-id="6d262-208">보간된 문자열 식은 식이 포함된 템플릿 문자열과 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-208">An interpolated string expression looks like a template string that contains expressions.</span></span>  <span data-ttu-id="6d262-209">보간된 문자열은 인수 측면에서 [복합 형식 지정](../../standard/base-types/composite-formatting.md)보다 이해하기 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-209">An interpolated string is easier to understand with respect to arguments than [Composite Formatting](../../standard/base-types/composite-formatting.md).</span></span>

[<span data-ttu-id="6d262-210">Null 조건부 멤버 액세스 및 인덱싱</span><span class="sxs-lookup"><span data-stu-id="6d262-210">Null-conditional member access and indexing</span></span>](../language-reference/operators/null-conditional-operators.md)

<span data-ttu-id="6d262-211">멤버 액세스(`?.`) 또는 인덱스(`?[]`) 작업을 수행하기 전에 매우 간단한 구문을 사용하여 null 테스트를 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-211">You can test for null in a very light syntactic way before performing a member access (`?.`) or index (`?[]`) operation.</span></span>  <span data-ttu-id="6d262-212">이러한 연산자는 null 검사의 처리를 위해 작성하는 코드의 양을 줄이는 데 도움이 되며 특히 데이터 구조에서 아래로 내려가는 경우에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-212">These operators help you write less code to handle null checks, especially for descending into data structures.</span></span>  <span data-ttu-id="6d262-213">왼쪽 피연산자 또는 개체 참조가 null이면 연산에서 null이 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-213">If the left operand or object reference is null, the operations returns null.</span></span>

[<span data-ttu-id="6d262-214">다중 선 문자열 리터럴</span><span class="sxs-lookup"><span data-stu-id="6d262-214">Multi-line string literals</span></span>](../programming-guide/language-features/strings/string-basics.md)

<span data-ttu-id="6d262-215">문자열 리터럴에 줄 바꿈 시퀀스가 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-215">String literals can contain newline sequences.</span></span>  <span data-ttu-id="6d262-216">`<xml><![CDATA[...text with newlines...]]></xml>.Value` 사용과 관련된 이전 작업은 더 이상 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-216">You no longer need the old work around of using `<xml><![CDATA[...text with newlines...]]></xml>.Value`</span></span>

<span data-ttu-id="6d262-217">**설명**</span><span class="sxs-lookup"><span data-stu-id="6d262-217">**Comments**</span></span>

<span data-ttu-id="6d262-218">암시적 줄 연속 뒤, 이니셜라이저 식 내부 및 LINQ 식 항 사이에 주석을 입력할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-218">You can put comments after implicit line continuations, inside initializer expressions, and among LINQ expression terms.</span></span>

<span data-ttu-id="6d262-219">**더 효율적인 정규화된 이름 확인**</span><span class="sxs-lookup"><span data-stu-id="6d262-219">**Smarter fully-qualified name resolution**</span></span>

<span data-ttu-id="6d262-220">`Threading.Thread.Sleep(1000)`과 같은 코드가 제공된 경우 이전에는 Visual Basic에서 "Threading" 네임스페이스를 조회하고 System.Threading 및 System.Windows.Threading 간에 모호하다는 사실을 발견한 후 오류를 보고했습니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-220">Given code such as `Threading.Thread.Sleep(1000)`, Visual Basic used to look up the namespace "Threading", discover it was ambiguous between System.Threading and System.Windows.Threading, and then report an error.</span></span>  <span data-ttu-id="6d262-221">이제 Visual Basic에서는 두 가지 가능한 네임스페이스를 함께 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-221">Visual Basic now considers both possible namespaces together.</span></span>  <span data-ttu-id="6d262-222">완성 목록을 표시하는 경우 Visual Studio 편집기에서 두 형식의 멤버가 모두 완성 목록에 나열됩니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-222">If you show the completion list, the Visual Studio editor lists members from both types in the completion list.</span></span>

<span data-ttu-id="6d262-223">**연도가 먼저 나오는 날짜 리터럴**</span><span class="sxs-lookup"><span data-stu-id="6d262-223">**Year-first date literals**</span></span>

<span data-ttu-id="6d262-224">yyyy-mm-dd 형식(`#2015-03-17 16:10 PM#`)의 날짜 리터럴을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-224">You can have date literals in yyyy-mm-dd format, `#2015-03-17 16:10 PM#`.</span></span>

<span data-ttu-id="6d262-225">**읽기 전용 인터페이스 속성**</span><span class="sxs-lookup"><span data-stu-id="6d262-225">**Readonly interface properties**</span></span>

<span data-ttu-id="6d262-226">읽기/쓰기 속성을 사용하여 읽기 전용 인터페이스 속성을 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-226">You can implement readonly interface properties using a readwrite property.</span></span> <span data-ttu-id="6d262-227">이러한 인터페이스는 최소 기능을 보장하며 구현 클래스에서 속성이 설정되도록 허용하는 것을 차단하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-227">The interface guarantees minimum functionality, and it does not stop an implementing class from allowing the property to be set.</span></span>

[<span data-ttu-id="6d262-228">TypeOf \<expr> IsNot \<type></span><span class="sxs-lookup"><span data-stu-id="6d262-228">TypeOf \<expr> IsNot \<type></span></span>](../language-reference/operators/typeof-operator.md)

<span data-ttu-id="6d262-229">코드를 더 읽기 쉽게 만들기 위해 `IsNot`과 함께 `TypeOf`를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-229">For more readability of your code, you can now use `TypeOf` with `IsNot`.</span></span>

[<span data-ttu-id="6d262-230">#Disable Warning \<ID> 및 #Enable Warning \<ID></span><span class="sxs-lookup"><span data-stu-id="6d262-230">#Disable Warning \<ID> and #Enable Warning \<ID></span></span>](../language-reference/directives/disable-enable.md)

<span data-ttu-id="6d262-231">소스 파일 내의 영역에 대한 특정 경고를 사용하지 않거나 사용하도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-231">You can disable and enable specific warnings for regions within a source file.</span></span>

<span data-ttu-id="6d262-232">**XML 문서 주석 향상**</span><span class="sxs-lookup"><span data-stu-id="6d262-232">**XML doc comment improvements**</span></span>

<span data-ttu-id="6d262-233">문서 주석을 작성하면 편집기의 효율성을 높이고 매개 변수 이름의 유효성 검사, `crefs`(제네릭, 연산자 등)의 적절한 처리, 색 지정 및 리팩터링에 대한 지원을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-233">When writing doc comments, you get smart editor and build support for validating parameter names, proper handling of `crefs` (generics, operators, etc.), colorizing, and refactoring.</span></span>

[<span data-ttu-id="6d262-234">부분 모듈 및 인터페이스 정의</span><span class="sxs-lookup"><span data-stu-id="6d262-234">Partial module and interface definitions</span></span>](../language-reference/modifiers/partial.md)

<span data-ttu-id="6d262-235">클래스 및 구조체 외에도 부분 모듈과 인터페이스를 선언할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-235">In addition to classes and structs, you can declare partial modules and interfaces.</span></span>

[<span data-ttu-id="6d262-236">메서드 본문 내의 #Region 지시문</span><span class="sxs-lookup"><span data-stu-id="6d262-236">#Region directives inside method bodies</span></span>](../language-reference/directives/region-directive.md)

<span data-ttu-id="6d262-237">#Region…#End Region 구분 기호를 파일의 원하는 위치, 함수 내부 및 여러 함수 본문을 포괄하여 입력할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-237">You can put #Region…#End Region delimiters anywhere in a file, inside functions, and even spanning across function bodies.</span></span>

[<span data-ttu-id="6d262-238">Overrides 정의는 암시적으로 overloads임</span><span class="sxs-lookup"><span data-stu-id="6d262-238">Overrides definitions are implicitly overloads</span></span>](../language-reference/modifiers/overrides.md)

<span data-ttu-id="6d262-239">`Overrides` 한정자를 정의에 추가하면 일반적인 경우에 더 적은 코드를 입력할 수 있도록 컴파일러에서 암시적으로 `Overloads`를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-239">If you add the `Overrides` modifier to a definition, the compiler implicitly adds `Overloads` so that you can type less code in common cases.</span></span>

<span data-ttu-id="6d262-240">**특성 인수에서 허용되는 CObj**</span><span class="sxs-lookup"><span data-stu-id="6d262-240">**CObj allowed in attributes arguments**</span></span>

<span data-ttu-id="6d262-241">이전에는 컴파일러에서 CObj(...)가 특성 생성에서 사용될 때 상수가 아니라는 오류를 제공했습니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-241">The compiler used to give an error that CObj(…) was not a constant when used in attribute constructions.</span></span>

<span data-ttu-id="6d262-242">**여러 인터페이스의 모호한 메서드 선언 및 사용**</span><span class="sxs-lookup"><span data-stu-id="6d262-242">**Declaring and consuming ambiguous methods from different interfaces**</span></span>

<span data-ttu-id="6d262-243">이전에는 다음 코드에서 `IMock`을 선언하거나 `GetDetails`를 호출하지 못하게 하는 오류가 발생했습니다(이러한 항목이 C#에서 선언된 경우).</span><span class="sxs-lookup"><span data-stu-id="6d262-243">Previously the following code yielded errors that prevented you from declaring `IMock` or from calling `GetDetails` (if these had been declared in C#):</span></span>

```vb
Interface ICustomer
  Sub GetDetails(x As Integer)
End Interface

Interface ITime
  Sub GetDetails(x As String)
End Interface

Interface IMock : Inherits ICustomer, ITime
  Overloads Sub GetDetails(x As Char)
End Interface

Interface IMock2 : Inherits ICustomer, ITime
End Interface
```

<span data-ttu-id="6d262-244">이제 컴파일러에서 일반 오버로드 확인 규칙을 사용하여 호출하는 데 가장 적합한 `GetDetails`를 선택하며, 샘플에서와 같이 Visual Basic에서 인터페이스 관계를 선언할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d262-244">Now the compiler will use normal overload resolution rules to choose the most appropriate `GetDetails` to call, and you can declare interface relationships in Visual Basic like those shown in the sample.</span></span>

## <a name="see-also"></a><span data-ttu-id="6d262-245">참조</span><span class="sxs-lookup"><span data-stu-id="6d262-245">See also</span></span>

- [<span data-ttu-id="6d262-246">Visual Studio 2017의 새로운 기능</span><span class="sxs-lookup"><span data-stu-id="6d262-246">What's New in Visual Studio 2017</span></span>](/visualstudio/ide/whats-new-visual-studio-2017)
- [<span data-ttu-id="6d262-247">Visual Studio 2019의 새로운 기능</span><span class="sxs-lookup"><span data-stu-id="6d262-247">What's New in Visual Studio 2019</span></span>](/visualstudio/ide/whats-new-visual-studio-2019)
